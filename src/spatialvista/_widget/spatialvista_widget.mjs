(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode(`/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-content:"";--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-green-400:oklch(79.2% .209 151.711);--color-indigo-300:oklch(78.5% .115 274.713);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-md:28rem;--container-lg:32rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--tracking-widest:.1em;--radius-xs:.125rem;--animate-spin:spin 1s linear infinite;--animate-pulse:pulse 2s cubic-bezier(.4,0,.6,1)infinite;--blur-sm:8px;--aspect-video:16/9;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono);--color-border:var(--border)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{border-color:var(--border);outline-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){*{outline-color:color-mix(in oklab,var(--ring)50%,transparent)}}body{background-color:var(--background);color:var(--foreground)}}@layer components;@layer utilities{.\\@container\\/card-header{container:card-header/inline-size}.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.sr-only{clip:rect(0,0,0,0);white-space:nowrap;border-width:0;width:1px;height:1px;margin:-1px;padding:0;position:absolute;overflow:hidden}.absolute{position:absolute}.relative{position:relative}.static{position:static}.sticky{position:sticky}.inset-0{inset:calc(var(--spacing)*0)}.-top-12{top:calc(var(--spacing)*-12)}.top-0{top:calc(var(--spacing)*0)}.top-1{top:calc(var(--spacing)*1)}.top-1\\/2{top:50%}.top-2{top:calc(var(--spacing)*2)}.top-4{top:calc(var(--spacing)*4)}.top-\\[1px\\]{top:1px}.top-\\[50\\%\\]{top:50%}.top-\\[60\\%\\]{top:60%}.top-full{top:100%}.-right-12{right:calc(var(--spacing)*-12)}.right-0{right:calc(var(--spacing)*0)}.right-2{right:calc(var(--spacing)*2)}.right-4{right:calc(var(--spacing)*4)}.right-12{right:calc(var(--spacing)*12)}.-bottom-12{bottom:calc(var(--spacing)*-12)}.bottom-0{bottom:calc(var(--spacing)*0)}.bottom-4{bottom:calc(var(--spacing)*4)}.-left-12{left:calc(var(--spacing)*-12)}.left-0{left:calc(var(--spacing)*0)}.left-1\\/2{left:50%}.left-2{left:calc(var(--spacing)*2)}.left-12{left:calc(var(--spacing)*12)}.left-\\[50\\%\\]{left:50%}.isolate{isolation:isolate}.z-10{z-index:10}.z-20{z-index:20}.z-50{z-index:50}.z-\\[1\\]{z-index:1}.col-start-2{grid-column-start:2}.row-span-2{grid-row:span 2/span 2}.row-start-1{grid-row-start:1}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.my-0\\.5{margin-block:calc(var(--spacing)*.5)}.my-1{margin-block:calc(var(--spacing)*1)}.my-2{margin-block:calc(var(--spacing)*2)}.-mt-4{margin-top:calc(var(--spacing)*-4)}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-1\\.5{margin-top:calc(var(--spacing)*1.5)}.mr-1\\.5{margin-right:calc(var(--spacing)*1.5)}.mr-2{margin-right:calc(var(--spacing)*2)}.mb-1{margin-bottom:calc(var(--spacing)*1)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.-ml-2{margin-left:calc(var(--spacing)*-2)}.-ml-4{margin-left:calc(var(--spacing)*-4)}.ml-1{margin-left:calc(var(--spacing)*1)}.ml-auto{margin-left:auto}.line-clamp-2{-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline-flex{display:inline-flex}.aspect-square{aspect-ratio:1}.aspect-video{aspect-ratio:var(--aspect-video)}.size-2{width:calc(var(--spacing)*2);height:calc(var(--spacing)*2)}.size-2\\.5{width:calc(var(--spacing)*2.5);height:calc(var(--spacing)*2.5)}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-3\\.5{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-9{width:calc(var(--spacing)*9);height:calc(var(--spacing)*9)}.h-1{height:calc(var(--spacing)*1)}.h-1\\.5{height:calc(var(--spacing)*1.5)}.h-2{height:calc(var(--spacing)*2)}.h-2\\.5{height:calc(var(--spacing)*2.5)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-5{height:calc(var(--spacing)*5)}.h-6{height:calc(var(--spacing)*6)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-20{height:calc(var(--spacing)*20)}.h-\\[1\\.2rem\\]{height:1.2rem}.h-\\[1\\.15rem\\]{height:1.15rem}.h-\\[2\\.5rem\\]{height:2.5rem}.h-\\[var\\(--radix-navigation-menu-viewport-height\\)\\]{height:var(--radix-navigation-menu-viewport-height)}.h-\\[var\\(--radix-select-trigger-height\\)\\]{height:var(--radix-select-trigger-height)}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-\\(--radix-dropdown-menu-content-available-height\\){max-height:var(--radix-dropdown-menu-content-available-height)}.max-h-\\(--radix-select-content-available-height\\){max-height:var(--radix-select-content-available-height)}.max-h-16{max-height:calc(var(--spacing)*16)}.max-h-\\[60vh\\]{max-height:60vh}.max-h-\\[300px\\]{max-height:300px}.w-0{width:calc(var(--spacing)*0)}.w-1{width:calc(var(--spacing)*1)}.w-2{width:calc(var(--spacing)*2)}.w-2\\.5{width:calc(var(--spacing)*2.5)}.w-3{width:calc(var(--spacing)*3)}.w-4{width:calc(var(--spacing)*4)}.w-6{width:calc(var(--spacing)*6)}.w-8{width:calc(var(--spacing)*8)}.w-64{width:calc(var(--spacing)*64)}.w-72{width:calc(var(--spacing)*72)}.w-\\[1\\.2rem\\]{width:1.2rem}.w-auto{width:auto}.w-fit{width:fit-content}.w-full{width:100%}.w-max{width:max-content}.w-px{width:1px}.max-w-\\[calc\\(100\\%-2rem\\)\\]{max-width:calc(100% - 2rem)}.max-w-max{max-width:max-content}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-8{min-width:calc(var(--spacing)*8)}.min-w-9{min-width:calc(var(--spacing)*9)}.min-w-10{min-width:calc(var(--spacing)*10)}.min-w-\\[8rem\\]{min-width:8rem}.min-w-\\[var\\(--radix-select-trigger-width\\)\\]{min-width:var(--radix-select-trigger-width)}.flex-1{flex:1}.flex-shrink-0,.shrink-0{flex-shrink:0}.grow{flex-grow:1}.grow-0{flex-grow:0}.basis-1\\/6{flex-basis:16.6667%}.basis-full{flex-basis:100%}.origin-\\(--radix-dropdown-menu-content-transform-origin\\){transform-origin:var(--radix-dropdown-menu-content-transform-origin)}.origin-\\(--radix-hover-card-content-transform-origin\\){transform-origin:var(--radix-hover-card-content-transform-origin)}.origin-\\(--radix-popover-content-transform-origin\\){transform-origin:var(--radix-popover-content-transform-origin)}.origin-\\(--radix-select-content-transform-origin\\){transform-origin:var(--radix-select-content-transform-origin)}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-x-\\[-50\\%\\]{--tw-translate-x:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-\\[-50\\%\\]{--tw-translate-y:-50%;translate:var(--tw-translate-x)var(--tw-translate-y)}.scale-0{--tw-scale-x:0%;--tw-scale-y:0%;--tw-scale-z:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-100{--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.rotate-0{rotate:none}.rotate-45{rotate:45deg}.rotate-90{rotate:90deg}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-pulse{animation:var(--animate-pulse)}.animate-spin{animation:var(--animate-spin)}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.scroll-my-1{scroll-margin-block:calc(var(--spacing)*1)}.scroll-py-1{scroll-padding-block:calc(var(--spacing)*1)}.list-none{list-style-type:none}.auto-rows-min{grid-auto-rows:min-content}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-rows-\\[auto_auto\\]{grid-template-rows:auto auto}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-0{gap:calc(var(--spacing)*0)}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-6{gap:calc(var(--spacing)*6)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-3>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*3)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-x-1>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*1)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-x-reverse)))}:where(.space-x-3>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*3)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-x-reverse)))}.self-start{align-self:flex-start}.justify-self-end{justify-self:flex-end}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:.25rem}.rounded-\\[2px\\]{border-radius:2px}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xl{border-radius:calc(var(--radius) + 4px)}.rounded-xs{border-radius:var(--radius-xs)}.rounded-tl-sm{border-top-left-radius:calc(var(--radius) - 4px)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-\\[1\\.5px\\]{border-style:var(--tw-border-style);border-width:1.5px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-\\(--color-border\\){border-color:var(--color-border)}.border-border,.border-border\\/50{border-color:var(--border)}@supports (color:color-mix(in lab,red,red)){.border-border\\/50{border-color:color-mix(in oklab,var(--border)50%,transparent)}}.border-input{border-color:var(--input)}.border-primary,.border-primary\\/30{border-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.border-primary\\/30{border-color:color-mix(in oklab,var(--primary)30%,transparent)}}.border-transparent{border-color:#0000}.border-b-border{border-bottom-color:var(--border)}.bg-\\(--color-bg\\){background-color:var(--color-bg)}.bg-accent{background-color:var(--accent)}.bg-background,.bg-background\\/40{background-color:var(--background)}@supports (color:color-mix(in lab,red,red)){.bg-background\\/40{background-color:color-mix(in oklab,var(--background)40%,transparent)}}.bg-black\\/50{background-color:#00000080}@supports (color:color-mix(in lab,red,red)){.bg-black\\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-border{background-color:var(--border)}.bg-card{background-color:var(--card)}.bg-destructive{background-color:var(--destructive)}.bg-muted,.bg-muted\\/30{background-color:var(--muted)}@supports (color:color-mix(in lab,red,red)){.bg-muted\\/30{background-color:color-mix(in oklab,var(--muted)30%,transparent)}}.bg-popover{background-color:var(--popover)}.bg-primary,.bg-primary\\/10{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.bg-primary\\/10{background-color:color-mix(in oklab,var(--primary)10%,transparent)}}.bg-primary\\/20{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.bg-primary\\/20{background-color:color-mix(in oklab,var(--primary)20%,transparent)}}.bg-secondary{background-color:var(--secondary)}.bg-transparent{background-color:#0000}.fill-current{fill:currentColor}.fill-primary{fill:var(--primary)}.object-cover{object-fit:cover}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-1\\.5{padding:calc(var(--spacing)*1.5)}.p-2{padding:calc(var(--spacing)*2)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.px-0{padding-inline:calc(var(--spacing)*0)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-6{padding-inline:calc(var(--spacing)*6)}.py-0\\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-6{padding-block:calc(var(--spacing)*6)}.pt-3{padding-top:calc(var(--spacing)*3)}.pt-4{padding-top:calc(var(--spacing)*4)}.pr-2{padding-right:calc(var(--spacing)*2)}.pr-2\\.5{padding-right:calc(var(--spacing)*2.5)}.pr-3{padding-right:calc(var(--spacing)*3)}.pr-8{padding-right:calc(var(--spacing)*8)}.pb-0{padding-bottom:calc(var(--spacing)*0)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.pl-4{padding-left:calc(var(--spacing)*4)}.pl-8{padding-left:calc(var(--spacing)*8)}.text-center{text-align:center}.text-left{text-align:left}.font-mono{font-family:var(--font-mono)}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[10px\\]{font-size:10px}.leading-none{--tw-leading:1;line-height:1}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-widest{--tw-tracking:var(--tracking-widest);letter-spacing:var(--tracking-widest)}.whitespace-nowrap{white-space:nowrap}.text-card-foreground{color:var(--card-foreground)}.text-foreground{color:var(--foreground)}.text-green-400{color:var(--color-green-400)}.text-muted-foreground{color:var(--muted-foreground)}.text-popover-foreground{color:var(--popover-foreground)}.text-primary{color:var(--primary)}.text-primary-foreground{color:var(--primary-foreground)}.text-secondary-foreground{color:var(--secondary-foreground)}.text-white{color:var(--color-white)}.tabular-nums{--tw-numeric-spacing:tabular-nums;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.underline-offset-4{text-underline-offset:4px}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.opacity-100{opacity:1}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-inner{--tw-shadow:inset 0 2px 4px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-0{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(0px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-ring\\/50{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.ring-ring\\/50{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.ring-offset-background{--tw-ring-offset-color:var(--background)}.outline-hidden{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.outline-hidden{outline-offset:2px;outline:2px solid #0000}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-\\[color\\,box-shadow\\]{transition-property:color,box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.running{animation-play-state:running}.group-data-\\[disabled\\=true\\]\\:pointer-events-none:is(:where(.group)[data-disabled=true] *){pointer-events:none}.group-data-\\[disabled\\=true\\]\\:opacity-50:is(:where(.group)[data-disabled=true] *){opacity:.5}.group-data-\\[state\\=open\\]\\:rotate-180:is(:where(.group)[data-state=open] *){rotate:180deg}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:top-full:is(:where(.group\\/navigation-menu)[data-viewport=false] *){top:100%}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:mt-1\\.5:is(:where(.group\\/navigation-menu)[data-viewport=false] *){margin-top:calc(var(--spacing)*1.5)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:overflow-hidden:is(:where(.group\\/navigation-menu)[data-viewport=false] *){overflow:hidden}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:rounded-md:is(:where(.group\\/navigation-menu)[data-viewport=false] *){border-radius:calc(var(--radius) - 2px)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:border:is(:where(.group\\/navigation-menu)[data-viewport=false] *){border-style:var(--tw-border-style);border-width:1px}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:bg-popover:is(:where(.group\\/navigation-menu)[data-viewport=false] *){background-color:var(--popover)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:text-popover-foreground:is(:where(.group\\/navigation-menu)[data-viewport=false] *){color:var(--popover-foreground)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:shadow:is(:where(.group\\/navigation-menu)[data-viewport=false] *){--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:duration-200:is(:where(.group\\/navigation-menu)[data-viewport=false] *){--tw-duration:.2s;transition-duration:.2s}.peer-disabled\\:cursor-not-allowed:is(:where(.peer):disabled~*){cursor:not-allowed}.peer-disabled\\:opacity-50:is(:where(.peer):disabled~*){opacity:.5}.selection\\:bg-primary ::selection{background-color:var(--primary)}.selection\\:bg-primary::selection{background-color:var(--primary)}.selection\\:text-primary-foreground ::selection{color:var(--primary-foreground)}.selection\\:text-primary-foreground::selection{color:var(--primary-foreground)}.file\\:inline-flex::file-selector-button{display:inline-flex}.file\\:h-7::file-selector-button{height:calc(var(--spacing)*7)}.file\\:border-0::file-selector-button{border-style:var(--tw-border-style);border-width:0}.file\\:bg-transparent::file-selector-button{background-color:#0000}.file\\:text-sm::file-selector-button{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.file\\:font-medium::file-selector-button{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.file\\:text-foreground::file-selector-button{color:var(--foreground)}.placeholder\\:text-muted-foreground::placeholder{color:var(--muted-foreground)}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:inset-y-0:after{content:var(--tw-content);inset-block:calc(var(--spacing)*0)}.after\\:left-1\\/2:after{content:var(--tw-content);left:50%}.after\\:w-1:after{content:var(--tw-content);width:calc(var(--spacing)*1)}.after\\:-translate-x-1\\/2:after{content:var(--tw-content);--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}@media (hover:hover){.hover\\:border-primary\\/50:hover{border-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:border-primary\\/50:hover{border-color:color-mix(in oklab,var(--primary)50%,transparent)}}.hover\\:bg-accent:hover{background-color:var(--accent)}.hover\\:bg-background\\/60:hover{background-color:var(--background)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-background\\/60:hover{background-color:color-mix(in oklab,var(--background)60%,transparent)}}.hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}.hover\\:bg-muted:hover{background-color:var(--muted)}.hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}.hover\\:bg-secondary:hover,.hover\\:bg-secondary\\/80:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-secondary\\/80:hover{background-color:color-mix(in oklab,var(--secondary)80%,transparent)}}.hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}.hover\\:text-indigo-300:hover{color:var(--color-indigo-300)}.hover\\:text-muted-foreground:hover{color:var(--muted-foreground)}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}.hover\\:ring-4:hover{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}.focus\\:bg-accent:focus{background-color:var(--accent)}.focus\\:text-accent-foreground:focus{color:var(--accent-foreground)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-ring:focus{--tw-ring-color:var(--ring)}.focus\\:ring-offset-2:focus{--tw-ring-offset-width:2px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}.focus\\:outline-hidden:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.focus\\:outline-hidden:focus{outline-offset:2px;outline:2px solid #0000}}.focus-visible\\:border-ring:focus-visible{border-color:var(--ring)}.focus-visible\\:ring-1:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-4:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-\\[3px\\]:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.focus-visible\\:ring-ring:focus-visible,.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus-visible\\:ring-offset-1:focus-visible{--tw-ring-offset-width:1px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}.focus-visible\\:outline-hidden:focus-visible{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.focus-visible\\:outline-hidden:focus-visible{outline-offset:2px;outline:2px solid #0000}}.focus-visible\\:outline-1:focus-visible{outline-style:var(--tw-outline-style);outline-width:1px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.has-data-\\[slot\\=card-action\\]\\:grid-cols-\\[1fr_auto\\]:has([data-slot=card-action]){grid-template-columns:1fr auto}.has-\\[\\>svg\\]\\:px-2\\.5:has(>svg){padding-inline:calc(var(--spacing)*2.5)}.has-\\[\\>svg\\]\\:px-3:has(>svg){padding-inline:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-4:has(>svg){padding-inline:calc(var(--spacing)*4)}.aria-invalid\\:border-destructive[aria-invalid=true]{border-color:var(--destructive)}.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.data-\\[active\\=true\\]\\:bg-accent\\/50[data-active=true]{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.data-\\[active\\=true\\]\\:bg-accent\\/50[data-active=true]{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.data-\\[active\\=true\\]\\:text-accent-foreground[data-active=true]{color:var(--accent-foreground)}@media (hover:hover){.data-\\[active\\=true\\]\\:hover\\:bg-accent[data-active=true]:hover{background-color:var(--accent)}}.data-\\[active\\=true\\]\\:focus\\:bg-accent[data-active=true]:focus{background-color:var(--accent)}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[disabled\\=true\\]\\:pointer-events-none[data-disabled=true]{pointer-events:none}.data-\\[disabled\\=true\\]\\:opacity-50[data-disabled=true]{opacity:.5}.data-\\[inset\\]\\:pl-8[data-inset]{padding-left:calc(var(--spacing)*8)}.data-\\[motion\\=from-end\\]\\:slide-in-from-right-52[data-motion=from-end]{--tw-enter-translate-x:calc(52*var(--spacing))}.data-\\[motion\\=from-start\\]\\:slide-in-from-left-52[data-motion=from-start]{--tw-enter-translate-x:calc(52*var(--spacing)*-1)}.data-\\[motion\\=to-end\\]\\:slide-out-to-right-52[data-motion=to-end]{--tw-exit-translate-x:calc(52*var(--spacing))}.data-\\[motion\\=to-start\\]\\:slide-out-to-left-52[data-motion=to-start]{--tw-exit-translate-x:calc(52*var(--spacing)*-1)}.data-\\[motion\\^\\=from-\\]\\:animate-in[data-motion^=from-]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[motion\\^\\=from-\\]\\:fade-in[data-motion^=from-]{--tw-enter-opacity:0}.data-\\[motion\\^\\=to-\\]\\:animate-out[data-motion^=to-]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[motion\\^\\=to-\\]\\:fade-out[data-motion^=to-]{--tw-exit-opacity:0}.data-\\[orientation\\=horizontal\\]\\:h-1\\.5[data-orientation=horizontal]{height:calc(var(--spacing)*1.5)}.data-\\[orientation\\=horizontal\\]\\:h-full[data-orientation=horizontal]{height:100%}.data-\\[orientation\\=horizontal\\]\\:w-full[data-orientation=horizontal]{width:100%}.data-\\[orientation\\=vertical\\]\\:h-full[data-orientation=vertical]{height:100%}.data-\\[orientation\\=vertical\\]\\:min-h-44[data-orientation=vertical]{min-height:calc(var(--spacing)*44)}.data-\\[orientation\\=vertical\\]\\:w-1\\.5[data-orientation=vertical]{width:calc(var(--spacing)*1.5)}.data-\\[orientation\\=vertical\\]\\:w-auto[data-orientation=vertical]{width:auto}.data-\\[orientation\\=vertical\\]\\:w-full[data-orientation=vertical]{width:100%}.data-\\[orientation\\=vertical\\]\\:flex-col[data-orientation=vertical]{flex-direction:column}.data-\\[panel-group-direction\\=vertical\\]\\:h-px[data-panel-group-direction=vertical]{height:1px}.data-\\[panel-group-direction\\=vertical\\]\\:w-full[data-panel-group-direction=vertical]{width:100%}.data-\\[panel-group-direction\\=vertical\\]\\:flex-col[data-panel-group-direction=vertical]{flex-direction:column}.data-\\[panel-group-direction\\=vertical\\]\\:after\\:left-0[data-panel-group-direction=vertical]:after{content:var(--tw-content);left:calc(var(--spacing)*0)}.data-\\[panel-group-direction\\=vertical\\]\\:after\\:h-1[data-panel-group-direction=vertical]:after{content:var(--tw-content);height:calc(var(--spacing)*1)}.data-\\[panel-group-direction\\=vertical\\]\\:after\\:w-full[data-panel-group-direction=vertical]:after{content:var(--tw-content);width:100%}.data-\\[panel-group-direction\\=vertical\\]\\:after\\:translate-x-0[data-panel-group-direction=vertical]:after{content:var(--tw-content);--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[panel-group-direction\\=vertical\\]\\:after\\:-translate-y-1\\/2[data-panel-group-direction=vertical]:after{content:var(--tw-content);--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[placeholder\\]\\:text-muted-foreground[data-placeholder]{color:var(--muted-foreground)}.data-\\[selected\\=true\\]\\:bg-accent[data-selected=true]{background-color:var(--accent)}.data-\\[selected\\=true\\]\\:text-accent-foreground[data-selected=true]{color:var(--accent-foreground)}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x:calc(var(--spacing)*1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y:calc(2*var(--spacing))}.data-\\[size\\=default\\]\\:h-9[data-size=default]{height:calc(var(--spacing)*9)}.data-\\[size\\=sm\\]\\:h-8[data-size=sm]{height:calc(var(--spacing)*8)}:is(.\\*\\*\\:data-\\[slot\\=command-input-wrapper\\]\\:h-12 *)[data-slot=command-input-wrapper]{height:calc(var(--spacing)*12)}:is(.\\*\\*\\:data-\\[slot\\=navigation-menu-link\\]\\:focus\\:ring-0 *)[data-slot=navigation-menu-link]:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(0px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}:is(.\\*\\*\\:data-\\[slot\\=navigation-menu-link\\]\\:focus\\:outline-none *)[data-slot=navigation-menu-link]:focus{--tw-outline-style:none;outline-style:none}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:line-clamp-1>*)[data-slot=select-value]{-webkit-line-clamp:1;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:flex>*)[data-slot=select-value]{display:flex}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:items-center>*)[data-slot=select-value]{align-items:center}:is(.\\*\\:data-\\[slot\\=select-value\\]\\:gap-2>*)[data-slot=select-value]{gap:calc(var(--spacing)*2)}.data-\\[state\\=checked\\]\\:translate-x-\\[calc\\(100\\%-2px\\)\\][data-state=checked]{--tw-translate-x: calc(100% - 2px) ;translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:var(--primary)}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity:0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale:.95}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:data-\\[state\\=closed\\]\\:animate-out:is(:where(.group\\/navigation-menu)[data-viewport=false] *)[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:data-\\[state\\=closed\\]\\:fade-out-0:is(:where(.group\\/navigation-menu)[data-viewport=false] *)[data-state=closed]{--tw-exit-opacity:0}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:data-\\[state\\=closed\\]\\:zoom-out-95:is(:where(.group\\/navigation-menu)[data-viewport=false] *)[data-state=closed]{--tw-exit-scale:.95}.data-\\[state\\=hidden\\]\\:animate-out[data-state=hidden]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=hidden\\]\\:fade-out[data-state=hidden]{--tw-exit-opacity:0}.data-\\[state\\=on\\]\\:bg-accent[data-state=on]{background-color:var(--accent)}.data-\\[state\\=on\\]\\:text-accent-foreground[data-state=on]{color:var(--accent-foreground)}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=open\\]\\:bg-accent[data-state=open],.data-\\[state\\=open\\]\\:bg-accent\\/50[data-state=open]{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.data-\\[state\\=open\\]\\:bg-accent\\/50[data-state=open]{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.data-\\[state\\=open\\]\\:text-accent-foreground[data-state=open]{color:var(--accent-foreground)}.data-\\[state\\=open\\]\\:text-muted-foreground[data-state=open]{color:var(--muted-foreground)}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity:0}.data-\\[state\\=open\\]\\:zoom-in-90[data-state=open]{--tw-enter-scale:.9}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale:.95}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:data-\\[state\\=open\\]\\:animate-in:is(:where(.group\\/navigation-menu)[data-viewport=false] *)[data-state=open]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:data-\\[state\\=open\\]\\:fade-in-0:is(:where(.group\\/navigation-menu)[data-viewport=false] *)[data-state=open]{--tw-enter-opacity:0}.group-data-\\[viewport\\=false\\]\\/navigation-menu\\:data-\\[state\\=open\\]\\:zoom-in-95:is(:where(.group\\/navigation-menu)[data-viewport=false] *)[data-state=open]{--tw-enter-scale:.95}@media (hover:hover){.data-\\[state\\=open\\]\\:hover\\:bg-accent[data-state=open]:hover{background-color:var(--accent)}}.data-\\[state\\=open\\]\\:focus\\:bg-accent[data-state=open]:focus{background-color:var(--accent)}.data-\\[state\\=unchecked\\]\\:translate-x-0[data-state=unchecked]{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[state\\=unchecked\\]\\:bg-input[data-state=unchecked]{background-color:var(--input)}.data-\\[state\\=visible\\]\\:animate-in[data-state=visible]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=visible\\]\\:fade-in[data-state=visible]{--tw-enter-opacity:0}.data-\\[variant\\=destructive\\]\\:text-destructive[data-variant=destructive]{color:var(--destructive)}.data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/10[data-variant=destructive]:focus{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/10[data-variant=destructive]:focus{background-color:color-mix(in oklab,var(--destructive)10%,transparent)}}.data-\\[variant\\=destructive\\]\\:focus\\:text-destructive[data-variant=destructive]:focus{color:var(--destructive)}@media (min-width:40rem){.sm\\:inline{display:inline}.sm\\:max-w-lg{max-width:var(--container-lg)}.sm\\:max-w-md{max-width:var(--container-md)}.sm\\:flex-row{flex-direction:row}.sm\\:items-center{align-items:center}.sm\\:justify-end{justify-content:flex-end}.sm\\:gap-10{gap:calc(var(--spacing)*10)}.sm\\:px-5{padding-inline:calc(var(--spacing)*5)}.sm\\:text-left{text-align:left}}@media (min-width:48rem){.md\\:absolute{position:absolute}.md\\:flex{display:flex}.md\\:inline{display:inline}.md\\:w-\\[10\\%\\]{width:10%}.md\\:w-\\[20\\%\\]{width:20%}.md\\:w-\\[var\\(--radix-navigation-menu-viewport-width\\)\\]{width:var(--radix-navigation-menu-viewport-width)}.md\\:w-auto{width:auto}.md\\:min-w-\\[120px\\]{min-width:120px}.md\\:basis-1\\/8{flex-basis:12.5%}.md\\:text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}}@media (min-width:64rem){.lg\\:w-\\[70\\%\\]{width:70%}.lg\\:basis-1\\/10{flex-basis:10%}.lg\\:flex-row{flex-direction:row}.lg\\:justify-between{justify-content:space-between}}.dark\\:scale-0:is(.dark *){--tw-scale-x:0%;--tw-scale-y:0%;--tw-scale-z:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.dark\\:scale-100:is(.dark *){--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.dark\\:-rotate-90:is(.dark *){rotate:-90deg}.dark\\:rotate-0:is(.dark *){rotate:none}.dark\\:border-input:is(.dark *){border-color:var(--input)}.dark\\:bg-destructive\\/60:is(.dark *){background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-destructive\\/60:is(.dark *){background-color:color-mix(in oklab,var(--destructive)60%,transparent)}}.dark\\:bg-input\\/30:is(.dark *){background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-input\\/30:is(.dark *){background-color:color-mix(in oklab,var(--input)30%,transparent)}}@media (hover:hover){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--input)50%,transparent)}}}.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:data-\\[state\\=checked\\]\\:bg-primary-foreground:is(.dark *)[data-state=checked]{background-color:var(--primary-foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-foreground:is(.dark *)[data-state=unchecked]{background-color:var(--foreground)}.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[state\\=unchecked\\]\\:bg-input\\/80:is(.dark *)[data-state=unchecked]{background-color:color-mix(in oklab,var(--input)80%,transparent)}}.dark\\:data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/20:is(.dark *)[data-variant=destructive]:focus{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/20:is(.dark *)[data-variant=destructive]:focus{background-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.\\[\\&_\\.recharts-cartesian-axis-tick_text\\]\\:fill-muted-foreground .recharts-cartesian-axis-tick text{fill:var(--muted-foreground)}.\\[\\&_\\.recharts-cartesian-grid_line\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border\\/50 .recharts-cartesian-grid line[stroke="#ccc"]{stroke:var(--border)}@supports (color:color-mix(in lab,red,red)){.\\[\\&_\\.recharts-cartesian-grid_line\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border\\/50 .recharts-cartesian-grid line[stroke="#ccc"]{stroke:color-mix(in oklab,var(--border)50%,transparent)}}.\\[\\&_\\.recharts-curve\\.recharts-tooltip-cursor\\]\\:stroke-border .recharts-curve.recharts-tooltip-cursor{stroke:var(--border)}.\\[\\&_\\.recharts-dot\\[stroke\\=\\'\\#fff\\'\\]\\]\\:stroke-transparent .recharts-dot[stroke="#fff"]{stroke:#0000}.\\[\\&_\\.recharts-layer\\]\\:outline-hidden .recharts-layer{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.\\[\\&_\\.recharts-layer\\]\\:outline-hidden .recharts-layer{outline-offset:2px;outline:2px solid #0000}}.\\[\\&_\\.recharts-polar-grid_\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border .recharts-polar-grid [stroke="#ccc"]{stroke:var(--border)}.\\[\\&_\\.recharts-radial-bar-background-sector\\]\\:fill-muted .recharts-radial-bar-background-sector,.\\[\\&_\\.recharts-rectangle\\.recharts-tooltip-cursor\\]\\:fill-muted .recharts-rectangle.recharts-tooltip-cursor{fill:var(--muted)}.\\[\\&_\\.recharts-reference-line_\\[stroke\\=\\'\\#ccc\\'\\]\\]\\:stroke-border .recharts-reference-line [stroke="#ccc"]{stroke:var(--border)}.\\[\\&_\\.recharts-sector\\]\\:outline-hidden .recharts-sector{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.\\[\\&_\\.recharts-sector\\]\\:outline-hidden .recharts-sector{outline-offset:2px;outline:2px solid #0000}}.\\[\\&_\\.recharts-sector\\[stroke\\=\\'\\#fff\\'\\]\\]\\:stroke-transparent .recharts-sector[stroke="#fff"]{stroke:#0000}.\\[\\&_\\.recharts-surface\\]\\:outline-hidden .recharts-surface{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.\\[\\&_\\.recharts-surface\\]\\:outline-hidden .recharts-surface{outline-offset:2px;outline:2px solid #0000}}.\\[\\&_\\[cmdk-group-heading\\]\\]\\:px-2 [cmdk-group-heading]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[cmdk-group-heading\\]\\]\\:py-1\\.5 [cmdk-group-heading]{padding-block:calc(var(--spacing)*1.5)}.\\[\\&_\\[cmdk-group-heading\\]\\]\\:text-xs [cmdk-group-heading]{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.\\[\\&_\\[cmdk-group-heading\\]\\]\\:font-medium [cmdk-group-heading]{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.\\[\\&_\\[cmdk-group-heading\\]\\]\\:text-muted-foreground [cmdk-group-heading]{color:var(--muted-foreground)}.\\[\\&_\\[cmdk-group\\]\\]\\:px-2 [cmdk-group]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[cmdk-group\\]\\:not\\(\\[hidden\\]\\)_\\~\\[cmdk-group\\]\\]\\:pt-0 [cmdk-group]:not([hidden])~[cmdk-group]{padding-top:calc(var(--spacing)*0)}.\\[\\&_\\[cmdk-input-wrapper\\]_svg\\]\\:h-5 [cmdk-input-wrapper] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[cmdk-input-wrapper\\]_svg\\]\\:w-5 [cmdk-input-wrapper] svg{width:calc(var(--spacing)*5)}.\\[\\&_\\[cmdk-input\\]\\]\\:h-12 [cmdk-input]{height:calc(var(--spacing)*12)}.\\[\\&_\\[cmdk-item\\]\\]\\:px-2 [cmdk-item]{padding-inline:calc(var(--spacing)*2)}.\\[\\&_\\[cmdk-item\\]\\]\\:py-3 [cmdk-item]{padding-block:calc(var(--spacing)*3)}.\\[\\&_\\[cmdk-item\\]_svg\\]\\:h-5 [cmdk-item] svg{height:calc(var(--spacing)*5)}.\\[\\&_\\[cmdk-item\\]_svg\\]\\:w-5 [cmdk-item] svg{width:calc(var(--spacing)*5)}.\\[\\&_svg\\]\\:pointer-events-none svg{pointer-events:none}.\\[\\&_svg\\]\\:shrink-0 svg{flex-shrink:0}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\'size-\\'\\]\\)\\]\\:size-4 svg:not([class*=size-]){width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\'text-\\'\\]\\)\\]\\:text-muted-foreground svg:not([class*=text-]){color:var(--muted-foreground)}.\\[\\.border-b\\]\\:pb-6.border-b{padding-bottom:calc(var(--spacing)*6)}.\\[\\.border-t\\]\\:pt-6.border-t{padding-top:calc(var(--spacing)*6)}:is(.\\*\\:\\[span\\]\\:last\\:flex>*):is(span):last-child{display:flex}:is(.\\*\\:\\[span\\]\\:last\\:items-center>*):is(span):last-child{align-items:center}:is(.\\*\\:\\[span\\]\\:last\\:gap-2>*):is(span):last-child{gap:calc(var(--spacing)*2)}:is(.data-\\[variant\\=destructive\\]\\:\\*\\:\\[svg\\]\\:\\!text-destructive[data-variant=destructive]>*):is(svg){color:var(--destructive)!important}.\\[\\&\\>\\[data-slot\\=slider-track\\]\\]\\:bg-transparent>[data-slot=slider-track],.\\[\\&\\>\\[data-slot\\=slider-track\\]\\>\\[data-slot\\=slider-range\\]\\]\\:bg-transparent>[data-slot=slider-track]>[data-slot=slider-range]{background-color:#0000}.\\[\\&\\>svg\\]\\:pointer-events-none>svg{pointer-events:none}.\\[\\&\\>svg\\]\\:size-3>svg{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.\\[\\&\\>svg\\]\\:h-2\\.5>svg{height:calc(var(--spacing)*2.5)}.\\[\\&\\>svg\\]\\:h-3>svg{height:calc(var(--spacing)*3)}.\\[\\&\\>svg\\]\\:w-2\\.5>svg{width:calc(var(--spacing)*2.5)}.\\[\\&\\>svg\\]\\:w-3>svg{width:calc(var(--spacing)*3)}.\\[\\&\\>svg\\]\\:text-muted-foreground>svg{color:var(--muted-foreground)}.\\[\\&\\[data-panel-group-direction\\=vertical\\]\\>div\\]\\:rotate-90[data-panel-group-direction=vertical]>div{rotate:90deg}@media (hover:hover){a.\\[a\\&\\]\\:hover\\:bg-accent:hover{background-color:var(--accent)}a.\\[a\\&\\]\\:hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){a.\\[a\\&\\]\\:hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}a.\\[a\\&\\]\\:hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){a.\\[a\\&\\]\\:hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}a.\\[a\\&\\]\\:hover\\:bg-secondary\\/90:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){a.\\[a\\&\\]\\:hover\\:bg-secondary\\/90:hover{background-color:color-mix(in oklab,var(--secondary)90%,transparent)}}a.\\[a\\&\\]\\:hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}}}@property --tw-animation-delay{syntax:"*";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:"*";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:"*";inherits:false}@property --tw-animation-fill-mode{syntax:"*";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:"*";inherits:false;initial-value:0}:root{--radius:.625rem;--background:oklch(100% 0 0);--foreground:oklch(12.9% .042 264.695);--card:oklch(100% 0 0);--card-foreground:oklch(12.9% .042 264.695);--popover:oklch(100% 0 0);--popover-foreground:oklch(12.9% .042 264.695);--primary:oklch(20.8% .042 265.755);--primary-foreground:oklch(98.4% .003 247.858);--secondary:oklch(96.8% .007 247.896);--secondary-foreground:oklch(20.8% .042 265.755);--muted:oklch(96.8% .007 247.896);--muted-foreground:oklch(55.4% .046 257.417);--accent:oklch(96.8% .007 247.896);--accent-foreground:oklch(20.8% .042 265.755);--destructive:oklch(57.7% .245 27.325);--border:oklch(92.9% .013 255.508);--input:oklch(92.9% .013 255.508);--ring:oklch(70.4% .04 256.788);--chart-1:oklch(64.6% .222 41.116);--chart-2:oklch(60% .118 184.704);--chart-3:oklch(39.8% .07 227.392);--chart-4:oklch(82.8% .189 84.429);--chart-5:oklch(76.9% .188 70.08);--sidebar:oklch(98.4% .003 247.858);--sidebar-foreground:oklch(12.9% .042 264.695);--sidebar-primary:oklch(20.8% .042 265.755);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(96.8% .007 247.896);--sidebar-accent-foreground:oklch(20.8% .042 265.755);--sidebar-border:oklch(92.9% .013 255.508);--sidebar-ring:oklch(70.4% .04 256.788)}.dark{--background:oklch(12.9% .042 264.695);--foreground:oklch(98.4% .003 247.858);--card:oklch(20.8% .042 265.755);--card-foreground:oklch(98.4% .003 247.858);--popover:oklch(20.8% .042 265.755);--popover-foreground:oklch(98.4% .003 247.858);--primary:oklch(92.9% .013 255.508);--primary-foreground:oklch(20.8% .042 265.755);--secondary:oklch(27.9% .041 260.031);--secondary-foreground:oklch(98.4% .003 247.858);--muted:oklch(27.9% .041 260.031);--muted-foreground:oklch(70.4% .04 256.788);--accent:oklch(27.9% .041 260.031);--accent-foreground:oklch(98.4% .003 247.858);--destructive:oklch(70.4% .191 22.216);--border:oklch(100% 0 0/.1);--input:oklch(100% 0 0/.15);--ring:oklch(55.1% .027 264.364);--chart-1:oklch(48.8% .243 264.376);--chart-2:oklch(69.6% .17 162.48);--chart-3:oklch(76.9% .188 70.08);--chart-4:oklch(62.7% .265 303.9);--chart-5:oklch(64.5% .246 16.439);--sidebar:oklch(20.8% .042 265.755);--sidebar-foreground:oklch(98.4% .003 247.858);--sidebar-primary:oklch(48.8% .243 264.376);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(27.9% .041 260.031);--sidebar-accent-foreground:oklch(98.4% .003 247.858);--sidebar-border:oklch(100% 0 0/.1);--sidebar-ring:oklch(55.1% .027 264.364)}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-space-x-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-tracking{syntax:"*";inherits:false}@property --tw-ordinal{syntax:"*";inherits:false}@property --tw-slashed-zero{syntax:"*";inherits:false}@property --tw-numeric-figure{syntax:"*";inherits:false}@property --tw-numeric-spacing{syntax:"*";inherits:false}@property --tw-numeric-fraction{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-content{syntax:"*";inherits:false;initial-value:""}@keyframes spin{to{transform:rotate(360deg)}}@keyframes pulse{50%{opacity:.5}}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));filter:blur(var(--tw-enter-blur,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));filter:blur(var(--tw-exit-blur,0))}}`)),document.head.appendChild(a)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
function MN(A, g) {
  for (var I = 0; I < g.length; I++) {
    const C = g[I];
    if (typeof C != "string" && !Array.isArray(C)) {
      for (const t in C)
        if (t !== "default" && !(t in A)) {
          const s = Object.getOwnPropertyDescriptor(C, t);
          s && Object.defineProperty(A, t, s.get ? s : {
            enumerable: !0,
            get: () => C[t]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(A, Symbol.toStringTag, { value: "Module" }));
}
function CG(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var bB = { exports: {} }, HD = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TY;
function wN() {
  if (TY) return HD;
  TY = 1;
  var A = Symbol.for("react.transitional.element"), g = Symbol.for("react.fragment");
  function I(C, t, s) {
    var r = null;
    if (s !== void 0 && (r = "" + s), t.key !== void 0 && (r = "" + t.key), "key" in t) {
      s = {};
      for (var l in t)
        l !== "key" && (s[l] = t[l]);
    } else s = t;
    return t = s.ref, {
      $$typeof: A,
      type: C,
      key: r,
      ref: t !== void 0 ? t : null,
      props: s
    };
  }
  return HD.Fragment = g, HD.jsx = I, HD.jsxs = I, HD;
}
var ED = {}, SB = { exports: {} }, KI = {}, YY;
function BN() {
  if (YY) return KI;
  YY = 1;
  var A = {};
  /**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var g = Symbol.for("react.transitional.element"), I = Symbol.for("react.portal"), C = Symbol.for("react.fragment"), t = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), r = Symbol.for("react.consumer"), l = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), D = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), p = Symbol.iterator;
  function b(N) {
    return N === null || typeof N != "object" ? null : (N = p && N[p] || N["@@iterator"], typeof N == "function" ? N : null);
  }
  var S = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, K = Object.assign, Y = {};
  function T(N, F, rg) {
    this.props = N, this.context = F, this.refs = Y, this.updater = rg || S;
  }
  T.prototype.isReactComponent = {}, T.prototype.setState = function(N, F) {
    if (typeof N != "object" && typeof N != "function" && N != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, N, F, "setState");
  }, T.prototype.forceUpdate = function(N) {
    this.updater.enqueueForceUpdate(this, N, "forceUpdate");
  };
  function E() {
  }
  E.prototype = T.prototype;
  function H(N, F, rg) {
    this.props = N, this.context = F, this.refs = Y, this.updater = rg || S;
  }
  var R = H.prototype = new E();
  R.constructor = H, K(R, T.prototype), R.isPureReactComponent = !0;
  var x = Array.isArray, U = { H: null, A: null, T: null, S: null, V: null }, J = Object.prototype.hasOwnProperty;
  function L(N, F, rg, Cg, Sg, kg) {
    return rg = kg.ref, {
      $$typeof: g,
      type: N,
      key: F,
      ref: rg !== void 0 ? rg : null,
      props: kg
    };
  }
  function eg(N, F) {
    return L(
      N.type,
      F,
      void 0,
      void 0,
      void 0,
      N.props
    );
  }
  function Mg(N) {
    return typeof N == "object" && N !== null && N.$$typeof === g;
  }
  function ig(N) {
    var F = { "=": "=0", ":": "=2" };
    return "$" + N.replace(/[=:]/g, function(rg) {
      return F[rg];
    });
  }
  var Zg = /\/+/g;
  function Kg(N, F) {
    return typeof N == "object" && N !== null && N.key != null ? ig("" + N.key) : F.toString(36);
  }
  function mg() {
  }
  function Ng(N) {
    switch (N.status) {
      case "fulfilled":
        return N.value;
      case "rejected":
        throw N.reason;
      default:
        switch (typeof N.status == "string" ? N.then(mg, mg) : (N.status = "pending", N.then(
          function(F) {
            N.status === "pending" && (N.status = "fulfilled", N.value = F);
          },
          function(F) {
            N.status === "pending" && (N.status = "rejected", N.reason = F);
          }
        )), N.status) {
          case "fulfilled":
            return N.value;
          case "rejected":
            throw N.reason;
        }
    }
    throw N;
  }
  function cg(N, F, rg, Cg, Sg) {
    var kg = typeof N;
    (kg === "undefined" || kg === "boolean") && (N = null);
    var Yg = !1;
    if (N === null) Yg = !0;
    else
      switch (kg) {
        case "bigint":
        case "string":
        case "number":
          Yg = !0;
          break;
        case "object":
          switch (N.$$typeof) {
            case g:
            case I:
              Yg = !0;
              break;
            case w:
              return Yg = N._init, cg(
                Yg(N._payload),
                F,
                rg,
                Cg,
                Sg
              );
          }
      }
    if (Yg)
      return Sg = Sg(N), Yg = Cg === "" ? "." + Kg(N, 0) : Cg, x(Sg) ? (rg = "", Yg != null && (rg = Yg.replace(Zg, "$&/") + "/"), cg(Sg, F, rg, "", function(nI) {
        return nI;
      })) : Sg != null && (Mg(Sg) && (Sg = eg(
        Sg,
        rg + (Sg.key == null || N && N.key === Sg.key ? "" : ("" + Sg.key).replace(
          Zg,
          "$&/"
        ) + "/") + Yg
      )), F.push(Sg)), 1;
    Yg = 0;
    var Wg = Cg === "" ? "." : Cg + ":";
    if (x(N))
      for (var Xg = 0; Xg < N.length; Xg++)
        Cg = N[Xg], kg = Wg + Kg(Cg, Xg), Yg += cg(
          Cg,
          F,
          rg,
          kg,
          Sg
        );
    else if (Xg = b(N), typeof Xg == "function")
      for (N = Xg.call(N), Xg = 0; !(Cg = N.next()).done; )
        Cg = Cg.value, kg = Wg + Kg(Cg, Xg++), Yg += cg(
          Cg,
          F,
          rg,
          kg,
          Sg
        );
    else if (kg === "object") {
      if (typeof N.then == "function")
        return cg(
          Ng(N),
          F,
          rg,
          Cg,
          Sg
        );
      throw F = String(N), Error(
        "Objects are not valid as a React child (found: " + (F === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : F) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return Yg;
  }
  function z(N, F, rg) {
    if (N == null) return N;
    var Cg = [], Sg = 0;
    return cg(N, Cg, "", "", function(kg) {
      return F.call(rg, kg, Sg++);
    }), Cg;
  }
  function Q(N) {
    if (N._status === -1) {
      var F = N._result;
      F = F(), F.then(
        function(rg) {
          (N._status === 0 || N._status === -1) && (N._status = 1, N._result = rg);
        },
        function(rg) {
          (N._status === 0 || N._status === -1) && (N._status = 2, N._result = rg);
        }
      ), N._status === -1 && (N._status = 0, N._result = F);
    }
    if (N._status === 1) return N._result.default;
    throw N._result;
  }
  var Bg = typeof reportError == "function" ? reportError : function(N) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var F = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof N == "object" && N !== null && typeof N.message == "string" ? String(N.message) : String(N),
        error: N
      });
      if (!window.dispatchEvent(F)) return;
    } else if (typeof A == "object" && typeof A.emit == "function") {
      A.emit("uncaughtException", N);
      return;
    }
    console.error(N);
  };
  function Rg() {
  }
  return KI.Children = {
    map: z,
    forEach: function(N, F, rg) {
      z(
        N,
        function() {
          F.apply(this, arguments);
        },
        rg
      );
    },
    count: function(N) {
      var F = 0;
      return z(N, function() {
        F++;
      }), F;
    },
    toArray: function(N) {
      return z(N, function(F) {
        return F;
      }) || [];
    },
    only: function(N) {
      if (!Mg(N))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return N;
    }
  }, KI.Component = T, KI.Fragment = C, KI.Profiler = s, KI.PureComponent = H, KI.StrictMode = t, KI.Suspense = h, KI.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = U, KI.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(N) {
      return U.H.useMemoCache(N);
    }
  }, KI.cache = function(N) {
    return function() {
      return N.apply(null, arguments);
    };
  }, KI.cloneElement = function(N, F, rg) {
    if (N == null)
      throw Error(
        "The argument must be a React element, but you passed " + N + "."
      );
    var Cg = K({}, N.props), Sg = N.key, kg = void 0;
    if (F != null)
      for (Yg in F.ref !== void 0 && (kg = void 0), F.key !== void 0 && (Sg = "" + F.key), F)
        !J.call(F, Yg) || Yg === "key" || Yg === "__self" || Yg === "__source" || Yg === "ref" && F.ref === void 0 || (Cg[Yg] = F[Yg]);
    var Yg = arguments.length - 2;
    if (Yg === 1) Cg.children = rg;
    else if (1 < Yg) {
      for (var Wg = Array(Yg), Xg = 0; Xg < Yg; Xg++)
        Wg[Xg] = arguments[Xg + 2];
      Cg.children = Wg;
    }
    return L(N.type, Sg, void 0, void 0, kg, Cg);
  }, KI.createContext = function(N) {
    return N = {
      $$typeof: l,
      _currentValue: N,
      _currentValue2: N,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, N.Provider = N, N.Consumer = {
      $$typeof: r,
      _context: N
    }, N;
  }, KI.createElement = function(N, F, rg) {
    var Cg, Sg = {}, kg = null;
    if (F != null)
      for (Cg in F.key !== void 0 && (kg = "" + F.key), F)
        J.call(F, Cg) && Cg !== "key" && Cg !== "__self" && Cg !== "__source" && (Sg[Cg] = F[Cg]);
    var Yg = arguments.length - 2;
    if (Yg === 1) Sg.children = rg;
    else if (1 < Yg) {
      for (var Wg = Array(Yg), Xg = 0; Xg < Yg; Xg++)
        Wg[Xg] = arguments[Xg + 2];
      Sg.children = Wg;
    }
    if (N && N.defaultProps)
      for (Cg in Yg = N.defaultProps, Yg)
        Sg[Cg] === void 0 && (Sg[Cg] = Yg[Cg]);
    return L(N, kg, void 0, void 0, null, Sg);
  }, KI.createRef = function() {
    return { current: null };
  }, KI.forwardRef = function(N) {
    return { $$typeof: d, render: N };
  }, KI.isValidElement = Mg, KI.lazy = function(N) {
    return {
      $$typeof: w,
      _payload: { _status: -1, _result: N },
      _init: Q
    };
  }, KI.memo = function(N, F) {
    return {
      $$typeof: D,
      type: N,
      compare: F === void 0 ? null : F
    };
  }, KI.startTransition = function(N) {
    var F = U.T, rg = {};
    U.T = rg;
    try {
      var Cg = N(), Sg = U.S;
      Sg !== null && Sg(rg, Cg), typeof Cg == "object" && Cg !== null && typeof Cg.then == "function" && Cg.then(Rg, Bg);
    } catch (kg) {
      Bg(kg);
    } finally {
      U.T = F;
    }
  }, KI.unstable_useCacheRefresh = function() {
    return U.H.useCacheRefresh();
  }, KI.use = function(N) {
    return U.H.use(N);
  }, KI.useActionState = function(N, F, rg) {
    return U.H.useActionState(N, F, rg);
  }, KI.useCallback = function(N, F) {
    return U.H.useCallback(N, F);
  }, KI.useContext = function(N) {
    return U.H.useContext(N);
  }, KI.useDebugValue = function() {
  }, KI.useDeferredValue = function(N, F) {
    return U.H.useDeferredValue(N, F);
  }, KI.useEffect = function(N, F, rg) {
    var Cg = U.H;
    if (typeof rg == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return Cg.useEffect(N, F);
  }, KI.useId = function() {
    return U.H.useId();
  }, KI.useImperativeHandle = function(N, F, rg) {
    return U.H.useImperativeHandle(N, F, rg);
  }, KI.useInsertionEffect = function(N, F) {
    return U.H.useInsertionEffect(N, F);
  }, KI.useLayoutEffect = function(N, F) {
    return U.H.useLayoutEffect(N, F);
  }, KI.useMemo = function(N, F) {
    return U.H.useMemo(N, F);
  }, KI.useOptimistic = function(N, F) {
    return U.H.useOptimistic(N, F);
  }, KI.useReducer = function(N, F, rg) {
    return U.H.useReducer(N, F, rg);
  }, KI.useRef = function(N) {
    return U.H.useRef(N);
  }, KI.useState = function(N) {
    return U.H.useState(N);
  }, KI.useSyncExternalStore = function(N, F, rg) {
    return U.H.useSyncExternalStore(
      N,
      F,
      rg
    );
  }, KI.useTransition = function() {
    return U.H.useTransition();
  }, KI.version = "19.1.1", KI;
}
var QD = { exports: {} };
QD.exports;
var PY;
function pN() {
  return PY || (PY = 1, (function(A, g) {
    var I = {}, C = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    C.NODE_ENV !== "production" && (function() {
      function t(k, og) {
        Object.defineProperty(l.prototype, k, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              og[0],
              og[1]
            );
          }
        });
      }
      function s(k) {
        return k === null || typeof k != "object" ? null : (k = fI && k[fI] || k["@@iterator"], typeof k == "function" ? k : null);
      }
      function r(k, og) {
        k = (k = k.constructor) && (k.displayName || k.name) || "ReactClass";
        var Vg = k + "." + og;
        VI[Vg] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          og,
          k
        ), VI[Vg] = !0);
      }
      function l(k, og, Vg) {
        this.props = k, this.context = og, this.refs = UC, this.updater = Vg || oA;
      }
      function d() {
      }
      function h(k, og, Vg) {
        this.props = k, this.context = og, this.refs = UC, this.updater = Vg || oA;
      }
      function D(k) {
        return "" + k;
      }
      function w(k) {
        try {
          D(k);
          var og = !1;
        } catch {
          og = !0;
        }
        if (og) {
          og = console;
          var Vg = og.error, _g = typeof Symbol == "function" && Symbol.toStringTag && k[Symbol.toStringTag] || k.constructor.name || "Object";
          return Vg.call(
            og,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            _g
          ), D(k);
        }
      }
      function p(k) {
        if (k == null) return null;
        if (typeof k == "function")
          return k.$$typeof === Lt ? null : k.displayName || k.name || null;
        if (typeof k == "string") return k;
        switch (k) {
          case F:
            return "Fragment";
          case Cg:
            return "Profiler";
          case rg:
            return "StrictMode";
          case Wg:
            return "Suspense";
          case Xg:
            return "SuspenseList";
          case Ug:
            return "Activity";
        }
        if (typeof k == "object")
          switch (typeof k.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), k.$$typeof) {
            case N:
              return "Portal";
            case kg:
              return (k.displayName || "Context") + ".Provider";
            case Sg:
              return (k._context.displayName || "Context") + ".Consumer";
            case Yg:
              var og = k.render;
              return k = k.displayName, k || (k = og.displayName || og.name || "", k = k !== "" ? "ForwardRef(" + k + ")" : "ForwardRef"), k;
            case nI:
              return og = k.displayName || null, og !== null ? og : p(k.type) || "Memo";
            case sI:
              og = k._payload, k = k._init;
              try {
                return p(k(og));
              } catch {
              }
          }
        return null;
      }
      function b(k) {
        if (k === F) return "<>";
        if (typeof k == "object" && k !== null && k.$$typeof === sI)
          return "<...>";
        try {
          var og = p(k);
          return og ? "<" + og + ">" : "<...>";
        } catch {
          return "<...>";
        }
      }
      function S() {
        var k = rI.A;
        return k === null ? null : k.getOwner();
      }
      function K() {
        return Error("react-stack-top-frame");
      }
      function Y(k) {
        if (lt.call(k, "key")) {
          var og = Object.getOwnPropertyDescriptor(k, "key").get;
          if (og && og.isReactWarning) return !1;
        }
        return k.key !== void 0;
      }
      function T(k, og) {
        function Vg() {
          ct || (ct = !0, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            og
          ));
        }
        Vg.isReactWarning = !0, Object.defineProperty(k, "key", {
          get: Vg,
          configurable: !0
        });
      }
      function E() {
        var k = p(this.type);
        return Qe[k] || (Qe[k] = !0, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        )), k = this.props.ref, k !== void 0 ? k : null;
      }
      function H(k, og, Vg, _g, Jg, yI, lI, TI) {
        return Vg = yI.ref, k = {
          $$typeof: Rg,
          type: k,
          key: og,
          props: yI,
          _owner: Jg
        }, (Vg !== void 0 ? Vg : null) !== null ? Object.defineProperty(k, "ref", {
          enumerable: !1,
          get: E
        }) : Object.defineProperty(k, "ref", { enumerable: !1, value: null }), k._store = {}, Object.defineProperty(k._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(k, "_debugInfo", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: null
        }), Object.defineProperty(k, "_debugStack", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: lI
        }), Object.defineProperty(k, "_debugTask", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: TI
        }), Object.freeze && (Object.freeze(k.props), Object.freeze(k)), k;
      }
      function R(k, og) {
        return og = H(
          k.type,
          og,
          void 0,
          void 0,
          k._owner,
          k.props,
          k._debugStack,
          k._debugTask
        ), k._store && (og._store.validated = k._store.validated), og;
      }
      function x(k) {
        return typeof k == "object" && k !== null && k.$$typeof === Rg;
      }
      function U(k) {
        var og = { "=": "=0", ":": "=2" };
        return "$" + k.replace(/[=:]/g, function(Vg) {
          return og[Vg];
        });
      }
      function J(k, og) {
        return typeof k == "object" && k !== null && k.key != null ? (w(k.key), U("" + k.key)) : og.toString(36);
      }
      function L() {
      }
      function eg(k) {
        switch (k.status) {
          case "fulfilled":
            return k.value;
          case "rejected":
            throw k.reason;
          default:
            switch (typeof k.status == "string" ? k.then(L, L) : (k.status = "pending", k.then(
              function(og) {
                k.status === "pending" && (k.status = "fulfilled", k.value = og);
              },
              function(og) {
                k.status === "pending" && (k.status = "rejected", k.reason = og);
              }
            )), k.status) {
              case "fulfilled":
                return k.value;
              case "rejected":
                throw k.reason;
            }
        }
        throw k;
      }
      function Mg(k, og, Vg, _g, Jg) {
        var yI = typeof k;
        (yI === "undefined" || yI === "boolean") && (k = null);
        var lI = !1;
        if (k === null) lI = !0;
        else
          switch (yI) {
            case "bigint":
            case "string":
            case "number":
              lI = !0;
              break;
            case "object":
              switch (k.$$typeof) {
                case Rg:
                case N:
                  lI = !0;
                  break;
                case sI:
                  return lI = k._init, Mg(
                    lI(k._payload),
                    og,
                    Vg,
                    _g,
                    Jg
                  );
              }
          }
        if (lI) {
          lI = k, Jg = Jg(lI);
          var TI = _g === "" ? "." + J(lI, 0) : _g;
          return hC(Jg) ? (Vg = "", TI != null && (Vg = TI.replace(Ri, "$&/") + "/"), Mg(Jg, og, Vg, "", function(VA) {
            return VA;
          })) : Jg != null && (x(Jg) && (Jg.key != null && (lI && lI.key === Jg.key || w(Jg.key)), Vg = R(
            Jg,
            Vg + (Jg.key == null || lI && lI.key === Jg.key ? "" : ("" + Jg.key).replace(
              Ri,
              "$&/"
            ) + "/") + TI
          ), _g !== "" && lI != null && x(lI) && lI.key == null && lI._store && !lI._store.validated && (Vg._store.validated = 2), Jg = Vg), og.push(Jg)), 1;
        }
        if (lI = 0, TI = _g === "" ? "." : _g + ":", hC(k))
          for (var cI = 0; cI < k.length; cI++)
            _g = k[cI], yI = TI + J(_g, cI), lI += Mg(
              _g,
              og,
              Vg,
              yI,
              Jg
            );
        else if (cI = s(k), typeof cI == "function")
          for (cI === k.entries && (pA || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), pA = !0), k = cI.call(k), cI = 0; !(_g = k.next()).done; )
            _g = _g.value, yI = TI + J(_g, cI++), lI += Mg(
              _g,
              og,
              Vg,
              yI,
              Jg
            );
        else if (yI === "object") {
          if (typeof k.then == "function")
            return Mg(
              eg(k),
              og,
              Vg,
              _g,
              Jg
            );
          throw og = String(k), Error(
            "Objects are not valid as a React child (found: " + (og === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : og) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return lI;
      }
      function ig(k, og, Vg) {
        if (k == null) return k;
        var _g = [], Jg = 0;
        return Mg(k, _g, "", "", function(yI) {
          return og.call(Vg, yI, Jg++);
        }), _g;
      }
      function Zg(k) {
        if (k._status === -1) {
          var og = k._result;
          og = og(), og.then(
            function(Vg) {
              (k._status === 0 || k._status === -1) && (k._status = 1, k._result = Vg);
            },
            function(Vg) {
              (k._status === 0 || k._status === -1) && (k._status = 2, k._result = Vg);
            }
          ), k._status === -1 && (k._status = 0, k._result = og);
        }
        if (k._status === 1)
          return og = k._result, og === void 0 && console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
            og
          ), "default" in og || console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
            og
          ), og.default;
        throw k._result;
      }
      function Kg() {
        var k = rI.H;
        return k === null && console.error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        ), k;
      }
      function mg() {
      }
      function Ng(k) {
        if (ut === null)
          try {
            var og = ("require" + Math.random()).slice(0, 7);
            ut = (A && A[og]).call(
              A,
              "timers"
            ).setImmediate;
          } catch {
            ut = function(_g) {
              gi === !1 && (gi = !0, typeof MessageChannel > "u" && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var Jg = new MessageChannel();
              Jg.port1.onmessage = _g, Jg.port2.postMessage(void 0);
            };
          }
        return ut(k);
      }
      function cg(k) {
        return 1 < k.length && typeof AggregateError == "function" ? new AggregateError(k) : k[0];
      }
      function z(k, og) {
        og !== Te - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        ), Te = og;
      }
      function Q(k, og, Vg) {
        var _g = rI.actQueue;
        if (_g !== null)
          if (_g.length !== 0)
            try {
              Bg(_g), Ng(function() {
                return Q(k, og, Vg);
              });
              return;
            } catch (Jg) {
              rI.thrownErrors.push(Jg);
            }
          else rI.actQueue = null;
        0 < rI.thrownErrors.length ? (_g = cg(rI.thrownErrors), rI.thrownErrors.length = 0, Vg(_g)) : og(k);
      }
      function Bg(k) {
        if (!ZC) {
          ZC = !0;
          var og = 0;
          try {
            for (; og < k.length; og++) {
              var Vg = k[og];
              do {
                rI.didUsePromise = !1;
                var _g = Vg(!1);
                if (_g !== null) {
                  if (rI.didUsePromise) {
                    k[og] = Vg, k.splice(0, og);
                    return;
                  }
                  Vg = _g;
                } else break;
              } while (!0);
            }
            k.length = 0;
          } catch (Jg) {
            k.splice(0, og + 1), rI.thrownErrors.push(Jg);
          } finally {
            ZC = !1;
          }
        }
      }
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var Rg = Symbol.for("react.transitional.element"), N = Symbol.for("react.portal"), F = Symbol.for("react.fragment"), rg = Symbol.for("react.strict_mode"), Cg = Symbol.for("react.profiler"), Sg = Symbol.for("react.consumer"), kg = Symbol.for("react.context"), Yg = Symbol.for("react.forward_ref"), Wg = Symbol.for("react.suspense"), Xg = Symbol.for("react.suspense_list"), nI = Symbol.for("react.memo"), sI = Symbol.for("react.lazy"), Ug = Symbol.for("react.activity"), fI = Symbol.iterator, VI = {}, oA = {
        isMounted: function() {
          return !1;
        },
        enqueueForceUpdate: function(k) {
          r(k, "forceUpdate");
        },
        enqueueReplaceState: function(k) {
          r(k, "replaceState");
        },
        enqueueSetState: function(k) {
          r(k, "setState");
        }
      }, _C = Object.assign, UC = {};
      Object.freeze(UC), l.prototype.isReactComponent = {}, l.prototype.setState = function(k, og) {
        if (typeof k != "object" && typeof k != "function" && k != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, k, og, "setState");
      }, l.prototype.forceUpdate = function(k) {
        this.updater.enqueueForceUpdate(this, k, "forceUpdate");
      };
      var vI = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, CC;
      for (CC in vI)
        vI.hasOwnProperty(CC) && t(CC, vI[CC]);
      d.prototype = l.prototype, vI = h.prototype = new d(), vI.constructor = h, _C(vI, l.prototype), vI.isPureReactComponent = !0;
      var hC = Array.isArray, Lt = Symbol.for("react.client.reference"), rI = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, lt = Object.prototype.hasOwnProperty, qt = console.createTask ? console.createTask : function() {
        return null;
      };
      vI = {
        react_stack_bottom_frame: function(k) {
          return k();
        }
      };
      var ct, Eo, Qe = {}, eC = vI.react_stack_bottom_frame.bind(
        vI,
        K
      )(), PC = qt(b(K)), pA = !1, Ri = /\/+/g, $t = typeof reportError == "function" ? reportError : function(k) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var og = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof k == "object" && k !== null && typeof k.message == "string" ? String(k.message) : String(k),
            error: k
          });
          if (!window.dispatchEvent(og)) return;
        } else if (typeof I == "object" && typeof I.emit == "function") {
          I.emit("uncaughtException", k);
          return;
        }
        console.error(k);
      }, gi = !1, ut = null, Te = 0, JA = !1, ZC = !1, Ie = typeof queueMicrotask == "function" ? function(k) {
        queueMicrotask(function() {
          return queueMicrotask(k);
        });
      } : Ng;
      vI = Object.freeze({
        __proto__: null,
        c: function(k) {
          return Kg().useMemoCache(k);
        }
      }), g.Children = {
        map: ig,
        forEach: function(k, og, Vg) {
          ig(
            k,
            function() {
              og.apply(this, arguments);
            },
            Vg
          );
        },
        count: function(k) {
          var og = 0;
          return ig(k, function() {
            og++;
          }), og;
        },
        toArray: function(k) {
          return ig(k, function(og) {
            return og;
          }) || [];
        },
        only: function(k) {
          if (!x(k))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return k;
        }
      }, g.Component = l, g.Fragment = F, g.Profiler = Cg, g.PureComponent = h, g.StrictMode = rg, g.Suspense = Wg, g.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = rI, g.__COMPILER_RUNTIME = vI, g.act = function(k) {
        var og = rI.actQueue, Vg = Te;
        Te++;
        var _g = rI.actQueue = og !== null ? og : [], Jg = !1;
        try {
          var yI = k();
        } catch (cI) {
          rI.thrownErrors.push(cI);
        }
        if (0 < rI.thrownErrors.length)
          throw z(og, Vg), k = cg(rI.thrownErrors), rI.thrownErrors.length = 0, k;
        if (yI !== null && typeof yI == "object" && typeof yI.then == "function") {
          var lI = yI;
          return Ie(function() {
            Jg || JA || (JA = !0, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          }), {
            then: function(cI, VA) {
              Jg = !0, lI.then(
                function(Ii) {
                  if (z(og, Vg), Vg === 0) {
                    try {
                      Bg(_g), Ng(function() {
                        return Q(
                          Ii,
                          cI,
                          VA
                        );
                      });
                    } catch (Ai) {
                      rI.thrownErrors.push(Ai);
                    }
                    if (0 < rI.thrownErrors.length) {
                      var Vf = cg(
                        rI.thrownErrors
                      );
                      rI.thrownErrors.length = 0, VA(Vf);
                    }
                  } else cI(Ii);
                },
                function(Ii) {
                  z(og, Vg), 0 < rI.thrownErrors.length && (Ii = cg(
                    rI.thrownErrors
                  ), rI.thrownErrors.length = 0), VA(Ii);
                }
              );
            }
          };
        }
        var TI = yI;
        if (z(og, Vg), Vg === 0 && (Bg(_g), _g.length !== 0 && Ie(function() {
          Jg || JA || (JA = !0, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), rI.actQueue = null), 0 < rI.thrownErrors.length)
          throw k = cg(rI.thrownErrors), rI.thrownErrors.length = 0, k;
        return {
          then: function(cI, VA) {
            Jg = !0, Vg === 0 ? (rI.actQueue = _g, Ng(function() {
              return Q(
                TI,
                cI,
                VA
              );
            })) : cI(TI);
          }
        };
      }, g.cache = function(k) {
        return function() {
          return k.apply(null, arguments);
        };
      }, g.captureOwnerStack = function() {
        var k = rI.getCurrentStack;
        return k === null ? null : k();
      }, g.cloneElement = function(k, og, Vg) {
        if (k == null)
          throw Error(
            "The argument must be a React element, but you passed " + k + "."
          );
        var _g = _C({}, k.props), Jg = k.key, yI = k._owner;
        if (og != null) {
          var lI;
          g: {
            if (lt.call(og, "ref") && (lI = Object.getOwnPropertyDescriptor(
              og,
              "ref"
            ).get) && lI.isReactWarning) {
              lI = !1;
              break g;
            }
            lI = og.ref !== void 0;
          }
          lI && (yI = S()), Y(og) && (w(og.key), Jg = "" + og.key);
          for (TI in og)
            !lt.call(og, TI) || TI === "key" || TI === "__self" || TI === "__source" || TI === "ref" && og.ref === void 0 || (_g[TI] = og[TI]);
        }
        var TI = arguments.length - 2;
        if (TI === 1) _g.children = Vg;
        else if (1 < TI) {
          lI = Array(TI);
          for (var cI = 0; cI < TI; cI++)
            lI[cI] = arguments[cI + 2];
          _g.children = lI;
        }
        for (_g = H(
          k.type,
          Jg,
          void 0,
          void 0,
          yI,
          _g,
          k._debugStack,
          k._debugTask
        ), Jg = 2; Jg < arguments.length; Jg++)
          yI = arguments[Jg], x(yI) && yI._store && (yI._store.validated = 1);
        return _g;
      }, g.createContext = function(k) {
        return k = {
          $$typeof: kg,
          _currentValue: k,
          _currentValue2: k,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, k.Provider = k, k.Consumer = {
          $$typeof: Sg,
          _context: k
        }, k._currentRenderer = null, k._currentRenderer2 = null, k;
      }, g.createElement = function(k, og, Vg) {
        for (var _g = 2; _g < arguments.length; _g++) {
          var Jg = arguments[_g];
          x(Jg) && Jg._store && (Jg._store.validated = 1);
        }
        if (_g = {}, Jg = null, og != null)
          for (cI in Eo || !("__self" in og) || "key" in og || (Eo = !0, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), Y(og) && (w(og.key), Jg = "" + og.key), og)
            lt.call(og, cI) && cI !== "key" && cI !== "__self" && cI !== "__source" && (_g[cI] = og[cI]);
        var yI = arguments.length - 2;
        if (yI === 1) _g.children = Vg;
        else if (1 < yI) {
          for (var lI = Array(yI), TI = 0; TI < yI; TI++)
            lI[TI] = arguments[TI + 2];
          Object.freeze && Object.freeze(lI), _g.children = lI;
        }
        if (k && k.defaultProps)
          for (cI in yI = k.defaultProps, yI)
            _g[cI] === void 0 && (_g[cI] = yI[cI]);
        Jg && T(
          _g,
          typeof k == "function" ? k.displayName || k.name || "Unknown" : k
        );
        var cI = 1e4 > rI.recentlyCreatedOwnerStacks++;
        return H(
          k,
          Jg,
          void 0,
          void 0,
          S(),
          _g,
          cI ? Error("react-stack-top-frame") : eC,
          cI ? qt(b(k)) : PC
        );
      }, g.createRef = function() {
        var k = { current: null };
        return Object.seal(k), k;
      }, g.forwardRef = function(k) {
        k != null && k.$$typeof === nI ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : typeof k != "function" ? console.error(
          "forwardRef requires a render function but was given %s.",
          k === null ? "null" : typeof k
        ) : k.length !== 0 && k.length !== 2 && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          k.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        ), k != null && k.defaultProps != null && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var og = { $$typeof: Yg, render: k }, Vg;
        return Object.defineProperty(og, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return Vg;
          },
          set: function(_g) {
            Vg = _g, k.name || k.displayName || (Object.defineProperty(k, "name", { value: _g }), k.displayName = _g);
          }
        }), og;
      }, g.isValidElement = x, g.lazy = function(k) {
        return {
          $$typeof: sI,
          _payload: { _status: -1, _result: k },
          _init: Zg
        };
      }, g.memo = function(k, og) {
        k == null && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          k === null ? "null" : typeof k
        ), og = {
          $$typeof: nI,
          type: k,
          compare: og === void 0 ? null : og
        };
        var Vg;
        return Object.defineProperty(og, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return Vg;
          },
          set: function(_g) {
            Vg = _g, k.name || k.displayName || (Object.defineProperty(k, "name", { value: _g }), k.displayName = _g);
          }
        }), og;
      }, g.startTransition = function(k) {
        var og = rI.T, Vg = {};
        rI.T = Vg, Vg._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var _g = k(), Jg = rI.S;
          Jg !== null && Jg(Vg, _g), typeof _g == "object" && _g !== null && typeof _g.then == "function" && _g.then(mg, $t);
        } catch (yI) {
          $t(yI);
        } finally {
          og === null && Vg._updatedFibers && (k = Vg._updatedFibers.size, Vg._updatedFibers.clear(), 10 < k && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), rI.T = og;
        }
      }, g.unstable_useCacheRefresh = function() {
        return Kg().useCacheRefresh();
      }, g.use = function(k) {
        return Kg().use(k);
      }, g.useActionState = function(k, og, Vg) {
        return Kg().useActionState(
          k,
          og,
          Vg
        );
      }, g.useCallback = function(k, og) {
        return Kg().useCallback(k, og);
      }, g.useContext = function(k) {
        var og = Kg();
        return k.$$typeof === Sg && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        ), og.useContext(k);
      }, g.useDebugValue = function(k, og) {
        return Kg().useDebugValue(k, og);
      }, g.useDeferredValue = function(k, og) {
        return Kg().useDeferredValue(k, og);
      }, g.useEffect = function(k, og, Vg) {
        k == null && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var _g = Kg();
        if (typeof Vg == "function")
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return _g.useEffect(k, og);
      }, g.useId = function() {
        return Kg().useId();
      }, g.useImperativeHandle = function(k, og, Vg) {
        return Kg().useImperativeHandle(k, og, Vg);
      }, g.useInsertionEffect = function(k, og) {
        return k == null && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), Kg().useInsertionEffect(k, og);
      }, g.useLayoutEffect = function(k, og) {
        return k == null && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), Kg().useLayoutEffect(k, og);
      }, g.useMemo = function(k, og) {
        return Kg().useMemo(k, og);
      }, g.useOptimistic = function(k, og) {
        return Kg().useOptimistic(k, og);
      }, g.useReducer = function(k, og, Vg) {
        return Kg().useReducer(k, og, Vg);
      }, g.useRef = function(k) {
        return Kg().useRef(k);
      }, g.useState = function(k) {
        return Kg().useState(k);
      }, g.useSyncExternalStore = function(k, og, Vg) {
        return Kg().useSyncExternalStore(
          k,
          og,
          Vg
        );
      }, g.useTransition = function() {
        return Kg().useTransition();
      }, g.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  })(QD, QD.exports)), QD.exports;
}
var ZY;
function Yc() {
  if (ZY) return SB.exports;
  ZY = 1;
  var A = {};
  return A.NODE_ENV === "production" ? SB.exports = BN() : SB.exports = pN(), SB.exports;
}
var jY;
function mN() {
  if (jY) return ED;
  jY = 1;
  var A = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return A.NODE_ENV !== "production" && (function() {
    function g(N) {
      if (N == null) return null;
      if (typeof N == "function")
        return N.$$typeof === ig ? null : N.displayName || N.name || null;
      if (typeof N == "string") return N;
      switch (N) {
        case Y:
          return "Fragment";
        case E:
          return "Profiler";
        case T:
          return "StrictMode";
        case U:
          return "Suspense";
        case J:
          return "SuspenseList";
        case Mg:
          return "Activity";
      }
      if (typeof N == "object")
        switch (typeof N.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), N.$$typeof) {
          case K:
            return "Portal";
          case R:
            return (N.displayName || "Context") + ".Provider";
          case H:
            return (N._context.displayName || "Context") + ".Consumer";
          case x:
            var F = N.render;
            return N = N.displayName, N || (N = F.displayName || F.name || "", N = N !== "" ? "ForwardRef(" + N + ")" : "ForwardRef"), N;
          case L:
            return F = N.displayName || null, F !== null ? F : g(N.type) || "Memo";
          case eg:
            F = N._payload, N = N._init;
            try {
              return g(N(F));
            } catch {
            }
        }
      return null;
    }
    function I(N) {
      return "" + N;
    }
    function C(N) {
      try {
        I(N);
        var F = !1;
      } catch {
        F = !0;
      }
      if (F) {
        F = console;
        var rg = F.error, Cg = typeof Symbol == "function" && Symbol.toStringTag && N[Symbol.toStringTag] || N.constructor.name || "Object";
        return rg.call(
          F,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          Cg
        ), I(N);
      }
    }
    function t(N) {
      if (N === Y) return "<>";
      if (typeof N == "object" && N !== null && N.$$typeof === eg)
        return "<...>";
      try {
        var F = g(N);
        return F ? "<" + F + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function s() {
      var N = Zg.A;
      return N === null ? null : N.getOwner();
    }
    function r() {
      return Error("react-stack-top-frame");
    }
    function l(N) {
      if (Kg.call(N, "key")) {
        var F = Object.getOwnPropertyDescriptor(N, "key").get;
        if (F && F.isReactWarning) return !1;
      }
      return N.key !== void 0;
    }
    function d(N, F) {
      function rg() {
        cg || (cg = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          F
        ));
      }
      rg.isReactWarning = !0, Object.defineProperty(N, "key", {
        get: rg,
        configurable: !0
      });
    }
    function h() {
      var N = g(this.type);
      return z[N] || (z[N] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), N = this.props.ref, N !== void 0 ? N : null;
    }
    function D(N, F, rg, Cg, Sg, kg, Yg, Wg) {
      return rg = kg.ref, N = {
        $$typeof: S,
        type: N,
        key: F,
        props: kg,
        _owner: Sg
      }, (rg !== void 0 ? rg : null) !== null ? Object.defineProperty(N, "ref", {
        enumerable: !1,
        get: h
      }) : Object.defineProperty(N, "ref", { enumerable: !1, value: null }), N._store = {}, Object.defineProperty(N._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(N, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(N, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Yg
      }), Object.defineProperty(N, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Wg
      }), Object.freeze && (Object.freeze(N.props), Object.freeze(N)), N;
    }
    function w(N, F, rg, Cg, Sg, kg, Yg, Wg) {
      var Xg = F.children;
      if (Xg !== void 0)
        if (Cg)
          if (mg(Xg)) {
            for (Cg = 0; Cg < Xg.length; Cg++)
              p(Xg[Cg]);
            Object.freeze && Object.freeze(Xg);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else p(Xg);
      if (Kg.call(F, "key")) {
        Xg = g(N);
        var nI = Object.keys(F).filter(function(Ug) {
          return Ug !== "key";
        });
        Cg = 0 < nI.length ? "{key: someKey, " + nI.join(": ..., ") + ": ...}" : "{key: someKey}", Rg[Xg + Cg] || (nI = 0 < nI.length ? "{" + nI.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          Cg,
          Xg,
          nI,
          Xg
        ), Rg[Xg + Cg] = !0);
      }
      if (Xg = null, rg !== void 0 && (C(rg), Xg = "" + rg), l(F) && (C(F.key), Xg = "" + F.key), "key" in F) {
        rg = {};
        for (var sI in F)
          sI !== "key" && (rg[sI] = F[sI]);
      } else rg = F;
      return Xg && d(
        rg,
        typeof N == "function" ? N.displayName || N.name || "Unknown" : N
      ), D(
        N,
        Xg,
        kg,
        Sg,
        s(),
        rg,
        Yg,
        Wg
      );
    }
    function p(N) {
      typeof N == "object" && N !== null && N.$$typeof === S && N._store && (N._store.validated = 1);
    }
    var b = Yc(), S = Symbol.for("react.transitional.element"), K = Symbol.for("react.portal"), Y = Symbol.for("react.fragment"), T = Symbol.for("react.strict_mode"), E = Symbol.for("react.profiler"), H = Symbol.for("react.consumer"), R = Symbol.for("react.context"), x = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), J = Symbol.for("react.suspense_list"), L = Symbol.for("react.memo"), eg = Symbol.for("react.lazy"), Mg = Symbol.for("react.activity"), ig = Symbol.for("react.client.reference"), Zg = b.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Kg = Object.prototype.hasOwnProperty, mg = Array.isArray, Ng = console.createTask ? console.createTask : function() {
      return null;
    };
    b = {
      react_stack_bottom_frame: function(N) {
        return N();
      }
    };
    var cg, z = {}, Q = b.react_stack_bottom_frame.bind(
      b,
      r
    )(), Bg = Ng(t(r)), Rg = {};
    ED.Fragment = Y, ED.jsx = function(N, F, rg, Cg, Sg) {
      var kg = 1e4 > Zg.recentlyCreatedOwnerStacks++;
      return w(
        N,
        F,
        rg,
        !1,
        Cg,
        Sg,
        kg ? Error("react-stack-top-frame") : Q,
        kg ? Ng(t(N)) : Bg
      );
    }, ED.jsxs = function(N, F, rg, Cg, Sg) {
      var kg = 1e4 > Zg.recentlyCreatedOwnerStacks++;
      return w(
        N,
        F,
        rg,
        !0,
        Cg,
        Sg,
        kg ? Error("react-stack-top-frame") : Q,
        kg ? Ng(t(N)) : Bg
      );
    };
  })(), ED;
}
var vY;
function bN() {
  if (vY) return bB.exports;
  vY = 1;
  var A = {};
  return A.NODE_ENV === "production" ? bB.exports = wN() : bB.exports = mN(), bB.exports;
}
var v = bN(), Z = Yc();
const EA = /* @__PURE__ */ CG(Z), kZ = /* @__PURE__ */ MN({
  __proto__: null,
  default: EA
}, [Z]);
var GB = { exports: {} }, RD = {}, KB = { exports: {} }, Jm = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HY;
function SN() {
  return HY || (HY = 1, (function(A) {
    function g(cg, z) {
      var Q = cg.length;
      cg.push(z);
      g: for (; 0 < Q; ) {
        var Bg = Q - 1 >>> 1, Rg = cg[Bg];
        if (0 < t(Rg, z))
          cg[Bg] = z, cg[Q] = Rg, Q = Bg;
        else break g;
      }
    }
    function I(cg) {
      return cg.length === 0 ? null : cg[0];
    }
    function C(cg) {
      if (cg.length === 0) return null;
      var z = cg[0], Q = cg.pop();
      if (Q !== z) {
        cg[0] = Q;
        g: for (var Bg = 0, Rg = cg.length, N = Rg >>> 1; Bg < N; ) {
          var F = 2 * (Bg + 1) - 1, rg = cg[F], Cg = F + 1, Sg = cg[Cg];
          if (0 > t(rg, Q))
            Cg < Rg && 0 > t(Sg, rg) ? (cg[Bg] = Sg, cg[Cg] = Q, Bg = Cg) : (cg[Bg] = rg, cg[F] = Q, Bg = F);
          else if (Cg < Rg && 0 > t(Sg, Q))
            cg[Bg] = Sg, cg[Cg] = Q, Bg = Cg;
          else break g;
        }
      }
      return z;
    }
    function t(cg, z) {
      var Q = cg.sortIndex - z.sortIndex;
      return Q !== 0 ? Q : cg.id - z.id;
    }
    if (A.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      A.unstable_now = function() {
        return s.now();
      };
    } else {
      var r = Date, l = r.now();
      A.unstable_now = function() {
        return r.now() - l;
      };
    }
    var d = [], h = [], D = 1, w = null, p = 3, b = !1, S = !1, K = !1, Y = !1, T = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, H = typeof setImmediate < "u" ? setImmediate : null;
    function R(cg) {
      for (var z = I(h); z !== null; ) {
        if (z.callback === null) C(h);
        else if (z.startTime <= cg)
          C(h), z.sortIndex = z.expirationTime, g(d, z);
        else break;
        z = I(h);
      }
    }
    function x(cg) {
      if (K = !1, R(cg), !S)
        if (I(d) !== null)
          S = !0, U || (U = !0, Zg());
        else {
          var z = I(h);
          z !== null && Ng(x, z.startTime - cg);
        }
    }
    var U = !1, J = -1, L = 5, eg = -1;
    function Mg() {
      return Y ? !0 : !(A.unstable_now() - eg < L);
    }
    function ig() {
      if (Y = !1, U) {
        var cg = A.unstable_now();
        eg = cg;
        var z = !0;
        try {
          g: {
            S = !1, K && (K = !1, E(J), J = -1), b = !0;
            var Q = p;
            try {
              I: {
                for (R(cg), w = I(d); w !== null && !(w.expirationTime > cg && Mg()); ) {
                  var Bg = w.callback;
                  if (typeof Bg == "function") {
                    w.callback = null, p = w.priorityLevel;
                    var Rg = Bg(
                      w.expirationTime <= cg
                    );
                    if (cg = A.unstable_now(), typeof Rg == "function") {
                      w.callback = Rg, R(cg), z = !0;
                      break I;
                    }
                    w === I(d) && C(d), R(cg);
                  } else C(d);
                  w = I(d);
                }
                if (w !== null) z = !0;
                else {
                  var N = I(h);
                  N !== null && Ng(
                    x,
                    N.startTime - cg
                  ), z = !1;
                }
              }
              break g;
            } finally {
              w = null, p = Q, b = !1;
            }
            z = void 0;
          }
        } finally {
          z ? Zg() : U = !1;
        }
      }
    }
    var Zg;
    if (typeof H == "function")
      Zg = function() {
        H(ig);
      };
    else if (typeof MessageChannel < "u") {
      var Kg = new MessageChannel(), mg = Kg.port2;
      Kg.port1.onmessage = ig, Zg = function() {
        mg.postMessage(null);
      };
    } else
      Zg = function() {
        T(ig, 0);
      };
    function Ng(cg, z) {
      J = T(function() {
        cg(A.unstable_now());
      }, z);
    }
    A.unstable_IdlePriority = 5, A.unstable_ImmediatePriority = 1, A.unstable_LowPriority = 4, A.unstable_NormalPriority = 3, A.unstable_Profiling = null, A.unstable_UserBlockingPriority = 2, A.unstable_cancelCallback = function(cg) {
      cg.callback = null;
    }, A.unstable_forceFrameRate = function(cg) {
      0 > cg || 125 < cg ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : L = 0 < cg ? Math.floor(1e3 / cg) : 5;
    }, A.unstable_getCurrentPriorityLevel = function() {
      return p;
    }, A.unstable_next = function(cg) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var z = 3;
          break;
        default:
          z = p;
      }
      var Q = p;
      p = z;
      try {
        return cg();
      } finally {
        p = Q;
      }
    }, A.unstable_requestPaint = function() {
      Y = !0;
    }, A.unstable_runWithPriority = function(cg, z) {
      switch (cg) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          cg = 3;
      }
      var Q = p;
      p = cg;
      try {
        return z();
      } finally {
        p = Q;
      }
    }, A.unstable_scheduleCallback = function(cg, z, Q) {
      var Bg = A.unstable_now();
      switch (typeof Q == "object" && Q !== null ? (Q = Q.delay, Q = typeof Q == "number" && 0 < Q ? Bg + Q : Bg) : Q = Bg, cg) {
        case 1:
          var Rg = -1;
          break;
        case 2:
          Rg = 250;
          break;
        case 5:
          Rg = 1073741823;
          break;
        case 4:
          Rg = 1e4;
          break;
        default:
          Rg = 5e3;
      }
      return Rg = Q + Rg, cg = {
        id: D++,
        callback: z,
        priorityLevel: cg,
        startTime: Q,
        expirationTime: Rg,
        sortIndex: -1
      }, Q > Bg ? (cg.sortIndex = Q, g(h, cg), I(d) === null && cg === I(h) && (K ? (E(J), J = -1) : K = !0, Ng(x, Q - Bg))) : (cg.sortIndex = Rg, g(d, cg), S || b || (S = !0, U || (U = !0, Zg()))), cg;
    }, A.unstable_shouldYield = Mg, A.unstable_wrapCallback = function(cg) {
      var z = p;
      return function() {
        var Q = p;
        p = z;
        try {
          return cg.apply(this, arguments);
        } finally {
          p = Q;
        }
      };
    };
  })(Jm)), Jm;
}
var Lm = {}, EY;
function GN() {
  return EY || (EY = 1, (function(A) {
    var g = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    g.NODE_ENV !== "production" && (function() {
      function I() {
        if (U = !1, Mg) {
          var z = A.unstable_now();
          Kg = z;
          var Q = !0;
          try {
            g: {
              R = !1, x && (x = !1, L(ig), ig = -1), H = !0;
              var Bg = E;
              try {
                I: {
                  for (l(z), T = t(S); T !== null && !(T.expirationTime > z && h()); ) {
                    var Rg = T.callback;
                    if (typeof Rg == "function") {
                      T.callback = null, E = T.priorityLevel;
                      var N = Rg(
                        T.expirationTime <= z
                      );
                      if (z = A.unstable_now(), typeof N == "function") {
                        T.callback = N, l(z), Q = !0;
                        break I;
                      }
                      T === t(S) && s(S), l(z);
                    } else s(S);
                    T = t(S);
                  }
                  if (T !== null) Q = !0;
                  else {
                    var F = t(K);
                    F !== null && D(
                      d,
                      F.startTime - z
                    ), Q = !1;
                  }
                }
                break g;
              } finally {
                T = null, E = Bg, H = !1;
              }
              Q = void 0;
            }
          } finally {
            Q ? mg() : Mg = !1;
          }
        }
      }
      function C(z, Q) {
        var Bg = z.length;
        z.push(Q);
        g: for (; 0 < Bg; ) {
          var Rg = Bg - 1 >>> 1, N = z[Rg];
          if (0 < r(N, Q))
            z[Rg] = Q, z[Bg] = N, Bg = Rg;
          else break g;
        }
      }
      function t(z) {
        return z.length === 0 ? null : z[0];
      }
      function s(z) {
        if (z.length === 0) return null;
        var Q = z[0], Bg = z.pop();
        if (Bg !== Q) {
          z[0] = Bg;
          g: for (var Rg = 0, N = z.length, F = N >>> 1; Rg < F; ) {
            var rg = 2 * (Rg + 1) - 1, Cg = z[rg], Sg = rg + 1, kg = z[Sg];
            if (0 > r(Cg, Bg))
              Sg < N && 0 > r(kg, Cg) ? (z[Rg] = kg, z[Sg] = Bg, Rg = Sg) : (z[Rg] = Cg, z[rg] = Bg, Rg = rg);
            else if (Sg < N && 0 > r(kg, Bg))
              z[Rg] = kg, z[Sg] = Bg, Rg = Sg;
            else break g;
          }
        }
        return Q;
      }
      function r(z, Q) {
        var Bg = z.sortIndex - Q.sortIndex;
        return Bg !== 0 ? Bg : z.id - Q.id;
      }
      function l(z) {
        for (var Q = t(K); Q !== null; ) {
          if (Q.callback === null) s(K);
          else if (Q.startTime <= z)
            s(K), Q.sortIndex = Q.expirationTime, C(S, Q);
          else break;
          Q = t(K);
        }
      }
      function d(z) {
        if (x = !1, l(z), !R)
          if (t(S) !== null)
            R = !0, Mg || (Mg = !0, mg());
          else {
            var Q = t(K);
            Q !== null && D(
              d,
              Q.startTime - z
            );
          }
      }
      function h() {
        return U ? !0 : !(A.unstable_now() - Kg < Zg);
      }
      function D(z, Q) {
        ig = J(function() {
          z(A.unstable_now());
        }, Q);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), A.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var w = performance;
        A.unstable_now = function() {
          return w.now();
        };
      } else {
        var p = Date, b = p.now();
        A.unstable_now = function() {
          return p.now() - b;
        };
      }
      var S = [], K = [], Y = 1, T = null, E = 3, H = !1, R = !1, x = !1, U = !1, J = typeof setTimeout == "function" ? setTimeout : null, L = typeof clearTimeout == "function" ? clearTimeout : null, eg = typeof setImmediate < "u" ? setImmediate : null, Mg = !1, ig = -1, Zg = 5, Kg = -1;
      if (typeof eg == "function")
        var mg = function() {
          eg(I);
        };
      else if (typeof MessageChannel < "u") {
        var Ng = new MessageChannel(), cg = Ng.port2;
        Ng.port1.onmessage = I, mg = function() {
          cg.postMessage(null);
        };
      } else
        mg = function() {
          J(I, 0);
        };
      A.unstable_IdlePriority = 5, A.unstable_ImmediatePriority = 1, A.unstable_LowPriority = 4, A.unstable_NormalPriority = 3, A.unstable_Profiling = null, A.unstable_UserBlockingPriority = 2, A.unstable_cancelCallback = function(z) {
        z.callback = null;
      }, A.unstable_forceFrameRate = function(z) {
        0 > z || 125 < z ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : Zg = 0 < z ? Math.floor(1e3 / z) : 5;
      }, A.unstable_getCurrentPriorityLevel = function() {
        return E;
      }, A.unstable_next = function(z) {
        switch (E) {
          case 1:
          case 2:
          case 3:
            var Q = 3;
            break;
          default:
            Q = E;
        }
        var Bg = E;
        E = Q;
        try {
          return z();
        } finally {
          E = Bg;
        }
      }, A.unstable_requestPaint = function() {
        U = !0;
      }, A.unstable_runWithPriority = function(z, Q) {
        switch (z) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            z = 3;
        }
        var Bg = E;
        E = z;
        try {
          return Q();
        } finally {
          E = Bg;
        }
      }, A.unstable_scheduleCallback = function(z, Q, Bg) {
        var Rg = A.unstable_now();
        switch (typeof Bg == "object" && Bg !== null ? (Bg = Bg.delay, Bg = typeof Bg == "number" && 0 < Bg ? Rg + Bg : Rg) : Bg = Rg, z) {
          case 1:
            var N = -1;
            break;
          case 2:
            N = 250;
            break;
          case 5:
            N = 1073741823;
            break;
          case 4:
            N = 1e4;
            break;
          default:
            N = 5e3;
        }
        return N = Bg + N, z = {
          id: Y++,
          callback: Q,
          priorityLevel: z,
          startTime: Bg,
          expirationTime: N,
          sortIndex: -1
        }, Bg > Rg ? (z.sortIndex = Bg, C(K, z), t(S) === null && z === t(K) && (x ? (L(ig), ig = -1) : x = !0, D(d, Bg - Rg))) : (z.sortIndex = N, C(S, z), R || H || (R = !0, Mg || (Mg = !0, mg()))), z;
      }, A.unstable_shouldYield = h, A.unstable_wrapCallback = function(z) {
        var Q = E;
        return function() {
          var Bg = E;
          E = Q;
          try {
            return z.apply(this, arguments);
          } finally {
            E = Bg;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  })(Lm)), Lm;
}
var RY;
function WZ() {
  if (RY) return KB.exports;
  RY = 1;
  var A = {};
  return A.NODE_ENV === "production" ? KB.exports = SN() : KB.exports = GN(), KB.exports;
}
var TB = { exports: {} }, Be = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OY;
function KN() {
  if (OY) return Be;
  OY = 1;
  var A = Yc();
  function g(d) {
    var h = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      h += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var D = 2; D < arguments.length; D++)
        h += "&args[]=" + encodeURIComponent(arguments[D]);
    }
    return "Minified React error #" + d + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function I() {
  }
  var C = {
    d: {
      f: I,
      r: function() {
        throw Error(g(522));
      },
      D: I,
      C: I,
      L: I,
      m: I,
      X: I,
      S: I,
      M: I
    },
    p: 0,
    findDOMNode: null
  }, t = Symbol.for("react.portal");
  function s(d, h, D) {
    var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: t,
      key: w == null ? null : "" + w,
      children: d,
      containerInfo: h,
      implementation: D
    };
  }
  var r = A.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function l(d, h) {
    if (d === "font") return "";
    if (typeof h == "string")
      return h === "use-credentials" ? h : "";
  }
  return Be.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = C, Be.createPortal = function(d, h) {
    var D = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
      throw Error(g(299));
    return s(d, h, null, D);
  }, Be.flushSync = function(d) {
    var h = r.T, D = C.p;
    try {
      if (r.T = null, C.p = 2, d) return d();
    } finally {
      r.T = h, C.p = D, C.d.f();
    }
  }, Be.preconnect = function(d, h) {
    typeof d == "string" && (h ? (h = h.crossOrigin, h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null, C.d.C(d, h));
  }, Be.prefetchDNS = function(d) {
    typeof d == "string" && C.d.D(d);
  }, Be.preinit = function(d, h) {
    if (typeof d == "string" && h && typeof h.as == "string") {
      var D = h.as, w = l(D, h.crossOrigin), p = typeof h.integrity == "string" ? h.integrity : void 0, b = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
      D === "style" ? C.d.S(
        d,
        typeof h.precedence == "string" ? h.precedence : void 0,
        {
          crossOrigin: w,
          integrity: p,
          fetchPriority: b
        }
      ) : D === "script" && C.d.X(d, {
        crossOrigin: w,
        integrity: p,
        fetchPriority: b,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0
      });
    }
  }, Be.preinitModule = function(d, h) {
    if (typeof d == "string")
      if (typeof h == "object" && h !== null) {
        if (h.as == null || h.as === "script") {
          var D = l(
            h.as,
            h.crossOrigin
          );
          C.d.M(d, {
            crossOrigin: D,
            integrity: typeof h.integrity == "string" ? h.integrity : void 0,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0
          });
        }
      } else h == null && C.d.M(d);
  }, Be.preload = function(d, h) {
    if (typeof d == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
      var D = h.as, w = l(D, h.crossOrigin);
      C.d.L(d, D, {
        crossOrigin: w,
        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0,
        type: typeof h.type == "string" ? h.type : void 0,
        fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
        referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
        imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
        imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
        media: typeof h.media == "string" ? h.media : void 0
      });
    }
  }, Be.preloadModule = function(d, h) {
    if (typeof d == "string")
      if (h) {
        var D = l(h.as, h.crossOrigin);
        C.d.m(d, {
          as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
          crossOrigin: D,
          integrity: typeof h.integrity == "string" ? h.integrity : void 0
        });
      } else C.d.m(d);
  }, Be.requestFormReset = function(d) {
    C.d.r(d);
  }, Be.unstable_batchedUpdates = function(d, h) {
    return d(h);
  }, Be.useFormState = function(d, h, D) {
    return r.H.useFormState(d, h, D);
  }, Be.useFormStatus = function() {
    return r.H.useHostTransitionStatus();
  }, Be.version = "19.1.1", Be;
}
var pe = {}, NY;
function TN() {
  if (NY) return pe;
  NY = 1;
  var A = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return A.NODE_ENV !== "production" && (function() {
    function g() {
    }
    function I(p) {
      return "" + p;
    }
    function C(p, b, S) {
      var K = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      try {
        I(K);
        var Y = !1;
      } catch {
        Y = !0;
      }
      return Y && (console.error(
        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
        typeof Symbol == "function" && Symbol.toStringTag && K[Symbol.toStringTag] || K.constructor.name || "Object"
      ), I(K)), {
        $$typeof: D,
        key: K == null ? null : "" + K,
        children: p,
        containerInfo: b,
        implementation: S
      };
    }
    function t(p, b) {
      if (p === "font") return "";
      if (typeof b == "string")
        return b === "use-credentials" ? b : "";
    }
    function s(p) {
      return p === null ? "`null`" : p === void 0 ? "`undefined`" : p === "" ? "an empty string" : 'something with type "' + typeof p + '"';
    }
    function r(p) {
      return p === null ? "`null`" : p === void 0 ? "`undefined`" : p === "" ? "an empty string" : typeof p == "string" ? JSON.stringify(p) : typeof p == "number" ? "`" + p + "`" : 'something with type "' + typeof p + '"';
    }
    function l() {
      var p = w.H;
      return p === null && console.error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      ), p;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var d = Yc(), h = {
      d: {
        f: g,
        r: function() {
          throw Error(
            "Invalid form element. requestFormReset must be passed a form that was rendered by React."
          );
        },
        D: g,
        C: g,
        L: g,
        m: g,
        X: g,
        S: g,
        M: g
      },
      p: 0,
      findDOMNode: null
    }, D = Symbol.for("react.portal"), w = d.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    ), pe.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = h, pe.createPortal = function(p, b) {
      var S = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!b || b.nodeType !== 1 && b.nodeType !== 9 && b.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return C(p, b, null, S);
    }, pe.flushSync = function(p) {
      var b = w.T, S = h.p;
      try {
        if (w.T = null, h.p = 2, p)
          return p();
      } finally {
        w.T = b, h.p = S, h.d.f() && console.error(
          "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
        );
      }
    }, pe.preconnect = function(p, b) {
      typeof p == "string" && p ? b != null && typeof b != "object" ? console.error(
        "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
        r(b)
      ) : b != null && typeof b.crossOrigin != "string" && console.error(
        "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
        s(b.crossOrigin)
      ) : console.error(
        "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        s(p)
      ), typeof p == "string" && (b ? (b = b.crossOrigin, b = typeof b == "string" ? b === "use-credentials" ? b : "" : void 0) : b = null, h.d.C(p, b));
    }, pe.prefetchDNS = function(p) {
      if (typeof p != "string" || !p)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          s(p)
        );
      else if (1 < arguments.length) {
        var b = arguments[1];
        typeof b == "object" && b.hasOwnProperty("crossOrigin") ? console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          r(b)
        ) : console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          r(b)
        );
      }
      typeof p == "string" && h.d.D(p);
    }, pe.preinit = function(p, b) {
      if (typeof p == "string" && p ? b == null || typeof b != "object" ? console.error(
        "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
        r(b)
      ) : b.as !== "style" && b.as !== "script" && console.error(
        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
        r(b.as)
      ) : console.error(
        "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        s(p)
      ), typeof p == "string" && b && typeof b.as == "string") {
        var S = b.as, K = t(S, b.crossOrigin), Y = typeof b.integrity == "string" ? b.integrity : void 0, T = typeof b.fetchPriority == "string" ? b.fetchPriority : void 0;
        S === "style" ? h.d.S(
          p,
          typeof b.precedence == "string" ? b.precedence : void 0,
          {
            crossOrigin: K,
            integrity: Y,
            fetchPriority: T
          }
        ) : S === "script" && h.d.X(p, {
          crossOrigin: K,
          integrity: Y,
          fetchPriority: T,
          nonce: typeof b.nonce == "string" ? b.nonce : void 0
        });
      }
    }, pe.preinitModule = function(p, b) {
      var S = "";
      if (typeof p == "string" && p || (S += " The `href` argument encountered was " + s(p) + "."), b !== void 0 && typeof b != "object" ? S += " The `options` argument encountered was " + s(b) + "." : b && "as" in b && b.as !== "script" && (S += " The `as` option encountered was " + r(b.as) + "."), S)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          S
        );
      else
        switch (S = b && typeof b.as == "string" ? b.as : "script", S) {
          case "script":
            break;
          default:
            S = r(S), console.error(
              'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
              S,
              p
            );
        }
      typeof p == "string" && (typeof b == "object" && b !== null ? (b.as == null || b.as === "script") && (S = t(
        b.as,
        b.crossOrigin
      ), h.d.M(p, {
        crossOrigin: S,
        integrity: typeof b.integrity == "string" ? b.integrity : void 0,
        nonce: typeof b.nonce == "string" ? b.nonce : void 0
      })) : b == null && h.d.M(p));
    }, pe.preload = function(p, b) {
      var S = "";
      if (typeof p == "string" && p || (S += " The `href` argument encountered was " + s(p) + "."), b == null || typeof b != "object" ? S += " The `options` argument encountered was " + s(b) + "." : typeof b.as == "string" && b.as || (S += " The `as` option encountered was " + s(b.as) + "."), S && console.error(
        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
        S
      ), typeof p == "string" && typeof b == "object" && b !== null && typeof b.as == "string") {
        S = b.as;
        var K = t(
          S,
          b.crossOrigin
        );
        h.d.L(p, S, {
          crossOrigin: K,
          integrity: typeof b.integrity == "string" ? b.integrity : void 0,
          nonce: typeof b.nonce == "string" ? b.nonce : void 0,
          type: typeof b.type == "string" ? b.type : void 0,
          fetchPriority: typeof b.fetchPriority == "string" ? b.fetchPriority : void 0,
          referrerPolicy: typeof b.referrerPolicy == "string" ? b.referrerPolicy : void 0,
          imageSrcSet: typeof b.imageSrcSet == "string" ? b.imageSrcSet : void 0,
          imageSizes: typeof b.imageSizes == "string" ? b.imageSizes : void 0,
          media: typeof b.media == "string" ? b.media : void 0
        });
      }
    }, pe.preloadModule = function(p, b) {
      var S = "";
      typeof p == "string" && p || (S += " The `href` argument encountered was " + s(p) + "."), b !== void 0 && typeof b != "object" ? S += " The `options` argument encountered was " + s(b) + "." : b && "as" in b && typeof b.as != "string" && (S += " The `as` option encountered was " + s(b.as) + "."), S && console.error(
        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
        S
      ), typeof p == "string" && (b ? (S = t(
        b.as,
        b.crossOrigin
      ), h.d.m(p, {
        as: typeof b.as == "string" && b.as !== "script" ? b.as : void 0,
        crossOrigin: S,
        integrity: typeof b.integrity == "string" ? b.integrity : void 0
      })) : h.d.m(p));
    }, pe.requestFormReset = function(p) {
      h.d.r(p);
    }, pe.unstable_batchedUpdates = function(p, b) {
      return p(b);
    }, pe.useFormState = function(p, b, S) {
      return l().useFormState(p, b, S);
    }, pe.useFormStatus = function() {
      return l().useHostTransitionStatus();
    }, pe.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })(), pe;
}
var kY;
function eG() {
  if (kY) return TB.exports;
  kY = 1;
  var A = {};
  function g() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (A.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(g);
      } catch (I) {
        console.error(I);
      }
    }
  }
  return A.NODE_ENV === "production" ? (g(), TB.exports = KN()) : TB.exports = TN(), TB.exports;
}
var WY;
function YN() {
  if (WY) return RD;
  WY = 1;
  var A = {};
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var g = WZ(), I = Yc(), C = eG();
  function t(n) {
    var a = "https://react.dev/errors/" + n;
    if (1 < arguments.length) {
      a += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        a += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + n + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function s(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function r(n) {
    var a = n, c = n;
    if (n.alternate) for (; a.return; ) a = a.return;
    else {
      n = a;
      do
        a = n, (a.flags & 4098) !== 0 && (c = a.return), n = a.return;
      while (n);
    }
    return a.tag === 3 ? c : null;
  }
  function l(n) {
    if (n.tag === 13) {
      var a = n.memoizedState;
      if (a === null && (n = n.alternate, n !== null && (a = n.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function d(n) {
    if (r(n) !== n)
      throw Error(t(188));
  }
  function h(n) {
    var a = n.alternate;
    if (!a) {
      if (a = r(n), a === null) throw Error(t(188));
      return a !== n ? null : n;
    }
    for (var c = n, f = a; ; ) {
      var B = c.return;
      if (B === null) break;
      var m = B.alternate;
      if (m === null) {
        if (f = B.return, f !== null) {
          c = f;
          continue;
        }
        break;
      }
      if (B.child === m.child) {
        for (m = B.child; m; ) {
          if (m === c) return d(B), n;
          if (m === f) return d(B), a;
          m = m.sibling;
        }
        throw Error(t(188));
      }
      if (c.return !== f.return) c = B, f = m;
      else {
        for (var j = !1, O = B.child; O; ) {
          if (O === c) {
            j = !0, c = B, f = m;
            break;
          }
          if (O === f) {
            j = !0, f = B, c = m;
            break;
          }
          O = O.sibling;
        }
        if (!j) {
          for (O = m.child; O; ) {
            if (O === c) {
              j = !0, c = m, f = B;
              break;
            }
            if (O === f) {
              j = !0, f = m, c = B;
              break;
            }
            O = O.sibling;
          }
          if (!j) throw Error(t(189));
        }
      }
      if (c.alternate !== f) throw Error(t(190));
    }
    if (c.tag !== 3) throw Error(t(188));
    return c.stateNode.current === c ? n : a;
  }
  function D(n) {
    var a = n.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return n;
    for (n = n.child; n !== null; ) {
      if (a = D(n), a !== null) return a;
      n = n.sibling;
    }
    return null;
  }
  var w = Object.assign, p = Symbol.for("react.element"), b = Symbol.for("react.transitional.element"), S = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), Y = Symbol.for("react.strict_mode"), T = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), H = Symbol.for("react.consumer"), R = Symbol.for("react.context"), x = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), J = Symbol.for("react.suspense_list"), L = Symbol.for("react.memo"), eg = Symbol.for("react.lazy"), Mg = Symbol.for("react.activity"), ig = Symbol.for("react.memo_cache_sentinel"), Zg = Symbol.iterator;
  function Kg(n) {
    return n === null || typeof n != "object" ? null : (n = Zg && n[Zg] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var mg = Symbol.for("react.client.reference");
  function Ng(n) {
    if (n == null) return null;
    if (typeof n == "function")
      return n.$$typeof === mg ? null : n.displayName || n.name || null;
    if (typeof n == "string") return n;
    switch (n) {
      case K:
        return "Fragment";
      case T:
        return "Profiler";
      case Y:
        return "StrictMode";
      case U:
        return "Suspense";
      case J:
        return "SuspenseList";
      case Mg:
        return "Activity";
    }
    if (typeof n == "object")
      switch (n.$$typeof) {
        case S:
          return "Portal";
        case R:
          return (n.displayName || "Context") + ".Provider";
        case H:
          return (n._context.displayName || "Context") + ".Consumer";
        case x:
          var a = n.render;
          return n = n.displayName, n || (n = a.displayName || a.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case L:
          return a = n.displayName || null, a !== null ? a : Ng(n.type) || "Memo";
        case eg:
          a = n._payload, n = n._init;
          try {
            return Ng(n(a));
          } catch {
          }
      }
    return null;
  }
  var cg = Array.isArray, z = I.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Q = C.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Bg = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Rg = [], N = -1;
  function F(n) {
    return { current: n };
  }
  function rg(n) {
    0 > N || (n.current = Rg[N], Rg[N] = null, N--);
  }
  function Cg(n, a) {
    N++, Rg[N] = n.current, n.current = a;
  }
  var Sg = F(null), kg = F(null), Yg = F(null), Wg = F(null);
  function Xg(n, a) {
    switch (Cg(Yg, a), Cg(kg, n), Cg(Sg, null), a.nodeType) {
      case 9:
      case 11:
        n = (n = a.documentElement) && (n = n.namespaceURI) ? ri(n) : 0;
        break;
      default:
        if (n = a.tagName, a = a.namespaceURI)
          a = ri(a), n = rn(a, n);
        else
          switch (n) {
            case "svg":
              n = 1;
              break;
            case "math":
              n = 2;
              break;
            default:
              n = 0;
          }
    }
    rg(Sg), Cg(Sg, n);
  }
  function nI() {
    rg(Sg), rg(kg), rg(Yg);
  }
  function sI(n) {
    n.memoizedState !== null && Cg(Wg, n);
    var a = Sg.current, c = rn(a, n.type);
    a !== c && (Cg(kg, n), Cg(Sg, c));
  }
  function Ug(n) {
    kg.current === n && (rg(Sg), rg(kg)), Wg.current === n && (rg(Wg), mC._currentValue = Bg);
  }
  var fI = Object.prototype.hasOwnProperty, VI = g.unstable_scheduleCallback, oA = g.unstable_cancelCallback, _C = g.unstable_shouldYield, UC = g.unstable_requestPaint, vI = g.unstable_now, CC = g.unstable_getCurrentPriorityLevel, hC = g.unstable_ImmediatePriority, Lt = g.unstable_UserBlockingPriority, rI = g.unstable_NormalPriority, lt = g.unstable_LowPriority, qt = g.unstable_IdlePriority, ct = g.log, Eo = g.unstable_setDisableYieldValue, Qe = null, eC = null;
  function PC(n) {
    if (typeof ct == "function" && Eo(n), eC && typeof eC.setStrictMode == "function")
      try {
        eC.setStrictMode(Qe, n);
      } catch {
      }
  }
  var pA = Math.clz32 ? Math.clz32 : gi, Ri = Math.log, $t = Math.LN2;
  function gi(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (Ri(n) / $t | 0) | 0;
  }
  var ut = 256, Te = 4194304;
  function JA(n) {
    var a = n & 42;
    if (a !== 0) return a;
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return n & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return n;
    }
  }
  function ZC(n, a, c) {
    var f = n.pendingLanes;
    if (f === 0) return 0;
    var B = 0, m = n.suspendedLanes, j = n.pingedLanes;
    n = n.warmLanes;
    var O = f & 134217727;
    return O !== 0 ? (f = O & ~m, f !== 0 ? B = JA(f) : (j &= O, j !== 0 ? B = JA(j) : c || (c = O & ~n, c !== 0 && (B = JA(c))))) : (O = f & ~m, O !== 0 ? B = JA(O) : j !== 0 ? B = JA(j) : c || (c = f & ~n, c !== 0 && (B = JA(c)))), B === 0 ? 0 : a !== 0 && a !== B && (a & m) === 0 && (m = B & -B, c = a & -a, m >= c || m === 32 && (c & 4194048) !== 0) ? a : B;
  }
  function Ie(n, a) {
    return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & a) === 0;
  }
  function k(n, a) {
    switch (n) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return a + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function og() {
    var n = ut;
    return ut <<= 1, (ut & 4194048) === 0 && (ut = 256), n;
  }
  function Vg() {
    var n = Te;
    return Te <<= 1, (Te & 62914560) === 0 && (Te = 4194304), n;
  }
  function _g(n) {
    for (var a = [], c = 0; 31 > c; c++) a.push(n);
    return a;
  }
  function Jg(n, a) {
    n.pendingLanes |= a, a !== 268435456 && (n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0);
  }
  function yI(n, a, c, f, B, m) {
    var j = n.pendingLanes;
    n.pendingLanes = c, n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0, n.expiredLanes &= c, n.entangledLanes &= c, n.errorRecoveryDisabledLanes &= c, n.shellSuspendCounter = 0;
    var O = n.entanglements, q = n.expirationTimes, ug = n.hiddenUpdates;
    for (c = j & ~c; 0 < c; ) {
      var jg = 31 - pA(c), Hg = 1 << jg;
      O[jg] = 0, q[jg] = -1;
      var hg = ug[jg];
      if (hg !== null)
        for (ug[jg] = null, jg = 0; jg < hg.length; jg++) {
          var pg = hg[jg];
          pg !== null && (pg.lane &= -536870913);
        }
      c &= ~Hg;
    }
    f !== 0 && lI(n, f, 0), m !== 0 && B === 0 && n.tag !== 0 && (n.suspendedLanes |= m & ~(j & ~a));
  }
  function lI(n, a, c) {
    n.pendingLanes |= a, n.suspendedLanes &= ~a;
    var f = 31 - pA(a);
    n.entangledLanes |= a, n.entanglements[f] = n.entanglements[f] | 1073741824 | c & 4194090;
  }
  function TI(n, a) {
    var c = n.entangledLanes |= a;
    for (n = n.entanglements; c; ) {
      var f = 31 - pA(c), B = 1 << f;
      B & a | n[f] & a && (n[f] |= a), c &= ~B;
    }
  }
  function cI(n) {
    switch (n) {
      case 2:
        n = 1;
        break;
      case 8:
        n = 4;
        break;
      case 32:
        n = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        n = 128;
        break;
      case 268435456:
        n = 134217728;
        break;
      default:
        n = 0;
    }
    return n;
  }
  function VA(n) {
    return n &= -n, 2 < n ? 8 < n ? (n & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Ii() {
    var n = Q.p;
    return n !== 0 ? n : (n = window.event, n === void 0 ? 32 : kw(n.type));
  }
  function Vf(n, a) {
    var c = Q.p;
    try {
      return Q.p = n, a();
    } finally {
      Q.p = c;
    }
  }
  var Ai = Math.random().toString(36).slice(2), sA = "__reactFiber$" + Ai, jC = "__reactProps$" + Ai, Ys = "__reactContainer$" + Ai, xf = "__reactEvents$" + Ai, HM = "__reactListeners$" + Ai, EM = "__reactHandles$" + Ai, Sr = "__reactResources$" + Ai, Gr = "__reactMarker$" + Ai;
  function gI(n) {
    delete n[sA], delete n[jC], delete n[xf], delete n[HM], delete n[EM];
  }
  function Pn(n) {
    var a = n[sA];
    if (a) return a;
    for (var c = n.parentNode; c; ) {
      if (a = c[Ys] || c[sA]) {
        if (c = a.alternate, a.child !== null || c !== null && c.child !== null)
          for (n = co(n); n !== null; ) {
            if (c = n[sA]) return c;
            n = co(n);
          }
        return a;
      }
      n = c, c = n.parentNode;
    }
    return null;
  }
  function yC(n) {
    if (n = n[sA] || n[Ys]) {
      var a = n.tag;
      if (a === 5 || a === 6 || a === 13 || a === 26 || a === 27 || a === 3)
        return n;
    }
    return null;
  }
  function Ro(n) {
    var a = n.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return n.stateNode;
    throw Error(t(33));
  }
  function Oo(n) {
    var a = n[Sr];
    return a || (a = n[Sr] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), a;
  }
  function OA(n) {
    n[Gr] = !0;
  }
  var _f = /* @__PURE__ */ new Set(), Kr = {};
  function tC(n, a) {
    Ps(n, a), Ps(n + "Capture", a);
  }
  function Ps(n, a) {
    for (Kr[n] = a, n = 0; n < a.length; n++)
      _f.add(a[n]);
  }
  var Uf = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Ff = {}, Ec = {};
  function RM(n) {
    return fI.call(Ec, n) ? !0 : fI.call(Ff, n) ? !1 : Uf.test(n) ? Ec[n] = !0 : (Ff[n] = !0, !1);
  }
  function Tr(n, a, c) {
    if (RM(a))
      if (c === null) n.removeAttribute(a);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            n.removeAttribute(a);
            return;
          case "boolean":
            var f = a.toLowerCase().slice(0, 5);
            if (f !== "data-" && f !== "aria-") {
              n.removeAttribute(a);
              return;
            }
        }
        n.setAttribute(a, "" + c);
      }
  }
  function Oi(n, a, c) {
    if (c === null) n.removeAttribute(a);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(a);
          return;
      }
      n.setAttribute(a, "" + c);
    }
  }
  function Ci(n, a, c, f) {
    if (f === null) n.removeAttribute(c);
    else {
      switch (typeof f) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(c);
          return;
      }
      n.setAttributeNS(a, c, "" + f);
    }
  }
  var Rc, Xf;
  function Zs(n) {
    if (Rc === void 0)
      try {
        throw Error();
      } catch (c) {
        var a = c.stack.trim().match(/\n( *(at )?)/);
        Rc = a && a[1] || "", Xf = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Rc + n + Xf;
  }
  var Oc = !1;
  function FC(n, a) {
    if (!n || Oc) return "";
    Oc = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var f = {
        DetermineComponentFrameRoot: function() {
          try {
            if (a) {
              var Hg = function() {
                throw Error();
              };
              if (Object.defineProperty(Hg.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(Hg, []);
                } catch (pg) {
                  var hg = pg;
                }
                Reflect.construct(n, [], Hg);
              } else {
                try {
                  Hg.call();
                } catch (pg) {
                  hg = pg;
                }
                n.call(Hg.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (pg) {
                hg = pg;
              }
              (Hg = n()) && typeof Hg.catch == "function" && Hg.catch(function() {
              });
            }
          } catch (pg) {
            if (pg && hg && typeof pg.stack == "string")
              return [pg.stack, hg.stack];
          }
          return [null, null];
        }
      };
      f.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var B = Object.getOwnPropertyDescriptor(
        f.DetermineComponentFrameRoot,
        "name"
      );
      B && B.configurable && Object.defineProperty(
        f.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var m = f.DetermineComponentFrameRoot(), j = m[0], O = m[1];
      if (j && O) {
        var q = j.split(`
`), ug = O.split(`
`);
        for (B = f = 0; f < q.length && !q[f].includes("DetermineComponentFrameRoot"); )
          f++;
        for (; B < ug.length && !ug[B].includes(
          "DetermineComponentFrameRoot"
        ); )
          B++;
        if (f === q.length || B === ug.length)
          for (f = q.length - 1, B = ug.length - 1; 1 <= f && 0 <= B && q[f] !== ug[B]; )
            B--;
        for (; 1 <= f && 0 <= B; f--, B--)
          if (q[f] !== ug[B]) {
            if (f !== 1 || B !== 1)
              do
                if (f--, B--, 0 > B || q[f] !== ug[B]) {
                  var jg = `
` + q[f].replace(" at new ", " at ");
                  return n.displayName && jg.includes("<anonymous>") && (jg = jg.replace("<anonymous>", n.displayName)), jg;
                }
              while (1 <= f && 0 <= B);
            break;
          }
      }
    } finally {
      Oc = !1, Error.prepareStackTrace = c;
    }
    return (c = n ? n.displayName || n.name : "") ? Zs(c) : "";
  }
  function No(n) {
    switch (n.tag) {
      case 26:
      case 27:
      case 5:
        return Zs(n.type);
      case 16:
        return Zs("Lazy");
      case 13:
        return Zs("Suspense");
      case 19:
        return Zs("SuspenseList");
      case 0:
      case 15:
        return FC(n.type, !1);
      case 11:
        return FC(n.type.render, !1);
      case 1:
        return FC(n.type, !0);
      case 31:
        return Zs("Activity");
      default:
        return "";
    }
  }
  function Zn(n) {
    try {
      var a = "";
      do
        a += No(n), n = n.return;
      while (n);
      return a;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function Ye(n) {
    switch (typeof n) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function ko(n) {
    var a = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
  }
  function Nc(n) {
    var a = ko(n) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      n.constructor.prototype,
      a
    ), f = "" + n[a];
    if (!n.hasOwnProperty(a) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var B = c.get, m = c.set;
      return Object.defineProperty(n, a, {
        configurable: !0,
        get: function() {
          return B.call(this);
        },
        set: function(j) {
          f = "" + j, m.call(this, j);
        }
      }), Object.defineProperty(n, a, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return f;
        },
        setValue: function(j) {
          f = "" + j;
        },
        stopTracking: function() {
          n._valueTracker = null, delete n[a];
        }
      };
    }
  }
  function Wo(n) {
    n._valueTracker || (n._valueTracker = Nc(n));
  }
  function Vo(n) {
    if (!n) return !1;
    var a = n._valueTracker;
    if (!a) return !0;
    var c = a.getValue(), f = "";
    return n && (f = ko(n) ? n.checked ? "true" : "false" : n.value), n = f, n !== c ? (a.setValue(n), !0) : !1;
  }
  function Ni(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  var Qf = /[\n"\\]/g;
  function ze(n) {
    return n.replace(
      Qf,
      function(a) {
        return "\\" + a.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function zf(n, a, c, f, B, m, j, O) {
    n.name = "", j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" ? n.type = j : n.removeAttribute("type"), a != null ? j === "number" ? (a === 0 && n.value === "" || n.value != a) && (n.value = "" + Ye(a)) : n.value !== "" + Ye(a) && (n.value = "" + Ye(a)) : j !== "submit" && j !== "reset" || n.removeAttribute("value"), a != null ? Yr(n, j, Ye(a)) : c != null ? Yr(n, j, Ye(c)) : f != null && n.removeAttribute("value"), B == null && m != null && (n.defaultChecked = !!m), B != null && (n.checked = B && typeof B != "function" && typeof B != "symbol"), O != null && typeof O != "function" && typeof O != "symbol" && typeof O != "boolean" ? n.name = "" + Ye(O) : n.removeAttribute("name");
  }
  function Jf(n, a, c, f, B, m, j, O) {
    if (m != null && typeof m != "function" && typeof m != "symbol" && typeof m != "boolean" && (n.type = m), a != null || c != null) {
      if (!(m !== "submit" && m !== "reset" || a != null))
        return;
      c = c != null ? "" + Ye(c) : "", a = a != null ? "" + Ye(a) : c, O || a === n.value || (n.value = a), n.defaultValue = a;
    }
    f = f ?? B, f = typeof f != "function" && typeof f != "symbol" && !!f, n.checked = O ? n.checked : !!f, n.defaultChecked = !!f, j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" && (n.name = j);
  }
  function Yr(n, a, c) {
    a === "number" && Ni(n.ownerDocument) === n || n.defaultValue === "" + c || (n.defaultValue = "" + c);
  }
  function jn(n, a, c, f) {
    if (n = n.options, a) {
      a = {};
      for (var B = 0; B < c.length; B++)
        a["$" + c[B]] = !0;
      for (c = 0; c < n.length; c++)
        B = a.hasOwnProperty("$" + n[c].value), n[c].selected !== B && (n[c].selected = B), B && f && (n[c].defaultSelected = !0);
    } else {
      for (c = "" + Ye(c), a = null, B = 0; B < n.length; B++) {
        if (n[B].value === c) {
          n[B].selected = !0, f && (n[B].defaultSelected = !0);
          return;
        }
        a !== null || n[B].disabled || (a = n[B]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function Lf(n, a, c) {
    if (a != null && (a = "" + Ye(a), a !== n.value && (n.value = a), c == null)) {
      n.defaultValue !== a && (n.defaultValue = a);
      return;
    }
    n.defaultValue = c != null ? "" + Ye(c) : "";
  }
  function qf(n, a, c, f) {
    if (a == null) {
      if (f != null) {
        if (c != null) throw Error(t(92));
        if (cg(f)) {
          if (1 < f.length) throw Error(t(93));
          f = f[0];
        }
        c = f;
      }
      c == null && (c = ""), a = c;
    }
    c = Ye(a), n.defaultValue = c, f = n.textContent, f === c && f !== "" && f !== null && (n.value = f);
  }
  function js(n, a) {
    if (a) {
      var c = n.firstChild;
      if (c && c === n.lastChild && c.nodeType === 3) {
        c.nodeValue = a;
        return;
      }
    }
    n.textContent = a;
  }
  var P0 = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function $f(n, a, c) {
    var f = a.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? f ? n.setProperty(a, "") : a === "float" ? n.cssFloat = "" : n[a] = "" : f ? n.setProperty(a, c) : typeof c != "number" || c === 0 || P0.has(a) ? a === "float" ? n.cssFloat = c : n[a] = ("" + c).trim() : n[a] = c + "px";
  }
  function kc(n, a, c) {
    if (a != null && typeof a != "object")
      throw Error(t(62));
    if (n = n.style, c != null) {
      for (var f in c)
        !c.hasOwnProperty(f) || a != null && a.hasOwnProperty(f) || (f.indexOf("--") === 0 ? n.setProperty(f, "") : f === "float" ? n.cssFloat = "" : n[f] = "");
      for (var B in a)
        f = a[B], a.hasOwnProperty(B) && c[B] !== f && $f(n, B, f);
    } else
      for (var m in a)
        a.hasOwnProperty(m) && $f(n, m, a[m]);
  }
  function xo(n) {
    if (n.indexOf("-") === -1) return !1;
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Pr = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Z0 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Zr(n) {
    return Z0.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n;
  }
  var Wc = null;
  function vs(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
  }
  var Hs = null, _o = null;
  function OM(n) {
    var a = yC(n);
    if (a && (n = a.stateNode)) {
      var c = n[jC] || null;
      g: switch (n = a.stateNode, a.type) {
        case "input":
          if (zf(
            n,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), a = c.name, c.type === "radio" && a != null) {
            for (c = n; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + ze(
                "" + a
              ) + '"][type="radio"]'
            ), a = 0; a < c.length; a++) {
              var f = c[a];
              if (f !== n && f.form === n.form) {
                var B = f[jC] || null;
                if (!B) throw Error(t(90));
                zf(
                  f,
                  B.value,
                  B.defaultValue,
                  B.defaultValue,
                  B.checked,
                  B.defaultChecked,
                  B.type,
                  B.name
                );
              }
            }
            for (a = 0; a < c.length; a++)
              f = c[a], f.form === n.form && Vo(f);
          }
          break g;
        case "textarea":
          Lf(n, c.value, c.defaultValue);
          break g;
        case "select":
          a = c.value, a != null && jn(n, !!c.multiple, a, !1);
      }
    }
  }
  var gh = !1;
  function NM(n, a, c) {
    if (gh) return n(a, c);
    gh = !0;
    try {
      var f = n(a);
      return f;
    } finally {
      if (gh = !1, (Hs !== null || _o !== null) && (pl(), Hs && (a = Hs, n = _o, _o = Hs = null, OM(a), n)))
        for (a = 0; a < n.length; a++) OM(n[a]);
    }
  }
  function ki(n, a) {
    var c = n.stateNode;
    if (c === null) return null;
    var f = c[jC] || null;
    if (f === null) return null;
    c = f[a];
    g: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (f = !f.disabled) || (n = n.type, f = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !f;
        break g;
      default:
        n = !1;
    }
    if (n) return null;
    if (c && typeof c != "function")
      throw Error(
        t(231, a, typeof c)
      );
    return c;
  }
  var dt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Vc = !1;
  if (dt)
    try {
      var Uo = {};
      Object.defineProperty(Uo, "passive", {
        get: function() {
          Vc = !0;
        }
      }), window.addEventListener("test", Uo, Uo), window.removeEventListener("test", Uo, Uo);
    } catch {
      Vc = !1;
    }
  var Je = null, xc = null, Es = null;
  function jr() {
    if (Es) return Es;
    var n, a = xc, c = a.length, f, B = "value" in Je ? Je.value : Je.textContent, m = B.length;
    for (n = 0; n < c && a[n] === B[n]; n++) ;
    var j = c - n;
    for (f = 1; f <= j && a[c - f] === B[m - f]; f++) ;
    return Es = B.slice(n, 1 < f ? 1 - f : void 0);
  }
  function vr(n) {
    var a = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && a === 13 && (n = 13)) : n = a, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
  }
  function DC() {
    return !0;
  }
  function kM() {
    return !1;
  }
  function vC(n) {
    function a(c, f, B, m, j) {
      this._reactName = c, this._targetInst = B, this.type = f, this.nativeEvent = m, this.target = j, this.currentTarget = null;
      for (var O in n)
        n.hasOwnProperty(O) && (c = n[O], this[O] = c ? c(m) : m[O]);
      return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1) ? DC : kM, this.isPropagationStopped = kM, this;
    }
    return w(a.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = DC);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = DC);
      },
      persist: function() {
      },
      isPersistent: DC
    }), a;
  }
  var vn = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Hr = vC(vn), Er = w({}, vn, { view: 0, detail: 0 }), j0 = vC(Er), _c, Ih, Fo, Uc = w({}, Er, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Fc,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
      return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
    },
    movementX: function(n) {
      return "movementX" in n ? n.movementX : (n !== Fo && (Fo && n.type === "mousemove" ? (_c = n.screenX - Fo.screenX, Ih = n.screenY - Fo.screenY) : Ih = _c = 0, Fo = n), _c);
    },
    movementY: function(n) {
      return "movementY" in n ? n.movementY : Ih;
    }
  }), Rr = vC(Uc), WM = w({}, Uc, { dataTransfer: 0 }), VM = vC(WM), xM = w({}, Er, { relatedTarget: 0 }), Ah = vC(xM), v0 = w({}, vn, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), H0 = vC(v0), E0 = w({}, vn, {
    clipboardData: function(n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    }
  }), R0 = vC(E0), Or = w({}, vn, { data: 0 }), Ch = vC(Or), _M = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, UM = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, FM = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function eh(n) {
    var a = this.nativeEvent;
    return a.getModifierState ? a.getModifierState(n) : (n = FM[n]) ? !!a[n] : !1;
  }
  function Fc() {
    return eh;
  }
  var Rs = w({}, Er, {
    key: function(n) {
      if (n.key) {
        var a = _M[n.key] || n.key;
        if (a !== "Unidentified") return a;
      }
      return n.type === "keypress" ? (n = vr(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? UM[n.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Fc,
    charCode: function(n) {
      return n.type === "keypress" ? vr(n) : 0;
    },
    keyCode: function(n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function(n) {
      return n.type === "keypress" ? vr(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    }
  }), Os = vC(Rs), ft = w({}, Uc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Ae = vC(ft), Xc = w({}, Er, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Fc
  }), Qc = vC(Xc), th = w({}, vn, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Ce = vC(th), XM = w({}, Uc, {
    deltaX: function(n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function(n) {
      return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), zc = vC(XM), Ns = w({}, vn, {
    newState: 0,
    oldState: 0
  }), ih = vC(Ns), QM = [9, 13, 27, 32], Jc = dt && "CompositionEvent" in window, ks = null;
  dt && "documentMode" in document && (ks = document.documentMode);
  var O0 = dt && "TextEvent" in window && !ks, Lc = dt && (!Jc || ks && 8 < ks && 11 >= ks), ei = " ", nh = !1;
  function qc(n, a) {
    switch (n) {
      case "keyup":
        return QM.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Nr(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var Le = !1;
  function sh(n, a) {
    switch (n) {
      case "compositionend":
        return Nr(a);
      case "keypress":
        return a.which !== 32 ? null : (nh = !0, ei);
      case "textInput":
        return n = a.data, n === ei && nh ? null : n;
      default:
        return null;
    }
  }
  function oh(n, a) {
    if (Le)
      return n === "compositionend" || !Jc && qc(n, a) ? (n = jr(), Es = xc = Je = null, Le = !1, n) : null;
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
          if (a.char && 1 < a.char.length)
            return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return Lc && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var Ws = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function ah(n) {
    var a = n && n.nodeName && n.nodeName.toLowerCase();
    return a === "input" ? !!Ws[n.type] : a === "textarea";
  }
  function $c(n, a, c, f) {
    Hs ? _o ? _o.push(f) : _o = [f] : Hs = f, a = ss(a, "onChange"), 0 < a.length && (c = new Hr(
      "onChange",
      "change",
      null,
      c,
      f
    ), n.push({ event: c, listeners: a }));
  }
  var Vs = null, ht = null;
  function xs(n) {
    an(n, 0);
  }
  function Xo(n) {
    var a = Ro(n);
    if (Vo(a)) return n;
  }
  function Hn(n, a) {
    if (n === "change") return a;
  }
  var rh = !1;
  if (dt) {
    var gu;
    if (dt) {
      var _s = "oninput" in document;
      if (!_s) {
        var Qo = document.createElement("div");
        Qo.setAttribute("oninput", "return;"), _s = typeof Qo.oninput == "function";
      }
      gu = _s;
    } else gu = !1;
    rh = gu && (!document.documentMode || 9 < document.documentMode);
  }
  function lh() {
    Vs && (Vs.detachEvent("onpropertychange", zo), ht = Vs = null);
  }
  function zo(n) {
    if (n.propertyName === "value" && Xo(ht)) {
      var a = [];
      $c(
        a,
        ht,
        n,
        vs(n)
      ), NM(xs, a);
    }
  }
  function zM(n, a, c) {
    n === "focusin" ? (lh(), Vs = a, ht = c, Vs.attachEvent("onpropertychange", zo)) : n === "focusout" && lh();
  }
  function Iu(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
      return Xo(ht);
  }
  function En(n, a) {
    if (n === "click") return Xo(a);
  }
  function Wi(n, a) {
    if (n === "input" || n === "change")
      return Xo(a);
  }
  function ch(n, a) {
    return n === a && (n !== 0 || 1 / n === 1 / a) || n !== n && a !== a;
  }
  var XC = typeof Object.is == "function" ? Object.is : ch;
  function Vi(n, a) {
    if (XC(n, a)) return !0;
    if (typeof n != "object" || n === null || typeof a != "object" || a === null)
      return !1;
    var c = Object.keys(n), f = Object.keys(a);
    if (c.length !== f.length) return !1;
    for (f = 0; f < c.length; f++) {
      var B = c[f];
      if (!fI.call(a, B) || !XC(n[B], a[B]))
        return !1;
    }
    return !0;
  }
  function kr(n) {
    for (; n && n.firstChild; ) n = n.firstChild;
    return n;
  }
  function Rn(n, a) {
    var c = kr(n);
    n = 0;
    for (var f; c; ) {
      if (c.nodeType === 3) {
        if (f = n + c.textContent.length, n <= a && f >= a)
          return { node: c, offset: a - n };
        n = f;
      }
      g: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break g;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = kr(c);
    }
  }
  function fA(n, a) {
    return n && a ? n === a ? !0 : n && n.nodeType === 3 ? !1 : a && a.nodeType === 3 ? fA(n, a.parentNode) : "contains" in n ? n.contains(a) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(a) & 16) : !1 : !1;
  }
  function Wr(n) {
    n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window;
    for (var a = Ni(n.document); a instanceof n.HTMLIFrameElement; ) {
      try {
        var c = typeof a.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) n = a.contentWindow;
      else break;
      a = Ni(n.document);
    }
    return a;
  }
  function Au(n) {
    var a = n && n.nodeName && n.nodeName.toLowerCase();
    return a && (a === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || a === "textarea" || n.contentEditable === "true");
  }
  var uh = dt && "documentMode" in document && 11 >= document.documentMode, qe = null, Us = null, Pe = null, Jo = !1;
  function Lo(n, a, c) {
    var f = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Jo || qe == null || qe !== Ni(f) || (f = qe, "selectionStart" in f && Au(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
      anchorNode: f.anchorNode,
      anchorOffset: f.anchorOffset,
      focusNode: f.focusNode,
      focusOffset: f.focusOffset
    }), Pe && Vi(Pe, f) || (Pe = f, f = ss(Us, "onSelect"), 0 < f.length && (a = new Hr(
      "onSelect",
      "select",
      null,
      a,
      c
    ), n.push({ event: a, listeners: f }), a.target = qe)));
  }
  function xi(n, a) {
    var c = {};
    return c[n.toLowerCase()] = a.toLowerCase(), c["Webkit" + n] = "webkit" + a, c["Moz" + n] = "moz" + a, c;
  }
  var On = {
    animationend: xi("Animation", "AnimationEnd"),
    animationiteration: xi("Animation", "AnimationIteration"),
    animationstart: xi("Animation", "AnimationStart"),
    transitionrun: xi("Transition", "TransitionRun"),
    transitionstart: xi("Transition", "TransitionStart"),
    transitioncancel: xi("Transition", "TransitionCancel"),
    transitionend: xi("Transition", "TransitionEnd")
  }, Cu = {}, yt = {};
  dt && (yt = document.createElement("div").style, "AnimationEvent" in window || (delete On.animationend.animation, delete On.animationiteration.animation, delete On.animationstart.animation), "TransitionEvent" in window || delete On.transitionend.transition);
  function HC(n) {
    if (Cu[n]) return Cu[n];
    if (!On[n]) return n;
    var a = On[n], c;
    for (c in a)
      if (a.hasOwnProperty(c) && c in yt)
        return Cu[n] = a[c];
    return n;
  }
  var Vr = HC("animationend"), JM = HC("animationiteration"), dh = HC("animationstart"), N0 = HC("transitionrun"), fh = HC("transitionstart"), eu = HC("transitioncancel"), hh = HC("transitionend"), yh = /* @__PURE__ */ new Map(), tu = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  tu.push("scrollEnd");
  function ee(n, a) {
    yh.set(n, a), tC(a, [n]);
  }
  var Dh = /* @__PURE__ */ new WeakMap();
  function Ze(n, a) {
    if (typeof n == "object" && n !== null) {
      var c = Dh.get(n);
      return c !== void 0 ? c : (a = {
        value: n,
        source: a,
        stack: Zn(a)
      }, Dh.set(n, a), a);
    }
    return {
      value: n,
      source: a,
      stack: Zn(a)
    };
  }
  var je = [], Nn = 0, xr = 0;
  function Dt() {
    for (var n = Nn, a = xr = Nn = 0; a < n; ) {
      var c = je[a];
      je[a++] = null;
      var f = je[a];
      je[a++] = null;
      var B = je[a];
      je[a++] = null;
      var m = je[a];
      if (je[a++] = null, f !== null && B !== null) {
        var j = f.pending;
        j === null ? B.next = B : (B.next = j.next, j.next = B), f.pending = B;
      }
      m !== 0 && qo(c, B, m);
    }
  }
  function Mt(n, a, c, f) {
    je[Nn++] = n, je[Nn++] = a, je[Nn++] = c, je[Nn++] = f, xr |= f, n.lanes |= f, n = n.alternate, n !== null && (n.lanes |= f);
  }
  function Fs(n, a, c, f) {
    return Mt(n, a, c, f), kn(n);
  }
  function _i(n, a) {
    return Mt(n, null, null, a), kn(n);
  }
  function qo(n, a, c) {
    n.lanes |= c;
    var f = n.alternate;
    f !== null && (f.lanes |= c);
    for (var B = !1, m = n.return; m !== null; )
      m.childLanes |= c, f = m.alternate, f !== null && (f.childLanes |= c), m.tag === 22 && (n = m.stateNode, n === null || n._visibility & 1 || (B = !0)), n = m, m = m.return;
    return n.tag === 3 ? (m = n.stateNode, B && a !== null && (B = 31 - pA(c), n = m.hiddenUpdates, f = n[B], f === null ? n[B] = [a] : f.push(a), a.lane = c | 536870912), m) : null;
  }
  function kn(n) {
    if (50 < Pa)
      throw Pa = 0, Fu = null, Error(t(185));
    for (var a = n.return; a !== null; )
      n = a, a = n.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var Xs = {};
  function k0(n, a, c, f) {
    this.tag = n, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function te(n, a, c, f) {
    return new k0(n, a, c, f);
  }
  function iu(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function wt(n, a) {
    var c = n.alternate;
    return c === null ? (c = te(
      n.tag,
      a,
      n.key,
      n.mode
    ), c.elementType = n.elementType, c.type = n.type, c.stateNode = n.stateNode, c.alternate = n, n.alternate = c) : (c.pendingProps = a, c.type = n.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = n.flags & 65011712, c.childLanes = n.childLanes, c.lanes = n.lanes, c.child = n.child, c.memoizedProps = n.memoizedProps, c.memoizedState = n.memoizedState, c.updateQueue = n.updateQueue, a = n.dependencies, c.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }, c.sibling = n.sibling, c.index = n.index, c.ref = n.ref, c.refCleanup = n.refCleanup, c;
  }
  function nu(n, a) {
    n.flags &= 65011714;
    var c = n.alternate;
    return c === null ? (n.childLanes = 0, n.lanes = a, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = c.childLanes, n.lanes = c.lanes, n.child = c.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = c.memoizedProps, n.memoizedState = c.memoizedState, n.updateQueue = c.updateQueue, n.type = c.type, a = c.dependencies, n.dependencies = a === null ? null : {
      lanes: a.lanes,
      firstContext: a.firstContext
    }), n;
  }
  function BI(n, a, c, f, B, m) {
    var j = 0;
    if (f = n, typeof n == "function") iu(n) && (j = 1);
    else if (typeof n == "string")
      j = jw(
        n,
        c,
        Sg.current
      ) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5;
    else
      g: switch (n) {
        case Mg:
          return n = te(31, c, a, B), n.elementType = Mg, n.lanes = m, n;
        case K:
          return Og(c.children, B, m, a);
        case Y:
          j = 8, B |= 24;
          break;
        case T:
          return n = te(12, c, a, B | 2), n.elementType = T, n.lanes = m, n;
        case U:
          return n = te(13, c, a, B), n.elementType = U, n.lanes = m, n;
        case J:
          return n = te(19, c, a, B), n.elementType = J, n.lanes = m, n;
        default:
          if (typeof n == "object" && n !== null)
            switch (n.$$typeof) {
              case E:
              case R:
                j = 10;
                break g;
              case H:
                j = 9;
                break g;
              case x:
                j = 11;
                break g;
              case L:
                j = 14;
                break g;
              case eg:
                j = 16, f = null;
                break g;
            }
          j = 29, c = Error(
            t(130, n === null ? "null" : typeof n, "")
          ), f = null;
      }
    return a = te(j, c, a, B), a.elementType = n, a.type = f, a.lanes = m, a;
  }
  function Og(n, a, c, f) {
    return n = te(7, n, f, a), n.lanes = c, n;
  }
  function Wn(n, a, c) {
    return n = te(6, n, null, a), n.lanes = c, n;
  }
  function $o(n, a, c) {
    return a = te(
      4,
      n.children !== null ? n.children : [],
      n.key,
      a
    ), a.lanes = c, a.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation
    }, a;
  }
  var aA = [], Vn = 0, ga = null, _r = 0, ie = [], $e = 0, Ui = null, Bt = 1, pt = "";
  function xA(n, a) {
    aA[Vn++] = _r, aA[Vn++] = ga, ga = n, _r = a;
  }
  function JI(n, a, c) {
    ie[$e++] = Bt, ie[$e++] = pt, ie[$e++] = Ui, Ui = n;
    var f = Bt;
    n = pt;
    var B = 32 - pA(f) - 1;
    f &= ~(1 << B), c += 1;
    var m = 32 - pA(a) + B;
    if (30 < m) {
      var j = B - B % 5;
      m = (f & (1 << j) - 1).toString(32), f >>= j, B -= j, Bt = 1 << 32 - pA(a) + B | c << B | f, pt = m + n;
    } else
      Bt = 1 << m | c << B | f, pt = n;
  }
  function Ur(n) {
    n.return !== null && (xA(n, 1), JI(n, 1, 0));
  }
  function Qs(n) {
    for (; n === ga; )
      ga = aA[--Vn], aA[Vn] = null, _r = aA[--Vn], aA[Vn] = null;
    for (; n === Ui; )
      Ui = ie[--$e], ie[$e] = null, pt = ie[--$e], ie[$e] = null, Bt = ie[--$e], ie[$e] = null;
  }
  var PA = null, IA = null, pI = !1, Fi = null, QC = !1, Fr = Error(t(519));
  function mt(n) {
    var a = Error(t(418, ""));
    throw Ca(Ze(a, n)), Fr;
  }
  function su(n) {
    var a = n.stateNode, c = n.type, f = n.memoizedProps;
    switch (a[sA] = n, a[jC] = f, c) {
      case "dialog":
        DI("cancel", a), DI("close", a);
        break;
      case "iframe":
      case "object":
      case "embed":
        DI("load", a);
        break;
      case "video":
      case "audio":
        for (c = 0; c < uI.length; c++)
          DI(uI[c], a);
        break;
      case "source":
        DI("error", a);
        break;
      case "img":
      case "image":
      case "link":
        DI("error", a), DI("load", a);
        break;
      case "details":
        DI("toggle", a);
        break;
      case "input":
        DI("invalid", a), Jf(
          a,
          f.value,
          f.defaultValue,
          f.checked,
          f.defaultChecked,
          f.type,
          f.name,
          !0
        ), Wo(a);
        break;
      case "select":
        DI("invalid", a);
        break;
      case "textarea":
        DI("invalid", a), qf(a, f.value, f.defaultValue, f.children), Wo(a);
    }
    c = f.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || a.textContent === "" + c || f.suppressHydrationWarning === !0 || Yw(a.textContent, c) ? (f.popover != null && (DI("beforetoggle", a), DI("toggle", a)), f.onScroll != null && DI("scroll", a), f.onScrollEnd != null && DI("scrollend", a), f.onClick != null && (a.onclick = Pl), a = !0) : a = !1, a || mt(n);
  }
  function Xr(n) {
    for (PA = n.return; PA; )
      switch (PA.tag) {
        case 5:
        case 13:
          QC = !1;
          return;
        case 27:
        case 3:
          QC = !0;
          return;
        default:
          PA = PA.return;
      }
  }
  function Ia(n) {
    if (n !== PA) return !1;
    if (!pI) return Xr(n), pI = !0, !1;
    var a = n.tag, c;
    if ((c = a !== 3 && a !== 27) && ((c = a === 5) && (c = n.type, c = !(c !== "form" && c !== "button") || lo(n.type, n.memoizedProps)), c = !c), c && IA && mt(n), Xr(n), a === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(t(317));
      g: {
        for (n = n.nextSibling, a = 0; n; ) {
          if (n.nodeType === 8)
            if (c = n.data, c === "/$") {
              if (a === 0) {
                IA = Rt(n.nextSibling);
                break g;
              }
              a--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || a++;
          n = n.nextSibling;
        }
        IA = null;
      }
    } else
      a === 27 ? (a = IA, BC(n.type) ? (n = Ny, Ny = null, IA = n) : IA = a) : IA = PA ? Rt(n.stateNode.nextSibling) : null;
    return !0;
  }
  function Aa() {
    IA = PA = null, pI = !1;
  }
  function Mh() {
    var n = Fi;
    return n !== null && (JC === null ? JC = n : JC.push.apply(
      JC,
      n
    ), Fi = null), n;
  }
  function Ca(n) {
    Fi === null ? Fi = [n] : Fi.push(n);
  }
  var ou = F(null), Xi = null, bt = null;
  function ti(n, a, c) {
    Cg(ou, a._currentValue), a._currentValue = c;
  }
  function ii(n) {
    n._currentValue = ou.current, rg(ou);
  }
  function au(n, a, c) {
    for (; n !== null; ) {
      var f = n.alternate;
      if ((n.childLanes & a) !== a ? (n.childLanes |= a, f !== null && (f.childLanes |= a)) : f !== null && (f.childLanes & a) !== a && (f.childLanes |= a), n === c) break;
      n = n.return;
    }
  }
  function ru(n, a, c, f) {
    var B = n.child;
    for (B !== null && (B.return = n); B !== null; ) {
      var m = B.dependencies;
      if (m !== null) {
        var j = B.child;
        m = m.firstContext;
        g: for (; m !== null; ) {
          var O = m;
          m = B;
          for (var q = 0; q < a.length; q++)
            if (O.context === a[q]) {
              m.lanes |= c, O = m.alternate, O !== null && (O.lanes |= c), au(
                m.return,
                c,
                n
              ), f || (j = null);
              break g;
            }
          m = O.next;
        }
      } else if (B.tag === 18) {
        if (j = B.return, j === null) throw Error(t(341));
        j.lanes |= c, m = j.alternate, m !== null && (m.lanes |= c), au(j, c, n), j = null;
      } else j = B.child;
      if (j !== null) j.return = B;
      else
        for (j = B; j !== null; ) {
          if (j === n) {
            j = null;
            break;
          }
          if (B = j.sibling, B !== null) {
            B.return = j.return, j = B;
            break;
          }
          j = j.return;
        }
      B = j;
    }
  }
  function Qr(n, a, c, f) {
    n = null;
    for (var B = a, m = !1; B !== null; ) {
      if (!m) {
        if ((B.flags & 524288) !== 0) m = !0;
        else if ((B.flags & 262144) !== 0) break;
      }
      if (B.tag === 10) {
        var j = B.alternate;
        if (j === null) throw Error(t(387));
        if (j = j.memoizedProps, j !== null) {
          var O = B.type;
          XC(B.pendingProps.value, j.value) || (n !== null ? n.push(O) : n = [O]);
        }
      } else if (B === Wg.current) {
        if (j = B.alternate, j === null) throw Error(t(387));
        j.memoizedState.memoizedState !== B.memoizedState.memoizedState && (n !== null ? n.push(mC) : n = [mC]);
      }
      B = B.return;
    }
    n !== null && ru(
      a,
      n,
      c,
      f
    ), a.flags |= 262144;
  }
  function zr(n) {
    for (n = n.firstContext; n !== null; ) {
      if (!XC(
        n.context._currentValue,
        n.memoizedValue
      ))
        return !0;
      n = n.next;
    }
    return !1;
  }
  function xn(n) {
    Xi = n, bt = null, n = n.dependencies, n !== null && (n.firstContext = null);
  }
  function MC(n) {
    return wh(Xi, n);
  }
  function ea(n, a) {
    return Xi === null && xn(n), wh(n, a);
  }
  function wh(n, a) {
    var c = a._currentValue;
    if (a = { context: a, memoizedValue: c, next: null }, bt === null) {
      if (n === null) throw Error(t(308));
      bt = a, n.dependencies = { lanes: 0, firstContext: a }, n.flags |= 524288;
    } else bt = bt.next = a;
    return c;
  }
  var LM = typeof AbortController < "u" ? AbortController : function() {
    var n = [], a = this.signal = {
      aborted: !1,
      addEventListener: function(c, f) {
        n.push(f);
      }
    };
    this.abort = function() {
      a.aborted = !0, n.forEach(function(c) {
        return c();
      });
    };
  }, ta = g.unstable_scheduleCallback, lu = g.unstable_NormalPriority, _A = {
    $$typeof: R,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Bh() {
    return {
      controller: new LM(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function _n(n) {
    n.refCount--, n.refCount === 0 && ta(lu, function() {
      n.controller.abort();
    });
  }
  var ni = null, ia = 0, Un = 0, gt = null;
  function ne(n, a) {
    if (ni === null) {
      var c = ni = [];
      ia = 0, Un = Ad(), gt = {
        status: "pending",
        value: void 0,
        then: function(f) {
          c.push(f);
        }
      };
    }
    return ia++, a.then(Jr, Jr), a;
  }
  function Jr() {
    if (--ia === 0 && ni !== null) {
      gt !== null && (gt.status = "fulfilled");
      var n = ni;
      ni = null, Un = 0, gt = null;
      for (var a = 0; a < n.length; a++) (0, n[a])();
    }
  }
  function ph(n, a) {
    var c = [], f = {
      status: "pending",
      value: null,
      reason: null,
      then: function(B) {
        c.push(B);
      }
    };
    return n.then(
      function() {
        f.status = "fulfilled", f.value = a;
        for (var B = 0; B < c.length; B++) (0, c[B])(a);
      },
      function(B) {
        for (f.status = "rejected", f.reason = B, B = 0; B < c.length; B++)
          (0, c[B])(void 0);
      }
    ), f;
  }
  var mh = z.S;
  z.S = function(n, a) {
    typeof a == "object" && a !== null && typeof a.then == "function" && ne(n, a), mh !== null && mh(n, a);
  };
  var Qi = F(null);
  function na() {
    var n = Qi.current;
    return n !== null ? n : CA.pooledCache;
  }
  function sa(n, a) {
    a === null ? Cg(Qi, Qi.current) : Cg(Qi, a.pool);
  }
  function Lr() {
    var n = na();
    return n === null ? null : { parent: _A._currentValue, pool: n };
  }
  var zs = Error(t(460)), qr = Error(t(474)), oa = Error(t(542)), cu = { then: function() {
  } };
  function bh(n) {
    return n = n.status, n === "fulfilled" || n === "rejected";
  }
  function aa() {
  }
  function Sh(n, a, c) {
    switch (c = n[c], c === void 0 ? n.push(a) : c !== a && (a.then(aa, aa), a = c), a.status) {
      case "fulfilled":
        return a.value;
      case "rejected":
        throw n = a.reason, Gh(n), n;
      default:
        if (typeof a.status == "string") a.then(aa, aa);
        else {
          if (n = CA, n !== null && 100 < n.shellSuspendCounter)
            throw Error(t(482));
          n = a, n.status = "pending", n.then(
            function(f) {
              if (a.status === "pending") {
                var B = a;
                B.status = "fulfilled", B.value = f;
              }
            },
            function(f) {
              if (a.status === "pending") {
                var B = a;
                B.status = "rejected", B.reason = f;
              }
            }
          );
        }
        switch (a.status) {
          case "fulfilled":
            return a.value;
          case "rejected":
            throw n = a.reason, Gh(n), n;
        }
        throw ra = a, zs;
    }
  }
  var ra = null;
  function uu() {
    if (ra === null) throw Error(t(459));
    var n = ra;
    return ra = null, n;
  }
  function Gh(n) {
    if (n === zs || n === oa)
      throw Error(t(483));
  }
  var zi = !1;
  function $r(n) {
    n.updateQueue = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function du(n, a) {
    n = n.updateQueue, a.updateQueue === n && (a.updateQueue = {
      baseState: n.baseState,
      firstBaseUpdate: n.firstBaseUpdate,
      lastBaseUpdate: n.lastBaseUpdate,
      shared: n.shared,
      callbacks: null
    });
  }
  function Ji(n) {
    return { lane: n, tag: 0, payload: null, callback: null, next: null };
  }
  function se(n, a, c) {
    var f = n.updateQueue;
    if (f === null) return null;
    if (f = f.shared, (LI & 2) !== 0) {
      var B = f.pending;
      return B === null ? a.next = a : (a.next = B.next, B.next = a), f.pending = a, a = kn(n), qo(n, null, c), a;
    }
    return Mt(n, f, a, c), kn(n);
  }
  function Js(n, a, c) {
    if (a = a.updateQueue, a !== null && (a = a.shared, (c & 4194048) !== 0)) {
      var f = a.lanes;
      f &= n.pendingLanes, c |= f, a.lanes = c, TI(n, c);
    }
  }
  function gl(n, a) {
    var c = n.updateQueue, f = n.alternate;
    if (f !== null && (f = f.updateQueue, c === f)) {
      var B = null, m = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var j = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          m === null ? B = m = j : m = m.next = j, c = c.next;
        } while (c !== null);
        m === null ? B = m = a : m = m.next = a;
      } else B = m = a;
      c = {
        baseState: f.baseState,
        firstBaseUpdate: B,
        lastBaseUpdate: m,
        shared: f.shared,
        callbacks: f.callbacks
      }, n.updateQueue = c;
      return;
    }
    n = c.lastBaseUpdate, n === null ? c.firstBaseUpdate = a : n.next = a, c.lastBaseUpdate = a;
  }
  var Kh = !1;
  function Il() {
    if (Kh) {
      var n = gt;
      if (n !== null) throw n;
    }
  }
  function la(n, a, c, f) {
    Kh = !1;
    var B = n.updateQueue;
    zi = !1;
    var m = B.firstBaseUpdate, j = B.lastBaseUpdate, O = B.shared.pending;
    if (O !== null) {
      B.shared.pending = null;
      var q = O, ug = q.next;
      q.next = null, j === null ? m = ug : j.next = ug, j = q;
      var jg = n.alternate;
      jg !== null && (jg = jg.updateQueue, O = jg.lastBaseUpdate, O !== j && (O === null ? jg.firstBaseUpdate = ug : O.next = ug, jg.lastBaseUpdate = q));
    }
    if (m !== null) {
      var Hg = B.baseState;
      j = 0, jg = ug = q = null, O = m;
      do {
        var hg = O.lane & -536870913, pg = hg !== O.lane;
        if (pg ? (WI & hg) === hg : (f & hg) === hg) {
          hg !== 0 && hg === Un && (Kh = !0), jg !== null && (jg = jg.next = {
            lane: 0,
            tag: O.tag,
            payload: O.payload,
            callback: null,
            next: null
          });
          g: {
            var tI = n, eI = O;
            hg = a;
            var zI = c;
            switch (eI.tag) {
              case 1:
                if (tI = eI.payload, typeof tI == "function") {
                  Hg = tI.call(zI, Hg, hg);
                  break g;
                }
                Hg = tI;
                break g;
              case 3:
                tI.flags = tI.flags & -65537 | 128;
              case 0:
                if (tI = eI.payload, hg = typeof tI == "function" ? tI.call(zI, Hg, hg) : tI, hg == null) break g;
                Hg = w({}, Hg, hg);
                break g;
              case 2:
                zi = !0;
            }
          }
          hg = O.callback, hg !== null && (n.flags |= 64, pg && (n.flags |= 8192), pg = B.callbacks, pg === null ? B.callbacks = [hg] : pg.push(hg));
        } else
          pg = {
            lane: hg,
            tag: O.tag,
            payload: O.payload,
            callback: O.callback,
            next: null
          }, jg === null ? (ug = jg = pg, q = Hg) : jg = jg.next = pg, j |= hg;
        if (O = O.next, O === null) {
          if (O = B.shared.pending, O === null)
            break;
          pg = O, O = pg.next, pg.next = null, B.lastBaseUpdate = pg, B.shared.pending = null;
        }
      } while (!0);
      jg === null && (q = Hg), B.baseState = q, B.firstBaseUpdate = ug, B.lastBaseUpdate = jg, m === null && (B.shared.lanes = 0), Is |= j, n.lanes = j, n.memoizedState = Hg;
    }
  }
  function ca(n, a) {
    if (typeof n != "function")
      throw Error(t(191, n));
    n.call(a);
  }
  function fu(n, a) {
    var c = n.callbacks;
    if (c !== null)
      for (n.callbacks = null, n = 0; n < c.length; n++)
        ca(c[n], a);
  }
  var Li = F(null), Al = F(0);
  function Th(n, a) {
    n = nn, Cg(Al, n), Cg(Li, a), nn = n | a.baseLanes;
  }
  function LA() {
    Cg(Al, nn), Cg(Li, Li.current);
  }
  function ua() {
    nn = Al.current, rg(Li), rg(Al);
  }
  var St = 0, hI = null, XI = null, KA = null, Ls = !1, qs = !1, oe = !1, Cl = 0, It = 0, ae = null, hu = 0;
  function TA() {
    throw Error(t(321));
  }
  function el(n, a) {
    if (a === null) return !1;
    for (var c = 0; c < a.length && c < n.length; c++)
      if (!XC(n[c], a[c])) return !1;
    return !0;
  }
  function yu(n, a, c, f, B, m) {
    return St = m, hI = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, z.H = n === null || n.memoizedState === null ? tw : Qh, oe = !1, m = c(f, B), oe = !1, qs && (m = Fn(
      a,
      c,
      f,
      B
    )), Yh(n), m;
  }
  function Yh(n) {
    z.H = ul;
    var a = XI !== null && XI.next !== null;
    if (St = 0, KA = XI = hI = null, Ls = !1, It = 0, ae = null, a) throw Error(t(300));
    n === null || YI || (n = n.dependencies, n !== null && zr(n) && (YI = !0));
  }
  function Fn(n, a, c, f) {
    hI = n;
    var B = 0;
    do {
      if (qs && (ae = null), It = 0, qs = !1, 25 <= B) throw Error(t(301));
      if (B += 1, KA = XI = null, n.updateQueue != null) {
        var m = n.updateQueue;
        m.lastEffect = null, m.events = null, m.stores = null, m.memoCache != null && (m.memoCache.index = 0);
      }
      z.H = iw, m = a(c, f);
    } while (qs);
    return m;
  }
  function qM() {
    var n = z.H, a = n.useState()[0];
    return a = typeof a.then == "function" ? $s(a) : a, n = n.useState()[0], (XI !== null ? XI.memoizedState : null) !== n && (hI.flags |= 1024), a;
  }
  function Du() {
    var n = Cl !== 0;
    return Cl = 0, n;
  }
  function Mu(n, a, c) {
    a.updateQueue = n.updateQueue, a.flags &= -2053, n.lanes &= ~c;
  }
  function da(n) {
    if (Ls) {
      for (n = n.memoizedState; n !== null; ) {
        var a = n.queue;
        a !== null && (a.pending = null), n = n.next;
      }
      Ls = !1;
    }
    St = 0, KA = XI = hI = null, qs = !1, It = Cl = 0, ae = null;
  }
  function zC() {
    var n = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return KA === null ? hI.memoizedState = KA = n : KA = KA.next = n, KA;
  }
  function ZA() {
    if (XI === null) {
      var n = hI.alternate;
      n = n !== null ? n.memoizedState : null;
    } else n = XI.next;
    var a = KA === null ? hI.memoizedState : KA.next;
    if (a !== null)
      KA = a, XI = n;
    else {
      if (n === null)
        throw hI.alternate === null ? Error(t(467)) : Error(t(310));
      XI = n, n = {
        memoizedState: XI.memoizedState,
        baseState: XI.baseState,
        baseQueue: XI.baseQueue,
        queue: XI.queue,
        next: null
      }, KA === null ? hI.memoizedState = KA = n : KA = KA.next = n;
    }
    return KA;
  }
  function tl() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function $s(n) {
    var a = It;
    return It += 1, ae === null && (ae = []), n = Sh(ae, n, a), a = hI, (KA === null ? a.memoizedState : KA.next) === null && (a = a.alternate, z.H = a === null || a.memoizedState === null ? tw : Qh), n;
  }
  function wu(n) {
    if (n !== null && typeof n == "object") {
      if (typeof n.then == "function") return $s(n);
      if (n.$$typeof === R) return MC(n);
    }
    throw Error(t(438, String(n)));
  }
  function qA(n) {
    var a = null, c = hI.updateQueue;
    if (c !== null && (a = c.memoCache), a == null) {
      var f = hI.alternate;
      f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (a = {
        data: f.data.map(function(B) {
          return B.slice();
        }),
        index: 0
      })));
    }
    if (a == null && (a = { data: [], index: 0 }), c === null && (c = tl(), hI.updateQueue = c), c.memoCache = a, c = a.data[a.index], c === void 0)
      for (c = a.data[a.index] = Array(n), f = 0; f < n; f++)
        c[f] = ig;
    return a.index++, c;
  }
  function si(n, a) {
    return typeof a == "function" ? a(n) : a;
  }
  function il(n) {
    var a = ZA();
    return Bu(a, XI, n);
  }
  function Bu(n, a, c) {
    var f = n.queue;
    if (f === null) throw Error(t(311));
    f.lastRenderedReducer = c;
    var B = n.baseQueue, m = f.pending;
    if (m !== null) {
      if (B !== null) {
        var j = B.next;
        B.next = m.next, m.next = j;
      }
      a.baseQueue = B = m, f.pending = null;
    }
    if (m = n.baseState, B === null) n.memoizedState = m;
    else {
      a = B.next;
      var O = j = null, q = null, ug = a, jg = !1;
      do {
        var Hg = ug.lane & -536870913;
        if (Hg !== ug.lane ? (WI & Hg) === Hg : (St & Hg) === Hg) {
          var hg = ug.revertLane;
          if (hg === 0)
            q !== null && (q = q.next = {
              lane: 0,
              revertLane: 0,
              action: ug.action,
              hasEagerState: ug.hasEagerState,
              eagerState: ug.eagerState,
              next: null
            }), Hg === Un && (jg = !0);
          else if ((St & hg) === hg) {
            ug = ug.next, hg === Un && (jg = !0);
            continue;
          } else
            Hg = {
              lane: 0,
              revertLane: ug.revertLane,
              action: ug.action,
              hasEagerState: ug.hasEagerState,
              eagerState: ug.eagerState,
              next: null
            }, q === null ? (O = q = Hg, j = m) : q = q.next = Hg, hI.lanes |= hg, Is |= hg;
          Hg = ug.action, oe && c(m, Hg), m = ug.hasEagerState ? ug.eagerState : c(m, Hg);
        } else
          hg = {
            lane: Hg,
            revertLane: ug.revertLane,
            action: ug.action,
            hasEagerState: ug.hasEagerState,
            eagerState: ug.eagerState,
            next: null
          }, q === null ? (O = q = hg, j = m) : q = q.next = hg, hI.lanes |= Hg, Is |= Hg;
        ug = ug.next;
      } while (ug !== null && ug !== a);
      if (q === null ? j = m : q.next = O, !XC(m, n.memoizedState) && (YI = !0, jg && (c = gt, c !== null)))
        throw c;
      n.memoizedState = m, n.baseState = j, n.baseQueue = q, f.lastRenderedState = m;
    }
    return B === null && (f.lanes = 0), [n.memoizedState, f.dispatch];
  }
  function pu(n) {
    var a = ZA(), c = a.queue;
    if (c === null) throw Error(t(311));
    c.lastRenderedReducer = n;
    var f = c.dispatch, B = c.pending, m = a.memoizedState;
    if (B !== null) {
      c.pending = null;
      var j = B = B.next;
      do
        m = n(m, j.action), j = j.next;
      while (j !== B);
      XC(m, a.memoizedState) || (YI = !0), a.memoizedState = m, a.baseQueue === null && (a.baseState = m), c.lastRenderedState = m;
    }
    return [m, f];
  }
  function Ph(n, a, c) {
    var f = hI, B = ZA(), m = pI;
    if (m) {
      if (c === void 0) throw Error(t(407));
      c = c();
    } else c = a();
    var j = !XC(
      (XI || B).memoizedState,
      c
    );
    j && (B.memoizedState = c, YI = !0), B = B.queue;
    var O = Zh.bind(null, f, B, n);
    if (qi(2048, 8, O, [n]), B.getSnapshot !== a || j || KA !== null && KA.memoizedState.tag & 1) {
      if (f.flags |= 2048, Xn(
        9,
        At(),
        mu.bind(
          null,
          f,
          B,
          c,
          a
        ),
        null
      ), CA === null) throw Error(t(349));
      m || (St & 124) !== 0 || nl(f, a, c);
    }
    return c;
  }
  function nl(n, a, c) {
    n.flags |= 16384, n = { getSnapshot: a, value: c }, a = hI.updateQueue, a === null ? (a = tl(), hI.updateQueue = a, a.stores = [n]) : (c = a.stores, c === null ? a.stores = [n] : c.push(n));
  }
  function mu(n, a, c, f) {
    a.value = c, a.getSnapshot = f, jh(a) && vh(n);
  }
  function Zh(n, a, c) {
    return c(function() {
      jh(a) && vh(n);
    });
  }
  function jh(n) {
    var a = n.getSnapshot;
    n = n.value;
    try {
      var c = a();
      return !XC(n, c);
    } catch {
      return !0;
    }
  }
  function vh(n) {
    var a = _i(n, 2);
    a !== null && ye(a, n, 2);
  }
  function sl(n) {
    var a = zC();
    if (typeof n == "function") {
      var c = n;
      if (n = c(), oe) {
        PC(!0);
        try {
          c();
        } finally {
          PC(!1);
        }
      }
    }
    return a.memoizedState = a.baseState = n, a.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: si,
      lastRenderedState: n
    }, a;
  }
  function bu(n, a, c, f) {
    return n.baseState = c, Bu(
      n,
      XI,
      typeof f == "function" ? f : si
    );
  }
  function Hh(n, a, c, f, B) {
    if (ya(n)) throw Error(t(485));
    if (n = a.action, n !== null) {
      var m = {
        payload: B,
        action: n,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(j) {
          m.listeners.push(j);
        }
      };
      z.T !== null ? c(!0) : m.isTransition = !1, f(m), c = a.pending, c === null ? (m.next = a.pending = m, Eh(a, m)) : (m.next = c.next, a.pending = c.next = m);
    }
  }
  function Eh(n, a) {
    var c = a.action, f = a.payload, B = n.state;
    if (a.isTransition) {
      var m = z.T, j = {};
      z.T = j;
      try {
        var O = c(B, f), q = z.S;
        q !== null && q(j, O), Su(n, a, O);
      } catch (ug) {
        al(n, a, ug);
      } finally {
        z.T = m;
      }
    } else
      try {
        m = c(B, f), Su(n, a, m);
      } catch (ug) {
        al(n, a, ug);
      }
  }
  function Su(n, a, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(f) {
        ol(n, a, f);
      },
      function(f) {
        return al(n, a, f);
      }
    ) : ol(n, a, c);
  }
  function ol(n, a, c) {
    a.status = "fulfilled", a.value = c, Rh(a), n.state = c, a = n.pending, a !== null && (c = a.next, c === a ? n.pending = null : (c = c.next, a.next = c, Eh(n, c)));
  }
  function al(n, a, c) {
    var f = n.pending;
    if (n.pending = null, f !== null) {
      f = f.next;
      do
        a.status = "rejected", a.reason = c, Rh(a), a = a.next;
      while (a !== f);
    }
    n.action = null;
  }
  function Rh(n) {
    n = n.listeners;
    for (var a = 0; a < n.length; a++) (0, n[a])();
  }
  function Oh(n, a) {
    return a;
  }
  function Gu(n, a) {
    if (pI) {
      var c = CA.formState;
      if (c !== null) {
        g: {
          var f = hI;
          if (pI) {
            if (IA) {
              I: {
                for (var B = IA, m = QC; B.nodeType !== 8; ) {
                  if (!m) {
                    B = null;
                    break I;
                  }
                  if (B = Rt(
                    B.nextSibling
                  ), B === null) {
                    B = null;
                    break I;
                  }
                }
                m = B.data, B = m === "F!" || m === "F" ? B : null;
              }
              if (B) {
                IA = Rt(
                  B.nextSibling
                ), f = B.data === "F!";
                break g;
              }
            }
            mt(f);
          }
          f = !1;
        }
        f && (a = c[0]);
      }
    }
    return c = zC(), c.memoizedState = c.baseState = a, f = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Oh,
      lastRenderedState: a
    }, c.queue = f, c = Yu.bind(
      null,
      hI,
      f
    ), f.dispatch = c, f = sl(!1), m = ll.bind(
      null,
      hI,
      !1,
      f.queue
    ), f = zC(), B = {
      state: a,
      dispatch: null,
      action: n,
      pending: null
    }, f.queue = B, c = Hh.bind(
      null,
      hI,
      B,
      m,
      c
    ), B.dispatch = c, f.memoizedState = n, [a, c, !1];
  }
  function Nh(n) {
    var a = ZA();
    return oi(a, XI, n);
  }
  function oi(n, a, c) {
    if (a = Bu(
      n,
      a,
      Oh
    )[0], n = il(si)[0], typeof a == "object" && a !== null && typeof a.then == "function")
      try {
        var f = $s(a);
      } catch (j) {
        throw j === zs ? oa : j;
      }
    else f = a;
    a = ZA();
    var B = a.queue, m = B.dispatch;
    return c !== a.memoizedState && (hI.flags |= 2048, Xn(
      9,
      At(),
      kh.bind(null, B, c),
      null
    )), [f, m, n];
  }
  function kh(n, a) {
    n.action = a;
  }
  function $M(n) {
    var a = ZA(), c = XI;
    if (c !== null)
      return oi(a, c, n);
    ZA(), a = a.memoizedState, c = ZA();
    var f = c.queue.dispatch;
    return c.memoizedState = n, [a, f, !1];
  }
  function Xn(n, a, c, f) {
    return n = { tag: n, create: c, deps: f, inst: a, next: null }, a = hI.updateQueue, a === null && (a = tl(), hI.updateQueue = a), c = a.lastEffect, c === null ? a.lastEffect = n.next = n : (f = c.next, c.next = n, n.next = f, a.lastEffect = n), n;
  }
  function At() {
    return { destroy: void 0, resource: void 0 };
  }
  function Wh() {
    return ZA().memoizedState;
  }
  function go(n, a, c, f) {
    var B = zC();
    f = f === void 0 ? null : f, hI.flags |= n, B.memoizedState = Xn(
      1 | a,
      At(),
      c,
      f
    );
  }
  function qi(n, a, c, f) {
    var B = ZA();
    f = f === void 0 ? null : f;
    var m = B.memoizedState.inst;
    XI !== null && f !== null && el(f, XI.memoizedState.deps) ? B.memoizedState = Xn(a, m, c, f) : (hI.flags |= n, B.memoizedState = Xn(
      1 | a,
      m,
      c,
      f
    ));
  }
  function hA(n, a) {
    go(8390656, 8, n, a);
  }
  function gw(n, a) {
    qi(2048, 8, n, a);
  }
  function Iw(n, a) {
    return qi(4, 2, n, a);
  }
  function Vh(n, a) {
    return qi(4, 4, n, a);
  }
  function Gt(n, a) {
    if (typeof a == "function") {
      n = n();
      var c = a(n);
      return function() {
        typeof c == "function" ? c() : a(null);
      };
    }
    if (a != null)
      return n = n(), a.current = n, function() {
        a.current = null;
      };
  }
  function xh(n, a, c) {
    c = c != null ? c.concat([n]) : null, qi(4, 4, Gt.bind(null, a, n), c);
  }
  function rl() {
  }
  function fa(n, a) {
    var c = ZA();
    a = a === void 0 ? null : a;
    var f = c.memoizedState;
    return a !== null && el(a, f[1]) ? f[0] : (c.memoizedState = [n, a], n);
  }
  function Io(n, a) {
    var c = ZA();
    a = a === void 0 ? null : a;
    var f = c.memoizedState;
    if (a !== null && el(a, f[1]))
      return f[0];
    if (f = n(), oe) {
      PC(!0);
      try {
        n();
      } finally {
        PC(!1);
      }
    }
    return c.memoizedState = [f, a], f;
  }
  function Ku(n, a, c) {
    return c === void 0 || (St & 1073741824) !== 0 ? n.memoizedState = a : (n.memoizedState = c, n = yw(), hI.lanes |= n, Is |= n, c);
  }
  function Tu(n, a, c, f) {
    return XC(c, a) ? c : Li.current !== null ? (n = Ku(n, c, f), XC(n, a) || (YI = !0), n) : (St & 42) === 0 ? (YI = !0, n.memoizedState = c) : (n = yw(), hI.lanes |= n, Is |= n, a);
  }
  function _h(n, a, c, f, B) {
    var m = Q.p;
    Q.p = m !== 0 && 8 > m ? m : 8;
    var j = z.T, O = {};
    z.T = O, ll(n, !1, a, c);
    try {
      var q = B(), ug = z.S;
      if (ug !== null && ug(O, q), q !== null && typeof q == "object" && typeof q.then == "function") {
        var jg = ph(
          q,
          f
        );
        ha(
          n,
          a,
          jg,
          Oe(n)
        );
      } else
        ha(
          n,
          a,
          f,
          Oe(n)
        );
    } catch (Hg) {
      ha(
        n,
        a,
        { then: function() {
        }, status: "rejected", reason: Hg },
        Oe()
      );
    } finally {
      Q.p = m, z.T = j;
    }
  }
  function W0() {
  }
  function Uh(n, a, c, f) {
    if (n.tag !== 5) throw Error(t(476));
    var B = Fh(n).queue;
    _h(
      n,
      B,
      a,
      Bg,
      c === null ? W0 : function() {
        return Aw(n), c(f);
      }
    );
  }
  function Fh(n) {
    var a = n.memoizedState;
    if (a !== null) return a;
    a = {
      memoizedState: Bg,
      baseState: Bg,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: si,
        lastRenderedState: Bg
      },
      next: null
    };
    var c = {};
    return a.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: si,
        lastRenderedState: c
      },
      next: null
    }, n.memoizedState = a, n = n.alternate, n !== null && (n.memoizedState = a), a;
  }
  function Aw(n) {
    var a = Fh(n).next.queue;
    ha(n, a, {}, Oe());
  }
  function Ao() {
    return MC(mC);
  }
  function Kt() {
    return ZA().memoizedState;
  }
  function Xh() {
    return ZA().memoizedState;
  }
  function V0(n) {
    for (var a = n.return; a !== null; ) {
      switch (a.tag) {
        case 24:
        case 3:
          var c = Oe();
          n = Ji(c);
          var f = se(a, n, c);
          f !== null && (ye(f, a, c), Js(f, a, c)), a = { cache: Bh() }, n.payload = a;
          return;
      }
      a = a.return;
    }
  }
  function Cw(n, a, c) {
    var f = Oe();
    c = {
      lane: f,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, ya(n) ? cl(a, c) : (c = Fs(n, a, c, f), c !== null && (ye(c, n, f), ew(c, a, f)));
  }
  function Yu(n, a, c) {
    var f = Oe();
    ha(n, a, c, f);
  }
  function ha(n, a, c, f) {
    var B = {
      lane: f,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (ya(n)) cl(a, B);
    else {
      var m = n.alternate;
      if (n.lanes === 0 && (m === null || m.lanes === 0) && (m = a.lastRenderedReducer, m !== null))
        try {
          var j = a.lastRenderedState, O = m(j, c);
          if (B.hasEagerState = !0, B.eagerState = O, XC(O, j))
            return Mt(n, a, B, 0), CA === null && Dt(), !1;
        } catch {
        } finally {
        }
      if (c = Fs(n, a, B, f), c !== null)
        return ye(c, n, f), ew(c, a, f), !0;
    }
    return !1;
  }
  function ll(n, a, c, f) {
    if (f = {
      lane: 2,
      revertLane: Ad(),
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, ya(n)) {
      if (a) throw Error(t(479));
    } else
      a = Fs(
        n,
        c,
        f,
        2
      ), a !== null && ye(a, n, 2);
  }
  function ya(n) {
    var a = n.alternate;
    return n === hI || a !== null && a === hI;
  }
  function cl(n, a) {
    qs = Ls = !0;
    var c = n.pending;
    c === null ? a.next = a : (a.next = c.next, c.next = a), n.pending = a;
  }
  function ew(n, a, c) {
    if ((c & 4194048) !== 0) {
      var f = a.lanes;
      f &= n.pendingLanes, c |= f, a.lanes = c, TI(n, c);
    }
  }
  var ul = {
    readContext: MC,
    use: wu,
    useCallback: TA,
    useContext: TA,
    useEffect: TA,
    useImperativeHandle: TA,
    useLayoutEffect: TA,
    useInsertionEffect: TA,
    useMemo: TA,
    useReducer: TA,
    useRef: TA,
    useState: TA,
    useDebugValue: TA,
    useDeferredValue: TA,
    useTransition: TA,
    useSyncExternalStore: TA,
    useId: TA,
    useHostTransitionStatus: TA,
    useFormState: TA,
    useActionState: TA,
    useOptimistic: TA,
    useMemoCache: TA,
    useCacheRefresh: TA
  }, tw = {
    readContext: MC,
    use: wu,
    useCallback: function(n, a) {
      return zC().memoizedState = [
        n,
        a === void 0 ? null : a
      ], n;
    },
    useContext: MC,
    useEffect: hA,
    useImperativeHandle: function(n, a, c) {
      c = c != null ? c.concat([n]) : null, go(
        4194308,
        4,
        Gt.bind(null, a, n),
        c
      );
    },
    useLayoutEffect: function(n, a) {
      return go(4194308, 4, n, a);
    },
    useInsertionEffect: function(n, a) {
      go(4, 2, n, a);
    },
    useMemo: function(n, a) {
      var c = zC();
      a = a === void 0 ? null : a;
      var f = n();
      if (oe) {
        PC(!0);
        try {
          n();
        } finally {
          PC(!1);
        }
      }
      return c.memoizedState = [f, a], f;
    },
    useReducer: function(n, a, c) {
      var f = zC();
      if (c !== void 0) {
        var B = c(a);
        if (oe) {
          PC(!0);
          try {
            c(a);
          } finally {
            PC(!1);
          }
        }
      } else B = a;
      return f.memoizedState = f.baseState = B, n = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: B
      }, f.queue = n, n = n.dispatch = Cw.bind(
        null,
        hI,
        n
      ), [f.memoizedState, n];
    },
    useRef: function(n) {
      var a = zC();
      return n = { current: n }, a.memoizedState = n;
    },
    useState: function(n) {
      n = sl(n);
      var a = n.queue, c = Yu.bind(null, hI, a);
      return a.dispatch = c, [n.memoizedState, c];
    },
    useDebugValue: rl,
    useDeferredValue: function(n, a) {
      var c = zC();
      return Ku(c, n, a);
    },
    useTransition: function() {
      var n = sl(!1);
      return n = _h.bind(
        null,
        hI,
        n.queue,
        !0,
        !1
      ), zC().memoizedState = n, [!1, n];
    },
    useSyncExternalStore: function(n, a, c) {
      var f = hI, B = zC();
      if (pI) {
        if (c === void 0)
          throw Error(t(407));
        c = c();
      } else {
        if (c = a(), CA === null)
          throw Error(t(349));
        (WI & 124) !== 0 || nl(f, a, c);
      }
      B.memoizedState = c;
      var m = { value: c, getSnapshot: a };
      return B.queue = m, hA(Zh.bind(null, f, m, n), [
        n
      ]), f.flags |= 2048, Xn(
        9,
        At(),
        mu.bind(
          null,
          f,
          m,
          c,
          a
        ),
        null
      ), c;
    },
    useId: function() {
      var n = zC(), a = CA.identifierPrefix;
      if (pI) {
        var c = pt, f = Bt;
        c = (f & ~(1 << 32 - pA(f) - 1)).toString(32) + c, a = "" + a + "R" + c, c = Cl++, 0 < c && (a += "H" + c.toString(32)), a += "";
      } else
        c = hu++, a = "" + a + "r" + c.toString(32) + "";
      return n.memoizedState = a;
    },
    useHostTransitionStatus: Ao,
    useFormState: Gu,
    useActionState: Gu,
    useOptimistic: function(n) {
      var a = zC();
      a.memoizedState = a.baseState = n;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return a.queue = c, a = ll.bind(
        null,
        hI,
        !0,
        c
      ), c.dispatch = a, [n, a];
    },
    useMemoCache: qA,
    useCacheRefresh: function() {
      return zC().memoizedState = V0.bind(
        null,
        hI
      );
    }
  }, Qh = {
    readContext: MC,
    use: wu,
    useCallback: fa,
    useContext: MC,
    useEffect: gw,
    useImperativeHandle: xh,
    useInsertionEffect: Iw,
    useLayoutEffect: Vh,
    useMemo: Io,
    useReducer: il,
    useRef: Wh,
    useState: function() {
      return il(si);
    },
    useDebugValue: rl,
    useDeferredValue: function(n, a) {
      var c = ZA();
      return Tu(
        c,
        XI.memoizedState,
        n,
        a
      );
    },
    useTransition: function() {
      var n = il(si)[0], a = ZA().memoizedState;
      return [
        typeof n == "boolean" ? n : $s(n),
        a
      ];
    },
    useSyncExternalStore: Ph,
    useId: Kt,
    useHostTransitionStatus: Ao,
    useFormState: Nh,
    useActionState: Nh,
    useOptimistic: function(n, a) {
      var c = ZA();
      return bu(c, XI, n, a);
    },
    useMemoCache: qA,
    useCacheRefresh: Xh
  }, iw = {
    readContext: MC,
    use: wu,
    useCallback: fa,
    useContext: MC,
    useEffect: gw,
    useImperativeHandle: xh,
    useInsertionEffect: Iw,
    useLayoutEffect: Vh,
    useMemo: Io,
    useReducer: pu,
    useRef: Wh,
    useState: function() {
      return pu(si);
    },
    useDebugValue: rl,
    useDeferredValue: function(n, a) {
      var c = ZA();
      return XI === null ? Ku(c, n, a) : Tu(
        c,
        XI.memoizedState,
        n,
        a
      );
    },
    useTransition: function() {
      var n = pu(si)[0], a = ZA().memoizedState;
      return [
        typeof n == "boolean" ? n : $s(n),
        a
      ];
    },
    useSyncExternalStore: Ph,
    useId: Kt,
    useHostTransitionStatus: Ao,
    useFormState: $M,
    useActionState: $M,
    useOptimistic: function(n, a) {
      var c = ZA();
      return XI !== null ? bu(c, XI, n, a) : (c.baseState = n, [n, c.queue.dispatch]);
    },
    useMemoCache: qA,
    useCacheRefresh: Xh
  }, re = null, Da = 0;
  function dl(n) {
    var a = Da;
    return Da += 1, re === null && (re = []), Sh(re, n, a);
  }
  function fl(n, a) {
    a = a.props.ref, n.ref = a !== void 0 ? a : null;
  }
  function Ma(n, a) {
    throw a.$$typeof === p ? Error(t(525)) : (n = Object.prototype.toString.call(a), Error(
      t(
        31,
        n === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : n
      )
    ));
  }
  function le(n) {
    var a = n._init;
    return a(n._payload);
  }
  function zh(n) {
    function a(ag, Ag) {
      if (n) {
        var dg = ag.deletions;
        dg === null ? (ag.deletions = [Ag], ag.flags |= 16) : dg.push(Ag);
      }
    }
    function c(ag, Ag) {
      if (!n) return null;
      for (; Ag !== null; )
        a(ag, Ag), Ag = Ag.sibling;
      return null;
    }
    function f(ag) {
      for (var Ag = /* @__PURE__ */ new Map(); ag !== null; )
        ag.key !== null ? Ag.set(ag.key, ag) : Ag.set(ag.index, ag), ag = ag.sibling;
      return Ag;
    }
    function B(ag, Ag) {
      return ag = wt(ag, Ag), ag.index = 0, ag.sibling = null, ag;
    }
    function m(ag, Ag, dg) {
      return ag.index = dg, n ? (dg = ag.alternate, dg !== null ? (dg = dg.index, dg < Ag ? (ag.flags |= 67108866, Ag) : dg) : (ag.flags |= 67108866, Ag)) : (ag.flags |= 1048576, Ag);
    }
    function j(ag) {
      return n && ag.alternate === null && (ag.flags |= 67108866), ag;
    }
    function O(ag, Ag, dg, vg) {
      return Ag === null || Ag.tag !== 6 ? (Ag = Wn(dg, ag.mode, vg), Ag.return = ag, Ag) : (Ag = B(Ag, dg), Ag.return = ag, Ag);
    }
    function q(ag, Ag, dg, vg) {
      var Lg = dg.type;
      return Lg === K ? jg(
        ag,
        Ag,
        dg.props.children,
        vg,
        dg.key
      ) : Ag !== null && (Ag.elementType === Lg || typeof Lg == "object" && Lg !== null && Lg.$$typeof === eg && le(Lg) === Ag.type) ? (Ag = B(Ag, dg.props), fl(Ag, dg), Ag.return = ag, Ag) : (Ag = BI(
        dg.type,
        dg.key,
        dg.props,
        null,
        ag.mode,
        vg
      ), fl(Ag, dg), Ag.return = ag, Ag);
    }
    function ug(ag, Ag, dg, vg) {
      return Ag === null || Ag.tag !== 4 || Ag.stateNode.containerInfo !== dg.containerInfo || Ag.stateNode.implementation !== dg.implementation ? (Ag = $o(dg, ag.mode, vg), Ag.return = ag, Ag) : (Ag = B(Ag, dg.children || []), Ag.return = ag, Ag);
    }
    function jg(ag, Ag, dg, vg, Lg) {
      return Ag === null || Ag.tag !== 7 ? (Ag = Og(
        dg,
        ag.mode,
        vg,
        Lg
      ), Ag.return = ag, Ag) : (Ag = B(Ag, dg), Ag.return = ag, Ag);
    }
    function Hg(ag, Ag, dg) {
      if (typeof Ag == "string" && Ag !== "" || typeof Ag == "number" || typeof Ag == "bigint")
        return Ag = Wn(
          "" + Ag,
          ag.mode,
          dg
        ), Ag.return = ag, Ag;
      if (typeof Ag == "object" && Ag !== null) {
        switch (Ag.$$typeof) {
          case b:
            return dg = BI(
              Ag.type,
              Ag.key,
              Ag.props,
              null,
              ag.mode,
              dg
            ), fl(dg, Ag), dg.return = ag, dg;
          case S:
            return Ag = $o(
              Ag,
              ag.mode,
              dg
            ), Ag.return = ag, Ag;
          case eg:
            var vg = Ag._init;
            return Ag = vg(Ag._payload), Hg(ag, Ag, dg);
        }
        if (cg(Ag) || Kg(Ag))
          return Ag = Og(
            Ag,
            ag.mode,
            dg,
            null
          ), Ag.return = ag, Ag;
        if (typeof Ag.then == "function")
          return Hg(ag, dl(Ag), dg);
        if (Ag.$$typeof === R)
          return Hg(
            ag,
            ea(ag, Ag),
            dg
          );
        Ma(ag, Ag);
      }
      return null;
    }
    function hg(ag, Ag, dg, vg) {
      var Lg = Ag !== null ? Ag.key : null;
      if (typeof dg == "string" && dg !== "" || typeof dg == "number" || typeof dg == "bigint")
        return Lg !== null ? null : O(ag, Ag, "" + dg, vg);
      if (typeof dg == "object" && dg !== null) {
        switch (dg.$$typeof) {
          case b:
            return dg.key === Lg ? q(ag, Ag, dg, vg) : null;
          case S:
            return dg.key === Lg ? ug(ag, Ag, dg, vg) : null;
          case eg:
            return Lg = dg._init, dg = Lg(dg._payload), hg(ag, Ag, dg, vg);
        }
        if (cg(dg) || Kg(dg))
          return Lg !== null ? null : jg(ag, Ag, dg, vg, null);
        if (typeof dg.then == "function")
          return hg(
            ag,
            Ag,
            dl(dg),
            vg
          );
        if (dg.$$typeof === R)
          return hg(
            ag,
            Ag,
            ea(ag, dg),
            vg
          );
        Ma(ag, dg);
      }
      return null;
    }
    function pg(ag, Ag, dg, vg, Lg) {
      if (typeof vg == "string" && vg !== "" || typeof vg == "number" || typeof vg == "bigint")
        return ag = ag.get(dg) || null, O(Ag, ag, "" + vg, Lg);
      if (typeof vg == "object" && vg !== null) {
        switch (vg.$$typeof) {
          case b:
            return ag = ag.get(
              vg.key === null ? dg : vg.key
            ) || null, q(Ag, ag, vg, Lg);
          case S:
            return ag = ag.get(
              vg.key === null ? dg : vg.key
            ) || null, ug(Ag, ag, vg, Lg);
          case eg:
            var mI = vg._init;
            return vg = mI(vg._payload), pg(
              ag,
              Ag,
              dg,
              vg,
              Lg
            );
        }
        if (cg(vg) || Kg(vg))
          return ag = ag.get(dg) || null, jg(Ag, ag, vg, Lg, null);
        if (typeof vg.then == "function")
          return pg(
            ag,
            Ag,
            dg,
            dl(vg),
            Lg
          );
        if (vg.$$typeof === R)
          return pg(
            ag,
            Ag,
            dg,
            ea(Ag, vg),
            Lg
          );
        Ma(Ag, vg);
      }
      return null;
    }
    function tI(ag, Ag, dg, vg) {
      for (var Lg = null, mI = null, CI = Ag, iI = Ag = 0, rC = null; CI !== null && iI < dg.length; iI++) {
        CI.index > iI ? (rC = CI, CI = null) : rC = CI.sibling;
        var UI = hg(
          ag,
          CI,
          dg[iI],
          vg
        );
        if (UI === null) {
          CI === null && (CI = rC);
          break;
        }
        n && CI && UI.alternate === null && a(ag, CI), Ag = m(UI, Ag, iI), mI === null ? Lg = UI : mI.sibling = UI, mI = UI, CI = rC;
      }
      if (iI === dg.length)
        return c(ag, CI), pI && xA(ag, iI), Lg;
      if (CI === null) {
        for (; iI < dg.length; iI++)
          CI = Hg(ag, dg[iI], vg), CI !== null && (Ag = m(
            CI,
            Ag,
            iI
          ), mI === null ? Lg = CI : mI.sibling = CI, mI = CI);
        return pI && xA(ag, iI), Lg;
      }
      for (CI = f(CI); iI < dg.length; iI++)
        rC = pg(
          CI,
          ag,
          iI,
          dg[iI],
          vg
        ), rC !== null && (n && rC.alternate !== null && CI.delete(
          rC.key === null ? iI : rC.key
        ), Ag = m(
          rC,
          Ag,
          iI
        ), mI === null ? Lg = rC : mI.sibling = rC, mI = rC);
      return n && CI.forEach(function(yi) {
        return a(ag, yi);
      }), pI && xA(ag, iI), Lg;
    }
    function eI(ag, Ag, dg, vg) {
      if (dg == null) throw Error(t(151));
      for (var Lg = null, mI = null, CI = Ag, iI = Ag = 0, rC = null, UI = dg.next(); CI !== null && !UI.done; iI++, UI = dg.next()) {
        CI.index > iI ? (rC = CI, CI = null) : rC = CI.sibling;
        var yi = hg(ag, CI, UI.value, vg);
        if (yi === null) {
          CI === null && (CI = rC);
          break;
        }
        n && CI && yi.alternate === null && a(ag, CI), Ag = m(yi, Ag, iI), mI === null ? Lg = yi : mI.sibling = yi, mI = yi, CI = rC;
      }
      if (UI.done)
        return c(ag, CI), pI && xA(ag, iI), Lg;
      if (CI === null) {
        for (; !UI.done; iI++, UI = dg.next())
          UI = Hg(ag, UI.value, vg), UI !== null && (Ag = m(UI, Ag, iI), mI === null ? Lg = UI : mI.sibling = UI, mI = UI);
        return pI && xA(ag, iI), Lg;
      }
      for (CI = f(CI); !UI.done; iI++, UI = dg.next())
        UI = pg(CI, ag, iI, UI.value, vg), UI !== null && (n && UI.alternate !== null && CI.delete(UI.key === null ? iI : UI.key), Ag = m(UI, Ag, iI), mI === null ? Lg = UI : mI.sibling = UI, mI = UI);
      return n && CI.forEach(function(q0) {
        return a(ag, q0);
      }), pI && xA(ag, iI), Lg;
    }
    function zI(ag, Ag, dg, vg) {
      if (typeof dg == "object" && dg !== null && dg.type === K && dg.key === null && (dg = dg.props.children), typeof dg == "object" && dg !== null) {
        switch (dg.$$typeof) {
          case b:
            g: {
              for (var Lg = dg.key; Ag !== null; ) {
                if (Ag.key === Lg) {
                  if (Lg = dg.type, Lg === K) {
                    if (Ag.tag === 7) {
                      c(
                        ag,
                        Ag.sibling
                      ), vg = B(
                        Ag,
                        dg.props.children
                      ), vg.return = ag, ag = vg;
                      break g;
                    }
                  } else if (Ag.elementType === Lg || typeof Lg == "object" && Lg !== null && Lg.$$typeof === eg && le(Lg) === Ag.type) {
                    c(
                      ag,
                      Ag.sibling
                    ), vg = B(Ag, dg.props), fl(vg, dg), vg.return = ag, ag = vg;
                    break g;
                  }
                  c(ag, Ag);
                  break;
                } else a(ag, Ag);
                Ag = Ag.sibling;
              }
              dg.type === K ? (vg = Og(
                dg.props.children,
                ag.mode,
                vg,
                dg.key
              ), vg.return = ag, ag = vg) : (vg = BI(
                dg.type,
                dg.key,
                dg.props,
                null,
                ag.mode,
                vg
              ), fl(vg, dg), vg.return = ag, ag = vg);
            }
            return j(ag);
          case S:
            g: {
              for (Lg = dg.key; Ag !== null; ) {
                if (Ag.key === Lg)
                  if (Ag.tag === 4 && Ag.stateNode.containerInfo === dg.containerInfo && Ag.stateNode.implementation === dg.implementation) {
                    c(
                      ag,
                      Ag.sibling
                    ), vg = B(Ag, dg.children || []), vg.return = ag, ag = vg;
                    break g;
                  } else {
                    c(ag, Ag);
                    break;
                  }
                else a(ag, Ag);
                Ag = Ag.sibling;
              }
              vg = $o(dg, ag.mode, vg), vg.return = ag, ag = vg;
            }
            return j(ag);
          case eg:
            return Lg = dg._init, dg = Lg(dg._payload), zI(
              ag,
              Ag,
              dg,
              vg
            );
        }
        if (cg(dg))
          return tI(
            ag,
            Ag,
            dg,
            vg
          );
        if (Kg(dg)) {
          if (Lg = Kg(dg), typeof Lg != "function") throw Error(t(150));
          return dg = Lg.call(dg), eI(
            ag,
            Ag,
            dg,
            vg
          );
        }
        if (typeof dg.then == "function")
          return zI(
            ag,
            Ag,
            dl(dg),
            vg
          );
        if (dg.$$typeof === R)
          return zI(
            ag,
            Ag,
            ea(ag, dg),
            vg
          );
        Ma(ag, dg);
      }
      return typeof dg == "string" && dg !== "" || typeof dg == "number" || typeof dg == "bigint" ? (dg = "" + dg, Ag !== null && Ag.tag === 6 ? (c(ag, Ag.sibling), vg = B(Ag, dg), vg.return = ag, ag = vg) : (c(ag, Ag), vg = Wn(dg, ag.mode, vg), vg.return = ag, ag = vg), j(ag)) : c(ag, Ag);
    }
    return function(ag, Ag, dg, vg) {
      try {
        Da = 0;
        var Lg = zI(
          ag,
          Ag,
          dg,
          vg
        );
        return re = null, Lg;
      } catch (CI) {
        if (CI === zs || CI === oa) throw CI;
        var mI = te(29, CI, null, ag.mode);
        return mI.lanes = vg, mI.return = ag, mI;
      } finally {
      }
    };
  }
  var iC = zh(!0), Jh = zh(!1), UA = F(null), Tt = null;
  function ce(n) {
    var a = n.alternate;
    Cg(NA, NA.current & 1), Cg(UA, n), Tt === null && (a === null || Li.current !== null || a.memoizedState !== null) && (Tt = n);
  }
  function Lh(n) {
    if (n.tag === 22) {
      if (Cg(NA, NA.current), Cg(UA, n), Tt === null) {
        var a = n.alternate;
        a !== null && a.memoizedState !== null && (Tt = n);
      }
    } else EC();
  }
  function EC() {
    Cg(NA, NA.current), Cg(UA, UA.current);
  }
  function Yt(n) {
    rg(UA), Tt === n && (Tt = null), rg(NA);
  }
  var NA = F(0);
  function ve(n) {
    for (var a = n; a !== null; ) {
      if (a.tag === 13) {
        var c = a.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || Ry(c)))
          return a;
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if ((a.flags & 128) !== 0) return a;
      } else if (a.child !== null) {
        a.child.return = a, a = a.child;
        continue;
      }
      if (a === n) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === n) return null;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
    return null;
  }
  function Pu(n, a, c, f) {
    a = n.memoizedState, c = c(f, a), c = c == null ? a : w({}, a, c), n.memoizedState = c, n.lanes === 0 && (n.updateQueue.baseState = c);
  }
  var Qn = {
    enqueueSetState: function(n, a, c) {
      n = n._reactInternals;
      var f = Oe(), B = Ji(f);
      B.payload = a, c != null && (B.callback = c), a = se(n, B, f), a !== null && (ye(a, n, f), Js(a, n, f));
    },
    enqueueReplaceState: function(n, a, c) {
      n = n._reactInternals;
      var f = Oe(), B = Ji(f);
      B.tag = 1, B.payload = a, c != null && (B.callback = c), a = se(n, B, f), a !== null && (ye(a, n, f), Js(a, n, f));
    },
    enqueueForceUpdate: function(n, a) {
      n = n._reactInternals;
      var c = Oe(), f = Ji(c);
      f.tag = 2, a != null && (f.callback = a), a = se(n, f, c), a !== null && (ye(a, n, c), Js(a, n, c));
    }
  };
  function qh(n, a, c, f, B, m, j) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(f, m, j) : a.prototype && a.prototype.isPureReactComponent ? !Vi(c, f) || !Vi(B, m) : !0;
  }
  function wa(n, a, c, f) {
    n = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(c, f), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(c, f), a.state !== n && Qn.enqueueReplaceState(a, a.state, null);
  }
  function Ct(n, a) {
    var c = a;
    if ("ref" in a) {
      c = {};
      for (var f in a)
        f !== "ref" && (c[f] = a[f]);
    }
    if (n = n.defaultProps) {
      c === a && (c = w({}, c));
      for (var B in n)
        c[B] === void 0 && (c[B] = n[B]);
    }
    return c;
  }
  var hl = typeof reportError == "function" ? reportError : function(n) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var a = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n),
        error: n
      });
      if (!window.dispatchEvent(a)) return;
    } else if (typeof A == "object" && typeof A.emit == "function") {
      A.emit("uncaughtException", n);
      return;
    }
    console.error(n);
  };
  function $h(n) {
    hl(n);
  }
  function Ba(n) {
    console.error(n);
  }
  function gy(n) {
    hl(n);
  }
  function Co(n, a) {
    try {
      var c = n.onUncaughtError;
      c(a.value, { componentStack: a.stack });
    } catch (f) {
      setTimeout(function() {
        throw f;
      });
    }
  }
  function Iy(n, a, c) {
    try {
      var f = n.onCaughtError;
      f(c.value, {
        componentStack: c.stack,
        errorBoundary: a.tag === 1 ? a.stateNode : null
      });
    } catch (B) {
      setTimeout(function() {
        throw B;
      });
    }
  }
  function Zu(n, a, c) {
    return c = Ji(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      Co(n, a);
    }, c;
  }
  function nw(n) {
    return n = Ji(n), n.tag = 3, n;
  }
  function Ay(n, a, c, f) {
    var B = c.type.getDerivedStateFromError;
    if (typeof B == "function") {
      var m = f.value;
      n.payload = function() {
        return B(m);
      }, n.callback = function() {
        Iy(a, c, f);
      };
    }
    var j = c.stateNode;
    j !== null && typeof j.componentDidCatch == "function" && (n.callback = function() {
      Iy(a, c, f), typeof B != "function" && (ai === null ? ai = /* @__PURE__ */ new Set([this]) : ai.add(this));
      var O = f.stack;
      this.componentDidCatch(f.value, {
        componentStack: O !== null ? O : ""
      });
    });
  }
  function He(n, a, c, f, B) {
    if (c.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") {
      if (a = c.alternate, a !== null && Qr(
        a,
        c,
        B,
        !0
      ), c = UA.current, c !== null) {
        switch (c.tag) {
          case 13:
            return Tt === null ? ts() : c.alternate === null && vA === 0 && (vA = 3), c.flags &= -257, c.flags |= 65536, c.lanes = B, f === cu ? c.flags |= 16384 : (a = c.updateQueue, a === null ? c.updateQueue = /* @__PURE__ */ new Set([f]) : a.add(f), bl(n, f, B)), !1;
          case 22:
            return c.flags |= 65536, f === cu ? c.flags |= 16384 : (a = c.updateQueue, a === null ? (a = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([f])
            }, c.updateQueue = a) : (c = a.retryQueue, c === null ? a.retryQueue = /* @__PURE__ */ new Set([f]) : c.add(f)), bl(n, f, B)), !1;
        }
        throw Error(t(435, c.tag));
      }
      return bl(n, f, B), ts(), !1;
    }
    if (pI)
      return a = UA.current, a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256), a.flags |= 65536, a.lanes = B, f !== Fr && (n = Error(t(422), { cause: f }), Ca(Ze(n, c)))) : (f !== Fr && (a = Error(t(423), {
        cause: f
      }), Ca(
        Ze(a, c)
      )), n = n.current.alternate, n.flags |= 65536, B &= -B, n.lanes |= B, f = Ze(f, c), B = Zu(
        n.stateNode,
        f,
        B
      ), gl(n, B), vA !== 4 && (vA = 2)), !1;
    var m = Error(t(520), { cause: f });
    if (m = Ze(m, c), Bl === null ? Bl = [m] : Bl.push(m), vA !== 4 && (vA = 2), a === null) return !0;
    f = Ze(f, c), c = a;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, n = B & -B, c.lanes |= n, n = Zu(c.stateNode, f, n), gl(c, n), !1;
        case 1:
          if (a = c.type, m = c.stateNode, (c.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (ai === null || !ai.has(m))))
            return c.flags |= 65536, B &= -B, c.lanes |= B, B = nw(B), Ay(
              B,
              n,
              c,
              f
            ), gl(c, B), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var Cy = Error(t(461)), YI = !1;
  function nC(n, a, c, f) {
    a.child = n === null ? Jh(a, null, c, f) : iC(
      a,
      n.child,
      c,
      f
    );
  }
  function ey(n, a, c, f, B) {
    c = c.render;
    var m = a.ref;
    if ("ref" in f) {
      var j = {};
      for (var O in f)
        O !== "ref" && (j[O] = f[O]);
    } else j = f;
    return xn(a), f = yu(
      n,
      a,
      c,
      j,
      m,
      B
    ), O = Du(), n !== null && !YI ? (Mu(n, a, B), Pt(n, a, B)) : (pI && O && Ur(a), a.flags |= 1, nC(n, a, f, B), a.child);
  }
  function sw(n, a, c, f, B) {
    if (n === null) {
      var m = c.type;
      return typeof m == "function" && !iu(m) && m.defaultProps === void 0 && c.compare === null ? (a.tag = 15, a.type = m, $i(
        n,
        a,
        m,
        f,
        B
      )) : (n = BI(
        c.type,
        null,
        f,
        a,
        a.mode,
        B
      ), n.ref = a.ref, n.return = a, a.child = n);
    }
    if (m = n.child, !Ou(n, B)) {
      var j = m.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Vi, c(j, f) && n.ref === a.ref)
        return Pt(n, a, B);
    }
    return a.flags |= 1, n = wt(m, f), n.ref = a.ref, n.return = a, a.child = n;
  }
  function $i(n, a, c, f, B) {
    if (n !== null) {
      var m = n.memoizedProps;
      if (Vi(m, f) && n.ref === a.ref)
        if (YI = !1, a.pendingProps = f = m, Ou(n, B))
          (n.flags & 131072) !== 0 && (YI = !0);
        else
          return a.lanes = n.lanes, Pt(n, a, B);
    }
    return vu(
      n,
      a,
      c,
      f,
      B
    );
  }
  function eo(n, a, c) {
    var f = a.pendingProps, B = f.children, m = n !== null ? n.memoizedState : null;
    if (f.mode === "hidden") {
      if ((a.flags & 128) !== 0) {
        if (f = m !== null ? m.baseLanes | c : c, n !== null) {
          for (B = a.child = n.child, m = 0; B !== null; )
            m = m | B.lanes | B.childLanes, B = B.sibling;
          a.childLanes = m & ~f;
        } else a.childLanes = 0, a.child = null;
        return ju(
          n,
          a,
          f,
          c
        );
      }
      if ((c & 536870912) !== 0)
        a.memoizedState = { baseLanes: 0, cachePool: null }, n !== null && sa(
          a,
          m !== null ? m.cachePool : null
        ), m !== null ? Th(a, m) : LA(), Lh(a);
      else
        return a.lanes = a.childLanes = 536870912, ju(
          n,
          a,
          m !== null ? m.baseLanes | c : c,
          c
        );
    } else
      m !== null ? (sa(a, m.cachePool), Th(a, m), EC(), a.memoizedState = null) : (n !== null && sa(a, null), LA(), EC());
    return nC(n, a, B, c), a.child;
  }
  function ju(n, a, c, f) {
    var B = na();
    return B = B === null ? null : { parent: _A._currentValue, pool: B }, a.memoizedState = {
      baseLanes: c,
      cachePool: B
    }, n !== null && sa(a, null), LA(), Lh(a), n !== null && Qr(n, a, f, !0), null;
  }
  function gn(n, a) {
    var c = a.ref;
    if (c === null)
      n !== null && n.ref !== null && (a.flags |= 4194816);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(t(284));
      (n === null || n.ref !== c) && (a.flags |= 4194816);
    }
  }
  function vu(n, a, c, f, B) {
    return xn(a), c = yu(
      n,
      a,
      c,
      f,
      void 0,
      B
    ), f = Du(), n !== null && !YI ? (Mu(n, a, B), Pt(n, a, B)) : (pI && f && Ur(a), a.flags |= 1, nC(n, a, c, B), a.child);
  }
  function ty(n, a, c, f, B, m) {
    return xn(a), a.updateQueue = null, c = Fn(
      a,
      f,
      c,
      B
    ), Yh(n), f = Du(), n !== null && !YI ? (Mu(n, a, m), Pt(n, a, m)) : (pI && f && Ur(a), a.flags |= 1, nC(n, a, c, m), a.child);
  }
  function iy(n, a, c, f, B) {
    if (xn(a), a.stateNode === null) {
      var m = Xs, j = c.contextType;
      typeof j == "object" && j !== null && (m = MC(j)), m = new c(f, m), a.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = Qn, a.stateNode = m, m._reactInternals = a, m = a.stateNode, m.props = f, m.state = a.memoizedState, m.refs = {}, $r(a), j = c.contextType, m.context = typeof j == "object" && j !== null ? MC(j) : Xs, m.state = a.memoizedState, j = c.getDerivedStateFromProps, typeof j == "function" && (Pu(
        a,
        c,
        j,
        f
      ), m.state = a.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (j = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), j !== m.state && Qn.enqueueReplaceState(m, m.state, null), la(a, f, m, B), Il(), m.state = a.memoizedState), typeof m.componentDidMount == "function" && (a.flags |= 4194308), f = !0;
    } else if (n === null) {
      m = a.stateNode;
      var O = a.memoizedProps, q = Ct(c, O);
      m.props = q;
      var ug = m.context, jg = c.contextType;
      j = Xs, typeof jg == "object" && jg !== null && (j = MC(jg));
      var Hg = c.getDerivedStateFromProps;
      jg = typeof Hg == "function" || typeof m.getSnapshotBeforeUpdate == "function", O = a.pendingProps !== O, jg || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (O || ug !== j) && wa(
        a,
        m,
        f,
        j
      ), zi = !1;
      var hg = a.memoizedState;
      m.state = hg, la(a, f, m, B), Il(), ug = a.memoizedState, O || hg !== ug || zi ? (typeof Hg == "function" && (Pu(
        a,
        c,
        Hg,
        f
      ), ug = a.memoizedState), (q = zi || qh(
        a,
        c,
        q,
        f,
        hg,
        ug,
        j
      )) ? (jg || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = f, a.memoizedState = ug), m.props = f, m.state = ug, m.context = j, f = q) : (typeof m.componentDidMount == "function" && (a.flags |= 4194308), f = !1);
    } else {
      m = a.stateNode, du(n, a), j = a.memoizedProps, jg = Ct(c, j), m.props = jg, Hg = a.pendingProps, hg = m.context, ug = c.contextType, q = Xs, typeof ug == "object" && ug !== null && (q = MC(ug)), O = c.getDerivedStateFromProps, (ug = typeof O == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (j !== Hg || hg !== q) && wa(
        a,
        m,
        f,
        q
      ), zi = !1, hg = a.memoizedState, m.state = hg, la(a, f, m, B), Il();
      var pg = a.memoizedState;
      j !== Hg || hg !== pg || zi || n !== null && n.dependencies !== null && zr(n.dependencies) ? (typeof O == "function" && (Pu(
        a,
        c,
        O,
        f
      ), pg = a.memoizedState), (jg = zi || qh(
        a,
        c,
        jg,
        f,
        hg,
        pg,
        q
      ) || n !== null && n.dependencies !== null && zr(n.dependencies)) ? (ug || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(f, pg, q), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(
        f,
        pg,
        q
      )), typeof m.componentDidUpdate == "function" && (a.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || j === n.memoizedProps && hg === n.memoizedState || (a.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || j === n.memoizedProps && hg === n.memoizedState || (a.flags |= 1024), a.memoizedProps = f, a.memoizedState = pg), m.props = f, m.state = pg, m.context = q, f = jg) : (typeof m.componentDidUpdate != "function" || j === n.memoizedProps && hg === n.memoizedState || (a.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || j === n.memoizedProps && hg === n.memoizedState || (a.flags |= 1024), f = !1);
    }
    return m = f, gn(n, a), f = (a.flags & 128) !== 0, m || f ? (m = a.stateNode, c = f && typeof c.getDerivedStateFromError != "function" ? null : m.render(), a.flags |= 1, n !== null && f ? (a.child = iC(
      a,
      n.child,
      null,
      B
    ), a.child = iC(
      a,
      null,
      c,
      B
    )) : nC(n, a, c, B), a.memoizedState = m.state, n = a.child) : n = Pt(
      n,
      a,
      B
    ), n;
  }
  function Hu(n, a, c, f) {
    return Aa(), a.flags |= 256, nC(n, a, c, f), a.child;
  }
  var yl = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Eu(n) {
    return { baseLanes: n, cachePool: Lr() };
  }
  function ny(n, a, c) {
    return n = n !== null ? n.childLanes & ~c : 0, a && (n |= $A), n;
  }
  function ow(n, a, c) {
    var f = a.pendingProps, B = !1, m = (a.flags & 128) !== 0, j;
    if ((j = m) || (j = n !== null && n.memoizedState === null ? !1 : (NA.current & 2) !== 0), j && (B = !0, a.flags &= -129), j = (a.flags & 32) !== 0, a.flags &= -33, n === null) {
      if (pI) {
        if (B ? ce(a) : EC(), pI) {
          var O = IA, q;
          if (q = O) {
            g: {
              for (q = O, O = QC; q.nodeType !== 8; ) {
                if (!O) {
                  O = null;
                  break g;
                }
                if (q = Rt(
                  q.nextSibling
                ), q === null) {
                  O = null;
                  break g;
                }
              }
              O = q;
            }
            O !== null ? (a.memoizedState = {
              dehydrated: O,
              treeContext: Ui !== null ? { id: Bt, overflow: pt } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, q = te(
              18,
              null,
              null,
              0
            ), q.stateNode = O, q.return = a, a.child = q, PA = a, IA = null, q = !0) : q = !1;
          }
          q || mt(a);
        }
        if (O = a.memoizedState, O !== null && (O = O.dehydrated, O !== null))
          return Ry(O) ? a.lanes = 32 : a.lanes = 536870912, null;
        Yt(a);
      }
      return O = f.children, f = f.fallback, B ? (EC(), B = a.mode, O = Dl(
        { mode: "hidden", children: O },
        B
      ), f = Og(
        f,
        B,
        c,
        null
      ), O.return = a, f.return = a, O.sibling = f, a.child = O, B = a.child, B.memoizedState = Eu(c), B.childLanes = ny(
        n,
        j,
        c
      ), a.memoizedState = yl, f) : (ce(a), Ru(a, O));
    }
    if (q = n.memoizedState, q !== null && (O = q.dehydrated, O !== null)) {
      if (m)
        a.flags & 256 ? (ce(a), a.flags &= -257, a = sy(
          n,
          a,
          c
        )) : a.memoizedState !== null ? (EC(), a.child = n.child, a.flags |= 128, a = null) : (EC(), B = f.fallback, O = a.mode, f = Dl(
          { mode: "visible", children: f.children },
          O
        ), B = Og(
          B,
          O,
          c,
          null
        ), B.flags |= 2, f.return = a, B.return = a, f.sibling = B, a.child = f, iC(
          a,
          n.child,
          null,
          c
        ), f = a.child, f.memoizedState = Eu(c), f.childLanes = ny(
          n,
          j,
          c
        ), a.memoizedState = yl, a = B);
      else if (ce(a), Ry(O)) {
        if (j = O.nextSibling && O.nextSibling.dataset, j) var ug = j.dgst;
        j = ug, f = Error(t(419)), f.stack = "", f.digest = j, Ca({ value: f, source: null, stack: null }), a = sy(
          n,
          a,
          c
        );
      } else if (YI || Qr(n, a, c, !1), j = (c & n.childLanes) !== 0, YI || j) {
        if (j = CA, j !== null && (f = c & -c, f = (f & 42) !== 0 ? 1 : cI(f), f = (f & (j.suspendedLanes | c)) !== 0 ? 0 : f, f !== 0 && f !== q.retryLane))
          throw q.retryLane = f, _i(n, f), ye(j, n, f), Cy;
        O.data === "$?" || ts(), a = sy(
          n,
          a,
          c
        );
      } else
        O.data === "$?" ? (a.flags |= 192, a.child = n.child, a = null) : (n = q.treeContext, IA = Rt(
          O.nextSibling
        ), PA = a, pI = !0, Fi = null, QC = !1, n !== null && (ie[$e++] = Bt, ie[$e++] = pt, ie[$e++] = Ui, Bt = n.id, pt = n.overflow, Ui = a), a = Ru(
          a,
          f.children
        ), a.flags |= 4096);
      return a;
    }
    return B ? (EC(), B = f.fallback, O = a.mode, q = n.child, ug = q.sibling, f = wt(q, {
      mode: "hidden",
      children: f.children
    }), f.subtreeFlags = q.subtreeFlags & 65011712, ug !== null ? B = wt(ug, B) : (B = Og(
      B,
      O,
      c,
      null
    ), B.flags |= 2), B.return = a, f.return = a, f.sibling = B, a.child = f, f = B, B = a.child, O = n.child.memoizedState, O === null ? O = Eu(c) : (q = O.cachePool, q !== null ? (ug = _A._currentValue, q = q.parent !== ug ? { parent: ug, pool: ug } : q) : q = Lr(), O = {
      baseLanes: O.baseLanes | c,
      cachePool: q
    }), B.memoizedState = O, B.childLanes = ny(
      n,
      j,
      c
    ), a.memoizedState = yl, f) : (ce(a), c = n.child, n = c.sibling, c = wt(c, {
      mode: "visible",
      children: f.children
    }), c.return = a, c.sibling = null, n !== null && (j = a.deletions, j === null ? (a.deletions = [n], a.flags |= 16) : j.push(n)), a.child = c, a.memoizedState = null, c);
  }
  function Ru(n, a) {
    return a = Dl(
      { mode: "visible", children: a },
      n.mode
    ), a.return = n, n.child = a;
  }
  function Dl(n, a) {
    return n = te(22, n, null, a), n.lanes = 0, n.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, n;
  }
  function sy(n, a, c) {
    return iC(a, n.child, null, c), n = Ru(
      a,
      a.pendingProps.children
    ), n.flags |= 2, a.memoizedState = null, n;
  }
  function to(n, a, c) {
    n.lanes |= a;
    var f = n.alternate;
    f !== null && (f.lanes |= a), au(n.return, a, c);
  }
  function pa(n, a, c, f, B) {
    var m = n.memoizedState;
    m === null ? n.memoizedState = {
      isBackwards: a,
      rendering: null,
      renderingStartTime: 0,
      last: f,
      tail: c,
      tailMode: B
    } : (m.isBackwards = a, m.rendering = null, m.renderingStartTime = 0, m.last = f, m.tail = c, m.tailMode = B);
  }
  function oy(n, a, c) {
    var f = a.pendingProps, B = f.revealOrder, m = f.tail;
    if (nC(n, a, f.children, c), f = NA.current, (f & 2) !== 0)
      f = f & 1 | 2, a.flags |= 128;
    else {
      if (n !== null && (n.flags & 128) !== 0)
        g: for (n = a.child; n !== null; ) {
          if (n.tag === 13)
            n.memoizedState !== null && to(n, c, a);
          else if (n.tag === 19)
            to(n, c, a);
          else if (n.child !== null) {
            n.child.return = n, n = n.child;
            continue;
          }
          if (n === a) break g;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === a)
              break g;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
      f &= 1;
    }
    switch (Cg(NA, f), B) {
      case "forwards":
        for (c = a.child, B = null; c !== null; )
          n = c.alternate, n !== null && ve(n) === null && (B = c), c = c.sibling;
        c = B, c === null ? (B = a.child, a.child = null) : (B = c.sibling, c.sibling = null), pa(
          a,
          !1,
          B,
          c,
          m
        );
        break;
      case "backwards":
        for (c = null, B = a.child, a.child = null; B !== null; ) {
          if (n = B.alternate, n !== null && ve(n) === null) {
            a.child = B;
            break;
          }
          n = B.sibling, B.sibling = c, c = B, B = n;
        }
        pa(
          a,
          !0,
          c,
          null,
          m
        );
        break;
      case "together":
        pa(a, !1, null, null, void 0);
        break;
      default:
        a.memoizedState = null;
    }
    return a.child;
  }
  function Pt(n, a, c) {
    if (n !== null && (a.dependencies = n.dependencies), Is |= a.lanes, (c & a.childLanes) === 0)
      if (n !== null) {
        if (Qr(
          n,
          a,
          c,
          !1
        ), (c & a.childLanes) === 0)
          return null;
      } else return null;
    if (n !== null && a.child !== n.child)
      throw Error(t(153));
    if (a.child !== null) {
      for (n = a.child, c = wt(n, n.pendingProps), a.child = c, c.return = a; n.sibling !== null; )
        n = n.sibling, c = c.sibling = wt(n, n.pendingProps), c.return = a;
      c.sibling = null;
    }
    return a.child;
  }
  function Ou(n, a) {
    return (n.lanes & a) !== 0 ? !0 : (n = n.dependencies, !!(n !== null && zr(n)));
  }
  function aw(n, a, c) {
    switch (a.tag) {
      case 3:
        Xg(a, a.stateNode.containerInfo), ti(a, _A, n.memoizedState.cache), Aa();
        break;
      case 27:
      case 5:
        sI(a);
        break;
      case 4:
        Xg(a, a.stateNode.containerInfo);
        break;
      case 10:
        ti(
          a,
          a.type,
          a.memoizedProps.value
        );
        break;
      case 13:
        var f = a.memoizedState;
        if (f !== null)
          return f.dehydrated !== null ? (ce(a), a.flags |= 128, null) : (c & a.child.childLanes) !== 0 ? ow(n, a, c) : (ce(a), n = Pt(
            n,
            a,
            c
          ), n !== null ? n.sibling : null);
        ce(a);
        break;
      case 19:
        var B = (n.flags & 128) !== 0;
        if (f = (c & a.childLanes) !== 0, f || (Qr(
          n,
          a,
          c,
          !1
        ), f = (c & a.childLanes) !== 0), B) {
          if (f)
            return oy(
              n,
              a,
              c
            );
          a.flags |= 128;
        }
        if (B = a.memoizedState, B !== null && (B.rendering = null, B.tail = null, B.lastEffect = null), Cg(NA, NA.current), f) break;
        return null;
      case 22:
      case 23:
        return a.lanes = 0, eo(n, a, c);
      case 24:
        ti(a, _A, n.memoizedState.cache);
    }
    return Pt(n, a, c);
  }
  function ay(n, a, c) {
    if (n !== null)
      if (n.memoizedProps !== a.pendingProps)
        YI = !0;
      else {
        if (!Ou(n, c) && (a.flags & 128) === 0)
          return YI = !1, aw(
            n,
            a,
            c
          );
        YI = (n.flags & 131072) !== 0;
      }
    else
      YI = !1, pI && (a.flags & 1048576) !== 0 && JI(a, _r, a.index);
    switch (a.lanes = 0, a.tag) {
      case 16:
        g: {
          n = a.pendingProps;
          var f = a.elementType, B = f._init;
          if (f = B(f._payload), a.type = f, typeof f == "function")
            iu(f) ? (n = Ct(f, n), a.tag = 1, a = iy(
              null,
              a,
              f,
              n,
              c
            )) : (a.tag = 0, a = vu(
              null,
              a,
              f,
              n,
              c
            ));
          else {
            if (f != null) {
              if (B = f.$$typeof, B === x) {
                a.tag = 11, a = ey(
                  null,
                  a,
                  f,
                  n,
                  c
                );
                break g;
              } else if (B === L) {
                a.tag = 14, a = sw(
                  null,
                  a,
                  f,
                  n,
                  c
                );
                break g;
              }
            }
            throw a = Ng(f) || f, Error(t(306, a, ""));
          }
        }
        return a;
      case 0:
        return vu(
          n,
          a,
          a.type,
          a.pendingProps,
          c
        );
      case 1:
        return f = a.type, B = Ct(
          f,
          a.pendingProps
        ), iy(
          n,
          a,
          f,
          B,
          c
        );
      case 3:
        g: {
          if (Xg(
            a,
            a.stateNode.containerInfo
          ), n === null) throw Error(t(387));
          f = a.pendingProps;
          var m = a.memoizedState;
          B = m.element, du(n, a), la(a, f, null, c);
          var j = a.memoizedState;
          if (f = j.cache, ti(a, _A, f), f !== m.cache && ru(
            a,
            [_A],
            c,
            !0
          ), Il(), f = j.element, m.isDehydrated)
            if (m = {
              element: f,
              isDehydrated: !1,
              cache: j.cache
            }, a.updateQueue.baseState = m, a.memoizedState = m, a.flags & 256) {
              a = Hu(
                n,
                a,
                f,
                c
              );
              break g;
            } else if (f !== B) {
              B = Ze(
                Error(t(424)),
                a
              ), Ca(B), a = Hu(
                n,
                a,
                f,
                c
              );
              break g;
            } else {
              switch (n = a.stateNode.containerInfo, n.nodeType) {
                case 9:
                  n = n.body;
                  break;
                default:
                  n = n.nodeName === "HTML" ? n.ownerDocument.body : n;
              }
              for (IA = Rt(n.firstChild), PA = a, pI = !0, Fi = null, QC = !0, c = Jh(
                a,
                null,
                f,
                c
              ), a.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
          else {
            if (Aa(), f === B) {
              a = Pt(
                n,
                a,
                c
              );
              break g;
            }
            nC(
              n,
              a,
              f,
              c
            );
          }
          a = a.child;
        }
        return a;
      case 26:
        return gn(n, a), n === null ? (c = ld(
          a.type,
          null,
          a.pendingProps,
          null
        )) ? a.memoizedState = c : pI || (c = a.type, n = a.pendingProps, f = Oa(
          Yg.current
        ).createElement(c), f[sA] = a, f[jC] = n, Dg(f, c, n), OA(f), a.stateNode = f) : a.memoizedState = ld(
          a.type,
          n.memoizedProps,
          a.pendingProps,
          n.memoizedState
        ), null;
      case 27:
        return sI(a), n === null && pI && (f = a.stateNode = pC(
          a.type,
          a.pendingProps,
          Yg.current
        ), PA = a, QC = !0, B = IA, BC(a.type) ? (Ny = B, IA = Rt(
          f.firstChild
        )) : IA = B), nC(
          n,
          a,
          a.pendingProps.children,
          c
        ), gn(n, a), n === null && (a.flags |= 4194304), a.child;
      case 5:
        return n === null && pI && ((B = f = IA) && (f = Ey(
          f,
          a.type,
          a.pendingProps,
          QC
        ), f !== null ? (a.stateNode = f, PA = a, IA = Rt(
          f.firstChild
        ), QC = !1, B = !0) : B = !1), B || mt(a)), sI(a), B = a.type, m = a.pendingProps, j = n !== null ? n.memoizedProps : null, f = m.children, lo(B, m) ? f = null : j !== null && lo(B, j) && (a.flags |= 32), a.memoizedState !== null && (B = yu(
          n,
          a,
          qM,
          null,
          null,
          c
        ), mC._currentValue = B), gn(n, a), nC(n, a, f, c), a.child;
      case 6:
        return n === null && pI && ((n = c = IA) && (c = Na(
          c,
          a.pendingProps,
          QC
        ), c !== null ? (a.stateNode = c, PA = a, IA = null, n = !0) : n = !1), n || mt(a)), null;
      case 13:
        return ow(n, a, c);
      case 4:
        return Xg(
          a,
          a.stateNode.containerInfo
        ), f = a.pendingProps, n === null ? a.child = iC(
          a,
          null,
          f,
          c
        ) : nC(
          n,
          a,
          f,
          c
        ), a.child;
      case 11:
        return ey(
          n,
          a,
          a.type,
          a.pendingProps,
          c
        );
      case 7:
        return nC(
          n,
          a,
          a.pendingProps,
          c
        ), a.child;
      case 8:
        return nC(
          n,
          a,
          a.pendingProps.children,
          c
        ), a.child;
      case 12:
        return nC(
          n,
          a,
          a.pendingProps.children,
          c
        ), a.child;
      case 10:
        return f = a.pendingProps, ti(a, a.type, f.value), nC(
          n,
          a,
          f.children,
          c
        ), a.child;
      case 9:
        return B = a.type._context, f = a.pendingProps.children, xn(a), B = MC(B), f = f(B), a.flags |= 1, nC(n, a, f, c), a.child;
      case 14:
        return sw(
          n,
          a,
          a.type,
          a.pendingProps,
          c
        );
      case 15:
        return $i(
          n,
          a,
          a.type,
          a.pendingProps,
          c
        );
      case 19:
        return oy(n, a, c);
      case 31:
        return f = a.pendingProps, c = a.mode, f = {
          mode: f.mode,
          children: f.children
        }, n === null ? (c = Dl(
          f,
          c
        ), c.ref = a.ref, a.child = c, c.return = a, a = c) : (c = wt(n.child, f), c.ref = a.ref, a.child = c, c.return = a, a = c), a;
      case 22:
        return eo(n, a, c);
      case 24:
        return xn(a), f = MC(_A), n === null ? (B = na(), B === null && (B = CA, m = Bh(), B.pooledCache = m, m.refCount++, m !== null && (B.pooledCacheLanes |= c), B = m), a.memoizedState = {
          parent: f,
          cache: B
        }, $r(a), ti(a, _A, B)) : ((n.lanes & c) !== 0 && (du(n, a), la(a, null, null, c), Il()), B = n.memoizedState, m = a.memoizedState, B.parent !== f ? (B = { parent: f, cache: f }, a.memoizedState = B, a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = B), ti(a, _A, f)) : (f = m.cache, ti(a, _A, f), f !== B.cache && ru(
          a,
          [_A],
          c,
          !0
        ))), nC(
          n,
          a,
          a.pendingProps.children,
          c
        ), a.child;
      case 29:
        throw a.pendingProps;
    }
    throw Error(t(156, a.tag));
  }
  function In(n) {
    n.flags |= 4;
  }
  function ry(n, a) {
    if (a.type !== "stylesheet" || (a.state.loading & 4) !== 0)
      n.flags &= -16777217;
    else if (n.flags |= 16777216, !xy(a)) {
      if (a = UA.current, a !== null && ((WI & 4194048) === WI ? Tt !== null : (WI & 62914560) !== WI && (WI & 536870912) === 0 || a !== Tt))
        throw ra = cu, qr;
      n.flags |= 8192;
    }
  }
  function zn(n, a) {
    a !== null && (n.flags |= 4), n.flags & 16384 && (a = n.tag !== 22 ? Vg() : 536870912, n.lanes |= a, Ta |= a);
  }
  function ma(n, a) {
    if (!pI)
      switch (n.tailMode) {
        case "hidden":
          a = n.tail;
          for (var c = null; a !== null; )
            a.alternate !== null && (c = a), a = a.sibling;
          c === null ? n.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = n.tail;
          for (var f = null; c !== null; )
            c.alternate !== null && (f = c), c = c.sibling;
          f === null ? a || n.tail === null ? n.tail = null : n.tail.sibling = null : f.sibling = null;
      }
  }
  function mA(n) {
    var a = n.alternate !== null && n.alternate.child === n.child, c = 0, f = 0;
    if (a)
      for (var B = n.child; B !== null; )
        c |= B.lanes | B.childLanes, f |= B.subtreeFlags & 65011712, f |= B.flags & 65011712, B.return = n, B = B.sibling;
    else
      for (B = n.child; B !== null; )
        c |= B.lanes | B.childLanes, f |= B.subtreeFlags, f |= B.flags, B.return = n, B = B.sibling;
    return n.subtreeFlags |= f, n.childLanes = c, a;
  }
  function AA(n, a, c) {
    var f = a.pendingProps;
    switch (Qs(a), a.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return mA(a), null;
      case 1:
        return mA(a), null;
      case 3:
        return c = a.stateNode, f = null, n !== null && (f = n.memoizedState.cache), a.memoizedState.cache !== f && (a.flags |= 2048), ii(_A), nI(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (n === null || n.child === null) && (Ia(a) ? In(a) : n === null || n.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, Mh())), mA(a), null;
      case 26:
        return c = a.memoizedState, n === null ? (In(a), c !== null ? (mA(a), ry(a, c)) : (mA(a), a.flags &= -16777217)) : c ? c !== n.memoizedState ? (In(a), mA(a), ry(a, c)) : (mA(a), a.flags &= -16777217) : (n.memoizedProps !== f && In(a), mA(a), a.flags &= -16777217), null;
      case 27:
        Ug(a), c = Yg.current;
        var B = a.type;
        if (n !== null && a.stateNode != null)
          n.memoizedProps !== f && In(a);
        else {
          if (!f) {
            if (a.stateNode === null)
              throw Error(t(166));
            return mA(a), null;
          }
          n = Sg.current, Ia(a) ? su(a) : (n = pC(B, f, c), a.stateNode = n, In(a));
        }
        return mA(a), null;
      case 5:
        if (Ug(a), c = a.type, n !== null && a.stateNode != null)
          n.memoizedProps !== f && In(a);
        else {
          if (!f) {
            if (a.stateNode === null)
              throw Error(t(166));
            return mA(a), null;
          }
          if (n = Sg.current, Ia(a))
            su(a);
          else {
            switch (B = Oa(
              Yg.current
            ), n) {
              case 1:
                n = B.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                n = B.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    n = B.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    n = B.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    n = B.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild);
                    break;
                  case "select":
                    n = typeof f.is == "string" ? B.createElement("select", { is: f.is }) : B.createElement("select"), f.multiple ? n.multiple = !0 : f.size && (n.size = f.size);
                    break;
                  default:
                    n = typeof f.is == "string" ? B.createElement(c, { is: f.is }) : B.createElement(c);
                }
            }
            n[sA] = a, n[jC] = f;
            g: for (B = a.child; B !== null; ) {
              if (B.tag === 5 || B.tag === 6)
                n.appendChild(B.stateNode);
              else if (B.tag !== 4 && B.tag !== 27 && B.child !== null) {
                B.child.return = B, B = B.child;
                continue;
              }
              if (B === a) break g;
              for (; B.sibling === null; ) {
                if (B.return === null || B.return === a)
                  break g;
                B = B.return;
              }
              B.sibling.return = B.return, B = B.sibling;
            }
            a.stateNode = n;
            g: switch (Dg(n, c, f), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n = !!f.autoFocus;
                break g;
              case "img":
                n = !0;
                break g;
              default:
                n = !1;
            }
            n && In(a);
          }
        }
        return mA(a), a.flags &= -16777217, null;
      case 6:
        if (n && a.stateNode != null)
          n.memoizedProps !== f && In(a);
        else {
          if (typeof f != "string" && a.stateNode === null)
            throw Error(t(166));
          if (n = Yg.current, Ia(a)) {
            if (n = a.stateNode, c = a.memoizedProps, f = null, B = PA, B !== null)
              switch (B.tag) {
                case 27:
                case 5:
                  f = B.memoizedProps;
              }
            n[sA] = a, n = !!(n.nodeValue === c || f !== null && f.suppressHydrationWarning === !0 || Yw(n.nodeValue, c)), n || mt(a);
          } else
            n = Oa(n).createTextNode(
              f
            ), n[sA] = a, a.stateNode = n;
        }
        return mA(a), null;
      case 13:
        if (f = a.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
          if (B = Ia(a), f !== null && f.dehydrated !== null) {
            if (n === null) {
              if (!B) throw Error(t(318));
              if (B = a.memoizedState, B = B !== null ? B.dehydrated : null, !B) throw Error(t(317));
              B[sA] = a;
            } else
              Aa(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
            mA(a), B = !1;
          } else
            B = Mh(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = B), B = !0;
          if (!B)
            return a.flags & 256 ? (Yt(a), a) : (Yt(a), null);
        }
        if (Yt(a), (a.flags & 128) !== 0)
          return a.lanes = c, a;
        if (c = f !== null, n = n !== null && n.memoizedState !== null, c) {
          f = a.child, B = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (B = f.alternate.memoizedState.cachePool.pool);
          var m = null;
          f.memoizedState !== null && f.memoizedState.cachePool !== null && (m = f.memoizedState.cachePool.pool), m !== B && (f.flags |= 2048);
        }
        return c !== n && c && (a.child.flags |= 8192), zn(a, a.updateQueue), mA(a), null;
      case 4:
        return nI(), n === null && Tl(a.stateNode.containerInfo), mA(a), null;
      case 10:
        return ii(a.type), mA(a), null;
      case 19:
        if (rg(NA), B = a.memoizedState, B === null) return mA(a), null;
        if (f = (a.flags & 128) !== 0, m = B.rendering, m === null)
          if (f) ma(B, !1);
          else {
            if (vA !== 0 || n !== null && (n.flags & 128) !== 0)
              for (n = a.child; n !== null; ) {
                if (m = ve(n), m !== null) {
                  for (a.flags |= 128, ma(B, !1), n = m.updateQueue, a.updateQueue = n, zn(a, n), a.subtreeFlags = 0, n = c, c = a.child; c !== null; )
                    nu(c, n), c = c.sibling;
                  return Cg(
                    NA,
                    NA.current & 1 | 2
                  ), a.child;
                }
                n = n.sibling;
              }
            B.tail !== null && vI() > xu && (a.flags |= 128, f = !0, ma(B, !1), a.lanes = 4194304);
          }
        else {
          if (!f)
            if (n = ve(m), n !== null) {
              if (a.flags |= 128, f = !0, n = n.updateQueue, a.updateQueue = n, zn(a, n), ma(B, !0), B.tail === null && B.tailMode === "hidden" && !m.alternate && !pI)
                return mA(a), null;
            } else
              2 * vI() - B.renderingStartTime > xu && c !== 536870912 && (a.flags |= 128, f = !0, ma(B, !1), a.lanes = 4194304);
          B.isBackwards ? (m.sibling = a.child, a.child = m) : (n = B.last, n !== null ? n.sibling = m : a.child = m, B.last = m);
        }
        return B.tail !== null ? (a = B.tail, B.rendering = a, B.tail = a.sibling, B.renderingStartTime = vI(), a.sibling = null, n = NA.current, Cg(NA, f ? n & 1 | 2 : n & 1), a) : (mA(a), null);
      case 22:
      case 23:
        return Yt(a), ua(), f = a.memoizedState !== null, n !== null ? n.memoizedState !== null !== f && (a.flags |= 8192) : f && (a.flags |= 8192), f ? (c & 536870912) !== 0 && (a.flags & 128) === 0 && (mA(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : mA(a), c = a.updateQueue, c !== null && zn(a, c.retryQueue), c = null, n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), f = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool), f !== c && (a.flags |= 2048), n !== null && rg(Qi), null;
      case 24:
        return c = null, n !== null && (c = n.memoizedState.cache), a.memoizedState.cache !== c && (a.flags |= 2048), ii(_A), mA(a), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(t(156, a.tag));
  }
  function ly(n, a) {
    switch (Qs(a), a.tag) {
      case 1:
        return n = a.flags, n & 65536 ? (a.flags = n & -65537 | 128, a) : null;
      case 3:
        return ii(_A), nI(), n = a.flags, (n & 65536) !== 0 && (n & 128) === 0 ? (a.flags = n & -65537 | 128, a) : null;
      case 26:
      case 27:
      case 5:
        return Ug(a), null;
      case 13:
        if (Yt(a), n = a.memoizedState, n !== null && n.dehydrated !== null) {
          if (a.alternate === null)
            throw Error(t(340));
          Aa();
        }
        return n = a.flags, n & 65536 ? (a.flags = n & -65537 | 128, a) : null;
      case 19:
        return rg(NA), null;
      case 4:
        return nI(), null;
      case 10:
        return ii(a.type), null;
      case 22:
      case 23:
        return Yt(a), ua(), n !== null && rg(Qi), n = a.flags, n & 65536 ? (a.flags = n & -65537 | 128, a) : null;
      case 24:
        return ii(_A), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function rw(n, a) {
    switch (Qs(a), a.tag) {
      case 3:
        ii(_A), nI();
        break;
      case 26:
      case 27:
      case 5:
        Ug(a);
        break;
      case 4:
        nI();
        break;
      case 13:
        Yt(a);
        break;
      case 19:
        rg(NA);
        break;
      case 10:
        ii(a.type);
        break;
      case 22:
      case 23:
        Yt(a), ua(), n !== null && rg(Qi);
        break;
      case 24:
        ii(_A);
    }
  }
  function ba(n, a) {
    try {
      var c = a.updateQueue, f = c !== null ? c.lastEffect : null;
      if (f !== null) {
        var B = f.next;
        c = B;
        do {
          if ((c.tag & n) === n) {
            f = void 0;
            var m = c.create, j = c.inst;
            f = m(), j.destroy = f;
          }
          c = c.next;
        } while (c !== B);
      }
    } catch (O) {
      eA(a, a.return, O);
    }
  }
  function Jn(n, a, c) {
    try {
      var f = a.updateQueue, B = f !== null ? f.lastEffect : null;
      if (B !== null) {
        var m = B.next;
        f = m;
        do {
          if ((f.tag & n) === n) {
            var j = f.inst, O = j.destroy;
            if (O !== void 0) {
              j.destroy = void 0, B = a;
              var q = c, ug = O;
              try {
                ug();
              } catch (jg) {
                eA(
                  B,
                  q,
                  jg
                );
              }
            }
          }
          f = f.next;
        } while (f !== m);
      }
    } catch (jg) {
      eA(a, a.return, jg);
    }
  }
  function lw(n) {
    var a = n.updateQueue;
    if (a !== null) {
      var c = n.stateNode;
      try {
        fu(a, c);
      } catch (f) {
        eA(n, n.return, f);
      }
    }
  }
  function Nu(n, a, c) {
    c.props = Ct(
      n.type,
      n.memoizedProps
    ), c.state = n.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (f) {
      eA(n, a, f);
    }
  }
  function Sa(n, a) {
    try {
      var c = n.ref;
      if (c !== null) {
        switch (n.tag) {
          case 26:
          case 27:
          case 5:
            var f = n.stateNode;
            break;
          case 30:
            f = n.stateNode;
            break;
          default:
            f = n.stateNode;
        }
        typeof c == "function" ? n.refCleanup = c(f) : c.current = f;
      }
    } catch (B) {
      eA(n, a, B);
    }
  }
  function Zt(n, a) {
    var c = n.ref, f = n.refCleanup;
    if (c !== null)
      if (typeof f == "function")
        try {
          f();
        } catch (B) {
          eA(n, a, B);
        } finally {
          n.refCleanup = null, n = n.alternate, n != null && (n.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (B) {
          eA(n, a, B);
        }
      else c.current = null;
  }
  function cy(n) {
    var a = n.type, c = n.memoizedProps, f = n.stateNode;
    try {
      g: switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && f.focus();
          break g;
        case "img":
          c.src ? f.src = c.src : c.srcSet && (f.srcset = c.srcSet);
      }
    } catch (B) {
      eA(n, n.return, B);
    }
  }
  function io(n, a, c) {
    try {
      var f = n.stateNode;
      QI(f, n.type, c, a), f[jC] = a;
    } catch (B) {
      eA(n, n.return, B);
    }
  }
  function cw(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && BC(n.type) || n.tag === 4;
  }
  function uy(n) {
    g: for (; ; ) {
      for (; n.sibling === null; ) {
        if (n.return === null || cw(n.return)) return null;
        n = n.return;
      }
      for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
        if (n.tag === 27 && BC(n.type) || n.flags & 2 || n.child === null || n.tag === 4) continue g;
        n.child.return = n, n = n.child;
      }
      if (!(n.flags & 2)) return n.stateNode;
    }
  }
  function et(n, a, c) {
    var f = n.tag;
    if (f === 5 || f === 6)
      n = n.stateNode, a ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(n, a) : (a = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, a.appendChild(n), c = c._reactRootContainer, c != null || a.onclick !== null || (a.onclick = Pl));
    else if (f !== 4 && (f === 27 && BC(n.type) && (c = n.stateNode, a = null), n = n.child, n !== null))
      for (et(n, a, c), n = n.sibling; n !== null; )
        et(n, a, c), n = n.sibling;
  }
  function Ln(n, a, c) {
    var f = n.tag;
    if (f === 5 || f === 6)
      n = n.stateNode, a ? c.insertBefore(n, a) : c.appendChild(n);
    else if (f !== 4 && (f === 27 && BC(n.type) && (c = n.stateNode), n = n.child, n !== null))
      for (Ln(n, a, c), n = n.sibling; n !== null; )
        Ln(n, a, c), n = n.sibling;
  }
  function uw(n) {
    var a = n.stateNode, c = n.memoizedProps;
    try {
      for (var f = n.type, B = a.attributes; B.length; )
        a.removeAttributeNode(B[0]);
      Dg(a, f, c), a[sA] = n, a[jC] = c;
    } catch (m) {
      eA(n, n.return, m);
    }
  }
  var jt = !1, jA = !1, ku = !1, dy = typeof WeakSet == "function" ? WeakSet : Set, FA = null;
  function dw(n, a) {
    if (n = n.containerInfo, vy = Nl, n = Wr(n), Au(n)) {
      if ("selectionStart" in n)
        var c = {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      else
        g: {
          c = (c = n.ownerDocument) && c.defaultView || window;
          var f = c.getSelection && c.getSelection();
          if (f && f.rangeCount !== 0) {
            c = f.anchorNode;
            var B = f.anchorOffset, m = f.focusNode;
            f = f.focusOffset;
            try {
              c.nodeType, m.nodeType;
            } catch {
              c = null;
              break g;
            }
            var j = 0, O = -1, q = -1, ug = 0, jg = 0, Hg = n, hg = null;
            I: for (; ; ) {
              for (var pg; Hg !== c || B !== 0 && Hg.nodeType !== 3 || (O = j + B), Hg !== m || f !== 0 && Hg.nodeType !== 3 || (q = j + f), Hg.nodeType === 3 && (j += Hg.nodeValue.length), (pg = Hg.firstChild) !== null; )
                hg = Hg, Hg = pg;
              for (; ; ) {
                if (Hg === n) break I;
                if (hg === c && ++ug === B && (O = j), hg === m && ++jg === f && (q = j), (pg = Hg.nextSibling) !== null) break;
                Hg = hg, hg = Hg.parentNode;
              }
              Hg = pg;
            }
            c = O === -1 || q === -1 ? null : { start: O, end: q };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (Zl = { focusedElem: n, selectionRange: c }, Nl = !1, FA = a; FA !== null; )
      if (a = FA, n = a.child, (a.subtreeFlags & 1024) !== 0 && n !== null)
        n.return = a, FA = n;
      else
        for (; FA !== null; ) {
          switch (a = FA, m = a.alternate, n = a.flags, a.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((n & 1024) !== 0 && m !== null) {
                n = void 0, c = a, B = m.memoizedProps, m = m.memoizedState, f = c.stateNode;
                try {
                  var tI = Ct(
                    c.type,
                    B,
                    c.elementType === c.type
                  );
                  n = f.getSnapshotBeforeUpdate(
                    tI,
                    m
                  ), f.__reactInternalSnapshotBeforeUpdate = n;
                } catch (eI) {
                  eA(
                    c,
                    c.return,
                    eI
                  );
                }
              }
              break;
            case 3:
              if ((n & 1024) !== 0) {
                if (n = a.stateNode.containerInfo, c = n.nodeType, c === 9)
                  jl(n);
                else if (c === 1)
                  switch (n.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      jl(n);
                      break;
                    default:
                      n.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((n & 1024) !== 0) throw Error(t(163));
          }
          if (n = a.sibling, n !== null) {
            n.return = a.return, FA = n;
            break;
          }
          FA = a.return;
        }
  }
  function Wu(n, a, c) {
    var f = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        An(n, c), f & 4 && ba(5, c);
        break;
      case 1:
        if (An(n, c), f & 4)
          if (n = c.stateNode, a === null)
            try {
              n.componentDidMount();
            } catch (j) {
              eA(c, c.return, j);
            }
          else {
            var B = Ct(
              c.type,
              a.memoizedProps
            );
            a = a.memoizedState;
            try {
              n.componentDidUpdate(
                B,
                a,
                n.__reactInternalSnapshotBeforeUpdate
              );
            } catch (j) {
              eA(
                c,
                c.return,
                j
              );
            }
          }
        f & 64 && lw(c), f & 512 && Sa(c, c.return);
        break;
      case 3:
        if (An(n, c), f & 64 && (n = c.updateQueue, n !== null)) {
          if (a = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                a = c.child.stateNode;
                break;
              case 1:
                a = c.child.stateNode;
            }
          try {
            fu(n, a);
          } catch (j) {
            eA(c, c.return, j);
          }
        }
        break;
      case 27:
        a === null && f & 4 && uw(c);
      case 26:
      case 5:
        An(n, c), a === null && f & 4 && cy(c), f & 512 && Sa(c, c.return);
        break;
      case 12:
        An(n, c);
        break;
      case 13:
        An(n, c), f & 4 && PI(n, c), f & 64 && (n = c.memoizedState, n !== null && (n = n.dehydrated, n !== null && (c = Gw.bind(
          null,
          c
        ), Oy(n, c))));
        break;
      case 22:
        if (f = c.memoizedState !== null || jt, !f) {
          a = a !== null && a.memoizedState !== null || jA, B = jt;
          var m = jA;
          jt = f, (jA = a) && !m ? DA(
            n,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : An(n, c), jt = B, jA = m;
        }
        break;
      case 30:
        break;
      default:
        An(n, c);
    }
  }
  function fy(n) {
    var a = n.alternate;
    a !== null && (n.alternate = null, fy(a)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (a = n.stateNode, a !== null && gI(a)), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
  }
  var yA = null, ue = !1;
  function tt(n, a, c) {
    for (c = c.child; c !== null; )
      hy(n, a, c), c = c.sibling;
  }
  function hy(n, a, c) {
    if (eC && typeof eC.onCommitFiberUnmount == "function")
      try {
        eC.onCommitFiberUnmount(Qe, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        jA || Zt(c, a), tt(
          n,
          a,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        jA || Zt(c, a);
        var f = yA, B = ue;
        BC(c.type) && (yA = c.stateNode, ue = !1), tt(
          n,
          a,
          c
        ), Qg(c.stateNode), yA = f, ue = B;
        break;
      case 5:
        jA || Zt(c, a);
      case 6:
        if (f = yA, B = ue, yA = null, tt(
          n,
          a,
          c
        ), yA = f, ue = B, yA !== null)
          if (ue)
            try {
              (yA.nodeType === 9 ? yA.body : yA.nodeName === "HTML" ? yA.ownerDocument.body : yA).removeChild(c.stateNode);
            } catch (m) {
              eA(
                c,
                a,
                m
              );
            }
          else
            try {
              yA.removeChild(c.stateNode);
            } catch (m) {
              eA(
                c,
                a,
                m
              );
            }
        break;
      case 18:
        yA !== null && (ue ? (n = yA, Zw(
          n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n,
          c.stateNode
        ), Ua(n)) : Zw(yA, c.stateNode));
        break;
      case 4:
        f = yA, B = ue, yA = c.stateNode.containerInfo, ue = !0, tt(
          n,
          a,
          c
        ), yA = f, ue = B;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        jA || Jn(2, c, a), jA || Jn(4, c, a), tt(
          n,
          a,
          c
        );
        break;
      case 1:
        jA || (Zt(c, a), f = c.stateNode, typeof f.componentWillUnmount == "function" && Nu(
          c,
          a,
          f
        )), tt(
          n,
          a,
          c
        );
        break;
      case 21:
        tt(
          n,
          a,
          c
        );
        break;
      case 22:
        jA = (f = jA) || c.memoizedState !== null, tt(
          n,
          a,
          c
        ), jA = f;
        break;
      default:
        tt(
          n,
          a,
          c
        );
    }
  }
  function PI(n, a) {
    if (a.memoizedState === null && (n = a.alternate, n !== null && (n = n.memoizedState, n !== null && (n = n.dehydrated, n !== null))))
      try {
        Ua(n);
      } catch (c) {
        eA(a, a.return, c);
      }
  }
  function yy(n) {
    switch (n.tag) {
      case 13:
      case 19:
        var a = n.stateNode;
        return a === null && (a = n.stateNode = new dy()), a;
      case 22:
        return n = n.stateNode, a = n._retryCache, a === null && (a = n._retryCache = new dy()), a;
      default:
        throw Error(t(435, n.tag));
    }
  }
  function Ml(n, a) {
    var c = yy(n);
    a.forEach(function(f) {
      var B = x0.bind(null, n, f);
      c.has(f) || (c.add(f), f.then(B, B));
    });
  }
  function de(n, a) {
    var c = a.deletions;
    if (c !== null)
      for (var f = 0; f < c.length; f++) {
        var B = c[f], m = n, j = a, O = j;
        g: for (; O !== null; ) {
          switch (O.tag) {
            case 27:
              if (BC(O.type)) {
                yA = O.stateNode, ue = !1;
                break g;
              }
              break;
            case 5:
              yA = O.stateNode, ue = !1;
              break g;
            case 3:
            case 4:
              yA = O.stateNode.containerInfo, ue = !0;
              break g;
          }
          O = O.return;
        }
        if (yA === null) throw Error(t(160));
        hy(m, j, B), yA = null, ue = !1, m = B.alternate, m !== null && (m.return = null), B.return = null;
      }
    if (a.subtreeFlags & 13878)
      for (a = a.child; a !== null; )
        Ga(a, n), a = a.sibling;
  }
  var Ee = null;
  function Ga(n, a) {
    var c = n.alternate, f = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        de(a, n), RC(n), f & 4 && (Jn(3, n, n.return), ba(3, n), Jn(5, n, n.return));
        break;
      case 1:
        de(a, n), RC(n), f & 512 && (jA || c === null || Zt(c, c.return)), f & 64 && jt && (n = n.updateQueue, n !== null && (f = n.callbacks, f !== null && (c = n.shared.hiddenCallbacks, n.shared.hiddenCallbacks = c === null ? f : c.concat(f))));
        break;
      case 26:
        var B = Ee;
        if (de(a, n), RC(n), f & 512 && (jA || c === null || Zt(c, c.return)), f & 4) {
          var m = c !== null ? c.memoizedState : null;
          if (f = n.memoizedState, c === null)
            if (f === null)
              if (n.stateNode === null) {
                g: {
                  f = n.type, c = n.memoizedProps, B = B.ownerDocument || B;
                  I: switch (f) {
                    case "title":
                      m = B.getElementsByTagName("title")[0], (!m || m[Gr] || m[sA] || m.namespaceURI === "http://www.w3.org/2000/svg" || m.hasAttribute("itemprop")) && (m = B.createElement(f), B.head.insertBefore(
                        m,
                        B.querySelector("head > title")
                      )), Dg(m, f, c), m[sA] = n, OA(m), f = m;
                      break g;
                    case "link":
                      var j = Wa(
                        "link",
                        "href",
                        B
                      ).get(f + (c.href || ""));
                      if (j) {
                        for (var O = 0; O < j.length; O++)
                          if (m = j[O], m.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && m.getAttribute("rel") === (c.rel == null ? null : c.rel) && m.getAttribute("title") === (c.title == null ? null : c.title) && m.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            j.splice(O, 1);
                            break I;
                          }
                      }
                      m = B.createElement(f), Dg(m, f, c), B.head.appendChild(m);
                      break;
                    case "meta":
                      if (j = Wa(
                        "meta",
                        "content",
                        B
                      ).get(f + (c.content || ""))) {
                        for (O = 0; O < j.length; O++)
                          if (m = j[O], m.getAttribute("content") === (c.content == null ? null : "" + c.content) && m.getAttribute("name") === (c.name == null ? null : c.name) && m.getAttribute("property") === (c.property == null ? null : c.property) && m.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && m.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            j.splice(O, 1);
                            break I;
                          }
                      }
                      m = B.createElement(f), Dg(m, f, c), B.head.appendChild(m);
                      break;
                    default:
                      throw Error(t(468, f));
                  }
                  m[sA] = n, OA(m), f = m;
                }
                n.stateNode = f;
              } else
                Vy(
                  B,
                  n.type,
                  n.stateNode
                );
            else
              n.stateNode = cd(
                B,
                f,
                n.memoizedProps
              );
          else
            m !== f ? (m === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : m.count--, f === null ? Vy(
              B,
              n.type,
              n.stateNode
            ) : cd(
              B,
              f,
              n.memoizedProps
            )) : f === null && n.stateNode !== null && io(
              n,
              n.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        de(a, n), RC(n), f & 512 && (jA || c === null || Zt(c, c.return)), c !== null && f & 4 && io(
          n,
          n.memoizedProps,
          c.memoizedProps
        );
        break;
      case 5:
        if (de(a, n), RC(n), f & 512 && (jA || c === null || Zt(c, c.return)), n.flags & 32) {
          B = n.stateNode;
          try {
            js(B, "");
          } catch (pg) {
            eA(n, n.return, pg);
          }
        }
        f & 4 && n.stateNode != null && (B = n.memoizedProps, io(
          n,
          B,
          c !== null ? c.memoizedProps : B
        )), f & 1024 && (ku = !0);
        break;
      case 6:
        if (de(a, n), RC(n), f & 4) {
          if (n.stateNode === null)
            throw Error(t(162));
          f = n.memoizedProps, c = n.stateNode;
          try {
            c.nodeValue = f;
          } catch (pg) {
            eA(n, n.return, pg);
          }
        }
        break;
      case 3:
        if (El = null, B = Ee, Ee = oC(a.containerInfo), de(a, n), Ee = B, RC(n), f & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            Ua(a.containerInfo);
          } catch (pg) {
            eA(n, n.return, pg);
          }
        ku && (ku = !1, no(n));
        break;
      case 4:
        f = Ee, Ee = oC(
          n.stateNode.containerInfo
        ), de(a, n), RC(n), Ee = f;
        break;
      case 12:
        de(a, n), RC(n);
        break;
      case 13:
        de(a, n), RC(n), n.child.flags & 8192 && n.memoizedState !== null != (c !== null && c.memoizedState !== null) && (my = vI()), f & 4 && (f = n.updateQueue, f !== null && (n.updateQueue = null, Ml(n, f)));
        break;
      case 22:
        B = n.memoizedState !== null;
        var q = c !== null && c.memoizedState !== null, ug = jt, jg = jA;
        if (jt = ug || B, jA = jg || q, de(a, n), jA = jg, jt = ug, RC(n), f & 8192)
          g: for (a = n.stateNode, a._visibility = B ? a._visibility & -2 : a._visibility | 1, B && (c === null || q || jt || jA || Cn(n)), c = null, a = n; ; ) {
            if (a.tag === 5 || a.tag === 26) {
              if (c === null) {
                q = c = a;
                try {
                  if (m = q.stateNode, B)
                    j = m.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none";
                  else {
                    O = q.stateNode;
                    var Hg = q.memoizedProps.style, hg = Hg != null && Hg.hasOwnProperty("display") ? Hg.display : null;
                    O.style.display = hg == null || typeof hg == "boolean" ? "" : ("" + hg).trim();
                  }
                } catch (pg) {
                  eA(q, q.return, pg);
                }
              }
            } else if (a.tag === 6) {
              if (c === null) {
                q = a;
                try {
                  q.stateNode.nodeValue = B ? "" : q.memoizedProps;
                } catch (pg) {
                  eA(q, q.return, pg);
                }
              }
            } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === n) && a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === n) break g;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === n) break g;
              c === a && (c = null), a = a.return;
            }
            c === a && (c = null), a.sibling.return = a.return, a = a.sibling;
          }
        f & 4 && (f = n.updateQueue, f !== null && (c = f.retryQueue, c !== null && (f.retryQueue = null, Ml(n, c))));
        break;
      case 19:
        de(a, n), RC(n), f & 4 && (f = n.updateQueue, f !== null && (n.updateQueue = null, Ml(n, f)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        de(a, n), RC(n);
    }
  }
  function RC(n) {
    var a = n.flags;
    if (a & 2) {
      try {
        for (var c, f = n.return; f !== null; ) {
          if (cw(f)) {
            c = f;
            break;
          }
          f = f.return;
        }
        if (c == null) throw Error(t(160));
        switch (c.tag) {
          case 27:
            var B = c.stateNode, m = uy(n);
            Ln(n, m, B);
            break;
          case 5:
            var j = c.stateNode;
            c.flags & 32 && (js(j, ""), c.flags &= -33);
            var O = uy(n);
            Ln(n, O, j);
            break;
          case 3:
          case 4:
            var q = c.stateNode.containerInfo, ug = uy(n);
            et(
              n,
              ug,
              q
            );
            break;
          default:
            throw Error(t(161));
        }
      } catch (jg) {
        eA(n, n.return, jg);
      }
      n.flags &= -3;
    }
    a & 4096 && (n.flags &= -4097);
  }
  function no(n) {
    if (n.subtreeFlags & 1024)
      for (n = n.child; n !== null; ) {
        var a = n;
        no(a), a.tag === 5 && a.flags & 1024 && a.stateNode.reset(), n = n.sibling;
      }
  }
  function An(n, a) {
    if (a.subtreeFlags & 8772)
      for (a = a.child; a !== null; )
        Wu(n, a.alternate, a), a = a.sibling;
  }
  function Cn(n) {
    for (n = n.child; n !== null; ) {
      var a = n;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Jn(4, a, a.return), Cn(a);
          break;
        case 1:
          Zt(a, a.return);
          var c = a.stateNode;
          typeof c.componentWillUnmount == "function" && Nu(
            a,
            a.return,
            c
          ), Cn(a);
          break;
        case 27:
          Qg(a.stateNode);
        case 26:
        case 5:
          Zt(a, a.return), Cn(a);
          break;
        case 22:
          a.memoizedState === null && Cn(a);
          break;
        case 30:
          Cn(a);
          break;
        default:
          Cn(a);
      }
      n = n.sibling;
    }
  }
  function DA(n, a, c) {
    for (c = c && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null; ) {
      var f = a.alternate, B = n, m = a, j = m.flags;
      switch (m.tag) {
        case 0:
        case 11:
        case 15:
          DA(
            B,
            m,
            c
          ), ba(4, m);
          break;
        case 1:
          if (DA(
            B,
            m,
            c
          ), f = m, B = f.stateNode, typeof B.componentDidMount == "function")
            try {
              B.componentDidMount();
            } catch (ug) {
              eA(f, f.return, ug);
            }
          if (f = m, B = f.updateQueue, B !== null) {
            var O = f.stateNode;
            try {
              var q = B.shared.hiddenCallbacks;
              if (q !== null)
                for (B.shared.hiddenCallbacks = null, B = 0; B < q.length; B++)
                  ca(q[B], O);
            } catch (ug) {
              eA(f, f.return, ug);
            }
          }
          c && j & 64 && lw(m), Sa(m, m.return);
          break;
        case 27:
          uw(m);
        case 26:
        case 5:
          DA(
            B,
            m,
            c
          ), c && f === null && j & 4 && cy(m), Sa(m, m.return);
          break;
        case 12:
          DA(
            B,
            m,
            c
          );
          break;
        case 13:
          DA(
            B,
            m,
            c
          ), c && j & 4 && PI(B, m);
          break;
        case 22:
          m.memoizedState === null && DA(
            B,
            m,
            c
          ), Sa(m, m.return);
          break;
        case 30:
          break;
        default:
          DA(
            B,
            m,
            c
          );
      }
      a = a.sibling;
    }
  }
  function Dy(n, a) {
    var c = null;
    n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), n = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (n = a.memoizedState.cachePool.pool), n !== c && (n != null && n.refCount++, c != null && _n(c));
  }
  function it(n, a) {
    n = null, a.alternate !== null && (n = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== n && (a.refCount++, n != null && _n(n));
  }
  function vt(n, a, c, f) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        en(
          n,
          a,
          c,
          f
        ), a = a.sibling;
  }
  function en(n, a, c, f) {
    var B = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        vt(
          n,
          a,
          c,
          f
        ), B & 2048 && ba(9, a);
        break;
      case 1:
        vt(
          n,
          a,
          c,
          f
        );
        break;
      case 3:
        vt(
          n,
          a,
          c,
          f
        ), B & 2048 && (n = null, a.alternate !== null && (n = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== n && (a.refCount++, n != null && _n(n)));
        break;
      case 12:
        if (B & 2048) {
          vt(
            n,
            a,
            c,
            f
          ), n = a.stateNode;
          try {
            var m = a.memoizedProps, j = m.id, O = m.onPostCommit;
            typeof O == "function" && O(
              j,
              a.alternate === null ? "mount" : "update",
              n.passiveEffectDuration,
              -0
            );
          } catch (q) {
            eA(a, a.return, q);
          }
        } else
          vt(
            n,
            a,
            c,
            f
          );
        break;
      case 13:
        vt(
          n,
          a,
          c,
          f
        );
        break;
      case 23:
        break;
      case 22:
        m = a.stateNode, j = a.alternate, a.memoizedState !== null ? m._visibility & 2 ? vt(
          n,
          a,
          c,
          f
        ) : qn(n, a) : m._visibility & 2 ? vt(
          n,
          a,
          c,
          f
        ) : (m._visibility |= 2, so(
          n,
          a,
          c,
          f,
          (a.subtreeFlags & 10256) !== 0
        )), B & 2048 && Dy(j, a);
        break;
      case 24:
        vt(
          n,
          a,
          c,
          f
        ), B & 2048 && it(a.alternate, a);
        break;
      default:
        vt(
          n,
          a,
          c,
          f
        );
    }
  }
  function so(n, a, c, f, B) {
    for (B = B && (a.subtreeFlags & 10256) !== 0, a = a.child; a !== null; ) {
      var m = n, j = a, O = c, q = f, ug = j.flags;
      switch (j.tag) {
        case 0:
        case 11:
        case 15:
          so(
            m,
            j,
            O,
            q,
            B
          ), ba(8, j);
          break;
        case 23:
          break;
        case 22:
          var jg = j.stateNode;
          j.memoizedState !== null ? jg._visibility & 2 ? so(
            m,
            j,
            O,
            q,
            B
          ) : qn(
            m,
            j
          ) : (jg._visibility |= 2, so(
            m,
            j,
            O,
            q,
            B
          )), B && ug & 2048 && Dy(
            j.alternate,
            j
          );
          break;
        case 24:
          so(
            m,
            j,
            O,
            q,
            B
          ), B && ug & 2048 && it(j.alternate, j);
          break;
        default:
          so(
            m,
            j,
            O,
            q,
            B
          );
      }
      a = a.sibling;
    }
  }
  function qn(n, a) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; ) {
        var c = n, f = a, B = f.flags;
        switch (f.tag) {
          case 22:
            qn(c, f), B & 2048 && Dy(
              f.alternate,
              f
            );
            break;
          case 24:
            qn(c, f), B & 2048 && it(f.alternate, f);
            break;
          default:
            qn(c, f);
        }
        a = a.sibling;
      }
  }
  var xI = 8192;
  function $n(n) {
    if (n.subtreeFlags & xI)
      for (n = n.child; n !== null; )
        sC(n), n = n.sibling;
  }
  function sC(n) {
    switch (n.tag) {
      case 26:
        $n(n), n.flags & xI && n.memoizedState !== null && Hw(
          Ee,
          n.memoizedState,
          n.memoizedProps
        );
        break;
      case 5:
        $n(n);
        break;
      case 3:
      case 4:
        var a = Ee;
        Ee = oC(n.stateNode.containerInfo), $n(n), Ee = a;
        break;
      case 22:
        n.memoizedState === null && (a = n.alternate, a !== null && a.memoizedState !== null ? (a = xI, xI = 16777216, $n(n), xI = a) : $n(n));
        break;
      default:
        $n(n);
    }
  }
  function fw(n) {
    var a = n.alternate;
    if (a !== null && (n = a.child, n !== null)) {
      a.child = null;
      do
        a = n.sibling, n.sibling = null, n = a;
      while (n !== null);
    }
  }
  function Ka(n) {
    var a = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (a !== null)
        for (var c = 0; c < a.length; c++) {
          var f = a[c];
          FA = f, Re(
            f,
            n
          );
        }
      fw(n);
    }
    if (n.subtreeFlags & 10256)
      for (n = n.child; n !== null; )
        Vu(n), n = n.sibling;
  }
  function Vu(n) {
    switch (n.tag) {
      case 0:
      case 11:
      case 15:
        Ka(n), n.flags & 2048 && Jn(9, n, n.return);
        break;
      case 3:
        Ka(n);
        break;
      case 12:
        Ka(n);
        break;
      case 22:
        var a = n.stateNode;
        n.memoizedState !== null && a._visibility & 2 && (n.return === null || n.return.tag !== 13) ? (a._visibility &= -3, wl(n)) : Ka(n);
        break;
      default:
        Ka(n);
    }
  }
  function wl(n) {
    var a = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (a !== null)
        for (var c = 0; c < a.length; c++) {
          var f = a[c];
          FA = f, Re(
            f,
            n
          );
        }
      fw(n);
    }
    for (n = n.child; n !== null; ) {
      switch (a = n, a.tag) {
        case 0:
        case 11:
        case 15:
          Jn(8, a, a.return), wl(a);
          break;
        case 22:
          c = a.stateNode, c._visibility & 2 && (c._visibility &= -3, wl(a));
          break;
        default:
          wl(a);
      }
      n = n.sibling;
    }
  }
  function Re(n, a) {
    for (; FA !== null; ) {
      var c = FA;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          Jn(8, c, a);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var f = c.memoizedState.cachePool.pool;
            f != null && f.refCount++;
          }
          break;
        case 24:
          _n(c.memoizedState.cache);
      }
      if (f = c.child, f !== null) f.return = c, FA = f;
      else
        g: for (c = n; FA !== null; ) {
          f = FA;
          var B = f.sibling, m = f.return;
          if (fy(f), f === c) {
            FA = null;
            break g;
          }
          if (B !== null) {
            B.return = m, FA = B;
            break g;
          }
          FA = m;
        }
    }
  }
  var hw = {
    getCacheForType: function(n) {
      var a = MC(_A), c = a.data.get(n);
      return c === void 0 && (c = n(), a.data.set(n, c)), c;
    }
  }, My = typeof WeakMap == "function" ? WeakMap : Map, LI = 0, CA = null, ZI = null, WI = 0, _I = 0, fe = null, tn = !1, gs = !1, wy = !1, nn = 0, vA = 0, Is = 0, As = 0, By = 0, $A = 0, Ta = 0, Bl = null, JC = null, py = !1, my = 0, xu = 1 / 0, _u = null, ai = null, wC = 0, Cs = null, es = null, Ya = 0, he = 0, Uu = null, by = null, Pa = 0, Fu = null;
  function Oe() {
    if ((LI & 2) !== 0 && WI !== 0)
      return WI & -WI;
    if (z.T !== null) {
      var n = Un;
      return n !== 0 ? n : Ad();
    }
    return Ii();
  }
  function yw() {
    $A === 0 && ($A = (WI & 536870912) === 0 || pI ? og() : 536870912);
    var n = UA.current;
    return n !== null && (n.flags |= 32), $A;
  }
  function ye(n, a, c) {
    (n === CA && (_I === 2 || _I === 9) || n.cancelPendingCommit !== null) && (Ht(n, 0), sn(
      n,
      WI,
      $A,
      !1
    )), Jg(n, c), ((LI & 2) === 0 || n !== CA) && (n === CA && ((LI & 2) === 0 && (As |= c), vA === 4 && sn(
      n,
      WI,
      $A,
      !1
    )), Et(n));
  }
  function Dw(n, a, c) {
    if ((LI & 6) !== 0) throw Error(t(327));
    var f = !c && (a & 124) === 0 && (a & n.expiredLanes) === 0 || Ie(n, a), B = f ? Qu(n, a) : oo(n, a, !0), m = f;
    do {
      if (B === 0) {
        gs && !f && sn(n, a, 0, !1);
        break;
      } else {
        if (c = n.current.alternate, m && !Xu(c)) {
          B = oo(n, a, !1), m = !1;
          continue;
        }
        if (B === 2) {
          if (m = a, n.errorRecoveryDisabledLanes & m)
            var j = 0;
          else
            j = n.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
          if (j !== 0) {
            a = j;
            g: {
              var O = n;
              B = Bl;
              var q = O.current.memoizedState.isDehydrated;
              if (q && (Ht(O, j).flags |= 256), j = oo(
                O,
                j,
                !1
              ), j !== 2) {
                if (wy && !q) {
                  O.errorRecoveryDisabledLanes |= m, As |= m, B = 4;
                  break g;
                }
                m = JC, JC = B, m !== null && (JC === null ? JC = m : JC.push.apply(
                  JC,
                  m
                ));
              }
              B = j;
            }
            if (m = !1, B !== 2) continue;
          }
        }
        if (B === 1) {
          Ht(n, 0), sn(n, a, 0, !0);
          break;
        }
        g: {
          switch (f = n, m = B, m) {
            case 0:
            case 1:
              throw Error(t(345));
            case 4:
              if ((a & 4194048) !== a) break;
            case 6:
              sn(
                f,
                a,
                $A,
                !tn
              );
              break g;
            case 2:
              JC = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(t(329));
          }
          if ((a & 62914560) === a && (B = my + 300 - vI(), 10 < B)) {
            if (sn(
              f,
              a,
              $A,
              !tn
            ), ZC(f, 0, !0) !== 0) break g;
            f.timeoutHandle = ci(
              Za.bind(
                null,
                f,
                c,
                JC,
                _u,
                py,
                a,
                $A,
                As,
                Ta,
                tn,
                m,
                2,
                -0,
                0
              ),
              B
            );
            break g;
          }
          Za(
            f,
            c,
            JC,
            _u,
            py,
            a,
            $A,
            As,
            Ta,
            tn,
            m,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Et(n);
  }
  function Za(n, a, c, f, B, m, j, O, q, ug, jg, Hg, hg, pg) {
    if (n.timeoutHandle = -1, Hg = a.subtreeFlags, (Hg & 8192 || (Hg & 16785408) === 16785408) && (Va = { stylesheets: null, count: 0, unsuspend: vw }, sC(a), Hg = Ew(), Hg !== null)) {
      n.cancelPendingCommit = Hg(
        Bw.bind(
          null,
          n,
          a,
          m,
          c,
          f,
          B,
          j,
          O,
          q,
          jg,
          1,
          hg,
          pg
        )
      ), sn(n, m, j, !ug);
      return;
    }
    Bw(
      n,
      a,
      m,
      c,
      f,
      B,
      j,
      O,
      q
    );
  }
  function Xu(n) {
    for (var a = n; ; ) {
      var c = a.tag;
      if ((c === 0 || c === 11 || c === 15) && a.flags & 16384 && (c = a.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var f = 0; f < c.length; f++) {
          var B = c[f], m = B.getSnapshot;
          B = B.value;
          try {
            if (!XC(m(), B)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = a.child, a.subtreeFlags & 16384 && c !== null)
        c.return = a, a = c;
      else {
        if (a === n) break;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === n) return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
    }
    return !0;
  }
  function sn(n, a, c, f) {
    a &= ~By, a &= ~As, n.suspendedLanes |= a, n.pingedLanes &= ~a, f && (n.warmLanes |= a), f = n.expirationTimes;
    for (var B = a; 0 < B; ) {
      var m = 31 - pA(B), j = 1 << m;
      f[m] = -1, B &= ~j;
    }
    c !== 0 && lI(n, c, a);
  }
  function pl() {
    return (LI & 6) === 0 ? (on(0), !1) : !0;
  }
  function ja() {
    if (ZI !== null) {
      if (_I === 0)
        var n = ZI.return;
      else
        n = ZI, bt = Xi = null, da(n), re = null, Da = 0, n = ZI;
      for (; n !== null; )
        rw(n.alternate, n), n = n.return;
      ZI = null;
    }
  }
  function Ht(n, a) {
    var c = n.timeoutHandle;
    c !== -1 && (n.timeoutHandle = -1, Hy(c)), c = n.cancelPendingCommit, c !== null && (n.cancelPendingCommit = null, c()), ja(), CA = n, ZI = c = wt(n.current, null), WI = a, _I = 0, fe = null, tn = !1, gs = Ie(n, a), wy = !1, Ta = $A = By = As = Is = vA = 0, JC = Bl = null, py = !1, (a & 8) !== 0 && (a |= a & 32);
    var f = n.entangledLanes;
    if (f !== 0)
      for (n = n.entanglements, f &= a; 0 < f; ) {
        var B = 31 - pA(f), m = 1 << B;
        a |= n[B], f &= ~m;
      }
    return nn = a, Dt(), c;
  }
  function va(n, a) {
    hI = null, z.H = ul, a === zs || a === oa ? (a = uu(), _I = 3) : a === qr ? (a = uu(), _I = 4) : _I = a === Cy ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1, fe = a, ZI === null && (vA = 1, Co(
      n,
      Ze(a, n.current)
    ));
  }
  function Sy() {
    var n = z.H;
    return z.H = ul, n === null ? ul : n;
  }
  function Mw() {
    var n = z.A;
    return z.A = hw, n;
  }
  function ts() {
    vA = 4, tn || (WI & 4194048) !== WI && UA.current !== null || (gs = !0), (Is & 134217727) === 0 && (As & 134217727) === 0 || CA === null || sn(
      CA,
      WI,
      $A,
      !1
    );
  }
  function oo(n, a, c) {
    var f = LI;
    LI |= 2;
    var B = Sy(), m = Mw();
    (CA !== n || WI !== a) && (_u = null, Ht(n, a)), a = !1;
    var j = vA;
    g: do
      try {
        if (_I !== 0 && ZI !== null) {
          var O = ZI, q = fe;
          switch (_I) {
            case 8:
              ja(), j = 6;
              break g;
            case 3:
            case 2:
            case 9:
            case 6:
              UA.current === null && (a = !0);
              var ug = _I;
              if (_I = 0, fe = null, ao(n, O, q, ug), c && gs) {
                j = 0;
                break g;
              }
              break;
            default:
              ug = _I, _I = 0, fe = null, ao(n, O, q, ug);
          }
        }
        ww(), j = vA;
        break;
      } catch (jg) {
        va(n, jg);
      }
    while (!0);
    return a && n.shellSuspendCounter++, bt = Xi = null, LI = f, z.H = B, z.A = m, ZI === null && (CA = null, WI = 0, Dt()), j;
  }
  function ww() {
    for (; ZI !== null; ) zu(ZI);
  }
  function Qu(n, a) {
    var c = LI;
    LI |= 2;
    var f = Sy(), B = Mw();
    CA !== n || WI !== a ? (_u = null, xu = vI() + 500, Ht(n, a)) : gs = Ie(
      n,
      a
    );
    g: do
      try {
        if (_I !== 0 && ZI !== null) {
          a = ZI;
          var m = fe;
          I: switch (_I) {
            case 1:
              _I = 0, fe = null, ao(n, a, m, 1);
              break;
            case 2:
            case 9:
              if (bh(m)) {
                _I = 0, fe = null, Ky(a);
                break;
              }
              a = function() {
                _I !== 2 && _I !== 9 || CA !== n || (_I = 7), Et(n);
              }, m.then(a, a);
              break g;
            case 3:
              _I = 7;
              break g;
            case 4:
              _I = 5;
              break g;
            case 7:
              bh(m) ? (_I = 0, fe = null, Ky(a)) : (_I = 0, fe = null, ao(n, a, m, 7));
              break;
            case 5:
              var j = null;
              switch (ZI.tag) {
                case 26:
                  j = ZI.memoizedState;
                case 5:
                case 27:
                  var O = ZI;
                  if (!j || xy(j)) {
                    _I = 0, fe = null;
                    var q = O.sibling;
                    if (q !== null) ZI = q;
                    else {
                      var ug = O.return;
                      ug !== null ? (ZI = ug, Ju(ug)) : ZI = null;
                    }
                    break I;
                  }
              }
              _I = 0, fe = null, ao(n, a, m, 5);
              break;
            case 6:
              _I = 0, fe = null, ao(n, a, m, 6);
              break;
            case 8:
              ja(), vA = 6;
              break g;
            default:
              throw Error(t(462));
          }
        }
        Gy();
        break;
      } catch (jg) {
        va(n, jg);
      }
    while (!0);
    return bt = Xi = null, z.H = f, z.A = B, LI = c, ZI !== null ? 0 : (CA = null, WI = 0, Dt(), vA);
  }
  function Gy() {
    for (; ZI !== null && !_C(); )
      zu(ZI);
  }
  function zu(n) {
    var a = ay(n.alternate, n, nn);
    n.memoizedProps = n.pendingProps, a === null ? Ju(n) : ZI = a;
  }
  function Ky(n) {
    var a = n, c = a.alternate;
    switch (a.tag) {
      case 15:
      case 0:
        a = ty(
          c,
          a,
          a.pendingProps,
          a.type,
          void 0,
          WI
        );
        break;
      case 11:
        a = ty(
          c,
          a,
          a.pendingProps,
          a.type.render,
          a.ref,
          WI
        );
        break;
      case 5:
        da(a);
      default:
        rw(c, a), a = ZI = nu(a, nn), a = ay(c, a, nn);
    }
    n.memoizedProps = n.pendingProps, a === null ? Ju(n) : ZI = a;
  }
  function ao(n, a, c, f) {
    bt = Xi = null, da(a), re = null, Da = 0;
    var B = a.return;
    try {
      if (He(
        n,
        B,
        a,
        c,
        WI
      )) {
        vA = 1, Co(
          n,
          Ze(c, n.current)
        ), ZI = null;
        return;
      }
    } catch (m) {
      if (B !== null) throw ZI = B, m;
      vA = 1, Co(
        n,
        Ze(c, n.current)
      ), ZI = null;
      return;
    }
    a.flags & 32768 ? (pI || f === 1 ? n = !0 : gs || (WI & 536870912) !== 0 ? n = !1 : (tn = n = !0, (f === 2 || f === 9 || f === 3 || f === 6) && (f = UA.current, f !== null && f.tag === 13 && (f.flags |= 16384))), Ty(a, n)) : Ju(a);
  }
  function Ju(n) {
    var a = n;
    do {
      if ((a.flags & 32768) !== 0) {
        Ty(
          a,
          tn
        );
        return;
      }
      n = a.return;
      var c = AA(
        a.alternate,
        a,
        nn
      );
      if (c !== null) {
        ZI = c;
        return;
      }
      if (a = a.sibling, a !== null) {
        ZI = a;
        return;
      }
      ZI = a = n;
    } while (a !== null);
    vA === 0 && (vA = 5);
  }
  function Ty(n, a) {
    do {
      var c = ly(n.alternate, n);
      if (c !== null) {
        c.flags &= 32767, ZI = c;
        return;
      }
      if (c = n.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !a && (n = n.sibling, n !== null)) {
        ZI = n;
        return;
      }
      ZI = n = c;
    } while (n !== null);
    vA = 6, ZI = null;
  }
  function Bw(n, a, c, f, B, m, j, O, q) {
    n.cancelPendingCommit = null;
    do
      qu();
    while (wC !== 0);
    if ((LI & 6) !== 0) throw Error(t(327));
    if (a !== null) {
      if (a === n.current) throw Error(t(177));
      if (m = a.lanes | a.childLanes, m |= xr, yI(
        n,
        c,
        m,
        j,
        O,
        q
      ), n === CA && (ZI = CA = null, WI = 0), es = a, Cs = n, Ya = c, he = m, Uu = B, by = f, (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? (n.callbackNode = null, n.callbackPriority = 0, _0(rI, function() {
        return bw(), null;
      })) : (n.callbackNode = null, n.callbackPriority = 0), f = (a.flags & 13878) !== 0, (a.subtreeFlags & 13878) !== 0 || f) {
        f = z.T, z.T = null, B = Q.p, Q.p = 2, j = LI, LI |= 4;
        try {
          dw(n, a, c);
        } finally {
          LI = j, Q.p = B, z.T = f;
        }
      }
      wC = 1, pw(), mw(), ml();
    }
  }
  function pw() {
    if (wC === 1) {
      wC = 0;
      var n = Cs, a = es, c = (a.flags & 13878) !== 0;
      if ((a.subtreeFlags & 13878) !== 0 || c) {
        c = z.T, z.T = null;
        var f = Q.p;
        Q.p = 2;
        var B = LI;
        LI |= 4;
        try {
          Ga(a, n);
          var m = Zl, j = Wr(n.containerInfo), O = m.focusedElem, q = m.selectionRange;
          if (j !== O && O && O.ownerDocument && fA(
            O.ownerDocument.documentElement,
            O
          )) {
            if (q !== null && Au(O)) {
              var ug = q.start, jg = q.end;
              if (jg === void 0 && (jg = ug), "selectionStart" in O)
                O.selectionStart = ug, O.selectionEnd = Math.min(
                  jg,
                  O.value.length
                );
              else {
                var Hg = O.ownerDocument || document, hg = Hg && Hg.defaultView || window;
                if (hg.getSelection) {
                  var pg = hg.getSelection(), tI = O.textContent.length, eI = Math.min(q.start, tI), zI = q.end === void 0 ? eI : Math.min(q.end, tI);
                  !pg.extend && eI > zI && (j = zI, zI = eI, eI = j);
                  var ag = Rn(
                    O,
                    eI
                  ), Ag = Rn(
                    O,
                    zI
                  );
                  if (ag && Ag && (pg.rangeCount !== 1 || pg.anchorNode !== ag.node || pg.anchorOffset !== ag.offset || pg.focusNode !== Ag.node || pg.focusOffset !== Ag.offset)) {
                    var dg = Hg.createRange();
                    dg.setStart(ag.node, ag.offset), pg.removeAllRanges(), eI > zI ? (pg.addRange(dg), pg.extend(Ag.node, Ag.offset)) : (dg.setEnd(Ag.node, Ag.offset), pg.addRange(dg));
                  }
                }
              }
            }
            for (Hg = [], pg = O; pg = pg.parentNode; )
              pg.nodeType === 1 && Hg.push({
                element: pg,
                left: pg.scrollLeft,
                top: pg.scrollTop
              });
            for (typeof O.focus == "function" && O.focus(), O = 0; O < Hg.length; O++) {
              var vg = Hg[O];
              vg.element.scrollLeft = vg.left, vg.element.scrollTop = vg.top;
            }
          }
          Nl = !!vy, Zl = vy = null;
        } finally {
          LI = B, Q.p = f, z.T = c;
        }
      }
      n.current = a, wC = 2;
    }
  }
  function mw() {
    if (wC === 2) {
      wC = 0;
      var n = Cs, a = es, c = (a.flags & 8772) !== 0;
      if ((a.subtreeFlags & 8772) !== 0 || c) {
        c = z.T, z.T = null;
        var f = Q.p;
        Q.p = 2;
        var B = LI;
        LI |= 4;
        try {
          Wu(n, a.alternate, a);
        } finally {
          LI = B, Q.p = f, z.T = c;
        }
      }
      wC = 3;
    }
  }
  function ml() {
    if (wC === 4 || wC === 3) {
      wC = 0, UC();
      var n = Cs, a = es, c = Ya, f = by;
      (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? wC = 5 : (wC = 0, es = Cs = null, Lu(n, n.pendingLanes));
      var B = n.pendingLanes;
      if (B === 0 && (ai = null), VA(c), a = a.stateNode, eC && typeof eC.onCommitFiberRoot == "function")
        try {
          eC.onCommitFiberRoot(
            Qe,
            a,
            void 0,
            (a.current.flags & 128) === 128
          );
        } catch {
        }
      if (f !== null) {
        a = z.T, B = Q.p, Q.p = 2, z.T = null;
        try {
          for (var m = n.onRecoverableError, j = 0; j < f.length; j++) {
            var O = f[j];
            m(O.value, {
              componentStack: O.stack
            });
          }
        } finally {
          z.T = a, Q.p = B;
        }
      }
      (Ya & 3) !== 0 && qu(), Et(n), B = n.pendingLanes, (c & 4194090) !== 0 && (B & 42) !== 0 ? n === Fu ? Pa++ : (Pa = 0, Fu = n) : Pa = 0, on(0);
    }
  }
  function Lu(n, a) {
    (n.pooledCacheLanes &= a) === 0 && (a = n.pooledCache, a != null && (n.pooledCache = null, _n(a)));
  }
  function qu(n) {
    return pw(), mw(), ml(), bw();
  }
  function bw() {
    if (wC !== 5) return !1;
    var n = Cs, a = he;
    he = 0;
    var c = VA(Ya), f = z.T, B = Q.p;
    try {
      Q.p = 32 > c ? 32 : c, z.T = null, c = Uu, Uu = null;
      var m = Cs, j = Ya;
      if (wC = 0, es = Cs = null, Ya = 0, (LI & 6) !== 0) throw Error(t(331));
      var O = LI;
      if (LI |= 4, Vu(m.current), en(
        m,
        m.current,
        j,
        c
      ), LI = O, on(0, !1), eC && typeof eC.onPostCommitFiberRoot == "function")
        try {
          eC.onPostCommitFiberRoot(Qe, m);
        } catch {
        }
      return !0;
    } finally {
      Q.p = B, z.T = f, Lu(n, a);
    }
  }
  function Yy(n, a, c) {
    a = Ze(c, a), a = Zu(n.stateNode, a, 2), n = se(n, a, 2), n !== null && (Jg(n, 2), Et(n));
  }
  function eA(n, a, c) {
    if (n.tag === 3)
      Yy(n, n, c);
    else
      for (; a !== null; ) {
        if (a.tag === 3) {
          Yy(
            a,
            n,
            c
          );
          break;
        } else if (a.tag === 1) {
          var f = a.stateNode;
          if (typeof a.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (ai === null || !ai.has(f))) {
            n = Ze(c, n), c = nw(2), f = se(a, c, 2), f !== null && (Ay(
              c,
              f,
              a,
              n
            ), Jg(f, 2), Et(f));
            break;
          }
        }
        a = a.return;
      }
  }
  function bl(n, a, c) {
    var f = n.pingCache;
    if (f === null) {
      f = n.pingCache = new My();
      var B = /* @__PURE__ */ new Set();
      f.set(a, B);
    } else
      B = f.get(a), B === void 0 && (B = /* @__PURE__ */ new Set(), f.set(a, B));
    B.has(c) || (wy = !0, B.add(c), n = Sw.bind(null, n, a, c), a.then(n, n));
  }
  function Sw(n, a, c) {
    var f = n.pingCache;
    f !== null && f.delete(a), n.pingedLanes |= n.suspendedLanes & c, n.warmLanes &= ~c, CA === n && (WI & c) === c && (vA === 4 || vA === 3 && (WI & 62914560) === WI && 300 > vI() - my ? (LI & 2) === 0 && Ht(n, 0) : By |= c, Ta === WI && (Ta = 0)), Et(n);
  }
  function $u(n, a) {
    a === 0 && (a = Vg()), n = _i(n, a), n !== null && (Jg(n, a), Et(n));
  }
  function Gw(n) {
    var a = n.memoizedState, c = 0;
    a !== null && (c = a.retryLane), $u(n, c);
  }
  function x0(n, a) {
    var c = 0;
    switch (n.tag) {
      case 13:
        var f = n.stateNode, B = n.memoizedState;
        B !== null && (c = B.retryLane);
        break;
      case 19:
        f = n.stateNode;
        break;
      case 22:
        f = n.stateNode._retryCache;
        break;
      default:
        throw Error(t(314));
    }
    f !== null && f.delete(a), $u(n, c);
  }
  function _0(n, a) {
    return VI(n, a);
  }
  var gd = null, Ha = null, Sl = !1, Ea = !1, Gl = !1, is = 0;
  function Et(n) {
    n !== Ha && n.next === null && (Ha === null ? gd = Ha = n : Ha = Ha.next = n), Ea = !0, Sl || (Sl = !0, Id());
  }
  function on(n, a) {
    if (!Gl && Ea) {
      Gl = !0;
      do
        for (var c = !1, f = gd; f !== null; ) {
          if (n !== 0) {
            var B = f.pendingLanes;
            if (B === 0) var m = 0;
            else {
              var j = f.suspendedLanes, O = f.pingedLanes;
              m = (1 << 31 - pA(42 | n) + 1) - 1, m &= B & ~(j & ~O), m = m & 201326741 ? m & 201326741 | 1 : m ? m | 2 : 0;
            }
            m !== 0 && (c = !0, Kw(f, m));
          } else
            m = WI, m = ZC(
              f,
              f === CA ? m : 0,
              f.cancelPendingCommit !== null || f.timeoutHandle !== -1
            ), (m & 3) === 0 || Ie(f, m) || (c = !0, Kw(f, m));
          f = f.next;
        }
      while (c);
      Gl = !1;
    }
  }
  function U0() {
    Py();
  }
  function Py() {
    Ea = Sl = !1;
    var n = 0;
    is !== 0 && (od() && (n = is), is = 0);
    for (var a = vI(), c = null, f = gd; f !== null; ) {
      var B = f.next, m = Kl(f, a);
      m === 0 ? (f.next = null, c === null ? gd = B : c.next = B, B === null && (Ha = c)) : (c = f, (n !== 0 || (m & 3) !== 0) && (Ea = !0)), f = B;
    }
    on(n);
  }
  function Kl(n, a) {
    for (var c = n.suspendedLanes, f = n.pingedLanes, B = n.expirationTimes, m = n.pendingLanes & -62914561; 0 < m; ) {
      var j = 31 - pA(m), O = 1 << j, q = B[j];
      q === -1 ? ((O & c) === 0 || (O & f) !== 0) && (B[j] = k(O, a)) : q <= a && (n.expiredLanes |= O), m &= ~O;
    }
    if (a = CA, c = WI, c = ZC(
      n,
      n === a ? c : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), f = n.callbackNode, c === 0 || n === a && (_I === 2 || _I === 9) || n.cancelPendingCommit !== null)
      return f !== null && f !== null && oA(f), n.callbackNode = null, n.callbackPriority = 0;
    if ((c & 3) === 0 || Ie(n, c)) {
      if (a = c & -c, a === n.callbackPriority) return a;
      switch (f !== null && oA(f), VA(c)) {
        case 2:
        case 8:
          c = Lt;
          break;
        case 32:
          c = rI;
          break;
        case 268435456:
          c = qt;
          break;
        default:
          c = rI;
      }
      return f = Zy.bind(null, n), c = VI(c, f), n.callbackPriority = a, n.callbackNode = c, a;
    }
    return f !== null && f !== null && oA(f), n.callbackPriority = 2, n.callbackNode = null, 2;
  }
  function Zy(n, a) {
    if (wC !== 0 && wC !== 5)
      return n.callbackNode = null, n.callbackPriority = 0, null;
    var c = n.callbackNode;
    if (qu() && n.callbackNode !== c)
      return null;
    var f = WI;
    return f = ZC(
      n,
      n === CA ? f : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), f === 0 ? null : (Dw(n, f, a), Kl(n, vI()), n.callbackNode != null && n.callbackNode === c ? Zy.bind(null, n) : null);
  }
  function Kw(n, a) {
    if (qu()) return null;
    Dw(n, a, !0);
  }
  function Id() {
    Q0(function() {
      (LI & 6) !== 0 ? VI(
        hC,
        U0
      ) : Py();
    });
  }
  function Ad() {
    return is === 0 && (is = og()), is;
  }
  function Ra(n) {
    return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : Zr("" + n);
  }
  function Cd(n, a) {
    var c = a.ownerDocument.createElement("input");
    return c.name = a.name, c.value = a.value, n.id && c.setAttribute("form", n.id), a.parentNode.insertBefore(c, a), n = new FormData(n), c.parentNode.removeChild(c), n;
  }
  function ed(n, a, c, f, B) {
    if (a === "submit" && c && c.stateNode === B) {
      var m = Ra(
        (B[jC] || null).action
      ), j = f.submitter;
      j && (a = (a = j[jC] || null) ? Ra(a.formAction) : j.getAttribute("formAction"), a !== null && (m = a, j = null));
      var O = new Hr(
        "action",
        "action",
        null,
        f,
        B
      );
      n.push({
        event: O,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (f.defaultPrevented) {
                if (is !== 0) {
                  var q = j ? Cd(B, j) : new FormData(B);
                  Uh(
                    c,
                    {
                      pending: !0,
                      data: q,
                      method: B.method,
                      action: m
                    },
                    null,
                    q
                  );
                }
              } else
                typeof m == "function" && (O.preventDefault(), q = j ? Cd(B, j) : new FormData(B), Uh(
                  c,
                  {
                    pending: !0,
                    data: q,
                    method: B.method,
                    action: m
                  },
                  m,
                  q
                ));
            },
            currentTarget: B
          }
        ]
      });
    }
  }
  for (var td = 0; td < tu.length; td++) {
    var HA = tu[td], jy = HA.toLowerCase(), F0 = HA[0].toUpperCase() + HA.slice(1);
    ee(
      jy,
      "on" + F0
    );
  }
  ee(Vr, "onAnimationEnd"), ee(JM, "onAnimationIteration"), ee(dh, "onAnimationStart"), ee("dblclick", "onDoubleClick"), ee("focusin", "onFocus"), ee("focusout", "onBlur"), ee(N0, "onTransitionRun"), ee(fh, "onTransitionStart"), ee(eu, "onTransitionCancel"), ee(hh, "onTransitionEnd"), Ps("onMouseEnter", ["mouseout", "mouseover"]), Ps("onMouseLeave", ["mouseout", "mouseover"]), Ps("onPointerEnter", ["pointerout", "pointerover"]), Ps("onPointerLeave", ["pointerout", "pointerover"]), tC(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), tC(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), tC("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), tC(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), tC(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), tC(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var uI = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), X0 = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(uI)
  );
  function an(n, a) {
    a = (a & 4) !== 0;
    for (var c = 0; c < n.length; c++) {
      var f = n[c], B = f.event;
      f = f.listeners;
      g: {
        var m = void 0;
        if (a)
          for (var j = f.length - 1; 0 <= j; j--) {
            var O = f[j], q = O.instance, ug = O.currentTarget;
            if (O = O.listener, q !== m && B.isPropagationStopped())
              break g;
            m = O, B.currentTarget = ug;
            try {
              m(B);
            } catch (jg) {
              hl(jg);
            }
            B.currentTarget = null, m = q;
          }
        else
          for (j = 0; j < f.length; j++) {
            if (O = f[j], q = O.instance, ug = O.currentTarget, O = O.listener, q !== m && B.isPropagationStopped())
              break g;
            m = O, B.currentTarget = ug;
            try {
              m(B);
            } catch (jg) {
              hl(jg);
            }
            B.currentTarget = null, m = q;
          }
      }
    }
  }
  function DI(n, a) {
    var c = a[xf];
    c === void 0 && (c = a[xf] = /* @__PURE__ */ new Set());
    var f = n + "__bubble";
    c.has(f) || (Tw(a, n, 2, !1), c.add(f));
  }
  function ns(n, a, c) {
    var f = 0;
    a && (f |= 4), Tw(
      c,
      n,
      f,
      a
    );
  }
  var ro = "_reactListening" + Math.random().toString(36).slice(2);
  function Tl(n) {
    if (!n[ro]) {
      n[ro] = !0, _f.forEach(function(c) {
        c !== "selectionchange" && (X0.has(c) || ns(c, !1, n), ns(c, !0, n));
      });
      var a = n.nodeType === 9 ? n : n.ownerDocument;
      a === null || a[ro] || (a[ro] = !0, ns("selectionchange", !1, a));
    }
  }
  function Tw(n, a, c, f) {
    switch (kw(a)) {
      case 2:
        var B = Ow;
        break;
      case 8:
        B = Nw;
        break;
      default:
        B = hd;
    }
    c = B.bind(
      null,
      a,
      c,
      n
    ), B = void 0, !Vc || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (B = !0), f ? B !== void 0 ? n.addEventListener(a, c, {
      capture: !0,
      passive: B
    }) : n.addEventListener(a, c, !0) : B !== void 0 ? n.addEventListener(a, c, {
      passive: B
    }) : n.addEventListener(a, c, !1);
  }
  function Yl(n, a, c, f, B) {
    var m = f;
    if ((a & 1) === 0 && (a & 2) === 0 && f !== null)
      g: for (; ; ) {
        if (f === null) return;
        var j = f.tag;
        if (j === 3 || j === 4) {
          var O = f.stateNode.containerInfo;
          if (O === B) break;
          if (j === 4)
            for (j = f.return; j !== null; ) {
              var q = j.tag;
              if ((q === 3 || q === 4) && j.stateNode.containerInfo === B)
                return;
              j = j.return;
            }
          for (; O !== null; ) {
            if (j = Pn(O), j === null) return;
            if (q = j.tag, q === 5 || q === 6 || q === 26 || q === 27) {
              f = m = j;
              continue g;
            }
            O = O.parentNode;
          }
        }
        f = f.return;
      }
    NM(function() {
      var ug = m, jg = vs(c), Hg = [];
      g: {
        var hg = yh.get(n);
        if (hg !== void 0) {
          var pg = Hr, tI = n;
          switch (n) {
            case "keypress":
              if (vr(c) === 0) break g;
            case "keydown":
            case "keyup":
              pg = Os;
              break;
            case "focusin":
              tI = "focus", pg = Ah;
              break;
            case "focusout":
              tI = "blur", pg = Ah;
              break;
            case "beforeblur":
            case "afterblur":
              pg = Ah;
              break;
            case "click":
              if (c.button === 2) break g;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              pg = Rr;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              pg = VM;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              pg = Qc;
              break;
            case Vr:
            case JM:
            case dh:
              pg = H0;
              break;
            case hh:
              pg = Ce;
              break;
            case "scroll":
            case "scrollend":
              pg = j0;
              break;
            case "wheel":
              pg = zc;
              break;
            case "copy":
            case "cut":
            case "paste":
              pg = R0;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              pg = Ae;
              break;
            case "toggle":
            case "beforetoggle":
              pg = ih;
          }
          var eI = (a & 4) !== 0, zI = !eI && (n === "scroll" || n === "scrollend"), ag = eI ? hg !== null ? hg + "Capture" : null : hg;
          eI = [];
          for (var Ag = ug, dg; Ag !== null; ) {
            var vg = Ag;
            if (dg = vg.stateNode, vg = vg.tag, vg !== 5 && vg !== 26 && vg !== 27 || dg === null || ag === null || (vg = ki(Ag, ag), vg != null && eI.push(
              De(Ag, vg, dg)
            )), zI) break;
            Ag = Ag.return;
          }
          0 < eI.length && (hg = new pg(
            hg,
            tI,
            null,
            c,
            jg
          ), Hg.push({ event: hg, listeners: eI }));
        }
      }
      if ((a & 7) === 0) {
        g: {
          if (hg = n === "mouseover" || n === "pointerover", pg = n === "mouseout" || n === "pointerout", hg && c !== Wc && (tI = c.relatedTarget || c.fromElement) && (Pn(tI) || tI[Ys]))
            break g;
          if ((pg || hg) && (hg = jg.window === jg ? jg : (hg = jg.ownerDocument) ? hg.defaultView || hg.parentWindow : window, pg ? (tI = c.relatedTarget || c.toElement, pg = ug, tI = tI ? Pn(tI) : null, tI !== null && (zI = r(tI), eI = tI.tag, tI !== zI || eI !== 5 && eI !== 27 && eI !== 6) && (tI = null)) : (pg = null, tI = ug), pg !== tI)) {
            if (eI = Rr, vg = "onMouseLeave", ag = "onMouseEnter", Ag = "mouse", (n === "pointerout" || n === "pointerover") && (eI = Ae, vg = "onPointerLeave", ag = "onPointerEnter", Ag = "pointer"), zI = pg == null ? hg : Ro(pg), dg = tI == null ? hg : Ro(tI), hg = new eI(
              vg,
              Ag + "leave",
              pg,
              c,
              jg
            ), hg.target = zI, hg.relatedTarget = dg, vg = null, Pn(jg) === ug && (eI = new eI(
              ag,
              Ag + "enter",
              tI,
              c,
              jg
            ), eI.target = dg, eI.relatedTarget = zI, vg = eI), zI = vg, pg && tI)
              I: {
                for (eI = pg, ag = tI, Ag = 0, dg = eI; dg; dg = os(dg))
                  Ag++;
                for (dg = 0, vg = ag; vg; vg = os(vg))
                  dg++;
                for (; 0 < Ag - dg; )
                  eI = os(eI), Ag--;
                for (; 0 < dg - Ag; )
                  ag = os(ag), dg--;
                for (; Ag--; ) {
                  if (eI === ag || ag !== null && eI === ag.alternate)
                    break I;
                  eI = os(eI), ag = os(ag);
                }
                eI = null;
              }
            else eI = null;
            pg !== null && id(
              Hg,
              hg,
              pg,
              eI,
              !1
            ), tI !== null && zI !== null && id(
              Hg,
              zI,
              tI,
              eI,
              !0
            );
          }
        }
        g: {
          if (hg = ug ? Ro(ug) : window, pg = hg.nodeName && hg.nodeName.toLowerCase(), pg === "select" || pg === "input" && hg.type === "file")
            var Lg = Hn;
          else if (ah(hg))
            if (rh)
              Lg = Wi;
            else {
              Lg = Iu;
              var mI = zM;
            }
          else
            pg = hg.nodeName, !pg || pg.toLowerCase() !== "input" || hg.type !== "checkbox" && hg.type !== "radio" ? ug && xo(ug.elementType) && (Lg = Hn) : Lg = En;
          if (Lg && (Lg = Lg(n, ug))) {
            $c(
              Hg,
              Lg,
              c,
              jg
            );
            break g;
          }
          mI && mI(n, hg, ug), n === "focusout" && ug && hg.type === "number" && ug.memoizedProps.value != null && Yr(hg, "number", hg.value);
        }
        switch (mI = ug ? Ro(ug) : window, n) {
          case "focusin":
            (ah(mI) || mI.contentEditable === "true") && (qe = mI, Us = ug, Pe = null);
            break;
          case "focusout":
            Pe = Us = qe = null;
            break;
          case "mousedown":
            Jo = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Jo = !1, Lo(Hg, c, jg);
            break;
          case "selectionchange":
            if (uh) break;
          case "keydown":
          case "keyup":
            Lo(Hg, c, jg);
        }
        var CI;
        if (Jc)
          g: {
            switch (n) {
              case "compositionstart":
                var iI = "onCompositionStart";
                break g;
              case "compositionend":
                iI = "onCompositionEnd";
                break g;
              case "compositionupdate":
                iI = "onCompositionUpdate";
                break g;
            }
            iI = void 0;
          }
        else
          Le ? qc(n, c) && (iI = "onCompositionEnd") : n === "keydown" && c.keyCode === 229 && (iI = "onCompositionStart");
        iI && (Lc && c.locale !== "ko" && (Le || iI !== "onCompositionStart" ? iI === "onCompositionEnd" && Le && (CI = jr()) : (Je = jg, xc = "value" in Je ? Je.value : Je.textContent, Le = !0)), mI = ss(ug, iI), 0 < mI.length && (iI = new Ch(
          iI,
          n,
          null,
          c,
          jg
        ), Hg.push({ event: iI, listeners: mI }), CI ? iI.data = CI : (CI = Nr(c), CI !== null && (iI.data = CI)))), (CI = O0 ? sh(n, c) : oh(n, c)) && (iI = ss(ug, "onBeforeInput"), 0 < iI.length && (mI = new Ch(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          jg
        ), Hg.push({
          event: mI,
          listeners: iI
        }), mI.data = CI)), ed(
          Hg,
          n,
          ug,
          c,
          jg
        );
      }
      an(Hg, a);
    });
  }
  function De(n, a, c) {
    return {
      instance: n,
      listener: a,
      currentTarget: c
    };
  }
  function ss(n, a) {
    for (var c = a + "Capture", f = []; n !== null; ) {
      var B = n, m = B.stateNode;
      if (B = B.tag, B !== 5 && B !== 26 && B !== 27 || m === null || (B = ki(n, c), B != null && f.unshift(
        De(n, B, m)
      ), B = ki(n, a), B != null && f.push(
        De(n, B, m)
      )), n.tag === 3) return f;
      n = n.return;
    }
    return [];
  }
  function os(n) {
    if (n === null) return null;
    do
      n = n.return;
    while (n && n.tag !== 5 && n.tag !== 27);
    return n || null;
  }
  function id(n, a, c, f, B) {
    for (var m = a._reactName, j = []; c !== null && c !== f; ) {
      var O = c, q = O.alternate, ug = O.stateNode;
      if (O = O.tag, q !== null && q === f) break;
      O !== 5 && O !== 26 && O !== 27 || ug === null || (q = ug, B ? (ug = ki(c, m), ug != null && j.unshift(
        De(c, ug, q)
      )) : B || (ug = ki(c, m), ug != null && j.push(
        De(c, ug, q)
      ))), c = c.return;
    }
    j.length !== 0 && n.push({ event: a, listeners: j });
  }
  var nd = /\r\n?/g, Ne = /\u0000|\uFFFD/g;
  function sd(n) {
    return (typeof n == "string" ? n : "" + n).replace(nd, `
`).replace(Ne, "");
  }
  function Yw(n, a) {
    return a = sd(a), sd(n) === a;
  }
  function Pl() {
  }
  function tA(n, a, c, f, B, m) {
    switch (c) {
      case "children":
        typeof f == "string" ? a === "body" || a === "textarea" && f === "" || js(n, f) : (typeof f == "number" || typeof f == "bigint") && a !== "body" && js(n, "" + f);
        break;
      case "className":
        Oi(n, "class", f);
        break;
      case "tabIndex":
        Oi(n, "tabindex", f);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Oi(n, c, f);
        break;
      case "style":
        kc(n, f, m);
        break;
      case "data":
        if (a !== "object") {
          Oi(n, "data", f);
          break;
        }
      case "src":
      case "href":
        if (f === "" && (a !== "a" || c !== "href")) {
          n.removeAttribute(c);
          break;
        }
        if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
          n.removeAttribute(c);
          break;
        }
        f = Zr("" + f), n.setAttribute(c, f);
        break;
      case "action":
      case "formAction":
        if (typeof f == "function") {
          n.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof m == "function" && (c === "formAction" ? (a !== "input" && tA(n, a, "name", B.name, B, null), tA(
            n,
            a,
            "formEncType",
            B.formEncType,
            B,
            null
          ), tA(
            n,
            a,
            "formMethod",
            B.formMethod,
            B,
            null
          ), tA(
            n,
            a,
            "formTarget",
            B.formTarget,
            B,
            null
          )) : (tA(n, a, "encType", B.encType, B, null), tA(n, a, "method", B.method, B, null), tA(n, a, "target", B.target, B, null)));
        if (f == null || typeof f == "symbol" || typeof f == "boolean") {
          n.removeAttribute(c);
          break;
        }
        f = Zr("" + f), n.setAttribute(c, f);
        break;
      case "onClick":
        f != null && (n.onclick = Pl);
        break;
      case "onScroll":
        f != null && DI("scroll", n);
        break;
      case "onScrollEnd":
        f != null && DI("scrollend", n);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(t(61));
          if (c = f.__html, c != null) {
            if (B.children != null) throw Error(t(60));
            n.innerHTML = c;
          }
        }
        break;
      case "multiple":
        n.multiple = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "muted":
        n.muted = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
          n.removeAttribute("xlink:href");
          break;
        }
        c = Zr("" + f), n.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        f != null && typeof f != "function" && typeof f != "symbol" ? n.setAttribute(c, "" + f) : n.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        f && typeof f != "function" && typeof f != "symbol" ? n.setAttribute(c, "") : n.removeAttribute(c);
        break;
      case "capture":
      case "download":
        f === !0 ? n.setAttribute(c, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? n.setAttribute(c, f) : n.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? n.setAttribute(c, f) : n.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? n.removeAttribute(c) : n.setAttribute(c, f);
        break;
      case "popover":
        DI("beforetoggle", n), DI("toggle", n), Tr(n, "popover", f);
        break;
      case "xlinkActuate":
        Ci(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          f
        );
        break;
      case "xlinkArcrole":
        Ci(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          f
        );
        break;
      case "xlinkRole":
        Ci(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          f
        );
        break;
      case "xlinkShow":
        Ci(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          f
        );
        break;
      case "xlinkTitle":
        Ci(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          f
        );
        break;
      case "xlinkType":
        Ci(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          f
        );
        break;
      case "xmlBase":
        Ci(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          f
        );
        break;
      case "xmlLang":
        Ci(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          f
        );
        break;
      case "xmlSpace":
        Ci(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          f
        );
        break;
      case "is":
        Tr(n, "is", f);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = Pr.get(c) || c, Tr(n, c, f));
    }
  }
  function gC(n, a, c, f, B, m) {
    switch (c) {
      case "style":
        kc(n, f, m);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(t(61));
          if (c = f.__html, c != null) {
            if (B.children != null) throw Error(t(60));
            n.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof f == "string" ? js(n, f) : (typeof f == "number" || typeof f == "bigint") && js(n, "" + f);
        break;
      case "onScroll":
        f != null && DI("scroll", n);
        break;
      case "onScrollEnd":
        f != null && DI("scrollend", n);
        break;
      case "onClick":
        f != null && (n.onclick = Pl);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Kr.hasOwnProperty(c))
          g: {
            if (c[0] === "o" && c[1] === "n" && (B = c.endsWith("Capture"), a = c.slice(2, B ? c.length - 7 : void 0), m = n[jC] || null, m = m != null ? m[c] : null, typeof m == "function" && n.removeEventListener(a, m, B), typeof f == "function")) {
              typeof m != "function" && m !== null && (c in n ? n[c] = null : n.hasAttribute(c) && n.removeAttribute(c)), n.addEventListener(a, f, B);
              break g;
            }
            c in n ? n[c] = f : f === !0 ? n.setAttribute(c, "") : Tr(n, c, f);
          }
    }
  }
  function Dg(n, a, c) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        DI("error", n), DI("load", n);
        var f = !1, B = !1, m;
        for (m in c)
          if (c.hasOwnProperty(m)) {
            var j = c[m];
            if (j != null)
              switch (m) {
                case "src":
                  f = !0;
                  break;
                case "srcSet":
                  B = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(t(137, a));
                default:
                  tA(n, a, m, j, c, null);
              }
          }
        B && tA(n, a, "srcSet", c.srcSet, c, null), f && tA(n, a, "src", c.src, c, null);
        return;
      case "input":
        DI("invalid", n);
        var O = m = j = B = null, q = null, ug = null;
        for (f in c)
          if (c.hasOwnProperty(f)) {
            var jg = c[f];
            if (jg != null)
              switch (f) {
                case "name":
                  B = jg;
                  break;
                case "type":
                  j = jg;
                  break;
                case "checked":
                  q = jg;
                  break;
                case "defaultChecked":
                  ug = jg;
                  break;
                case "value":
                  m = jg;
                  break;
                case "defaultValue":
                  O = jg;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (jg != null)
                    throw Error(t(137, a));
                  break;
                default:
                  tA(n, a, f, jg, c, null);
              }
          }
        Jf(
          n,
          m,
          O,
          q,
          ug,
          j,
          B,
          !1
        ), Wo(n);
        return;
      case "select":
        DI("invalid", n), f = j = m = null;
        for (B in c)
          if (c.hasOwnProperty(B) && (O = c[B], O != null))
            switch (B) {
              case "value":
                m = O;
                break;
              case "defaultValue":
                j = O;
                break;
              case "multiple":
                f = O;
              default:
                tA(n, a, B, O, c, null);
            }
        a = m, c = j, n.multiple = !!f, a != null ? jn(n, !!f, a, !1) : c != null && jn(n, !!f, c, !0);
        return;
      case "textarea":
        DI("invalid", n), m = B = f = null;
        for (j in c)
          if (c.hasOwnProperty(j) && (O = c[j], O != null))
            switch (j) {
              case "value":
                f = O;
                break;
              case "defaultValue":
                B = O;
                break;
              case "children":
                m = O;
                break;
              case "dangerouslySetInnerHTML":
                if (O != null) throw Error(t(91));
                break;
              default:
                tA(n, a, j, O, c, null);
            }
        qf(n, f, B, m), Wo(n);
        return;
      case "option":
        for (q in c)
          if (c.hasOwnProperty(q) && (f = c[q], f != null))
            switch (q) {
              case "selected":
                n.selected = f && typeof f != "function" && typeof f != "symbol";
                break;
              default:
                tA(n, a, q, f, c, null);
            }
        return;
      case "dialog":
        DI("beforetoggle", n), DI("toggle", n), DI("cancel", n), DI("close", n);
        break;
      case "iframe":
      case "object":
        DI("load", n);
        break;
      case "video":
      case "audio":
        for (f = 0; f < uI.length; f++)
          DI(uI[f], n);
        break;
      case "image":
        DI("error", n), DI("load", n);
        break;
      case "details":
        DI("toggle", n);
        break;
      case "embed":
      case "source":
      case "link":
        DI("error", n), DI("load", n);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ug in c)
          if (c.hasOwnProperty(ug) && (f = c[ug], f != null))
            switch (ug) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(137, a));
              default:
                tA(n, a, ug, f, c, null);
            }
        return;
      default:
        if (xo(a)) {
          for (jg in c)
            c.hasOwnProperty(jg) && (f = c[jg], f !== void 0 && gC(
              n,
              a,
              jg,
              f,
              c,
              void 0
            ));
          return;
        }
    }
    for (O in c)
      c.hasOwnProperty(O) && (f = c[O], f != null && tA(n, a, O, f, c, null));
  }
  function QI(n, a, c, f) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var B = null, m = null, j = null, O = null, q = null, ug = null, jg = null;
        for (pg in c) {
          var Hg = c[pg];
          if (c.hasOwnProperty(pg) && Hg != null)
            switch (pg) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                q = Hg;
              default:
                f.hasOwnProperty(pg) || tA(n, a, pg, null, f, Hg);
            }
        }
        for (var hg in f) {
          var pg = f[hg];
          if (Hg = c[hg], f.hasOwnProperty(hg) && (pg != null || Hg != null))
            switch (hg) {
              case "type":
                m = pg;
                break;
              case "name":
                B = pg;
                break;
              case "checked":
                ug = pg;
                break;
              case "defaultChecked":
                jg = pg;
                break;
              case "value":
                j = pg;
                break;
              case "defaultValue":
                O = pg;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (pg != null)
                  throw Error(t(137, a));
                break;
              default:
                pg !== Hg && tA(
                  n,
                  a,
                  hg,
                  pg,
                  f,
                  Hg
                );
            }
        }
        zf(
          n,
          j,
          O,
          q,
          ug,
          jg,
          m,
          B
        );
        return;
      case "select":
        pg = j = O = hg = null;
        for (m in c)
          if (q = c[m], c.hasOwnProperty(m) && q != null)
            switch (m) {
              case "value":
                break;
              case "multiple":
                pg = q;
              default:
                f.hasOwnProperty(m) || tA(
                  n,
                  a,
                  m,
                  null,
                  f,
                  q
                );
            }
        for (B in f)
          if (m = f[B], q = c[B], f.hasOwnProperty(B) && (m != null || q != null))
            switch (B) {
              case "value":
                hg = m;
                break;
              case "defaultValue":
                O = m;
                break;
              case "multiple":
                j = m;
              default:
                m !== q && tA(
                  n,
                  a,
                  B,
                  m,
                  f,
                  q
                );
            }
        a = O, c = j, f = pg, hg != null ? jn(n, !!c, hg, !1) : !!f != !!c && (a != null ? jn(n, !!c, a, !0) : jn(n, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        pg = hg = null;
        for (O in c)
          if (B = c[O], c.hasOwnProperty(O) && B != null && !f.hasOwnProperty(O))
            switch (O) {
              case "value":
                break;
              case "children":
                break;
              default:
                tA(n, a, O, null, f, B);
            }
        for (j in f)
          if (B = f[j], m = c[j], f.hasOwnProperty(j) && (B != null || m != null))
            switch (j) {
              case "value":
                hg = B;
                break;
              case "defaultValue":
                pg = B;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (B != null) throw Error(t(91));
                break;
              default:
                B !== m && tA(n, a, j, B, f, m);
            }
        Lf(n, hg, pg);
        return;
      case "option":
        for (var tI in c)
          if (hg = c[tI], c.hasOwnProperty(tI) && hg != null && !f.hasOwnProperty(tI))
            switch (tI) {
              case "selected":
                n.selected = !1;
                break;
              default:
                tA(
                  n,
                  a,
                  tI,
                  null,
                  f,
                  hg
                );
            }
        for (q in f)
          if (hg = f[q], pg = c[q], f.hasOwnProperty(q) && hg !== pg && (hg != null || pg != null))
            switch (q) {
              case "selected":
                n.selected = hg && typeof hg != "function" && typeof hg != "symbol";
                break;
              default:
                tA(
                  n,
                  a,
                  q,
                  hg,
                  f,
                  pg
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var eI in c)
          hg = c[eI], c.hasOwnProperty(eI) && hg != null && !f.hasOwnProperty(eI) && tA(n, a, eI, null, f, hg);
        for (ug in f)
          if (hg = f[ug], pg = c[ug], f.hasOwnProperty(ug) && hg !== pg && (hg != null || pg != null))
            switch (ug) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (hg != null)
                  throw Error(t(137, a));
                break;
              default:
                tA(
                  n,
                  a,
                  ug,
                  hg,
                  f,
                  pg
                );
            }
        return;
      default:
        if (xo(a)) {
          for (var zI in c)
            hg = c[zI], c.hasOwnProperty(zI) && hg !== void 0 && !f.hasOwnProperty(zI) && gC(
              n,
              a,
              zI,
              void 0,
              f,
              hg
            );
          for (jg in f)
            hg = f[jg], pg = c[jg], !f.hasOwnProperty(jg) || hg === pg || hg === void 0 && pg === void 0 || gC(
              n,
              a,
              jg,
              hg,
              f,
              pg
            );
          return;
        }
    }
    for (var ag in c)
      hg = c[ag], c.hasOwnProperty(ag) && hg != null && !f.hasOwnProperty(ag) && tA(n, a, ag, null, f, hg);
    for (Hg in f)
      hg = f[Hg], pg = c[Hg], !f.hasOwnProperty(Hg) || hg === pg || hg == null && pg == null || tA(n, a, Hg, hg, f, pg);
  }
  var vy = null, Zl = null;
  function Oa(n) {
    return n.nodeType === 9 ? n : n.ownerDocument;
  }
  function ri(n) {
    switch (n) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function rn(n, a) {
    if (n === 0)
      switch (a) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return n === 1 && a === "foreignObject" ? 0 : n;
  }
  function lo(n, a) {
    return n === "textarea" || n === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.children == "bigint" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
  }
  var li = null;
  function od() {
    var n = window.event;
    return n && n.type === "popstate" ? n === li ? !1 : (li = n, !0) : (li = null, !1);
  }
  var ci = typeof setTimeout == "function" ? setTimeout : void 0, Hy = typeof clearTimeout == "function" ? clearTimeout : void 0, Pw = typeof Promise == "function" ? Promise : void 0, Q0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Pw < "u" ? function(n) {
    return Pw.resolve(null).then(n).catch(z0);
  } : ci;
  function z0(n) {
    setTimeout(function() {
      throw n;
    });
  }
  function BC(n) {
    return n === "head";
  }
  function Zw(n, a) {
    var c = a, f = 0, B = 0;
    do {
      var m = c.nextSibling;
      if (n.removeChild(c), m && m.nodeType === 8)
        if (c = m.data, c === "/$") {
          if (0 < f && 8 > f) {
            c = f;
            var j = n.ownerDocument;
            if (c & 1 && Qg(j.documentElement), c & 2 && Qg(j.body), c & 4)
              for (c = j.head, Qg(c), j = c.firstChild; j; ) {
                var O = j.nextSibling, q = j.nodeName;
                j[Gr] || q === "SCRIPT" || q === "STYLE" || q === "LINK" && j.rel.toLowerCase() === "stylesheet" || c.removeChild(j), j = O;
              }
          }
          if (B === 0) {
            n.removeChild(m), Ua(a);
            return;
          }
          B--;
        } else
          c === "$" || c === "$?" || c === "$!" ? B++ : f = c.charCodeAt(0) - 48;
      else f = 0;
      c = m;
    } while (c);
    Ua(a);
  }
  function jl(n) {
    var a = n.firstChild;
    for (a && a.nodeType === 10 && (a = a.nextSibling); a; ) {
      var c = a;
      switch (a = a.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          jl(c), gI(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      n.removeChild(c);
    }
  }
  function Ey(n, a, c, f) {
    for (; n.nodeType === 1; ) {
      var B = c;
      if (n.nodeName.toLowerCase() !== a.toLowerCase()) {
        if (!f && (n.nodeName !== "INPUT" || n.type !== "hidden"))
          break;
      } else if (f) {
        if (!n[Gr])
          switch (a) {
            case "meta":
              if (!n.hasAttribute("itemprop")) break;
              return n;
            case "link":
              if (m = n.getAttribute("rel"), m === "stylesheet" && n.hasAttribute("data-precedence"))
                break;
              if (m !== B.rel || n.getAttribute("href") !== (B.href == null || B.href === "" ? null : B.href) || n.getAttribute("crossorigin") !== (B.crossOrigin == null ? null : B.crossOrigin) || n.getAttribute("title") !== (B.title == null ? null : B.title))
                break;
              return n;
            case "style":
              if (n.hasAttribute("data-precedence")) break;
              return n;
            case "script":
              if (m = n.getAttribute("src"), (m !== (B.src == null ? null : B.src) || n.getAttribute("type") !== (B.type == null ? null : B.type) || n.getAttribute("crossorigin") !== (B.crossOrigin == null ? null : B.crossOrigin)) && m && n.hasAttribute("async") && !n.hasAttribute("itemprop"))
                break;
              return n;
            default:
              return n;
          }
      } else if (a === "input" && n.type === "hidden") {
        var m = B.name == null ? null : "" + B.name;
        if (B.type === "hidden" && n.getAttribute("name") === m)
          return n;
      } else return n;
      if (n = Rt(n.nextSibling), n === null) break;
    }
    return null;
  }
  function Na(n, a, c) {
    if (a === "") return null;
    for (; n.nodeType !== 3; )
      if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !c || (n = Rt(n.nextSibling), n === null)) return null;
    return n;
  }
  function Ry(n) {
    return n.data === "$!" || n.data === "$?" && n.ownerDocument.readyState === "complete";
  }
  function Oy(n, a) {
    var c = n.ownerDocument;
    if (n.data !== "$?" || c.readyState === "complete")
      a();
    else {
      var f = function() {
        a(), c.removeEventListener("DOMContentLoaded", f);
      };
      c.addEventListener("DOMContentLoaded", f), n._reactRetry = f;
    }
  }
  function Rt(n) {
    for (; n != null; n = n.nextSibling) {
      var a = n.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (a = n.data, a === "$" || a === "$!" || a === "$?" || a === "F!" || a === "F")
          break;
        if (a === "/$") return null;
      }
    }
    return n;
  }
  var Ny = null;
  function co(n) {
    n = n.previousSibling;
    for (var a = 0; n; ) {
      if (n.nodeType === 8) {
        var c = n.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (a === 0) return n;
          a--;
        } else c === "/$" && a++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  function pC(n, a, c) {
    switch (a = Oa(c), n) {
      case "html":
        if (n = a.documentElement, !n) throw Error(t(452));
        return n;
      case "head":
        if (n = a.head, !n) throw Error(t(453));
        return n;
      case "body":
        if (n = a.body, !n) throw Error(t(454));
        return n;
      default:
        throw Error(t(451));
    }
  }
  function Qg(n) {
    for (var a = n.attributes; a.length; )
      n.removeAttributeNode(a[0]);
    gI(n);
  }
  var kA = /* @__PURE__ */ new Map(), nt = /* @__PURE__ */ new Set();
  function oC(n) {
    return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument;
  }
  var ln = Q.d;
  Q.d = {
    f: J0,
    r: ad,
    D: ui,
    C: un,
    L: rd,
    m: as,
    X: Me,
    S: OC,
    M: rs
  };
  function J0() {
    var n = ln.f(), a = pl();
    return n || a;
  }
  function ad(n) {
    var a = yC(n);
    a !== null && a.tag === 5 && a.type === "form" ? Aw(a) : ln.r(n);
  }
  var cn = typeof document > "u" ? null : document;
  function ke(n, a, c) {
    var f = cn;
    if (f && typeof a == "string" && a) {
      var B = ze(a);
      B = 'link[rel="' + n + '"][href="' + B + '"]', typeof c == "string" && (B += '[crossorigin="' + c + '"]'), nt.has(B) || (nt.add(B), n = { rel: n, crossOrigin: c, href: a }, f.querySelector(B) === null && (a = f.createElement("link"), Dg(a, "link", n), OA(a), f.head.appendChild(a)));
    }
  }
  function ui(n) {
    ln.D(n), ke("dns-prefetch", n, null);
  }
  function un(n, a) {
    ln.C(n, a), ke("preconnect", n, a);
  }
  function rd(n, a, c) {
    ln.L(n, a, c);
    var f = cn;
    if (f && n && a) {
      var B = 'link[rel="preload"][as="' + ze(a) + '"]';
      a === "image" && c && c.imageSrcSet ? (B += '[imagesrcset="' + ze(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (B += '[imagesizes="' + ze(
        c.imageSizes
      ) + '"]')) : B += '[href="' + ze(n) + '"]';
      var m = B;
      switch (a) {
        case "style":
          m = ka(n);
          break;
        case "script":
          m = uo(n);
      }
      kA.has(m) || (n = w(
        {
          rel: "preload",
          href: a === "image" && c && c.imageSrcSet ? void 0 : n,
          as: a
        },
        c
      ), kA.set(m, n), f.querySelector(B) !== null || a === "style" && f.querySelector(vl(m)) || a === "script" && f.querySelector(Ot(m)) || (a = f.createElement("link"), Dg(a, "link", n), OA(a), f.head.appendChild(a)));
    }
  }
  function as(n, a) {
    ln.m(n, a);
    var c = cn;
    if (c && n) {
      var f = a && typeof a.as == "string" ? a.as : "script", B = 'link[rel="modulepreload"][as="' + ze(f) + '"][href="' + ze(n) + '"]', m = B;
      switch (f) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          m = uo(n);
      }
      if (!kA.has(m) && (n = w({ rel: "modulepreload", href: n }, a), kA.set(m, n), c.querySelector(B) === null)) {
        switch (f) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(Ot(m)))
              return;
        }
        f = c.createElement("link"), Dg(f, "link", n), OA(f), c.head.appendChild(f);
      }
    }
  }
  function OC(n, a, c) {
    ln.S(n, a, c);
    var f = cn;
    if (f && n) {
      var B = Oo(f).hoistableStyles, m = ka(n);
      a = a || "default";
      var j = B.get(m);
      if (!j) {
        var O = { loading: 0, preload: null };
        if (j = f.querySelector(
          vl(m)
        ))
          O.loading = 5;
        else {
          n = w(
            { rel: "stylesheet", href: n, "data-precedence": a },
            c
          ), (c = kA.get(m)) && Wy(n, c);
          var q = j = f.createElement("link");
          OA(q), Dg(q, "link", n), q._p = new Promise(function(ug, jg) {
            q.onload = ug, q.onerror = jg;
          }), q.addEventListener("load", function() {
            O.loading |= 1;
          }), q.addEventListener("error", function() {
            O.loading |= 2;
          }), O.loading |= 4, ud(j, a, f);
        }
        j = {
          type: "stylesheet",
          instance: j,
          count: 1,
          state: O
        }, B.set(m, j);
      }
    }
  }
  function Me(n, a) {
    ln.X(n, a);
    var c = cn;
    if (c && n) {
      var f = Oo(c).hoistableScripts, B = uo(n), m = f.get(B);
      m || (m = c.querySelector(Ot(B)), m || (n = w({ src: n, async: !0 }, a), (a = kA.get(B)) && dd(n, a), m = c.createElement("script"), OA(m), Dg(m, "link", n), c.head.appendChild(m)), m = {
        type: "script",
        instance: m,
        count: 1,
        state: null
      }, f.set(B, m));
    }
  }
  function rs(n, a) {
    ln.M(n, a);
    var c = cn;
    if (c && n) {
      var f = Oo(c).hoistableScripts, B = uo(n), m = f.get(B);
      m || (m = c.querySelector(Ot(B)), m || (n = w({ src: n, async: !0, type: "module" }, a), (a = kA.get(B)) && dd(n, a), m = c.createElement("script"), OA(m), Dg(m, "link", n), c.head.appendChild(m)), m = {
        type: "script",
        instance: m,
        count: 1,
        state: null
      }, f.set(B, m));
    }
  }
  function ld(n, a, c, f) {
    var B = (B = Yg.current) ? oC(B) : null;
    if (!B) throw Error(t(446));
    switch (n) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (a = ka(c.href), c = Oo(
          B
        ).hoistableStyles, f = c.get(a), f || (f = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(a, f)), f) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          n = ka(c.href);
          var m = Oo(
            B
          ).hoistableStyles, j = m.get(n);
          if (j || (B = B.ownerDocument || B, j = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, m.set(n, j), (m = B.querySelector(
            vl(n)
          )) && !m._p && (j.instance = m, j.state.loading = 5), kA.has(n) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, kA.set(n, c), m || Hl(
            B,
            n,
            c,
            j.state
          ))), a && f === null)
            throw Error(t(528, ""));
          return j;
        }
        if (a && f !== null)
          throw Error(t(529, ""));
        return null;
      case "script":
        return a = c.async, c = c.src, typeof c == "string" && a && typeof a != "function" && typeof a != "symbol" ? (a = uo(c), c = Oo(
          B
        ).hoistableScripts, f = c.get(a), f || (f = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(a, f)), f) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(t(444, n));
    }
  }
  function ka(n) {
    return 'href="' + ze(n) + '"';
  }
  function vl(n) {
    return 'link[rel="stylesheet"][' + n + "]";
  }
  function ky(n) {
    return w({}, n, {
      "data-precedence": n.precedence,
      precedence: null
    });
  }
  function Hl(n, a, c, f) {
    n.querySelector('link[rel="preload"][as="style"][' + a + "]") ? f.loading = 1 : (a = n.createElement("link"), f.preload = a, a.addEventListener("load", function() {
      return f.loading |= 1;
    }), a.addEventListener("error", function() {
      return f.loading |= 2;
    }), Dg(a, "link", c), OA(a), n.head.appendChild(a));
  }
  function uo(n) {
    return '[src="' + ze(n) + '"]';
  }
  function Ot(n) {
    return "script[async]" + n;
  }
  function cd(n, a, c) {
    if (a.count++, a.instance === null)
      switch (a.type) {
        case "style":
          var f = n.querySelector(
            'style[data-href~="' + ze(c.href) + '"]'
          );
          if (f)
            return a.instance = f, OA(f), f;
          var B = w({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return f = (n.ownerDocument || n).createElement(
            "style"
          ), OA(f), Dg(f, "style", B), ud(f, c.precedence, n), a.instance = f;
        case "stylesheet":
          B = ka(c.href);
          var m = n.querySelector(
            vl(B)
          );
          if (m)
            return a.state.loading |= 4, a.instance = m, OA(m), m;
          f = ky(c), (B = kA.get(B)) && Wy(f, B), m = (n.ownerDocument || n).createElement("link"), OA(m);
          var j = m;
          return j._p = new Promise(function(O, q) {
            j.onload = O, j.onerror = q;
          }), Dg(m, "link", f), a.state.loading |= 4, ud(m, c.precedence, n), a.instance = m;
        case "script":
          return m = uo(c.src), (B = n.querySelector(
            Ot(m)
          )) ? (a.instance = B, OA(B), B) : (f = c, (B = kA.get(m)) && (f = w({}, c), dd(f, B)), n = n.ownerDocument || n, B = n.createElement("script"), OA(B), Dg(B, "link", f), n.head.appendChild(B), a.instance = B);
        case "void":
          return null;
        default:
          throw Error(t(443, a.type));
      }
    else
      a.type === "stylesheet" && (a.state.loading & 4) === 0 && (f = a.instance, a.state.loading |= 4, ud(f, c.precedence, n));
    return a.instance;
  }
  function ud(n, a, c) {
    for (var f = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), B = f.length ? f[f.length - 1] : null, m = B, j = 0; j < f.length; j++) {
      var O = f[j];
      if (O.dataset.precedence === a) m = O;
      else if (m !== B) break;
    }
    m ? m.parentNode.insertBefore(n, m.nextSibling) : (a = c.nodeType === 9 ? c.head : c, a.insertBefore(n, a.firstChild));
  }
  function Wy(n, a) {
    n.crossOrigin == null && (n.crossOrigin = a.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = a.referrerPolicy), n.title == null && (n.title = a.title);
  }
  function dd(n, a) {
    n.crossOrigin == null && (n.crossOrigin = a.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = a.referrerPolicy), n.integrity == null && (n.integrity = a.integrity);
  }
  var El = null;
  function Wa(n, a, c) {
    if (El === null) {
      var f = /* @__PURE__ */ new Map(), B = El = /* @__PURE__ */ new Map();
      B.set(c, f);
    } else
      B = El, f = B.get(c), f || (f = /* @__PURE__ */ new Map(), B.set(c, f));
    if (f.has(n)) return f;
    for (f.set(n, null), c = c.getElementsByTagName(n), B = 0; B < c.length; B++) {
      var m = c[B];
      if (!(m[Gr] || m[sA] || n === "link" && m.getAttribute("rel") === "stylesheet") && m.namespaceURI !== "http://www.w3.org/2000/svg") {
        var j = m.getAttribute(a) || "";
        j = n + j;
        var O = f.get(j);
        O ? O.push(m) : f.set(j, [m]);
      }
    }
    return f;
  }
  function Vy(n, a, c) {
    n = n.ownerDocument || n, n.head.insertBefore(
      c,
      a === "title" ? n.querySelector("head > title") : null
    );
  }
  function jw(n, a, c) {
    if (c === 1 || a.itemProp != null) return !1;
    switch (n) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof a.precedence != "string" || typeof a.href != "string" || a.href === "")
          break;
        return !0;
      case "link":
        if (typeof a.rel != "string" || typeof a.href != "string" || a.href === "" || a.onLoad || a.onError)
          break;
        switch (a.rel) {
          case "stylesheet":
            return n = a.disabled, typeof a.precedence == "string" && n == null;
          default:
            return !0;
        }
      case "script":
        if (a.async && typeof a.async != "function" && typeof a.async != "symbol" && !a.onLoad && !a.onError && a.src && typeof a.src == "string")
          return !0;
    }
    return !1;
  }
  function xy(n) {
    return !(n.type === "stylesheet" && (n.state.loading & 3) === 0);
  }
  var Va = null;
  function vw() {
  }
  function Hw(n, a, c) {
    if (Va === null) throw Error(t(475));
    var f = Va;
    if (a.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (a.state.loading & 4) === 0) {
      if (a.instance === null) {
        var B = ka(c.href), m = n.querySelector(
          vl(B)
        );
        if (m) {
          n = m._p, n !== null && typeof n == "object" && typeof n.then == "function" && (f.count++, f = xa.bind(f), n.then(f, f)), a.state.loading |= 4, a.instance = m, OA(m);
          return;
        }
        m = n.ownerDocument || n, c = ky(c), (B = kA.get(B)) && Wy(c, B), m = m.createElement("link"), OA(m);
        var j = m;
        j._p = new Promise(function(O, q) {
          j.onload = O, j.onerror = q;
        }), Dg(m, "link", c), a.instance = m;
      }
      f.stylesheets === null && (f.stylesheets = /* @__PURE__ */ new Map()), f.stylesheets.set(a, n), (n = a.state.preload) && (a.state.loading & 3) === 0 && (f.count++, a = xa.bind(f), n.addEventListener("load", a), n.addEventListener("error", a));
    }
  }
  function Ew() {
    if (Va === null) throw Error(t(475));
    var n = Va;
    return n.stylesheets && n.count === 0 && Ol(n, n.stylesheets), 0 < n.count ? function(a) {
      var c = setTimeout(function() {
        if (n.stylesheets && Ol(n, n.stylesheets), n.unsuspend) {
          var f = n.unsuspend;
          n.unsuspend = null, f();
        }
      }, 6e4);
      return n.unsuspend = a, function() {
        n.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function xa() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Ol(this, this.stylesheets);
      else if (this.unsuspend) {
        var n = this.unsuspend;
        this.unsuspend = null, n();
      }
    }
  }
  var Rl = null;
  function Ol(n, a) {
    n.stylesheets = null, n.unsuspend !== null && (n.count++, Rl = /* @__PURE__ */ new Map(), a.forEach(_y, n), Rl = null, xa.call(n));
  }
  function _y(n, a) {
    if (!(a.state.loading & 4)) {
      var c = Rl.get(n);
      if (c) var f = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), Rl.set(n, c);
        for (var B = n.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), m = 0; m < B.length; m++) {
          var j = B[m];
          (j.nodeName === "LINK" || j.getAttribute("media") !== "not all") && (c.set(j.dataset.precedence, j), f = j);
        }
        f && c.set(null, f);
      }
      B = a.instance, j = B.getAttribute("data-precedence"), m = c.get(j) || f, m === f && c.set(null, B), c.set(j, B), this.count++, f = xa.bind(this), B.addEventListener("load", f), B.addEventListener("error", f), m ? m.parentNode.insertBefore(B, m.nextSibling) : (n = n.nodeType === 9 ? n.head : n, n.insertBefore(B, n.firstChild)), a.state.loading |= 4;
    }
  }
  var mC = {
    $$typeof: R,
    Provider: null,
    Consumer: null,
    _currentValue: Bg,
    _currentValue2: Bg,
    _threadCount: 0
  };
  function di(n, a, c, f, B, m, j, O) {
    this.tag = 1, this.containerInfo = n, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = _g(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = _g(0), this.hiddenUpdates = _g(null), this.identifierPrefix = f, this.onUncaughtError = B, this.onCaughtError = m, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = O, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Rw(n, a, c, f, B, m, j, O, q, ug, jg, Hg) {
    return n = new di(
      n,
      a,
      c,
      j,
      O,
      q,
      ug,
      Hg
    ), a = 1, m === !0 && (a |= 24), m = te(3, null, null, a), n.current = m, m.stateNode = n, a = Bh(), a.refCount++, n.pooledCache = a, a.refCount++, m.memoizedState = {
      element: f,
      isDehydrated: c,
      cache: a
    }, $r(m), n;
  }
  function Uy(n) {
    return n ? (n = Xs, n) : Xs;
  }
  function Fy(n, a, c, f, B, m) {
    B = Uy(B), f.context === null ? f.context = B : f.pendingContext = B, f = Ji(a), f.payload = { element: c }, m = m === void 0 ? null : m, m !== null && (f.callback = m), c = se(n, f, a), c !== null && (ye(c, n, a), Js(c, n, a));
  }
  function Xy(n, a) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var c = n.retryLane;
      n.retryLane = c !== 0 && c < a ? c : a;
    }
  }
  function fd(n, a) {
    Xy(n, a), (n = n.alternate) && Xy(n, a);
  }
  function Qy(n) {
    if (n.tag === 13) {
      var a = _i(n, 67108864);
      a !== null && ye(a, n, 67108864), fd(n, 67108864);
    }
  }
  var Nl = !0;
  function Ow(n, a, c, f) {
    var B = z.T;
    z.T = null;
    var m = Q.p;
    try {
      Q.p = 2, hd(n, a, c, f);
    } finally {
      Q.p = m, z.T = B;
    }
  }
  function Nw(n, a, c, f) {
    var B = z.T;
    z.T = null;
    var m = Q.p;
    try {
      Q.p = 8, hd(n, a, c, f);
    } finally {
      Q.p = m, z.T = B;
    }
  }
  function hd(n, a, c, f) {
    if (Nl) {
      var B = zy(f);
      if (B === null)
        Yl(
          n,
          a,
          f,
          kl,
          c
        ), Ly(n, f);
      else if (qy(
        B,
        n,
        a,
        c,
        f
      ))
        f.stopPropagation();
      else if (Ly(n, f), a & 4 && -1 < L0.indexOf(n)) {
        for (; B !== null; ) {
          var m = yC(B);
          if (m !== null)
            switch (m.tag) {
              case 3:
                if (m = m.stateNode, m.current.memoizedState.isDehydrated) {
                  var j = JA(m.pendingLanes);
                  if (j !== 0) {
                    var O = m;
                    for (O.pendingLanes |= 2, O.entangledLanes |= 2; j; ) {
                      var q = 1 << 31 - pA(j);
                      O.entanglements[1] |= q, j &= ~q;
                    }
                    Et(m), (LI & 6) === 0 && (xu = vI() + 500, on(0));
                  }
                }
                break;
              case 13:
                O = _i(m, 2), O !== null && ye(O, m, 2), pl(), fd(m, 2);
            }
          if (m = zy(f), m === null && Yl(
            n,
            a,
            f,
            kl,
            c
          ), m === B) break;
          B = m;
        }
        B !== null && f.stopPropagation();
      } else
        Yl(
          n,
          a,
          f,
          null,
          c
        );
    }
  }
  function zy(n) {
    return n = vs(n), Jy(n);
  }
  var kl = null;
  function Jy(n) {
    if (kl = null, n = Pn(n), n !== null) {
      var a = r(n);
      if (a === null) n = null;
      else {
        var c = a.tag;
        if (c === 13) {
          if (n = l(a), n !== null) return n;
          n = null;
        } else if (c === 3) {
          if (a.stateNode.current.memoizedState.isDehydrated)
            return a.tag === 3 ? a.stateNode.containerInfo : null;
          n = null;
        } else a !== n && (n = null);
      }
    }
    return kl = n, null;
  }
  function kw(n) {
    switch (n) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (CC()) {
          case hC:
            return 2;
          case Lt:
            return 8;
          case rI:
          case lt:
            return 32;
          case qt:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var yd = !1, Nt = null, fi = null, dn = null, _a = /* @__PURE__ */ new Map(), Wl = /* @__PURE__ */ new Map(), ls = [], L0 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Ly(n, a) {
    switch (n) {
      case "focusin":
      case "focusout":
        Nt = null;
        break;
      case "dragenter":
      case "dragleave":
        fi = null;
        break;
      case "mouseover":
      case "mouseout":
        dn = null;
        break;
      case "pointerover":
      case "pointerout":
        _a.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Wl.delete(a.pointerId);
    }
  }
  function hi(n, a, c, f, B, m) {
    return n === null || n.nativeEvent !== m ? (n = {
      blockedOn: a,
      domEventName: c,
      eventSystemFlags: f,
      nativeEvent: m,
      targetContainers: [B]
    }, a !== null && (a = yC(a), a !== null && Qy(a)), n) : (n.eventSystemFlags |= f, a = n.targetContainers, B !== null && a.indexOf(B) === -1 && a.push(B), n);
  }
  function qy(n, a, c, f, B) {
    switch (a) {
      case "focusin":
        return Nt = hi(
          Nt,
          n,
          a,
          c,
          f,
          B
        ), !0;
      case "dragenter":
        return fi = hi(
          fi,
          n,
          a,
          c,
          f,
          B
        ), !0;
      case "mouseover":
        return dn = hi(
          dn,
          n,
          a,
          c,
          f,
          B
        ), !0;
      case "pointerover":
        var m = B.pointerId;
        return _a.set(
          m,
          hi(
            _a.get(m) || null,
            n,
            a,
            c,
            f,
            B
          )
        ), !0;
      case "gotpointercapture":
        return m = B.pointerId, Wl.set(
          m,
          hi(
            Wl.get(m) || null,
            n,
            a,
            c,
            f,
            B
          )
        ), !0;
    }
    return !1;
  }
  function $y(n) {
    var a = Pn(n.target);
    if (a !== null) {
      var c = r(a);
      if (c !== null) {
        if (a = c.tag, a === 13) {
          if (a = l(c), a !== null) {
            n.blockedOn = a, Vf(n.priority, function() {
              if (c.tag === 13) {
                var f = Oe();
                f = cI(f);
                var B = _i(c, f);
                B !== null && ye(B, c, f), fd(c, f);
              }
            });
            return;
          }
        } else if (a === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function Vl(n) {
    if (n.blockedOn !== null) return !1;
    for (var a = n.targetContainers; 0 < a.length; ) {
      var c = zy(n.nativeEvent);
      if (c === null) {
        c = n.nativeEvent;
        var f = new c.constructor(
          c.type,
          c
        );
        Wc = f, c.target.dispatchEvent(f), Wc = null;
      } else
        return a = yC(c), a !== null && Qy(a), n.blockedOn = c, !1;
      a.shift();
    }
    return !0;
  }
  function gD(n, a, c) {
    Vl(n) && c.delete(a);
  }
  function Dd() {
    yd = !1, Nt !== null && Vl(Nt) && (Nt = null), fi !== null && Vl(fi) && (fi = null), dn !== null && Vl(dn) && (dn = null), _a.forEach(gD), Wl.forEach(gD);
  }
  function fn(n, a) {
    n.blockedOn === a && (n.blockedOn = null, yd || (yd = !0, g.unstable_scheduleCallback(
      g.unstable_NormalPriority,
      Dd
    )));
  }
  var Md = null;
  function xl(n) {
    Md !== n && (Md = n, g.unstable_scheduleCallback(
      g.unstable_NormalPriority,
      function() {
        Md === n && (Md = null);
        for (var a = 0; a < n.length; a += 3) {
          var c = n[a], f = n[a + 1], B = n[a + 2];
          if (typeof f != "function") {
            if (Jy(f || c) === null)
              continue;
            break;
          }
          var m = yC(c);
          m !== null && (n.splice(a, 3), a -= 3, Uh(
            m,
            {
              pending: !0,
              data: B,
              method: c.method,
              action: f
            },
            f,
            B
          ));
        }
      }
    ));
  }
  function Ua(n) {
    function a(q) {
      return fn(q, n);
    }
    Nt !== null && fn(Nt, n), fi !== null && fn(fi, n), dn !== null && fn(dn, n), _a.forEach(a), Wl.forEach(a);
    for (var c = 0; c < ls.length; c++) {
      var f = ls[c];
      f.blockedOn === n && (f.blockedOn = null);
    }
    for (; 0 < ls.length && (c = ls[0], c.blockedOn === null); )
      $y(c), c.blockedOn === null && ls.shift();
    if (c = (n.ownerDocument || n).$$reactFormReplay, c != null)
      for (f = 0; f < c.length; f += 3) {
        var B = c[f], m = c[f + 1], j = B[jC] || null;
        if (typeof m == "function")
          j || xl(c);
        else if (j) {
          var O = null;
          if (m && m.hasAttribute("formAction")) {
            if (B = m, j = m[jC] || null)
              O = j.formAction;
            else if (Jy(B) !== null) continue;
          } else O = j.action;
          typeof O == "function" ? c[f + 1] = O : (c.splice(f, 3), f -= 3), xl(c);
        }
      }
  }
  function cs(n) {
    this._internalRoot = n;
  }
  wd.prototype.render = cs.prototype.render = function(n) {
    var a = this._internalRoot;
    if (a === null) throw Error(t(409));
    var c = a.current, f = Oe();
    Fy(c, f, n, a, null, null);
  }, wd.prototype.unmount = cs.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var a = n.containerInfo;
      Fy(n.current, 2, null, n, null, null), pl(), a[Ys] = null;
    }
  };
  function wd(n) {
    this._internalRoot = n;
  }
  wd.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
      var a = Ii();
      n = { blockedOn: null, target: n, priority: a };
      for (var c = 0; c < ls.length && a !== 0 && a < ls[c].priority; c++) ;
      ls.splice(c, 0, n), c === 0 && $y(n);
    }
  };
  var Ww = I.version;
  if (Ww !== "19.1.1")
    throw Error(
      t(
        527,
        Ww,
        "19.1.1"
      )
    );
  Q.findDOMNode = function(n) {
    var a = n._reactInternals;
    if (a === void 0)
      throw typeof n.render == "function" ? Error(t(188)) : (n = Object.keys(n).join(","), Error(t(268, n)));
    return n = h(a), n = n !== null ? D(n) : null, n = n === null ? null : n.stateNode, n;
  };
  var Vw = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: z,
    reconcilerVersion: "19.1.1"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var aC = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!aC.isDisabled && aC.supportsFiber)
      try {
        Qe = aC.inject(
          Vw
        ), eC = aC;
      } catch {
      }
  }
  return RD.createRoot = function(n, a) {
    if (!s(n)) throw Error(t(299));
    var c = !1, f = "", B = $h, m = Ba, j = gy, O = null;
    return a != null && (a.unstable_strictMode === !0 && (c = !0), a.identifierPrefix !== void 0 && (f = a.identifierPrefix), a.onUncaughtError !== void 0 && (B = a.onUncaughtError), a.onCaughtError !== void 0 && (m = a.onCaughtError), a.onRecoverableError !== void 0 && (j = a.onRecoverableError), a.unstable_transitionCallbacks !== void 0 && (O = a.unstable_transitionCallbacks)), a = Rw(
      n,
      1,
      !1,
      null,
      null,
      c,
      f,
      B,
      m,
      j,
      O,
      null
    ), n[Ys] = a.current, Tl(n), new cs(a);
  }, RD.hydrateRoot = function(n, a, c) {
    if (!s(n)) throw Error(t(299));
    var f = !1, B = "", m = $h, j = Ba, O = gy, q = null, ug = null;
    return c != null && (c.unstable_strictMode === !0 && (f = !0), c.identifierPrefix !== void 0 && (B = c.identifierPrefix), c.onUncaughtError !== void 0 && (m = c.onUncaughtError), c.onCaughtError !== void 0 && (j = c.onCaughtError), c.onRecoverableError !== void 0 && (O = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (q = c.unstable_transitionCallbacks), c.formState !== void 0 && (ug = c.formState)), a = Rw(
      n,
      1,
      !0,
      a,
      c ?? null,
      f,
      B,
      m,
      j,
      O,
      q,
      ug
    ), a.context = Uy(null), c = a.current, f = Oe(), f = cI(f), B = Ji(f), B.callback = null, se(c, B, f), c = f, a.current.lanes = c, Jg(a, c), Et(a), n[Ys] = a.current, Tl(n), new wd(a);
  }, RD.version = "19.1.1", RD;
}
var OD = {}, VY;
function PN() {
  if (VY) return OD;
  VY = 1;
  var A = {}, g = {};
  /**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return g.NODE_ENV !== "production" && (function() {
    function I(e, i) {
      for (e = e.memoizedState; e !== null && 0 < i; )
        e = e.next, i--;
      return e;
    }
    function C(e, i, o, u) {
      if (o >= i.length) return u;
      var y = i[o], M = gC(e) ? e.slice() : uI({}, e);
      return M[y] = C(e[y], i, o + 1, u), M;
    }
    function t(e, i, o) {
      if (i.length !== o.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var u = 0; u < o.length - 1; u++)
          if (i[u] !== o[u]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return s(e, i, o, 0);
      }
    }
    function s(e, i, o, u) {
      var y = i[u], M = gC(e) ? e.slice() : uI({}, e);
      return u + 1 === i.length ? (M[o[u]] = M[y], gC(M) ? M.splice(y, 1) : delete M[y]) : M[y] = s(
        e[y],
        i,
        o,
        u + 1
      ), M;
    }
    function r(e, i, o) {
      var u = i[o], y = gC(e) ? e.slice() : uI({}, e);
      return o + 1 === i.length ? (gC(y) ? y.splice(u, 1) : delete y[u], y) : (y[u] = r(e[u], i, o + 1), y);
    }
    function l() {
      return !1;
    }
    function d() {
      return null;
    }
    function h() {
    }
    function D() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function w() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function p() {
    }
    function b(e) {
      var i = [];
      return e.forEach(function(o) {
        i.push(o);
      }), i.sort().join(", ");
    }
    function S(e, i, o, u) {
      return new O0(e, i, o, u);
    }
    function K(e, i) {
      e.context === Fa && (bl(e.current, 2, i, e, null, null), eo());
    }
    function Y(e, i) {
      if (Mi !== null) {
        var o = i.staleFamilies;
        i = i.updatedFamilies, zn(), ks(
          e.current,
          i,
          o
        ), eo();
      }
    }
    function T(e) {
      Mi = e;
    }
    function E(e) {
      return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
    }
    function H(e) {
      var i = e, o = e;
      if (e.alternate) for (; i.return; ) i = i.return;
      else {
        e = i;
        do
          i = e, (i.flags & 4098) !== 0 && (o = i.return), e = i.return;
        while (e);
      }
      return i.tag === 3 ? o : null;
    }
    function R(e) {
      if (e.tag === 13) {
        var i = e.memoizedState;
        if (i === null && (e = e.alternate, e !== null && (i = e.memoizedState)), i !== null) return i.dehydrated;
      }
      return null;
    }
    function x(e) {
      if (H(e) !== e)
        throw Error("Unable to find node on an unmounted component.");
    }
    function U(e) {
      var i = e.alternate;
      if (!i) {
        if (i = H(e), i === null)
          throw Error("Unable to find node on an unmounted component.");
        return i !== e ? null : e;
      }
      for (var o = e, u = i; ; ) {
        var y = o.return;
        if (y === null) break;
        var M = y.alternate;
        if (M === null) {
          if (u = y.return, u !== null) {
            o = u;
            continue;
          }
          break;
        }
        if (y.child === M.child) {
          for (M = y.child; M; ) {
            if (M === o) return x(y), e;
            if (M === u) return x(y), i;
            M = M.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (o.return !== u.return) o = y, u = M;
        else {
          for (var G = !1, P = y.child; P; ) {
            if (P === o) {
              G = !0, o = y, u = M;
              break;
            }
            if (P === u) {
              G = !0, u = y, o = M;
              break;
            }
            P = P.sibling;
          }
          if (!G) {
            for (P = M.child; P; ) {
              if (P === o) {
                G = !0, o = M, u = y;
                break;
              }
              if (P === u) {
                G = !0, u = M, o = y;
                break;
              }
              P = P.sibling;
            }
            if (!G)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (o.alternate !== u)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (o.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return o.stateNode.current === o ? e : i;
    }
    function J(e) {
      var i = e.tag;
      if (i === 5 || i === 26 || i === 27 || i === 6) return e;
      for (e = e.child; e !== null; ) {
        if (i = J(e), i !== null) return i;
        e = e.sibling;
      }
      return null;
    }
    function L(e) {
      return e === null || typeof e != "object" ? null : (e = Pl && e[Pl] || e["@@iterator"], typeof e == "function" ? e : null);
    }
    function eg(e) {
      if (e == null) return null;
      if (typeof e == "function")
        return e.$$typeof === tA ? null : e.displayName || e.name || null;
      if (typeof e == "string") return e;
      switch (e) {
        case ns:
          return "Fragment";
        case Tl:
          return "Profiler";
        case ro:
          return "StrictMode";
        case os:
          return "Suspense";
        case id:
          return "SuspenseList";
        case sd:
          return "Activity";
      }
      if (typeof e == "object")
        switch (typeof e.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), e.$$typeof) {
          case DI:
            return "Portal";
          case De:
            return (e.displayName || "Context") + ".Provider";
          case Yl:
            return (e._context.displayName || "Context") + ".Consumer";
          case ss:
            var i = e.render;
            return e = e.displayName, e || (e = i.displayName || i.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
          case nd:
            return i = e.displayName || null, i !== null ? i : eg(e.type) || "Memo";
          case Ne:
            i = e._payload, e = e._init;
            try {
              return eg(e(i));
            } catch {
            }
        }
      return null;
    }
    function Mg(e) {
      return typeof e.tag == "number" ? ig(e) : typeof e.name == "string" ? e.name : null;
    }
    function ig(e) {
      var i = e.type;
      switch (e.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (i._context.displayName || "Context") + ".Consumer";
        case 10:
          return (i.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return e = i.render, e = e.displayName || e.name || "", i.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return i;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return eg(i);
        case 8:
          return i === ro ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof i == "function")
            return i.displayName || i.name || null;
          if (typeof i == "string") return i;
          break;
        case 29:
          if (i = e._debugInfo, i != null) {
            for (var o = i.length - 1; 0 <= o; o--)
              if (typeof i[o].name == "string") return i[o].name;
          }
          if (e.return !== null)
            return ig(e.return);
      }
      return null;
    }
    function Zg(e) {
      return { current: e };
    }
    function Kg(e, i) {
      0 > ri ? console.error("Unexpected pop.") : (i !== Oa[ri] && console.error("Unexpected Fiber popped."), e.current = Zl[ri], Zl[ri] = null, Oa[ri] = null, ri--);
    }
    function mg(e, i, o) {
      ri++, Zl[ri] = e.current, Oa[ri] = o, e.current = i;
    }
    function Ng(e) {
      return e === null && console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      ), e;
    }
    function cg(e, i) {
      mg(li, i, e), mg(lo, e, e), mg(rn, null, e);
      var o = i.nodeType;
      switch (o) {
        case 9:
        case 11:
          o = o === 9 ? "#document" : "#fragment", i = (i = i.documentElement) && (i = i.namespaceURI) ? fe(i) : bo;
          break;
        default:
          if (o = i.tagName, i = i.namespaceURI)
            i = fe(i), i = tn(
              i,
              o
            );
          else
            switch (o) {
              case "svg":
                i = zd;
                break;
              case "math":
                i = yB;
                break;
              default:
                i = bo;
            }
      }
      o = o.toLowerCase(), o = qf(null, o), o = {
        context: i,
        ancestorInfo: o
      }, Kg(rn, e), mg(rn, o, e);
    }
    function z(e) {
      Kg(rn, e), Kg(lo, e), Kg(li, e);
    }
    function Q() {
      return Ng(rn.current);
    }
    function Bg(e) {
      e.memoizedState !== null && mg(od, e, e);
      var i = Ng(rn.current), o = e.type, u = tn(i.context, o);
      o = qf(i.ancestorInfo, o), u = { context: u, ancestorInfo: o }, i !== u && (mg(lo, e, e), mg(rn, u, e));
    }
    function Rg(e) {
      lo.current === e && (Kg(rn, e), Kg(lo, e)), od.current === e && (Kg(od, e), ZD._currentValue = nc);
    }
    function N(e) {
      return typeof Symbol == "function" && Symbol.toStringTag && e[Symbol.toStringTag] || e.constructor.name || "Object";
    }
    function F(e) {
      try {
        return rg(e), !1;
      } catch {
        return !0;
      }
    }
    function rg(e) {
      return "" + e;
    }
    function Cg(e, i) {
      if (F(e))
        return console.error(
          "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
          i,
          N(e)
        ), rg(e);
    }
    function Sg(e, i) {
      if (F(e))
        return console.error(
          "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
          i,
          N(e)
        ), rg(e);
    }
    function kg(e) {
      if (F(e))
        return console.error(
          "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
          N(e)
        ), rg(e);
    }
    function Yg(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
      var i = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (i.isDisabled) return !0;
      if (!i.supportsFiber)
        return console.error(
          "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
        ), !0;
      try {
        co = i.inject(e), pC = i;
      } catch (o) {
        console.error("React instrumentation encountered an error: %s.", o);
      }
      return !!i.checkDCE;
    }
    function Wg(e) {
      if (typeof Rt == "function" && Ny(e), pC && typeof pC.setStrictMode == "function")
        try {
          pC.setStrictMode(co, e);
        } catch (i) {
          kA || (kA = !0, console.error(
            "React instrumentation encountered an error: %s",
            i
          ));
        }
    }
    function Xg(e) {
      Qg = e;
    }
    function nI() {
      Qg !== null && typeof Qg.markCommitStopped == "function" && Qg.markCommitStopped();
    }
    function sI(e) {
      Qg !== null && typeof Qg.markComponentRenderStarted == "function" && Qg.markComponentRenderStarted(e);
    }
    function Ug() {
      Qg !== null && typeof Qg.markComponentRenderStopped == "function" && Qg.markComponentRenderStopped();
    }
    function fI(e) {
      Qg !== null && typeof Qg.markRenderStarted == "function" && Qg.markRenderStarted(e);
    }
    function VI() {
      Qg !== null && typeof Qg.markRenderStopped == "function" && Qg.markRenderStopped();
    }
    function oA(e, i) {
      Qg !== null && typeof Qg.markStateUpdateScheduled == "function" && Qg.markStateUpdateScheduled(e, i);
    }
    function _C(e) {
      return e >>>= 0, e === 0 ? 32 : 31 - (ln(e) / J0 | 0) | 0;
    }
    function UC(e) {
      if (e & 1) return "SyncHydrationLane";
      if (e & 2) return "Sync";
      if (e & 4) return "InputContinuousHydration";
      if (e & 8) return "InputContinuous";
      if (e & 16) return "DefaultHydration";
      if (e & 32) return "Default";
      if (e & 128) return "TransitionHydration";
      if (e & 4194048) return "Transition";
      if (e & 62914560) return "Retry";
      if (e & 67108864) return "SelectiveHydration";
      if (e & 134217728) return "IdleHydration";
      if (e & 268435456) return "Idle";
      if (e & 536870912) return "Offscreen";
      if (e & 1073741824) return "Deferred";
    }
    function vI(e) {
      var i = e & 42;
      if (i !== 0) return i;
      switch (e & -e) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return e & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return e & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), e;
      }
    }
    function CC(e, i, o) {
      var u = e.pendingLanes;
      if (u === 0) return 0;
      var y = 0, M = e.suspendedLanes, G = e.pingedLanes;
      e = e.warmLanes;
      var P = u & 134217727;
      return P !== 0 ? (u = P & ~M, u !== 0 ? y = vI(u) : (G &= P, G !== 0 ? y = vI(G) : o || (o = P & ~e, o !== 0 && (y = vI(o))))) : (P = u & ~M, P !== 0 ? y = vI(P) : G !== 0 ? y = vI(G) : o || (o = u & ~e, o !== 0 && (y = vI(o)))), y === 0 ? 0 : i !== 0 && i !== y && (i & M) === 0 && (M = y & -y, o = i & -i, M >= o || M === 32 && (o & 4194048) !== 0) ? i : y;
    }
    function hC(e, i) {
      return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & i) === 0;
    }
    function Lt(e, i) {
      switch (e) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return i + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return i + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), -1;
      }
    }
    function rI() {
      var e = ad;
      return ad <<= 1, (ad & 4194048) === 0 && (ad = 256), e;
    }
    function lt() {
      var e = cn;
      return cn <<= 1, (cn & 62914560) === 0 && (cn = 4194304), e;
    }
    function qt(e) {
      for (var i = [], o = 0; 31 > o; o++) i.push(e);
      return i;
    }
    function ct(e, i) {
      e.pendingLanes |= i, i !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0);
    }
    function Eo(e, i, o, u, y, M) {
      var G = e.pendingLanes;
      e.pendingLanes = o, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= o, e.entangledLanes &= o, e.errorRecoveryDisabledLanes &= o, e.shellSuspendCounter = 0;
      var P = e.entanglements, W = e.expirationTimes, _ = e.hiddenUpdates;
      for (o = G & ~o; 0 < o; ) {
        var wg = 31 - oC(o), Gg = 1 << wg;
        P[wg] = 0, W[wg] = -1;
        var yg = _[wg];
        if (yg !== null)
          for (_[wg] = null, wg = 0; wg < yg.length; wg++) {
            var Tg = yg[wg];
            Tg !== null && (Tg.lane &= -536870913);
          }
        o &= ~Gg;
      }
      u !== 0 && Qe(e, u, 0), M !== 0 && y === 0 && e.tag !== 0 && (e.suspendedLanes |= M & ~(G & ~i));
    }
    function Qe(e, i, o) {
      e.pendingLanes |= i, e.suspendedLanes &= ~i;
      var u = 31 - oC(i);
      e.entangledLanes |= i, e.entanglements[u] = e.entanglements[u] | 1073741824 | o & 4194090;
    }
    function eC(e, i) {
      var o = e.entangledLanes |= i;
      for (e = e.entanglements; o; ) {
        var u = 31 - oC(o), y = 1 << u;
        y & i | e[u] & i && (e[u] |= i), o &= ~y;
      }
    }
    function PC(e) {
      switch (e) {
        case 2:
          e = 1;
          break;
        case 8:
          e = 4;
          break;
        case 32:
          e = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          e = 128;
          break;
        case 268435456:
          e = 134217728;
          break;
        default:
          e = 0;
      }
      return e;
    }
    function pA(e, i, o) {
      if (nt)
        for (e = e.pendingUpdatersLaneMap; 0 < o; ) {
          var u = 31 - oC(o), y = 1 << u;
          e[u].add(i), o &= ~y;
        }
    }
    function Ri(e, i) {
      if (nt)
        for (var o = e.pendingUpdatersLaneMap, u = e.memoizedUpdaters; 0 < i; ) {
          var y = 31 - oC(i);
          e = 1 << y, y = o[y], 0 < y.size && (y.forEach(function(M) {
            var G = M.alternate;
            G !== null && u.has(G) || u.add(M);
          }), y.clear()), i &= ~e;
        }
    }
    function $t(e) {
      return e &= -e, ke < e ? ui < e ? (e & 134217727) !== 0 ? un : rd : ui : ke;
    }
    function gi() {
      var e = QI.p;
      return e !== 0 ? e : (e = window.event, e === void 0 ? un : is(e.type));
    }
    function ut(e, i) {
      var o = QI.p;
      try {
        return QI.p = e, i();
      } finally {
        QI.p = o;
      }
    }
    function Te(e) {
      delete e[OC], delete e[Me], delete e[ld], delete e[ka], delete e[vl];
    }
    function JA(e) {
      var i = e[OC];
      if (i) return i;
      for (var o = e.parentNode; o; ) {
        if (i = o[rs] || o[OC]) {
          if (o = i.alternate, i.child !== null || o !== null && o.child !== null)
            for (e = Fu(e); e !== null; ) {
              if (o = e[OC])
                return o;
              e = Fu(e);
            }
          return i;
        }
        e = o, o = e.parentNode;
      }
      return null;
    }
    function ZC(e) {
      if (e = e[OC] || e[rs]) {
        var i = e.tag;
        if (i === 5 || i === 6 || i === 13 || i === 26 || i === 27 || i === 3)
          return e;
      }
      return null;
    }
    function Ie(e) {
      var i = e.tag;
      if (i === 5 || i === 26 || i === 27 || i === 6)
        return e.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function k(e) {
      var i = e[ky];
      return i || (i = e[ky] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
    }
    function og(e) {
      e[Hl] = !0;
    }
    function Vg(e, i) {
      _g(e, i), _g(e + "Capture", i);
    }
    function _g(e, i) {
      Ot[e] && console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        e
      ), Ot[e] = i;
      var o = e.toLowerCase();
      for (cd[o] = e, e === "onDoubleClick" && (cd.ondblclick = e), e = 0; e < i.length; e++)
        uo.add(i[e]);
    }
    function Jg(e, i) {
      ud[i.type] || i.onChange || i.onInput || i.readOnly || i.disabled || i.value == null || console.error(
        e === "select" ? "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`." : "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
      ), i.onChange || i.readOnly || i.disabled || i.checked == null || console.error(
        "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
      );
    }
    function yI(e) {
      return ci.call(El, e) ? !0 : ci.call(dd, e) ? !1 : Wy.test(e) ? El[e] = !0 : (dd[e] = !0, console.error("Invalid attribute name: `%s`", e), !1);
    }
    function lI(e, i, o) {
      if (yI(i)) {
        if (!e.hasAttribute(i)) {
          switch (typeof o) {
            case "symbol":
            case "object":
              return o;
            case "function":
              return o;
            case "boolean":
              if (o === !1) return o;
          }
          return o === void 0 ? void 0 : null;
        }
        return e = e.getAttribute(i), e === "" && o === !0 ? !0 : (Cg(o, i), e === "" + o ? o : e);
      }
    }
    function TI(e, i, o) {
      if (yI(i))
        if (o === null) e.removeAttribute(i);
        else {
          switch (typeof o) {
            case "undefined":
            case "function":
            case "symbol":
              e.removeAttribute(i);
              return;
            case "boolean":
              var u = i.toLowerCase().slice(0, 5);
              if (u !== "data-" && u !== "aria-") {
                e.removeAttribute(i);
                return;
              }
          }
          Cg(o, i), e.setAttribute(i, "" + o);
        }
    }
    function cI(e, i, o) {
      if (o === null) e.removeAttribute(i);
      else {
        switch (typeof o) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            e.removeAttribute(i);
            return;
        }
        Cg(o, i), e.setAttribute(i, "" + o);
      }
    }
    function VA(e, i, o, u) {
      if (u === null) e.removeAttribute(o);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            e.removeAttribute(o);
            return;
        }
        Cg(u, o), e.setAttributeNS(i, o, "" + u);
      }
    }
    function Ii() {
    }
    function Vf() {
      if (Wa === 0) {
        Vy = console.log, jw = console.info, xy = console.warn, Va = console.error, vw = console.group, Hw = console.groupCollapsed, Ew = console.groupEnd;
        var e = {
          configurable: !0,
          enumerable: !0,
          value: Ii,
          writable: !0
        };
        Object.defineProperties(console, {
          info: e,
          log: e,
          warn: e,
          error: e,
          group: e,
          groupCollapsed: e,
          groupEnd: e
        });
      }
      Wa++;
    }
    function Ai() {
      if (Wa--, Wa === 0) {
        var e = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: uI({}, e, { value: Vy }),
          info: uI({}, e, { value: jw }),
          warn: uI({}, e, { value: xy }),
          error: uI({}, e, { value: Va }),
          group: uI({}, e, { value: vw }),
          groupCollapsed: uI({}, e, { value: Hw }),
          groupEnd: uI({}, e, { value: Ew })
        });
      }
      0 > Wa && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function sA(e) {
      if (xa === void 0)
        try {
          throw Error();
        } catch (o) {
          var i = o.stack.trim().match(/\n( *(at )?)/);
          xa = i && i[1] || "", Rl = -1 < o.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < o.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + xa + e + Rl;
    }
    function jC(e, i) {
      if (!e || Ol) return "";
      var o = _y.get(e);
      if (o !== void 0) return o;
      Ol = !0, o = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var u = null;
      u = Dg.H, Dg.H = null, Vf();
      try {
        var y = {
          DetermineComponentFrameRoot: function() {
            try {
              if (i) {
                var yg = function() {
                  throw Error();
                };
                if (Object.defineProperty(yg.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(yg, []);
                  } catch (qg) {
                    var Tg = qg;
                  }
                  Reflect.construct(e, [], yg);
                } else {
                  try {
                    yg.call();
                  } catch (qg) {
                    Tg = qg;
                  }
                  e.call(yg.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (qg) {
                  Tg = qg;
                }
                (yg = e()) && typeof yg.catch == "function" && yg.catch(function() {
                });
              }
            } catch (qg) {
              if (qg && Tg && typeof qg.stack == "string")
                return [qg.stack, Tg.stack];
            }
            return [null, null];
          }
        };
        y.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var M = Object.getOwnPropertyDescriptor(
          y.DetermineComponentFrameRoot,
          "name"
        );
        M && M.configurable && Object.defineProperty(
          y.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var G = y.DetermineComponentFrameRoot(), P = G[0], W = G[1];
        if (P && W) {
          var _ = P.split(`
`), wg = W.split(`
`);
          for (G = M = 0; M < _.length && !_[M].includes(
            "DetermineComponentFrameRoot"
          ); )
            M++;
          for (; G < wg.length && !wg[G].includes(
            "DetermineComponentFrameRoot"
          ); )
            G++;
          if (M === _.length || G === wg.length)
            for (M = _.length - 1, G = wg.length - 1; 1 <= M && 0 <= G && _[M] !== wg[G]; )
              G--;
          for (; 1 <= M && 0 <= G; M--, G--)
            if (_[M] !== wg[G]) {
              if (M !== 1 || G !== 1)
                do
                  if (M--, G--, 0 > G || _[M] !== wg[G]) {
                    var Gg = `
` + _[M].replace(
                      " at new ",
                      " at "
                    );
                    return e.displayName && Gg.includes("<anonymous>") && (Gg = Gg.replace("<anonymous>", e.displayName)), typeof e == "function" && _y.set(e, Gg), Gg;
                  }
                while (1 <= M && 0 <= G);
              break;
            }
        }
      } finally {
        Ol = !1, Dg.H = u, Ai(), Error.prepareStackTrace = o;
      }
      return _ = (_ = e ? e.displayName || e.name : "") ? sA(_) : "", typeof e == "function" && _y.set(e, _), _;
    }
    function Ys(e) {
      var i = Error.prepareStackTrace;
      if (Error.prepareStackTrace = void 0, e = e.stack, Error.prepareStackTrace = i, e.startsWith(`Error: react-stack-top-frame
`) && (e = e.slice(29)), i = e.indexOf(`
`), i !== -1 && (e = e.slice(i + 1)), i = e.indexOf("react_stack_bottom_frame"), i !== -1 && (i = e.lastIndexOf(
        `
`,
        i
      )), i !== -1)
        e = e.slice(0, i);
      else return "";
      return e;
    }
    function xf(e) {
      switch (e.tag) {
        case 26:
        case 27:
        case 5:
          return sA(e.type);
        case 16:
          return sA("Lazy");
        case 13:
          return sA("Suspense");
        case 19:
          return sA("SuspenseList");
        case 0:
        case 15:
          return jC(e.type, !1);
        case 11:
          return jC(e.type.render, !1);
        case 1:
          return jC(e.type, !0);
        case 31:
          return sA("Activity");
        default:
          return "";
      }
    }
    function HM(e) {
      try {
        var i = "";
        do {
          i += xf(e);
          var o = e._debugInfo;
          if (o)
            for (var u = o.length - 1; 0 <= u; u--) {
              var y = o[u];
              if (typeof y.name == "string") {
                var M = i, G = y.env, P = sA(
                  y.name + (G ? " [" + G + "]" : "")
                );
                i = M + P;
              }
            }
          e = e.return;
        } while (e);
        return i;
      } catch (W) {
        return `
Error generating stack: ` + W.message + `
` + W.stack;
      }
    }
    function EM(e) {
      return (e = e ? e.displayName || e.name : "") ? sA(e) : "";
    }
    function Sr() {
      if (mC === null) return null;
      var e = mC._debugOwner;
      return e != null ? Mg(e) : null;
    }
    function Gr() {
      if (mC === null) return "";
      var e = mC;
      try {
        var i = "";
        switch (e.tag === 6 && (e = e.return), e.tag) {
          case 26:
          case 27:
          case 5:
            i += sA(e.type);
            break;
          case 13:
            i += sA("Suspense");
            break;
          case 19:
            i += sA("SuspenseList");
            break;
          case 31:
            i += sA("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            e._debugOwner || i !== "" || (i += EM(
              e.type
            ));
            break;
          case 11:
            e._debugOwner || i !== "" || (i += EM(
              e.type.render
            ));
        }
        for (; e; )
          if (typeof e.tag == "number") {
            var o = e;
            e = o._debugOwner;
            var u = o._debugStack;
            e && u && (typeof u != "string" && (o._debugStack = u = Ys(u)), u !== "" && (i += `
` + u));
          } else if (e.debugStack != null) {
            var y = e.debugStack;
            (e = e.owner) && y && (i += `
` + Ys(y));
          } else break;
        var M = i;
      } catch (G) {
        M = `
Error generating stack: ` + G.message + `
` + G.stack;
      }
      return M;
    }
    function gI(e, i, o, u, y, M, G) {
      var P = mC;
      Pn(e);
      try {
        return e !== null && e._debugTask ? e._debugTask.run(
          i.bind(null, o, u, y, M, G)
        ) : i(o, u, y, M, G);
      } finally {
        Pn(P);
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function Pn(e) {
      Dg.getCurrentStack = e === null ? null : Gr, di = !1, mC = e;
    }
    function yC(e) {
      switch (typeof e) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return kg(e), e;
        default:
          return "";
      }
    }
    function Ro(e) {
      var i = e.type;
      return (e = e.nodeName) && e.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
    }
    function Oo(e) {
      var i = Ro(e) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(
        e.constructor.prototype,
        i
      );
      kg(e[i]);
      var u = "" + e[i];
      if (!e.hasOwnProperty(i) && typeof o < "u" && typeof o.get == "function" && typeof o.set == "function") {
        var y = o.get, M = o.set;
        return Object.defineProperty(e, i, {
          configurable: !0,
          get: function() {
            return y.call(this);
          },
          set: function(G) {
            kg(G), u = "" + G, M.call(this, G);
          }
        }), Object.defineProperty(e, i, {
          enumerable: o.enumerable
        }), {
          getValue: function() {
            return u;
          },
          setValue: function(G) {
            kg(G), u = "" + G;
          },
          stopTracking: function() {
            e._valueTracker = null, delete e[i];
          }
        };
      }
    }
    function OA(e) {
      e._valueTracker || (e._valueTracker = Oo(e));
    }
    function _f(e) {
      if (!e) return !1;
      var i = e._valueTracker;
      if (!i) return !0;
      var o = i.getValue(), u = "";
      return e && (u = Ro(e) ? e.checked ? "true" : "false" : e.value), e = u, e !== o ? (i.setValue(e), !0) : !1;
    }
    function Kr(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    function tC(e) {
      return e.replace(
        Rw,
        function(i) {
          return "\\" + i.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function Ps(e, i) {
      i.checked === void 0 || i.defaultChecked === void 0 || Fy || (console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        Sr() || "A component",
        i.type
      ), Fy = !0), i.value === void 0 || i.defaultValue === void 0 || Uy || (console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        Sr() || "A component",
        i.type
      ), Uy = !0);
    }
    function Uf(e, i, o, u, y, M, G, P) {
      e.name = "", G != null && typeof G != "function" && typeof G != "symbol" && typeof G != "boolean" ? (Cg(G, "type"), e.type = G) : e.removeAttribute("type"), i != null ? G === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + yC(i)) : e.value !== "" + yC(i) && (e.value = "" + yC(i)) : G !== "submit" && G !== "reset" || e.removeAttribute("value"), i != null ? Ec(e, G, yC(i)) : o != null ? Ec(e, G, yC(o)) : u != null && e.removeAttribute("value"), y == null && M != null && (e.defaultChecked = !!M), y != null && (e.checked = y && typeof y != "function" && typeof y != "symbol"), P != null && typeof P != "function" && typeof P != "symbol" && typeof P != "boolean" ? (Cg(P, "name"), e.name = "" + yC(P)) : e.removeAttribute("name");
    }
    function Ff(e, i, o, u, y, M, G, P) {
      if (M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" && (Cg(M, "type"), e.type = M), i != null || o != null) {
        if (!(M !== "submit" && M !== "reset" || i != null))
          return;
        o = o != null ? "" + yC(o) : "", i = i != null ? "" + yC(i) : o, P || i === e.value || (e.value = i), e.defaultValue = i;
      }
      u = u ?? y, u = typeof u != "function" && typeof u != "symbol" && !!u, e.checked = P ? e.checked : !!u, e.defaultChecked = !!u, G != null && typeof G != "function" && typeof G != "symbol" && typeof G != "boolean" && (Cg(G, "name"), e.name = G);
    }
    function Ec(e, i, o) {
      i === "number" && Kr(e.ownerDocument) === e || e.defaultValue === "" + o || (e.defaultValue = "" + o);
    }
    function RM(e, i) {
      i.value == null && (typeof i.children == "object" && i.children !== null ? jy.Children.forEach(i.children, function(o) {
        o == null || typeof o == "string" || typeof o == "number" || typeof o == "bigint" || fd || (fd = !0, console.error(
          "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
        ));
      }) : i.dangerouslySetInnerHTML == null || Qy || (Qy = !0, console.error(
        "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
      ))), i.selected == null || Xy || (console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      ), Xy = !0);
    }
    function Tr() {
      var e = Sr();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    function Oi(e, i, o, u) {
      if (e = e.options, i) {
        i = {};
        for (var y = 0; y < o.length; y++)
          i["$" + o[y]] = !0;
        for (o = 0; o < e.length; o++)
          y = i.hasOwnProperty("$" + e[o].value), e[o].selected !== y && (e[o].selected = y), y && u && (e[o].defaultSelected = !0);
      } else {
        for (o = "" + yC(o), i = null, y = 0; y < e.length; y++) {
          if (e[y].value === o) {
            e[y].selected = !0, u && (e[y].defaultSelected = !0);
            return;
          }
          i !== null || e[y].disabled || (i = e[y]);
        }
        i !== null && (i.selected = !0);
      }
    }
    function Ci(e, i) {
      for (e = 0; e < Ow.length; e++) {
        var o = Ow[e];
        if (i[o] != null) {
          var u = gC(i[o]);
          i.multiple && !u ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
            o,
            Tr()
          ) : !i.multiple && u && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
            o,
            Tr()
          );
        }
      }
      i.value === void 0 || i.defaultValue === void 0 || Nl || (console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      ), Nl = !0);
    }
    function Rc(e, i) {
      i.value === void 0 || i.defaultValue === void 0 || Nw || (console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        Sr() || "A component"
      ), Nw = !0), i.children != null && i.value == null && console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
    function Xf(e, i, o) {
      if (i != null && (i = "" + yC(i), i !== e.value && (e.value = i), o == null)) {
        e.defaultValue !== i && (e.defaultValue = i);
        return;
      }
      e.defaultValue = o != null ? "" + yC(o) : "";
    }
    function Zs(e, i, o, u) {
      if (i == null) {
        if (u != null) {
          if (o != null)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (gC(u)) {
            if (1 < u.length)
              throw Error("<textarea> can only have at most one child.");
            u = u[0];
          }
          o = u;
        }
        o == null && (o = ""), i = o;
      }
      o = yC(i), e.defaultValue = o, u = e.textContent, u === o && u !== "" && u !== null && (e.value = u);
    }
    function Oc(e, i) {
      return e.serverProps === void 0 && e.serverTail.length === 0 && e.children.length === 1 && 3 < e.distanceFromLeaf && e.distanceFromLeaf > 15 - i ? Oc(e.children[0], i) : e;
    }
    function FC(e) {
      return "  " + "  ".repeat(e);
    }
    function No(e) {
      return "+ " + "  ".repeat(e);
    }
    function Zn(e) {
      return "- " + "  ".repeat(e);
    }
    function Ye(e) {
      switch (e.tag) {
        case 26:
        case 27:
        case 5:
          return e.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return e = e.type, e.displayName || e.name || null;
        case 11:
          return e = e.type.render, e.displayName || e.name || null;
        case 1:
          return e = e.type, e.displayName || e.name || null;
        default:
          return null;
      }
    }
    function ko(e, i) {
      return hd.test(e) ? (e = JSON.stringify(e), e.length > i - 2 ? 8 > i ? '{"..."}' : "{" + e.slice(0, i - 7) + '..."}' : "{" + e + "}") : e.length > i ? 5 > i ? '{"..."}' : e.slice(0, i - 3) + "..." : e;
    }
    function Nc(e, i, o) {
      var u = 120 - 2 * o;
      if (i === null)
        return No(o) + ko(e, u) + `
`;
      if (typeof i == "string") {
        for (var y = 0; y < i.length && y < e.length && i.charCodeAt(y) === e.charCodeAt(y); y++) ;
        return y > u - 8 && 10 < y && (e = "..." + e.slice(y - 8), i = "..." + i.slice(y - 8)), No(o) + ko(e, u) + `
` + Zn(o) + ko(i, u) + `
`;
      }
      return FC(o) + ko(e, u) + `
`;
    }
    function Wo(e) {
      return Object.prototype.toString.call(e).replace(/^\[object (.*)\]$/, function(i, o) {
        return o;
      });
    }
    function Vo(e, i) {
      switch (typeof e) {
        case "string":
          return e = JSON.stringify(e), e.length > i ? 5 > i ? '"..."' : e.slice(0, i - 4) + '..."' : e;
        case "object":
          if (e === null) return "null";
          if (gC(e)) return "[...]";
          if (e.$$typeof === an)
            return (i = eg(e.type)) ? "<" + i + ">" : "<...>";
          var o = Wo(e);
          if (o === "Object") {
            o = "", i -= 2;
            for (var u in e)
              if (e.hasOwnProperty(u)) {
                var y = JSON.stringify(u);
                if (y !== '"' + u + '"' && (u = y), i -= u.length - 2, y = Vo(
                  e[u],
                  15 > i ? i : 15
                ), i -= y.length, 0 > i) {
                  o += o === "" ? "..." : ", ...";
                  break;
                }
                o += (o === "" ? "" : ",") + u + ":" + y;
              }
            return "{" + o + "}";
          }
          return o;
        case "function":
          return (i = e.displayName || e.name) ? "function " + i : "function";
        default:
          return String(e);
      }
    }
    function Ni(e, i) {
      return typeof e != "string" || hd.test(e) ? "{" + Vo(e, i - 2) + "}" : e.length > i - 2 ? 5 > i ? '"..."' : '"' + e.slice(0, i - 5) + '..."' : '"' + e + '"';
    }
    function Qf(e, i, o) {
      var u = 120 - o.length - e.length, y = [], M;
      for (M in i)
        if (i.hasOwnProperty(M) && M !== "children") {
          var G = Ni(
            i[M],
            120 - o.length - M.length - 1
          );
          u -= M.length + G.length + 2, y.push(M + "=" + G);
        }
      return y.length === 0 ? o + "<" + e + `>
` : 0 < u ? o + "<" + e + " " + y.join(" ") + `>
` : o + "<" + e + `
` + o + "  " + y.join(`
` + o + "  ") + `
` + o + `>
`;
    }
    function ze(e, i, o) {
      var u = "", y = uI({}, i), M;
      for (M in e)
        if (e.hasOwnProperty(M)) {
          delete y[M];
          var G = 120 - 2 * o - M.length - 2, P = Vo(e[M], G);
          i.hasOwnProperty(M) ? (G = Vo(i[M], G), u += No(o) + M + ": " + P + `
`, u += Zn(o) + M + ": " + G + `
`) : u += No(o) + M + ": " + P + `
`;
        }
      for (var W in y)
        y.hasOwnProperty(W) && (e = Vo(
          y[W],
          120 - 2 * o - W.length - 2
        ), u += Zn(o) + W + ": " + e + `
`);
      return u;
    }
    function zf(e, i, o, u) {
      var y = "", M = /* @__PURE__ */ new Map();
      for (_ in o)
        o.hasOwnProperty(_) && M.set(
          _.toLowerCase(),
          _
        );
      if (M.size === 1 && M.has("children"))
        y += Qf(
          e,
          i,
          FC(u)
        );
      else {
        for (var G in i)
          if (i.hasOwnProperty(G) && G !== "children") {
            var P = 120 - 2 * (u + 1) - G.length - 1, W = M.get(G.toLowerCase());
            if (W !== void 0) {
              M.delete(G.toLowerCase());
              var _ = i[G];
              W = o[W];
              var wg = Ni(
                _,
                P
              );
              P = Ni(
                W,
                P
              ), typeof _ == "object" && _ !== null && typeof W == "object" && W !== null && Wo(_) === "Object" && Wo(W) === "Object" && (2 < Object.keys(_).length || 2 < Object.keys(W).length || -1 < wg.indexOf("...") || -1 < P.indexOf("...")) ? y += FC(u + 1) + G + `={{
` + ze(
                _,
                W,
                u + 2
              ) + FC(u + 1) + `}}
` : (y += No(u + 1) + G + "=" + wg + `
`, y += Zn(u + 1) + G + "=" + P + `
`);
            } else
              y += FC(u + 1) + G + "=" + Ni(i[G], P) + `
`;
          }
        M.forEach(function(Gg) {
          if (Gg !== "children") {
            var yg = 120 - 2 * (u + 1) - Gg.length - 1;
            y += Zn(u + 1) + Gg + "=" + Ni(o[Gg], yg) + `
`;
          }
        }), y = y === "" ? FC(u) + "<" + e + `>
` : FC(u) + "<" + e + `
` + y + FC(u) + `>
`;
      }
      return e = o.children, i = i.children, typeof e == "string" || typeof e == "number" || typeof e == "bigint" ? (M = "", (typeof i == "string" || typeof i == "number" || typeof i == "bigint") && (M = "" + i), y += Nc(M, "" + e, u + 1)) : (typeof i == "string" || typeof i == "number" || typeof i == "bigint") && (y = e == null ? y + Nc("" + i, null, u + 1) : y + Nc("" + i, void 0, u + 1)), y;
    }
    function Jf(e, i) {
      var o = Ye(e);
      if (o === null) {
        for (o = "", e = e.child; e; )
          o += Jf(e, i), e = e.sibling;
        return o;
      }
      return FC(i) + "<" + o + `>
`;
    }
    function Yr(e, i) {
      var o = Oc(e, i);
      if (o !== e && (e.children.length !== 1 || e.children[0] !== o))
        return FC(i) + `...
` + Yr(o, i + 1);
      o = "";
      var u = e.fiber._debugInfo;
      if (u)
        for (var y = 0; y < u.length; y++) {
          var M = u[y].name;
          typeof M == "string" && (o += FC(i) + "<" + M + `>
`, i++);
        }
      if (u = "", y = e.fiber.pendingProps, e.fiber.tag === 6)
        u = Nc(y, e.serverProps, i), i++;
      else if (M = Ye(e.fiber), M !== null)
        if (e.serverProps === void 0) {
          u = i;
          var G = 120 - 2 * u - M.length - 2, P = "";
          for (_ in y)
            if (y.hasOwnProperty(_) && _ !== "children") {
              var W = Ni(y[_], 15);
              if (G -= _.length + W.length + 2, 0 > G) {
                P += " ...";
                break;
              }
              P += " " + _ + "=" + W;
            }
          u = FC(u) + "<" + M + P + `>
`, i++;
        } else
          e.serverProps === null ? (u = Qf(
            M,
            y,
            No(i)
          ), i++) : typeof e.serverProps == "string" ? console.error(
            "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
          ) : (u = zf(
            M,
            y,
            e.serverProps,
            i
          ), i++);
      var _ = "";
      for (y = e.fiber.child, M = 0; y && M < e.children.length; )
        G = e.children[M], G.fiber === y ? (_ += Yr(G, i), M++) : _ += Jf(y, i), y = y.sibling;
      for (y && 0 < e.children.length && (_ += FC(i) + `...
`), y = e.serverTail, e.serverProps === null && i--, e = 0; e < y.length; e++)
        M = y[e], _ = typeof M == "string" ? _ + (Zn(i) + ko(M, 120 - 2 * i) + `
`) : _ + Qf(
          M.type,
          M.props,
          Zn(i)
        );
      return o + u + _;
    }
    function jn(e) {
      try {
        return `

` + Yr(e, 0);
      } catch {
        return "";
      }
    }
    function Lf(e, i, o) {
      for (var u = i, y = null, M = 0; u; )
        u === e && (M = 0), y = {
          fiber: u,
          children: y !== null ? [y] : [],
          serverProps: u === i ? o : u === e ? null : void 0,
          serverTail: [],
          distanceFromLeaf: M
        }, M++, u = u.return;
      return y !== null ? jn(y).replaceAll(/^[+-]/gm, ">") : "";
    }
    function qf(e, i) {
      var o = uI({}, e || yd), u = { tag: i };
      return kl.indexOf(i) !== -1 && (o.aTagInScope = null, o.buttonTagInScope = null, o.nobrTagInScope = null), Jy.indexOf(i) !== -1 && (o.pTagInButtonScope = null), zy.indexOf(i) !== -1 && i !== "address" && i !== "div" && i !== "p" && (o.listItemTagAutoclosing = null, o.dlItemTagAutoclosing = null), o.current = u, i === "form" && (o.formTag = u), i === "a" && (o.aTagInScope = u), i === "button" && (o.buttonTagInScope = u), i === "nobr" && (o.nobrTagInScope = u), i === "p" && (o.pTagInButtonScope = u), i === "li" && (o.listItemTagAutoclosing = u), (i === "dd" || i === "dt") && (o.dlItemTagAutoclosing = u), i === "#document" || i === "html" ? o.containerTagInScope = null : o.containerTagInScope || (o.containerTagInScope = u), e !== null || i !== "#document" && i !== "html" && i !== "body" ? o.implicitRootScope === !0 && (o.implicitRootScope = !1) : o.implicitRootScope = !0, o;
    }
    function js(e, i, o) {
      switch (i) {
        case "select":
          return e === "hr" || e === "option" || e === "optgroup" || e === "script" || e === "template" || e === "#text";
        case "optgroup":
          return e === "option" || e === "#text";
        case "option":
          return e === "#text";
        case "tr":
          return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return e === "tr" || e === "style" || e === "script" || e === "template";
        case "colgroup":
          return e === "col" || e === "template";
        case "table":
          return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
        case "head":
          return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
        case "html":
          if (o) break;
          return e === "head" || e === "body" || e === "frameset";
        case "frameset":
          return e === "frame";
        case "#document":
          if (!o) return e === "html";
      }
      switch (e) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return i !== "h1" && i !== "h2" && i !== "h3" && i !== "h4" && i !== "h5" && i !== "h6";
        case "rp":
        case "rt":
          return kw.indexOf(i) === -1;
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return i == null;
        case "head":
          return o || i === null;
        case "html":
          return o && i === "#document" || i === null;
        case "body":
          return o && (i === "#document" || i === "html") || i === null;
      }
      return !0;
    }
    function P0(e, i) {
      switch (e) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return i.pTagInButtonScope;
        case "form":
          return i.formTag || i.pTagInButtonScope;
        case "li":
          return i.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return i.dlItemTagAutoclosing;
        case "button":
          return i.buttonTagInScope;
        case "a":
          return i.aTagInScope;
        case "nobr":
          return i.nobrTagInScope;
      }
      return null;
    }
    function $f(e, i) {
      for (; e; ) {
        switch (e.tag) {
          case 5:
          case 26:
          case 27:
            if (e.type === i) return e;
        }
        e = e.return;
      }
      return null;
    }
    function kc(e, i) {
      i = i || yd;
      var o = i.current;
      if (i = (o = js(
        e,
        o && o.tag,
        i.implicitRootScope
      ) ? null : o) ? null : P0(e, i), i = o || i, !i) return !0;
      var u = i.tag;
      if (i = String(!!o) + "|" + e + "|" + u, Nt[i]) return !1;
      Nt[i] = !0;
      var y = (i = mC) ? $f(i.return, u) : null, M = i !== null && y !== null ? Lf(y, i, null) : "", G = "<" + e + ">";
      return o ? (o = "", u === "table" && e === "tr" && (o += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
        `In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,
        G,
        u,
        o,
        M
      )) : console.error(
        `In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,
        G,
        u,
        M
      ), i && (e = i.return, y === null || e === null || y === e && e._debugOwner === i._debugOwner || gI(y, function() {
        console.error(
          `<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`,
          u,
          G
        );
      })), !1;
    }
    function xo(e, i, o) {
      if (o || js("#text", i, !1))
        return !0;
      if (o = "#text|" + i, Nt[o]) return !1;
      Nt[o] = !0;
      var u = (o = mC) ? $f(o, i) : null;
      return o = o !== null && u !== null ? Lf(
        u,
        o,
        o.tag !== 6 ? { children: null } : null
      ) : "", /\S/.test(e) ? console.error(
        `In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,
        i,
        o
      ) : console.error(
        `In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,
        i,
        o
      ), !1;
    }
    function Pr(e, i) {
      if (i) {
        var o = e.firstChild;
        if (o && o === e.lastChild && o.nodeType === 3) {
          o.nodeValue = i;
          return;
        }
      }
      e.textContent = i;
    }
    function Z0(e) {
      return e.replace(L0, function(i, o) {
        return o.toUpperCase();
      });
    }
    function Zr(e, i, o) {
      var u = i.indexOf("--") === 0;
      u || (-1 < i.indexOf("-") ? hi.hasOwnProperty(i) && hi[i] || (hi[i] = !0, console.error(
        "Unsupported style property %s. Did you mean %s?",
        i,
        Z0(i.replace(ls, "ms-"))
      )) : Wl.test(i) ? hi.hasOwnProperty(i) && hi[i] || (hi[i] = !0, console.error(
        "Unsupported vendor-prefixed style property %s. Did you mean %s?",
        i,
        i.charAt(0).toUpperCase() + i.slice(1)
      )) : !Ly.test(o) || qy.hasOwnProperty(o) && qy[o] || (qy[o] = !0, console.error(
        `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
        i,
        o.replace(Ly, "")
      )), typeof o == "number" && (isNaN(o) ? $y || ($y = !0, console.error(
        "`NaN` is an invalid value for the `%s` css style property.",
        i
      )) : isFinite(o) || Vl || (Vl = !0, console.error(
        "`Infinity` is an invalid value for the `%s` css style property.",
        i
      )))), o == null || typeof o == "boolean" || o === "" ? u ? e.setProperty(i, "") : i === "float" ? e.cssFloat = "" : e[i] = "" : u ? e.setProperty(i, o) : typeof o != "number" || o === 0 || gD.has(i) ? i === "float" ? e.cssFloat = o : (Sg(o, i), e[i] = ("" + o).trim()) : e[i] = o + "px";
    }
    function Wc(e, i, o) {
      if (i != null && typeof i != "object")
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      if (i && Object.freeze(i), e = e.style, o != null) {
        if (i) {
          var u = {};
          if (o) {
            for (var y in o)
              if (o.hasOwnProperty(y) && !i.hasOwnProperty(y))
                for (var M = fi[y] || [y], G = 0; G < M.length; G++)
                  u[M[G]] = y;
          }
          for (var P in i)
            if (i.hasOwnProperty(P) && (!o || o[P] !== i[P]))
              for (y = fi[P] || [P], M = 0; M < y.length; M++)
                u[y[M]] = P;
          P = {};
          for (var W in i)
            for (y = fi[W] || [W], M = 0; M < y.length; M++)
              P[y[M]] = W;
          W = {};
          for (var _ in u)
            if (y = u[_], (M = P[_]) && y !== M && (G = y + "," + M, !W[G])) {
              W[G] = !0, G = console;
              var wg = i[y];
              G.error.call(
                G,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                wg == null || typeof wg == "boolean" || wg === "" ? "Removing" : "Updating",
                y,
                M
              );
            }
        }
        for (var Gg in o)
          !o.hasOwnProperty(Gg) || i != null && i.hasOwnProperty(Gg) || (Gg.indexOf("--") === 0 ? e.setProperty(Gg, "") : Gg === "float" ? e.cssFloat = "" : e[Gg] = "");
        for (var yg in i)
          _ = i[yg], i.hasOwnProperty(yg) && o[yg] !== _ && Zr(e, yg, _);
      } else
        for (u in i)
          i.hasOwnProperty(u) && Zr(e, u, i[u]);
    }
    function vs(e) {
      if (e.indexOf("-") === -1) return !1;
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function Hs(e) {
      return Md.get(e) || e;
    }
    function _o(e, i) {
      if (ci.call(cs, i) && cs[i])
        return !0;
      if (Ww.test(i)) {
        if (e = "aria-" + i.slice(4).toLowerCase(), e = Ua.hasOwnProperty(e) ? e : null, e == null)
          return console.error(
            "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
            i
          ), cs[i] = !0;
        if (i !== e)
          return console.error(
            "Invalid ARIA attribute `%s`. Did you mean `%s`?",
            i,
            e
          ), cs[i] = !0;
      }
      if (wd.test(i)) {
        if (e = i.toLowerCase(), e = Ua.hasOwnProperty(e) ? e : null, e == null) return cs[i] = !0, !1;
        i !== e && (console.error(
          "Unknown ARIA attribute `%s`. Did you mean `%s`?",
          i,
          e
        ), cs[i] = !0);
      }
      return !0;
    }
    function OM(e, i) {
      var o = [], u;
      for (u in i)
        _o(e, u) || o.push(u);
      i = o.map(function(y) {
        return "`" + y + "`";
      }).join(", "), o.length === 1 ? console.error(
        "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        i,
        e
      ) : 1 < o.length && console.error(
        "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        i,
        e
      );
    }
    function gh(e, i, o, u) {
      if (ci.call(aC, i) && aC[i])
        return !0;
      var y = i.toLowerCase();
      if (y === "onfocusin" || y === "onfocusout")
        return console.error(
          "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
        ), aC[i] = !0;
      if (typeof o == "function" && (e === "form" && i === "action" || e === "input" && i === "formAction" || e === "button" && i === "formAction"))
        return !0;
      if (u != null) {
        if (e = u.possibleRegistrationNames, u.registrationNameDependencies.hasOwnProperty(i))
          return !0;
        if (u = e.hasOwnProperty(y) ? e[y] : null, u != null)
          return console.error(
            "Invalid event handler property `%s`. Did you mean `%s`?",
            i,
            u
          ), aC[i] = !0;
        if (n.test(i))
          return console.error(
            "Unknown event handler property `%s`. It will be ignored.",
            i
          ), aC[i] = !0;
      } else if (n.test(i))
        return a.test(i) && console.error(
          "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
          i
        ), aC[i] = !0;
      if (c.test(i) || f.test(i)) return !0;
      if (y === "innerhtml")
        return console.error(
          "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
        ), aC[i] = !0;
      if (y === "aria")
        return console.error(
          "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
        ), aC[i] = !0;
      if (y === "is" && o !== null && o !== void 0 && typeof o != "string")
        return console.error(
          "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
          typeof o
        ), aC[i] = !0;
      if (typeof o == "number" && isNaN(o))
        return console.error(
          "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
          i
        ), aC[i] = !0;
      if (xl.hasOwnProperty(y)) {
        if (y = xl[y], y !== i)
          return console.error(
            "Invalid DOM property `%s`. Did you mean `%s`?",
            i,
            y
          ), aC[i] = !0;
      } else if (i !== y)
        return console.error(
          "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
          i,
          y
        ), aC[i] = !0;
      switch (i) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof o) {
        case "boolean":
          switch (i) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              return y = i.toLowerCase().slice(0, 5), y === "data-" || y === "aria-" ? !0 : (o ? console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                o,
                i,
                i,
                o,
                i
              ) : console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                o,
                i,
                i,
                o,
                i,
                i,
                i
              ), aC[i] = !0);
          }
        case "function":
        case "symbol":
          return aC[i] = !0, !1;
        case "string":
          if (o === "false" || o === "true") {
            switch (i) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              o,
              i,
              o === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
              i,
              o
            ), aC[i] = !0;
          }
      }
      return !0;
    }
    function NM(e, i, o) {
      var u = [], y;
      for (y in i)
        gh(e, y, i[y], o) || u.push(y);
      i = u.map(function(M) {
        return "`" + M + "`";
      }).join(", "), u.length === 1 ? console.error(
        "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        i,
        e
      ) : 1 < u.length && console.error(
        "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        i,
        e
      );
    }
    function ki(e) {
      return B.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e;
    }
    function dt(e) {
      return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
    }
    function Vc(e) {
      var i = ZC(e);
      if (i && (e = i.stateNode)) {
        var o = e[Me] || null;
        g: switch (e = i.stateNode, i.type) {
          case "input":
            if (Uf(
              e,
              o.value,
              o.defaultValue,
              o.defaultValue,
              o.checked,
              o.defaultChecked,
              o.type,
              o.name
            ), i = o.name, o.type === "radio" && i != null) {
              for (o = e; o.parentNode; ) o = o.parentNode;
              for (Cg(i, "name"), o = o.querySelectorAll(
                'input[name="' + tC(
                  "" + i
                ) + '"][type="radio"]'
              ), i = 0; i < o.length; i++) {
                var u = o[i];
                if (u !== e && u.form === e.form) {
                  var y = u[Me] || null;
                  if (!y)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  Uf(
                    u,
                    y.value,
                    y.defaultValue,
                    y.defaultValue,
                    y.checked,
                    y.defaultChecked,
                    y.type,
                    y.name
                  );
                }
              }
              for (i = 0; i < o.length; i++)
                u = o[i], u.form === e.form && _f(u);
            }
            break g;
          case "textarea":
            Xf(e, o.value, o.defaultValue);
            break g;
          case "select":
            i = o.value, i != null && Oi(e, !!o.multiple, i, !1);
        }
      }
    }
    function Uo(e, i, o) {
      if (q) return e(i, o);
      q = !0;
      try {
        var u = e(i);
        return u;
      } finally {
        if (q = !1, (j !== null || O !== null) && (eo(), j && (i = j, e = O, O = j = null, Vc(i), e)))
          for (i = 0; i < e.length; i++) Vc(e[i]);
      }
    }
    function Je(e, i) {
      var o = e.stateNode;
      if (o === null) return null;
      var u = o[Me] || null;
      if (u === null) return null;
      o = u[i];
      g: switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (u = !u.disabled) || (e = e.type, u = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !u;
          break g;
        default:
          e = !1;
      }
      if (e) return null;
      if (o && typeof o != "function")
        throw Error(
          "Expected `" + i + "` listener to be a function, instead got a value of `" + typeof o + "` type."
        );
      return o;
    }
    function xc() {
      if (tI) return tI;
      var e, i = pg, o = i.length, u, y = "value" in hg ? hg.value : hg.textContent, M = y.length;
      for (e = 0; e < o && i[e] === y[e]; e++) ;
      var G = o - e;
      for (u = 1; u <= G && i[o - u] === y[M - u]; u++) ;
      return tI = y.slice(e, 1 < u ? 1 - u : void 0);
    }
    function Es(e) {
      var i = e.keyCode;
      return "charCode" in e ? (e = e.charCode, e === 0 && i === 13 && (e = 13)) : e = i, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
    }
    function jr() {
      return !0;
    }
    function vr() {
      return !1;
    }
    function DC(e) {
      function i(o, u, y, M, G) {
        this._reactName = o, this._targetInst = y, this.type = u, this.nativeEvent = M, this.target = G, this.currentTarget = null;
        for (var P in e)
          e.hasOwnProperty(P) && (o = e[P], this[P] = o ? o(M) : M[P]);
        return this.isDefaultPrevented = (M.defaultPrevented != null ? M.defaultPrevented : M.returnValue === !1) ? jr : vr, this.isPropagationStopped = vr, this;
      }
      return uI(i.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var o = this.nativeEvent;
          o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = jr);
        },
        stopPropagation: function() {
          var o = this.nativeEvent;
          o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = jr);
        },
        persist: function() {
        },
        isPersistent: jr
      }), i;
    }
    function kM(e) {
      var i = this.nativeEvent;
      return i.getModifierState ? i.getModifierState(e) : (e = wO[e]) ? !!i[e] : !1;
    }
    function vC() {
      return kM;
    }
    function vn(e, i) {
      switch (e) {
        case "keyup":
          return jO.indexOf(i.keyCode) !== -1;
        case "keydown":
          return i.keyCode !== jK;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Hr(e) {
      return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
    }
    function Er(e, i) {
      switch (e) {
        case "compositionend":
          return Hr(i);
        case "keypress":
          return i.which !== HK ? null : (RK = !0, EK);
        case "textInput":
          return e = i.data, e === EK && RK ? null : e;
        default:
          return null;
      }
    }
    function j0(e, i) {
      if (Bd)
        return e === "compositionend" || !$0 && vn(e, i) ? (e = xc(), tI = pg = hg = null, Bd = !1, e) : null;
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
            if (i.char && 1 < i.char.length)
              return i.char;
            if (i.which)
              return String.fromCharCode(i.which);
          }
          return null;
        case "compositionend":
          return vK && i.locale !== "ko" ? null : i.data;
        default:
          return null;
      }
    }
    function _c(e) {
      var i = e && e.nodeName && e.nodeName.toLowerCase();
      return i === "input" ? !!HO[e.type] : i === "textarea";
    }
    function Ih(e) {
      if (!ug) return !1;
      e = "on" + e;
      var i = e in document;
      return i || (i = document.createElement("div"), i.setAttribute(e, "return;"), i = typeof i[e] == "function"), i;
    }
    function Fo(e, i, o, u) {
      j ? O ? O.push(u) : O = [u] : j = u, i = RC(i, "onChange"), 0 < i.length && (o = new zI(
        "onChange",
        "change",
        null,
        o,
        u
      ), e.push({ event: o, listeners: i }));
    }
    function Uc(e) {
      hy(e, 0);
    }
    function Rr(e) {
      var i = Ie(e);
      if (_f(i)) return e;
    }
    function WM(e, i) {
      if (e === "change") return i;
    }
    function VM() {
      AD && (AD.detachEvent("onpropertychange", xM), CD = AD = null);
    }
    function xM(e) {
      if (e.propertyName === "value" && Rr(CD)) {
        var i = [];
        Fo(
          i,
          CD,
          e,
          dt(e)
        ), Uo(Uc, i);
      }
    }
    function Ah(e, i, o) {
      e === "focusin" ? (VM(), AD = i, CD = o, AD.attachEvent("onpropertychange", xM)) : e === "focusout" && VM();
    }
    function v0(e) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return Rr(CD);
    }
    function H0(e, i) {
      if (e === "click") return Rr(i);
    }
    function E0(e, i) {
      if (e === "input" || e === "change")
        return Rr(i);
    }
    function R0(e, i) {
      return e === i && (e !== 0 || 1 / e === 1 / i) || e !== e && i !== i;
    }
    function Or(e, i) {
      if (We(e, i)) return !0;
      if (typeof e != "object" || e === null || typeof i != "object" || i === null)
        return !1;
      var o = Object.keys(e), u = Object.keys(i);
      if (o.length !== u.length) return !1;
      for (u = 0; u < o.length; u++) {
        var y = o[u];
        if (!ci.call(i, y) || !We(e[y], i[y]))
          return !1;
      }
      return !0;
    }
    function Ch(e) {
      for (; e && e.firstChild; ) e = e.firstChild;
      return e;
    }
    function _M(e, i) {
      var o = Ch(e);
      e = 0;
      for (var u; o; ) {
        if (o.nodeType === 3) {
          if (u = e + o.textContent.length, e <= i && u >= i)
            return { node: o, offset: i - e };
          e = u;
        }
        g: {
          for (; o; ) {
            if (o.nextSibling) {
              o = o.nextSibling;
              break g;
            }
            o = o.parentNode;
          }
          o = void 0;
        }
        o = Ch(o);
      }
    }
    function UM(e, i) {
      return e && i ? e === i ? !0 : e && e.nodeType === 3 ? !1 : i && i.nodeType === 3 ? UM(e, i.parentNode) : "contains" in e ? e.contains(i) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(i) & 16) : !1 : !1;
    }
    function FM(e) {
      e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window;
      for (var i = Kr(e.document); i instanceof e.HTMLIFrameElement; ) {
        try {
          var o = typeof i.contentWindow.location.href == "string";
        } catch {
          o = !1;
        }
        if (o) e = i.contentWindow;
        else break;
        i = Kr(e.document);
      }
      return i;
    }
    function eh(e) {
      var i = e && e.nodeName && e.nodeName.toLowerCase();
      return i && (i === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || i === "textarea" || e.contentEditable === "true");
    }
    function Fc(e, i, o) {
      var u = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument;
      Im || pd == null || pd !== Kr(u) || (u = pd, "selectionStart" in u && eh(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = {
        anchorNode: u.anchorNode,
        anchorOffset: u.anchorOffset,
        focusNode: u.focusNode,
        focusOffset: u.focusOffset
      }), eD && Or(eD, u) || (eD = u, u = RC(gm, "onSelect"), 0 < u.length && (i = new zI(
        "onSelect",
        "select",
        null,
        i,
        o
      ), e.push({ event: i, listeners: u }), i.target = pd)));
    }
    function Rs(e, i) {
      var o = {};
      return o[e.toLowerCase()] = i.toLowerCase(), o["Webkit" + e] = "webkit" + i, o["Moz" + e] = "moz" + i, o;
    }
    function Os(e) {
      if (Am[e]) return Am[e];
      if (!md[e]) return e;
      var i = md[e], o;
      for (o in i)
        if (i.hasOwnProperty(o) && o in NK)
          return Am[e] = i[o];
      return e;
    }
    function ft(e, i) {
      _K.set(e, i), Vg(i, [e]);
    }
    function Ae(e, i) {
      if (typeof e == "object" && e !== null) {
        var o = em.get(e);
        return o !== void 0 ? o : (i = {
          value: e,
          source: i,
          stack: HM(i)
        }, em.set(e, i), i);
      }
      return {
        value: e,
        source: i,
        stack: HM(i)
      };
    }
    function Xc() {
      for (var e = bd, i = tm = bd = 0; i < e; ) {
        var o = Di[i];
        Di[i++] = null;
        var u = Di[i];
        Di[i++] = null;
        var y = Di[i];
        Di[i++] = null;
        var M = Di[i];
        if (Di[i++] = null, u !== null && y !== null) {
          var G = u.pending;
          G === null ? y.next = y : (y.next = G.next, G.next = y), u.pending = y;
        }
        M !== 0 && XM(o, y, M);
      }
    }
    function Qc(e, i, o, u) {
      Di[bd++] = e, Di[bd++] = i, Di[bd++] = o, Di[bd++] = u, tm |= u, e.lanes |= u, e = e.alternate, e !== null && (e.lanes |= u);
    }
    function th(e, i, o, u) {
      return Qc(e, i, o, u), zc(e);
    }
    function Ce(e, i) {
      return Qc(e, null, null, i), zc(e);
    }
    function XM(e, i, o) {
      e.lanes |= o;
      var u = e.alternate;
      u !== null && (u.lanes |= o);
      for (var y = !1, M = e.return; M !== null; )
        M.childLanes |= o, u = M.alternate, u !== null && (u.childLanes |= o), M.tag === 22 && (e = M.stateNode, e === null || e._visibility & xw || (y = !0)), e = M, M = M.return;
      return e.tag === 3 ? (M = e.stateNode, y && i !== null && (y = 31 - oC(o), e = M.hiddenUpdates, u = e[y], u === null ? e[y] = [i] : u.push(i), i.lane = o | 536870912), M) : null;
    }
    function zc(e) {
      if (SD > eN)
        throw Ac = SD = 0, GD = Hm = null, Error(
          "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
        );
      Ac > tN && (Ac = 0, GD = null, console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      )), e.alternate === null && (e.flags & 4098) !== 0 && cy(e);
      for (var i = e, o = i.return; o !== null; )
        i.alternate === null && (i.flags & 4098) !== 0 && cy(e), i = o, o = i.return;
      return i.tag === 3 ? i.stateNode : null;
    }
    function Ns(e) {
      if (Mi === null) return e;
      var i = Mi(e);
      return i === void 0 ? e : i.current;
    }
    function ih(e) {
      if (Mi === null) return e;
      var i = Mi(e);
      return i === void 0 ? e != null && typeof e.render == "function" && (i = Ns(e.render), e.render !== i) ? (i = { $$typeof: ss, render: i }, e.displayName !== void 0 && (i.displayName = e.displayName), i) : e : i.current;
    }
    function QM(e, i) {
      if (Mi === null) return !1;
      var o = e.elementType;
      i = i.type;
      var u = !1, y = typeof i == "object" && i !== null ? i.$$typeof : null;
      switch (e.tag) {
        case 1:
          typeof i == "function" && (u = !0);
          break;
        case 0:
          (typeof i == "function" || y === Ne) && (u = !0);
          break;
        case 11:
          (y === ss || y === Ne) && (u = !0);
          break;
        case 14:
        case 15:
          (y === nd || y === Ne) && (u = !0);
          break;
        default:
          return !1;
      }
      return !!(u && (e = Mi(o), e !== void 0 && e === Mi(i)));
    }
    function Jc(e) {
      Mi !== null && typeof WeakSet == "function" && (Sd === null && (Sd = /* @__PURE__ */ new WeakSet()), Sd.add(e));
    }
    function ks(e, i, o) {
      var u = e.alternate, y = e.child, M = e.sibling, G = e.tag, P = e.type, W = null;
      switch (G) {
        case 0:
        case 15:
        case 1:
          W = P;
          break;
        case 11:
          W = P.render;
      }
      if (Mi === null)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var _ = !1;
      P = !1, W !== null && (W = Mi(W), W !== void 0 && (o.has(W) ? P = !0 : i.has(W) && (G === 1 ? P = !0 : _ = !0))), Sd !== null && (Sd.has(e) || u !== null && Sd.has(u)) && (P = !0), P && (e._debugNeedsRemount = !0), (P || _) && (u = Ce(e, 2), u !== null && YI(u, e, 2)), y === null || P || ks(
        y,
        i,
        o
      ), M !== null && ks(
        M,
        i,
        o
      );
    }
    function O0(e, i, o, u) {
      this.tag = e, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, FK || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    function Lc(e) {
      return e = e.prototype, !(!e || !e.isReactComponent);
    }
    function ei(e, i) {
      var o = e.alternate;
      switch (o === null ? (o = S(
        e.tag,
        i,
        e.key,
        e.mode
      ), o.elementType = e.elementType, o.type = e.type, o.stateNode = e.stateNode, o._debugOwner = e._debugOwner, o._debugStack = e._debugStack, o._debugTask = e._debugTask, o._debugHookTypes = e._debugHookTypes, o.alternate = e, e.alternate = o) : (o.pendingProps = i, o.type = e.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null, o.actualDuration = -0, o.actualStartTime = -1.1), o.flags = e.flags & 65011712, o.childLanes = e.childLanes, o.lanes = e.lanes, o.child = e.child, o.memoizedProps = e.memoizedProps, o.memoizedState = e.memoizedState, o.updateQueue = e.updateQueue, i = e.dependencies, o.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext,
        _debugThenableState: i._debugThenableState
      }, o.sibling = e.sibling, o.index = e.index, o.ref = e.ref, o.refCleanup = e.refCleanup, o.selfBaseDuration = e.selfBaseDuration, o.treeBaseDuration = e.treeBaseDuration, o._debugInfo = e._debugInfo, o._debugNeedsRemount = e._debugNeedsRemount, o.tag) {
        case 0:
        case 15:
          o.type = Ns(e.type);
          break;
        case 1:
          o.type = Ns(e.type);
          break;
        case 11:
          o.type = ih(e.type);
      }
      return o;
    }
    function nh(e, i) {
      e.flags &= 65011714;
      var o = e.alternate;
      return o === null ? (e.childLanes = 0, e.lanes = i, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0) : (e.childLanes = o.childLanes, e.lanes = o.lanes, e.child = o.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = o.memoizedProps, e.memoizedState = o.memoizedState, e.updateQueue = o.updateQueue, e.type = o.type, i = o.dependencies, e.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext,
        _debugThenableState: i._debugThenableState
      }, e.selfBaseDuration = o.selfBaseDuration, e.treeBaseDuration = o.treeBaseDuration), e;
    }
    function qc(e, i, o, u, y, M) {
      var G = 0, P = e;
      if (typeof e == "function")
        Lc(e) && (G = 1), P = Ns(P);
      else if (typeof e == "string")
        G = Q(), G = Ju(e, o, G) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5;
      else
        g: switch (e) {
          case sd:
            return i = S(31, o, i, y), i.elementType = sd, i.lanes = M, i;
          case ns:
            return Le(
              o.children,
              y,
              M,
              i
            );
          case ro:
            G = 8, y |= we, y |= hn;
            break;
          case Tl:
            return e = o, u = y, typeof e.id != "string" && console.error(
              'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
              typeof e.id
            ), i = S(12, e, i, u | LC), i.elementType = Tl, i.lanes = M, i.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, i;
          case os:
            return i = S(13, o, i, y), i.elementType = os, i.lanes = M, i;
          case id:
            return i = S(19, o, i, y), i.elementType = id, i.lanes = M, i;
          default:
            if (typeof e == "object" && e !== null)
              switch (e.$$typeof) {
                case Tw:
                case De:
                  G = 10;
                  break g;
                case Yl:
                  G = 9;
                  break g;
                case ss:
                  G = 11, P = ih(P);
                  break g;
                case nd:
                  G = 14;
                  break g;
                case Ne:
                  G = 16, P = null;
                  break g;
              }
            P = "", (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (P += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), e === null ? o = "null" : gC(e) ? o = "array" : e !== void 0 && e.$$typeof === an ? (o = "<" + (eg(e.type) || "Unknown") + " />", P = " Did you accidentally export a JSX literal instead of a component?") : o = typeof e, (G = u ? Mg(u) : null) && (P += `

Check the render method of \`` + G + "`."), G = 29, o = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (o + "." + P)
            ), P = null;
        }
      return i = S(G, o, i, y), i.elementType = e, i.type = P, i.lanes = M, i._debugOwner = u, i;
    }
    function Nr(e, i, o) {
      return i = qc(
        e.type,
        e.key,
        e.props,
        e._owner,
        i,
        o
      ), i._debugOwner = e._owner, i._debugStack = e._debugStack, i._debugTask = e._debugTask, i;
    }
    function Le(e, i, o, u) {
      return e = S(7, e, u, i), e.lanes = o, e;
    }
    function sh(e, i, o) {
      return e = S(6, e, null, i), e.lanes = o, e;
    }
    function oh(e, i, o) {
      return i = S(
        4,
        e.children !== null ? e.children : [],
        e.key,
        i
      ), i.lanes = o, i.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
      }, i;
    }
    function Ws(e, i) {
      ht(), Gd[Kd++] = Uw, Gd[Kd++] = _w, _w = e, Uw = i;
    }
    function ah(e, i, o) {
      ht(), wi[Bi++] = ho, wi[Bi++] = yo, wi[Bi++] = _l, _l = e;
      var u = ho;
      e = yo;
      var y = 32 - oC(u) - 1;
      u &= ~(1 << y), o += 1;
      var M = 32 - oC(i) + y;
      if (30 < M) {
        var G = y - y % 5;
        M = (u & (1 << G) - 1).toString(32), u >>= G, y -= G, ho = 1 << 32 - oC(i) + y | o << y | u, yo = M + e;
      } else
        ho = 1 << M | o << y | u, yo = e;
    }
    function $c(e) {
      ht(), e.return !== null && (Ws(e, 1), ah(e, 1, 0));
    }
    function Vs(e) {
      for (; e === _w; )
        _w = Gd[--Kd], Gd[Kd] = null, Uw = Gd[--Kd], Gd[Kd] = null;
      for (; e === _l; )
        _l = wi[--Bi], wi[Bi] = null, yo = wi[--Bi], wi[Bi] = null, ho = wi[--Bi], wi[Bi] = null;
    }
    function ht() {
      FI || console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
    function xs(e, i) {
      if (e.return === null) {
        if (pi === null)
          pi = {
            fiber: e,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: i
          };
        else {
          if (pi.fiber !== e)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          pi.distanceFromLeaf > i && (pi.distanceFromLeaf = i);
        }
        return pi;
      }
      var o = xs(
        e.return,
        i + 1
      ).children;
      return 0 < o.length && o[o.length - 1].fiber === e ? (o = o[o.length - 1], o.distanceFromLeaf > i && (o.distanceFromLeaf = i), o) : (i = {
        fiber: e,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: i
      }, o.push(i), i);
    }
    function Xo(e, i) {
      Do || (e = xs(e, 0), e.serverProps = null, i !== null && (i = Uu(i), e.serverTail.push(i)));
    }
    function Hn(e) {
      var i = "", o = pi;
      throw o !== null && (pi = null, i = jn(o)), zo(
        Ae(
          Error(
            `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + i
          ),
          e
        )
      ), im;
    }
    function rh(e) {
      var i = e.stateNode, o = e.type, u = e.memoizedProps;
      switch (i[OC] = e, i[Me] = u, Cn(o, u), o) {
        case "dialog":
          PI("cancel", i), PI("close", i);
          break;
        case "iframe":
        case "object":
        case "embed":
          PI("load", i);
          break;
        case "video":
        case "audio":
          for (o = 0; o < KD.length; o++)
            PI(KD[o], i);
          break;
        case "source":
          PI("error", i);
          break;
        case "img":
        case "image":
        case "link":
          PI("error", i), PI("load", i);
          break;
        case "details":
          PI("toggle", i);
          break;
        case "input":
          Jg("input", u), PI("invalid", i), Ps(i, u), Ff(
            i,
            u.value,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name,
            !0
          ), OA(i);
          break;
        case "option":
          RM(i, u);
          break;
        case "select":
          Jg("select", u), PI("invalid", i), Ci(i, u);
          break;
        case "textarea":
          Jg("textarea", u), PI("invalid", i), Rc(i, u), Zs(
            i,
            u.value,
            u.defaultValue,
            u.children
          ), OA(i);
      }
      o = u.children, typeof o != "string" && typeof o != "number" && typeof o != "bigint" || i.textContent === "" + o || u.suppressHydrationWarning === !0 || so(i.textContent, o) ? (u.popover != null && (PI("beforetoggle", i), PI("toggle", i)), u.onScroll != null && PI("scroll", i), u.onScrollEnd != null && PI("scrollend", i), u.onClick != null && (i.onclick = qn), i = !0) : i = !1, i || Hn(e);
    }
    function gu(e) {
      for (Ve = e.return; Ve; )
        switch (Ve.tag) {
          case 5:
          case 13:
            us = !1;
            return;
          case 27:
          case 3:
            us = !0;
            return;
          default:
            Ve = Ve.return;
        }
    }
    function _s(e) {
      if (e !== Ve) return !1;
      if (!FI)
        return gu(e), FI = !0, !1;
      var i = e.tag, o;
      if ((o = i !== 3 && i !== 27) && ((o = i === 5) && (o = e.type, o = !(o !== "form" && o !== "button") || gs(e.type, e.memoizedProps)), o = !o), o && XA) {
        for (o = XA; o; ) {
          var u = xs(e, 0), y = Uu(o);
          u.serverTail.push(y), o = y.type === "Suspense" ? Pa(o) : he(o.nextSibling);
        }
        Hn(e);
      }
      if (gu(e), i === 13) {
        if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        XA = Pa(e);
      } else
        i === 27 ? (i = XA, $A(e.type) ? (e = Xm, Xm = null, XA = e) : XA = i) : XA = Ve ? he(e.stateNode.nextSibling) : null;
      return !0;
    }
    function Qo() {
      XA = Ve = null, Do = FI = !1;
    }
    function lh() {
      var e = Ul;
      return e !== null && (Ue === null ? Ue = e : Ue.push.apply(
        Ue,
        e
      ), Ul = null), e;
    }
    function zo(e) {
      Ul === null ? Ul = [e] : Ul.push(e);
    }
    function zM() {
      var e = pi;
      if (e !== null) {
        pi = null;
        for (var i = jn(e); 0 < e.children.length; )
          e = e.children[0];
        gI(e.fiber, function() {
          console.error(
            `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
            "https://react.dev/link/hydration-mismatch",
            i
          );
        });
      }
    }
    function Iu() {
      Td = Fw = null, Yd = !1;
    }
    function En(e, i, o) {
      mg(nm, i._currentValue, e), i._currentValue = o, mg(sm, i._currentRenderer, e), i._currentRenderer !== void 0 && i._currentRenderer !== null && i._currentRenderer !== JK && console.error(
        "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
      ), i._currentRenderer = JK;
    }
    function Wi(e, i) {
      e._currentValue = nm.current;
      var o = sm.current;
      Kg(sm, i), e._currentRenderer = o, Kg(nm, i);
    }
    function ch(e, i, o) {
      for (; e !== null; ) {
        var u = e.alternate;
        if ((e.childLanes & i) !== i ? (e.childLanes |= i, u !== null && (u.childLanes |= i)) : u !== null && (u.childLanes & i) !== i && (u.childLanes |= i), e === o) break;
        e = e.return;
      }
      e !== o && console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function XC(e, i, o, u) {
      var y = e.child;
      for (y !== null && (y.return = e); y !== null; ) {
        var M = y.dependencies;
        if (M !== null) {
          var G = y.child;
          M = M.firstContext;
          g: for (; M !== null; ) {
            var P = M;
            M = y;
            for (var W = 0; W < i.length; W++)
              if (P.context === i[W]) {
                M.lanes |= o, P = M.alternate, P !== null && (P.lanes |= o), ch(
                  M.return,
                  o,
                  e
                ), u || (G = null);
                break g;
              }
            M = P.next;
          }
        } else if (y.tag === 18) {
          if (G = y.return, G === null)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          G.lanes |= o, M = G.alternate, M !== null && (M.lanes |= o), ch(
            G,
            o,
            e
          ), G = null;
        } else G = y.child;
        if (G !== null) G.return = y;
        else
          for (G = y; G !== null; ) {
            if (G === e) {
              G = null;
              break;
            }
            if (y = G.sibling, y !== null) {
              y.return = G.return, G = y;
              break;
            }
            G = G.return;
          }
        y = G;
      }
    }
    function Vi(e, i, o, u) {
      e = null;
      for (var y = i, M = !1; y !== null; ) {
        if (!M) {
          if ((y.flags & 524288) !== 0) M = !0;
          else if ((y.flags & 262144) !== 0) break;
        }
        if (y.tag === 10) {
          var G = y.alternate;
          if (G === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          if (G = G.memoizedProps, G !== null) {
            var P = y.type;
            We(y.pendingProps.value, G.value) || (e !== null ? e.push(P) : e = [P]);
          }
        } else if (y === od.current) {
          if (G = y.alternate, G === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          G.memoizedState.memoizedState !== y.memoizedState.memoizedState && (e !== null ? e.push(ZD) : e = [ZD]);
        }
        y = y.return;
      }
      e !== null && XC(
        i,
        e,
        o,
        u
      ), i.flags |= 262144;
    }
    function kr(e) {
      for (e = e.firstContext; e !== null; ) {
        if (!We(
          e.context._currentValue,
          e.memoizedValue
        ))
          return !0;
        e = e.next;
      }
      return !1;
    }
    function Rn(e) {
      Fw = e, Td = null, e = e.dependencies, e !== null && (e.firstContext = null);
    }
    function fA(e) {
      return Yd && console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      ), Au(Fw, e);
    }
    function Wr(e, i) {
      return Fw === null && Rn(e), Au(e, i);
    }
    function Au(e, i) {
      var o = i._currentValue;
      if (i = { context: i, memoizedValue: o, next: null }, Td === null) {
        if (e === null)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        Td = i, e.dependencies = {
          lanes: 0,
          firstContext: i,
          _debugThenableState: null
        }, e.flags |= 524288;
      } else Td = Td.next = i;
      return o;
    }
    function uh() {
      return {
        controller: new xO(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function qe(e) {
      e.controller.signal.aborted && console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      ), e.refCount++;
    }
    function Us(e) {
      e.refCount--, 0 > e.refCount && console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      ), e.refCount === 0 && _O(UO, function() {
        e.controller.abort();
      });
    }
    function Pe() {
      var e = Fl;
      return Fl = 0, e;
    }
    function Jo(e) {
      var i = Fl;
      return Fl = e, i;
    }
    function Lo(e) {
      var i = Fl;
      return Fl += e, i;
    }
    function xi(e) {
      st = Pd(), 0 > e.actualStartTime && (e.actualStartTime = st);
    }
    function On(e) {
      if (0 <= st) {
        var i = Pd() - st;
        e.actualDuration += i, e.selfBaseDuration = i, st = -1;
      }
    }
    function Cu(e) {
      if (0 <= st) {
        var i = Pd() - st;
        e.actualDuration += i, st = -1;
      }
    }
    function yt() {
      if (0 <= st) {
        var e = Pd() - st;
        st = -1, Fl += e;
      }
    }
    function HC() {
      st = Pd();
    }
    function Vr(e) {
      for (var i = e.child; i; )
        e.actualDuration += i.actualDuration, i = i.sibling;
    }
    function JM(e, i) {
      if (tD === null) {
        var o = tD = [];
        om = 0, Xl = Wu(), Zd = {
          status: "pending",
          value: void 0,
          then: function(u) {
            o.push(u);
          }
        };
      }
      return om++, i.then(dh, dh), i;
    }
    function dh() {
      if (--om === 0 && tD !== null) {
        Zd !== null && (Zd.status = "fulfilled");
        var e = tD;
        tD = null, Xl = 0, Zd = null;
        for (var i = 0; i < e.length; i++) (0, e[i])();
      }
    }
    function N0(e, i) {
      var o = [], u = {
        status: "pending",
        value: null,
        reason: null,
        then: function(y) {
          o.push(y);
        }
      };
      return e.then(
        function() {
          u.status = "fulfilled", u.value = i;
          for (var y = 0; y < o.length; y++) (0, o[y])(i);
        },
        function(y) {
          for (u.status = "rejected", u.reason = y, y = 0; y < o.length; y++)
            (0, o[y])(void 0);
        }
      ), u;
    }
    function fh() {
      var e = Ql.current;
      return e !== null ? e : MA.pooledCache;
    }
    function eu(e, i) {
      i === null ? mg(Ql, Ql.current, e) : mg(Ql, i.pool, e);
    }
    function hh() {
      var e = fh();
      return e === null ? null : { parent: bC._currentValue, pool: e };
    }
    function yh() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function tu(e) {
      return e = e.status, e === "fulfilled" || e === "rejected";
    }
    function ee() {
    }
    function Dh(e, i, o) {
      Dg.actQueue !== null && (Dg.didUsePromise = !0);
      var u = e.thenables;
      switch (o = u[o], o === void 0 ? u.push(i) : o !== i && (e.didWarnAboutUncachedPromise || (e.didWarnAboutUncachedPromise = !0, console.error(
        "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
      )), i.then(ee, ee), i = o), i.status) {
        case "fulfilled":
          return i.value;
        case "rejected":
          throw e = i.reason, je(e), e;
        default:
          if (typeof i.status == "string")
            i.then(ee, ee);
          else {
            if (e = MA, e !== null && 100 < e.shellSuspendCounter)
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            e = i, e.status = "pending", e.then(
              function(y) {
                if (i.status === "pending") {
                  var M = i;
                  M.status = "fulfilled", M.value = y;
                }
              },
              function(y) {
                if (i.status === "pending") {
                  var M = i;
                  M.status = "rejected", M.reason = y;
                }
              }
            );
          }
          switch (i.status) {
            case "fulfilled":
              return i.value;
            case "rejected":
              throw e = i.reason, je(e), e;
          }
          throw cD = i, qw = !0, lD;
      }
    }
    function Ze() {
      if (cD === null)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var e = cD;
      return cD = null, qw = !1, e;
    }
    function je(e) {
      if (e === lD || e === Lw)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function Nn(e) {
      e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function xr(e, i) {
      e = e.updateQueue, i.updateQueue === e && (i.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        callbacks: null
      });
    }
    function Dt(e) {
      return {
        lane: e,
        tag: IT,
        payload: null,
        callback: null,
        next: null
      };
    }
    function Mt(e, i, o) {
      var u = e.updateQueue;
      if (u === null) return null;
      if (u = u.shared, lm === u && !eT) {
        var y = ig(e);
        console.error(
          `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
          y
        ), eT = !0;
      }
      return (qI & _e) !== kt ? (y = u.pending, y === null ? i.next = i : (i.next = y.next, y.next = i), u.pending = i, i = zc(e), XM(e, null, o), i) : (Qc(e, u, i, o), zc(e));
    }
    function Fs(e, i, o) {
      if (i = i.updateQueue, i !== null && (i = i.shared, (o & 4194048) !== 0)) {
        var u = i.lanes;
        u &= e.pendingLanes, o |= u, i.lanes = o, eC(e, o);
      }
    }
    function _i(e, i) {
      var o = e.updateQueue, u = e.alternate;
      if (u !== null && (u = u.updateQueue, o === u)) {
        var y = null, M = null;
        if (o = o.firstBaseUpdate, o !== null) {
          do {
            var G = {
              lane: o.lane,
              tag: o.tag,
              payload: o.payload,
              callback: null,
              next: null
            };
            M === null ? y = M = G : M = M.next = G, o = o.next;
          } while (o !== null);
          M === null ? y = M = i : M = M.next = i;
        } else y = M = i;
        o = {
          baseState: u.baseState,
          firstBaseUpdate: y,
          lastBaseUpdate: M,
          shared: u.shared,
          callbacks: u.callbacks
        }, e.updateQueue = o;
        return;
      }
      e = o.lastBaseUpdate, e === null ? o.firstBaseUpdate = i : e.next = i, o.lastBaseUpdate = i;
    }
    function qo() {
      if (cm) {
        var e = Zd;
        if (e !== null) throw e;
      }
    }
    function kn(e, i, o, u) {
      cm = !1;
      var y = e.updateQueue;
      Xa = !1, lm = y.shared;
      var M = y.firstBaseUpdate, G = y.lastBaseUpdate, P = y.shared.pending;
      if (P !== null) {
        y.shared.pending = null;
        var W = P, _ = W.next;
        W.next = null, G === null ? M = _ : G.next = _, G = W;
        var wg = e.alternate;
        wg !== null && (wg = wg.updateQueue, P = wg.lastBaseUpdate, P !== G && (P === null ? wg.firstBaseUpdate = _ : P.next = _, wg.lastBaseUpdate = W));
      }
      if (M !== null) {
        var Gg = y.baseState;
        G = 0, wg = _ = W = null, P = M;
        do {
          var yg = P.lane & -536870913, Tg = yg !== P.lane;
          if (Tg ? (OI & yg) === yg : (u & yg) === yg) {
            yg !== 0 && yg === Xl && (cm = !0), wg !== null && (wg = wg.next = {
              lane: 0,
              tag: P.tag,
              payload: P.payload,
              callback: null,
              next: null
            });
            g: {
              yg = e;
              var qg = P, aI = i, wA = o;
              switch (qg.tag) {
                case AT:
                  if (qg = qg.payload, typeof qg == "function") {
                    Yd = !0;
                    var NI = qg.call(
                      wA,
                      Gg,
                      aI
                    );
                    if (yg.mode & we) {
                      Wg(!0);
                      try {
                        qg.call(wA, Gg, aI);
                      } finally {
                        Wg(!1);
                      }
                    }
                    Yd = !1, Gg = NI;
                    break g;
                  }
                  Gg = qg;
                  break g;
                case rm:
                  yg.flags = yg.flags & -65537 | 128;
                case IT:
                  if (NI = qg.payload, typeof NI == "function") {
                    if (Yd = !0, qg = NI.call(
                      wA,
                      Gg,
                      aI
                    ), yg.mode & we) {
                      Wg(!0);
                      try {
                        NI.call(wA, Gg, aI);
                      } finally {
                        Wg(!1);
                      }
                    }
                    Yd = !1;
                  } else qg = NI;
                  if (qg == null) break g;
                  Gg = uI({}, Gg, qg);
                  break g;
                case CT:
                  Xa = !0;
              }
            }
            yg = P.callback, yg !== null && (e.flags |= 64, Tg && (e.flags |= 8192), Tg = y.callbacks, Tg === null ? y.callbacks = [yg] : Tg.push(yg));
          } else
            Tg = {
              lane: yg,
              tag: P.tag,
              payload: P.payload,
              callback: P.callback,
              next: null
            }, wg === null ? (_ = wg = Tg, W = Gg) : wg = wg.next = Tg, G |= yg;
          if (P = P.next, P === null) {
            if (P = y.shared.pending, P === null)
              break;
            Tg = P, P = Tg.next, Tg.next = null, y.lastBaseUpdate = Tg, y.shared.pending = null;
          }
        } while (!0);
        wg === null && (W = Gg), y.baseState = W, y.firstBaseUpdate = _, y.lastBaseUpdate = wg, M === null && (y.shared.lanes = 0), La |= G, e.lanes = G, e.memoizedState = Gg;
      }
      lm = null;
    }
    function Xs(e, i) {
      if (typeof e != "function")
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " + e
        );
      e.call(i);
    }
    function k0(e, i) {
      var o = e.shared.hiddenCallbacks;
      if (o !== null)
        for (e.shared.hiddenCallbacks = null, e = 0; e < o.length; e++)
          Xs(o[e], i);
    }
    function te(e, i) {
      var o = e.callbacks;
      if (o !== null)
        for (e.callbacks = null, e = 0; e < o.length; e++)
          Xs(o[e], i);
    }
    function iu(e, i) {
      var o = hs;
      mg($w, o, e), mg(jd, i, e), hs = o | i.baseLanes;
    }
    function wt(e) {
      mg($w, hs, e), mg(
        jd,
        jd.current,
        e
      );
    }
    function nu(e) {
      hs = $w.current, Kg(jd, e), Kg($w, e);
    }
    function BI() {
      var e = bg;
      Si === null ? Si = [e] : Si.push(e);
    }
    function Og() {
      var e = bg;
      if (Si !== null && (wo++, Si[wo] !== e)) {
        var i = ig(dI);
        if (!tT.has(i) && (tT.add(i), Si !== null)) {
          for (var o = "", u = 0; u <= wo; u++) {
            var y = Si[u], M = u === wo ? e : y;
            for (y = u + 1 + ". " + y; 30 > y.length; )
              y += " ";
            y += M + `
`, o += y;
          }
          console.error(
            `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
            i,
            o
          );
        }
      }
    }
    function Wn(e) {
      e == null || gC(e) || console.error(
        "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
        bg,
        typeof e
      );
    }
    function $o() {
      var e = ig(dI);
      nT.has(e) || (nT.add(e), console.error(
        "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
        e
      ));
    }
    function aA() {
      throw Error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      );
    }
    function Vn(e, i) {
      if (dD) return !1;
      if (i === null)
        return console.error(
          "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
          bg
        ), !1;
      e.length !== i.length && console.error(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        bg,
        "[" + i.join(", ") + "]",
        "[" + e.join(", ") + "]"
      );
      for (var o = 0; o < i.length && o < e.length; o++)
        if (!We(e[o], i[o])) return !1;
      return !0;
    }
    function ga(e, i, o, u, y, M) {
      Qa = M, dI = i, Si = e !== null ? e._debugHookTypes : null, wo = -1, dD = e !== null && e.type !== i.type, (Object.prototype.toString.call(o) === "[object AsyncFunction]" || Object.prototype.toString.call(o) === "[object AsyncGeneratorFunction]") && (M = ig(dI), um.has(M) || (um.add(M), console.error(
        "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
        M === null ? "An unknown Component" : "<" + M + ">"
      ))), i.memoizedState = null, i.updateQueue = null, i.lanes = 0, Dg.H = e !== null && e.memoizedState !== null ? fm : Si !== null ? sT : dm, Jl = M = (i.mode & we) !== bA;
      var G = hm(o, u, y);
      if (Jl = !1, Hd && (G = ie(
        i,
        o,
        u,
        y
      )), M) {
        Wg(!0);
        try {
          G = ie(
            i,
            o,
            u,
            y
          );
        } finally {
          Wg(!1);
        }
      }
      return _r(e, i), G;
    }
    function _r(e, i) {
      i._debugHookTypes = Si, i.dependencies === null ? Mo !== null && (i.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: Mo
      }) : i.dependencies._debugThenableState = Mo, Dg.H = AB;
      var o = rA !== null && rA.next !== null;
      if (Qa = 0, Si = bg = lC = rA = dI = null, wo = -1, e !== null && (e.flags & 65011712) !== (i.flags & 65011712) && console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      ), gB = !1, uD = 0, Mo = null, o)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      e === null || NC || (e = e.dependencies, e !== null && kr(e) && (NC = !0)), qw ? (qw = !1, e = !0) : e = !1, e && (i = ig(i) || "Unknown", iT.has(i) || um.has(i) || (iT.add(i), console.error(
        "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
      )));
    }
    function ie(e, i, o, u) {
      dI = e;
      var y = 0;
      do {
        if (Hd && (Mo = null), uD = 0, Hd = !1, y >= XO)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (y += 1, dD = !1, lC = rA = null, e.updateQueue != null) {
          var M = e.updateQueue;
          M.lastEffect = null, M.events = null, M.stores = null, M.memoCache != null && (M.memoCache.index = 0);
        }
        wo = -1, Dg.H = oT, M = hm(i, o, u);
      } while (Hd);
      return M;
    }
    function $e() {
      var e = Dg.H, i = e.useState()[0];
      return i = typeof i.then == "function" ? Qs(i) : i, e = e.useState()[0], (rA !== null ? rA.memoizedState : null) !== e && (dI.flags |= 1024), i;
    }
    function Ui() {
      var e = IB !== 0;
      return IB = 0, e;
    }
    function Bt(e, i, o) {
      i.updateQueue = e.updateQueue, i.flags = (i.mode & hn) !== bA ? i.flags & -402655237 : i.flags & -2053, e.lanes &= ~o;
    }
    function pt(e) {
      if (gB) {
        for (e = e.memoizedState; e !== null; ) {
          var i = e.queue;
          i !== null && (i.pending = null), e = e.next;
        }
        gB = !1;
      }
      Qa = 0, Si = lC = rA = dI = null, wo = -1, bg = null, Hd = !1, uD = IB = 0, Mo = null;
    }
    function xA() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return lC === null ? dI.memoizedState = lC = e : lC = lC.next = e, lC;
    }
    function JI() {
      if (rA === null) {
        var e = dI.alternate;
        e = e !== null ? e.memoizedState : null;
      } else e = rA.next;
      var i = lC === null ? dI.memoizedState : lC.next;
      if (i !== null)
        lC = i, rA = e;
      else {
        if (e === null)
          throw dI.alternate === null ? Error(
            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
          ) : Error("Rendered more hooks than during the previous render.");
        rA = e, e = {
          memoizedState: rA.memoizedState,
          baseState: rA.baseState,
          baseQueue: rA.baseQueue,
          queue: rA.queue,
          next: null
        }, lC === null ? dI.memoizedState = lC = e : lC = lC.next = e;
      }
      return lC;
    }
    function Ur() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function Qs(e) {
      var i = uD;
      return uD += 1, Mo === null && (Mo = yh()), e = Dh(Mo, e, i), i = dI, (lC === null ? i.memoizedState : lC.next) === null && (i = i.alternate, Dg.H = i !== null && i.memoizedState !== null ? fm : dm), e;
    }
    function PA(e) {
      if (e !== null && typeof e == "object") {
        if (typeof e.then == "function") return Qs(e);
        if (e.$$typeof === De) return fA(e);
      }
      throw Error("An unsupported type was passed to use(): " + String(e));
    }
    function IA(e) {
      var i = null, o = dI.updateQueue;
      if (o !== null && (i = o.memoCache), i == null) {
        var u = dI.alternate;
        u !== null && (u = u.updateQueue, u !== null && (u = u.memoCache, u != null && (i = {
          data: u.data.map(function(y) {
            return y.slice();
          }),
          index: 0
        })));
      }
      if (i == null && (i = { data: [], index: 0 }), o === null && (o = Ur(), dI.updateQueue = o), o.memoCache = i, o = i.data[i.index], o === void 0 || dD)
        for (o = i.data[i.index] = Array(e), u = 0; u < e; u++)
          o[u] = Yw;
      else
        o.length !== e && console.error(
          "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
          o.length,
          e
        );
      return i.index++, o;
    }
    function pI(e, i) {
      return typeof i == "function" ? i(e) : i;
    }
    function Fi(e, i, o) {
      var u = xA();
      if (o !== void 0) {
        var y = o(i);
        if (Jl) {
          Wg(!0);
          try {
            o(i);
          } finally {
            Wg(!1);
          }
        }
      } else y = i;
      return u.memoizedState = u.baseState = y, e = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: y
      }, u.queue = e, e = e.dispatch = Il.bind(
        null,
        dI,
        e
      ), [u.memoizedState, e];
    }
    function QC(e) {
      var i = JI();
      return Fr(i, rA, e);
    }
    function Fr(e, i, o) {
      var u = e.queue;
      if (u === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      u.lastRenderedReducer = o;
      var y = e.baseQueue, M = u.pending;
      if (M !== null) {
        if (y !== null) {
          var G = y.next;
          y.next = M.next, M.next = G;
        }
        i.baseQueue !== y && console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        ), i.baseQueue = y = M, u.pending = null;
      }
      if (M = e.baseState, y === null) e.memoizedState = M;
      else {
        i = y.next;
        var P = G = null, W = null, _ = i, wg = !1;
        do {
          var Gg = _.lane & -536870913;
          if (Gg !== _.lane ? (OI & Gg) === Gg : (Qa & Gg) === Gg) {
            var yg = _.revertLane;
            if (yg === 0)
              W !== null && (W = W.next = {
                lane: 0,
                revertLane: 0,
                action: _.action,
                hasEagerState: _.hasEagerState,
                eagerState: _.eagerState,
                next: null
              }), Gg === Xl && (wg = !0);
            else if ((Qa & yg) === yg) {
              _ = _.next, yg === Xl && (wg = !0);
              continue;
            } else
              Gg = {
                lane: 0,
                revertLane: _.revertLane,
                action: _.action,
                hasEagerState: _.hasEagerState,
                eagerState: _.eagerState,
                next: null
              }, W === null ? (P = W = Gg, G = M) : W = W.next = Gg, dI.lanes |= yg, La |= yg;
            Gg = _.action, Jl && o(M, Gg), M = _.hasEagerState ? _.eagerState : o(M, Gg);
          } else
            yg = {
              lane: Gg,
              revertLane: _.revertLane,
              action: _.action,
              hasEagerState: _.hasEagerState,
              eagerState: _.eagerState,
              next: null
            }, W === null ? (P = W = yg, G = M) : W = W.next = yg, dI.lanes |= Gg, La |= Gg;
          _ = _.next;
        } while (_ !== null && _ !== i);
        if (W === null ? G = M : W.next = P, !We(M, e.memoizedState) && (NC = !0, wg && (o = Zd, o !== null)))
          throw o;
        e.memoizedState = M, e.baseState = G, e.baseQueue = W, u.lastRenderedState = M;
      }
      return y === null && (u.lanes = 0), [e.memoizedState, u.dispatch];
    }
    function mt(e) {
      var i = JI(), o = i.queue;
      if (o === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      o.lastRenderedReducer = e;
      var u = o.dispatch, y = o.pending, M = i.memoizedState;
      if (y !== null) {
        o.pending = null;
        var G = y = y.next;
        do
          M = e(M, G.action), G = G.next;
        while (G !== y);
        We(M, i.memoizedState) || (NC = !0), i.memoizedState = M, i.baseQueue === null && (i.baseState = M), o.lastRenderedState = M;
      }
      return [M, u];
    }
    function su(e, i, o) {
      var u = dI, y = xA();
      if (FI) {
        if (o === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var M = o();
        vd || M === o() || (console.error(
          "The result of getServerSnapshot should be cached to avoid an infinite loop"
        ), vd = !0);
      } else {
        if (M = i(), vd || (o = i(), We(M, o) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), vd = !0)), MA === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        (OI & 124) !== 0 || Ia(u, i, M);
      }
      return y.memoizedState = M, o = { value: M, getSnapshot: i }, y.queue = o, Jr(
        Mh.bind(null, u, o, e),
        [e]
      ), u.flags |= 2048, ni(
        bi | SC,
        ia(),
        Aa.bind(
          null,
          u,
          o,
          M,
          i
        ),
        null
      ), M;
    }
    function Xr(e, i, o) {
      var u = dI, y = JI(), M = FI;
      if (M) {
        if (o === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        o = o();
      } else if (o = i(), !vd) {
        var G = i();
        We(o, G) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), vd = !0);
      }
      (G = !We(
        (rA || y).memoizedState,
        o
      )) && (y.memoizedState = o, NC = !0), y = y.queue;
      var P = Mh.bind(null, u, y, e);
      if (ne(2048, SC, P, [e]), y.getSnapshot !== i || G || lC !== null && lC.memoizedState.tag & bi) {
        if (u.flags |= 2048, ni(
          bi | SC,
          ia(),
          Aa.bind(
            null,
            u,
            y,
            o,
            i
          ),
          null
        ), MA === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        M || (Qa & 124) !== 0 || Ia(u, i, o);
      }
      return o;
    }
    function Ia(e, i, o) {
      e.flags |= 16384, e = { getSnapshot: i, value: o }, i = dI.updateQueue, i === null ? (i = Ur(), dI.updateQueue = i, i.stores = [e]) : (o = i.stores, o === null ? i.stores = [e] : o.push(e));
    }
    function Aa(e, i, o, u) {
      i.value = o, i.getSnapshot = u, Ca(i) && ou(e);
    }
    function Mh(e, i, o) {
      return o(function() {
        Ca(i) && ou(e);
      });
    }
    function Ca(e) {
      var i = e.getSnapshot;
      e = e.value;
      try {
        var o = i();
        return !We(e, o);
      } catch {
        return !0;
      }
    }
    function ou(e) {
      var i = Ce(e, 2);
      i !== null && YI(i, e, 2);
    }
    function Xi(e) {
      var i = xA();
      if (typeof e == "function") {
        var o = e;
        if (e = o(), Jl) {
          Wg(!0);
          try {
            o();
          } finally {
            Wg(!1);
          }
        }
      }
      return i.memoizedState = i.baseState = e, i.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: pI,
        lastRenderedState: e
      }, i;
    }
    function bt(e) {
      e = Xi(e);
      var i = e.queue, o = la.bind(null, dI, i);
      return i.dispatch = o, [e.memoizedState, o];
    }
    function ti(e) {
      var i = xA();
      i.memoizedState = i.baseState = e;
      var o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = o, i = fu.bind(
        null,
        dI,
        !0,
        o
      ), o.dispatch = i, [e, i];
    }
    function ii(e, i) {
      var o = JI();
      return au(o, rA, e, i);
    }
    function au(e, i, o, u) {
      return e.baseState = o, Fr(
        e,
        rA,
        typeof u == "function" ? u : pI
      );
    }
    function ru(e, i) {
      var o = JI();
      return rA !== null ? au(o, rA, e, i) : (o.baseState = e, [e, o.queue.dispatch]);
    }
    function Qr(e, i, o, u, y) {
      if (Li(e))
        throw Error("Cannot update form state while rendering.");
      if (e = i.action, e !== null) {
        var M = {
          payload: y,
          action: e,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(G) {
            M.listeners.push(G);
          }
        };
        Dg.T !== null ? o(!0) : M.isTransition = !1, u(M), o = i.pending, o === null ? (M.next = i.pending = M, zr(i, M)) : (M.next = o.next, i.pending = o.next = M);
      }
    }
    function zr(e, i) {
      var o = i.action, u = i.payload, y = e.state;
      if (i.isTransition) {
        var M = Dg.T, G = {};
        Dg.T = G, Dg.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var P = o(y, u), W = Dg.S;
          W !== null && W(G, P), xn(e, i, P);
        } catch (_) {
          ea(e, i, _);
        } finally {
          Dg.T = M, M === null && G._updatedFibers && (e = G._updatedFibers.size, G._updatedFibers.clear(), 10 < e && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      } else
        try {
          G = o(y, u), xn(e, i, G);
        } catch (_) {
          ea(e, i, _);
        }
    }
    function xn(e, i, o) {
      o !== null && typeof o == "object" && typeof o.then == "function" ? (o.then(
        function(u) {
          MC(e, i, u);
        },
        function(u) {
          return ea(e, i, u);
        }
      ), i.isTransition || console.error(
        "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
      )) : MC(e, i, o);
    }
    function MC(e, i, o) {
      i.status = "fulfilled", i.value = o, wh(i), e.state = o, i = e.pending, i !== null && (o = i.next, o === i ? e.pending = null : (o = o.next, i.next = o, zr(e, o)));
    }
    function ea(e, i, o) {
      var u = e.pending;
      if (e.pending = null, u !== null) {
        u = u.next;
        do
          i.status = "rejected", i.reason = o, wh(i), i = i.next;
        while (i !== u);
      }
      e.action = null;
    }
    function wh(e) {
      e = e.listeners;
      for (var i = 0; i < e.length; i++) (0, e[i])();
    }
    function LM(e, i) {
      return i;
    }
    function ta(e, i) {
      if (FI) {
        var o = MA.formState;
        if (o !== null) {
          g: {
            var u = dI;
            if (FI) {
              if (XA) {
                I: {
                  for (var y = XA, M = us; y.nodeType !== 8; ) {
                    if (!M) {
                      y = null;
                      break I;
                    }
                    if (y = he(
                      y.nextSibling
                    ), y === null) {
                      y = null;
                      break I;
                    }
                  }
                  M = y.data, y = M === xm || M === nY ? y : null;
                }
                if (y) {
                  XA = he(
                    y.nextSibling
                  ), u = y.data === xm;
                  break g;
                }
              }
              Hn(u);
            }
            u = !1;
          }
          u && (i = o[0]);
        }
      }
      return o = xA(), o.memoizedState = o.baseState = i, u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: LM,
        lastRenderedState: i
      }, o.queue = u, o = la.bind(
        null,
        dI,
        u
      ), u.dispatch = o, u = Xi(!1), M = fu.bind(
        null,
        dI,
        !1,
        u.queue
      ), u = xA(), y = {
        state: i,
        dispatch: null,
        action: e,
        pending: null
      }, u.queue = y, o = Qr.bind(
        null,
        dI,
        y,
        M,
        o
      ), y.dispatch = o, u.memoizedState = e, [i, o, !1];
    }
    function lu(e) {
      var i = JI();
      return _A(i, rA, e);
    }
    function _A(e, i, o) {
      if (i = Fr(
        e,
        i,
        LM
      )[0], e = QC(pI)[0], typeof i == "object" && i !== null && typeof i.then == "function")
        try {
          var u = Qs(i);
        } catch (G) {
          throw G === lD ? Lw : G;
        }
      else u = i;
      i = JI();
      var y = i.queue, M = y.dispatch;
      return o !== i.memoizedState && (dI.flags |= 2048, ni(
        bi | SC,
        ia(),
        Bh.bind(null, y, o),
        null
      )), [u, M, e];
    }
    function Bh(e, i) {
      e.action = i;
    }
    function _n(e) {
      var i = JI(), o = rA;
      if (o !== null)
        return _A(i, o, e);
      JI(), i = i.memoizedState, o = JI();
      var u = o.queue.dispatch;
      return o.memoizedState = e, [i, u, !1];
    }
    function ni(e, i, o, u) {
      return e = {
        tag: e,
        create: o,
        deps: u,
        inst: i,
        next: null
      }, i = dI.updateQueue, i === null && (i = Ur(), dI.updateQueue = i), o = i.lastEffect, o === null ? i.lastEffect = e.next = e : (u = o.next, o.next = e, e.next = u, i.lastEffect = e), e;
    }
    function ia() {
      return { destroy: void 0, resource: void 0 };
    }
    function Un(e) {
      var i = xA();
      return e = { current: e }, i.memoizedState = e;
    }
    function gt(e, i, o, u) {
      var y = xA();
      u = u === void 0 ? null : u, dI.flags |= e, y.memoizedState = ni(
        bi | i,
        ia(),
        o,
        u
      );
    }
    function ne(e, i, o, u) {
      var y = JI();
      u = u === void 0 ? null : u;
      var M = y.memoizedState.inst;
      rA !== null && u !== null && Vn(u, rA.memoizedState.deps) ? y.memoizedState = ni(i, M, o, u) : (dI.flags |= e, y.memoizedState = ni(
        bi | i,
        M,
        o,
        u
      ));
    }
    function Jr(e, i) {
      (dI.mode & hn) !== bA && (dI.mode & UK) === bA ? gt(276826112, SC, e, i) : gt(8390656, SC, e, i);
    }
    function ph(e, i) {
      var o = 4194308;
      return (dI.mode & hn) !== bA && (o |= 134217728), gt(o, qC, e, i);
    }
    function mh(e, i) {
      if (typeof i == "function") {
        e = e();
        var o = i(e);
        return function() {
          typeof o == "function" ? o() : i(null);
        };
      }
      if (i != null)
        return i.hasOwnProperty("current") || console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(i).join(", ") + "}"
        ), e = e(), i.current = e, function() {
          i.current = null;
        };
    }
    function Qi(e, i, o) {
      typeof i != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        i !== null ? typeof i : "null"
      ), o = o != null ? o.concat([e]) : null;
      var u = 4194308;
      (dI.mode & hn) !== bA && (u |= 134217728), gt(
        u,
        qC,
        mh.bind(null, i, e),
        o
      );
    }
    function na(e, i, o) {
      typeof i != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        i !== null ? typeof i : "null"
      ), o = o != null ? o.concat([e]) : null, ne(
        4,
        qC,
        mh.bind(null, i, e),
        o
      );
    }
    function sa(e, i) {
      return xA().memoizedState = [
        e,
        i === void 0 ? null : i
      ], e;
    }
    function Lr(e, i) {
      var o = JI();
      i = i === void 0 ? null : i;
      var u = o.memoizedState;
      return i !== null && Vn(i, u[1]) ? u[0] : (o.memoizedState = [e, i], e);
    }
    function zs(e, i) {
      var o = xA();
      i = i === void 0 ? null : i;
      var u = e();
      if (Jl) {
        Wg(!0);
        try {
          e();
        } finally {
          Wg(!1);
        }
      }
      return o.memoizedState = [u, i], u;
    }
    function qr(e, i) {
      var o = JI();
      i = i === void 0 ? null : i;
      var u = o.memoizedState;
      if (i !== null && Vn(i, u[1]))
        return u[0];
      if (u = e(), Jl) {
        Wg(!0);
        try {
          e();
        } finally {
          Wg(!1);
        }
      }
      return o.memoizedState = [u, i], u;
    }
    function oa(e, i) {
      var o = xA();
      return aa(o, e, i);
    }
    function cu(e, i) {
      var o = JI();
      return Sh(
        o,
        rA.memoizedState,
        e,
        i
      );
    }
    function bh(e, i) {
      var o = JI();
      return rA === null ? aa(o, e, i) : Sh(
        o,
        rA.memoizedState,
        e,
        i
      );
    }
    function aa(e, i, o) {
      return o === void 0 || (Qa & 1073741824) !== 0 ? e.memoizedState = i : (e.memoizedState = o, e = Cy(), dI.lanes |= e, La |= e, o);
    }
    function Sh(e, i, o, u) {
      return We(o, i) ? o : jd.current !== null ? (e = aa(e, o, u), We(e, i) || (NC = !0), e) : (Qa & 42) === 0 ? (NC = !0, e.memoizedState = o) : (e = Cy(), dI.lanes |= e, La |= e, i);
    }
    function ra(e, i, o, u, y) {
      var M = QI.p;
      QI.p = M !== 0 && M < ui ? M : ui;
      var G = Dg.T, P = {};
      Dg.T = P, fu(e, !1, i, o), P._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var W = y(), _ = Dg.S;
        if (_ !== null && _(P, W), W !== null && typeof W == "object" && typeof W.then == "function") {
          var wg = N0(
            W,
            u
          );
          ca(
            e,
            i,
            wg,
            He(e)
          );
        } else
          ca(
            e,
            i,
            u,
            He(e)
          );
      } catch (Gg) {
        ca(
          e,
          i,
          { then: function() {
          }, status: "rejected", reason: Gg },
          He(e)
        );
      } finally {
        QI.p = M, Dg.T = G, G === null && P._updatedFibers && (e = P._updatedFibers.size, P._updatedFibers.clear(), 10 < e && console.warn(
          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
        ));
      }
    }
    function uu(e, i, o, u) {
      if (e.tag !== 5)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var y = Gh(e).queue;
      ra(
        e,
        y,
        i,
        nc,
        o === null ? p : function() {
          return zi(e), o(u);
        }
      );
    }
    function Gh(e) {
      var i = e.memoizedState;
      if (i !== null) return i;
      i = {
        memoizedState: nc,
        baseState: nc,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: pI,
          lastRenderedState: nc
        },
        next: null
      };
      var o = {};
      return i.next = {
        memoizedState: o,
        baseState: o,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: pI,
          lastRenderedState: o
        },
        next: null
      }, e.memoizedState = i, e = e.alternate, e !== null && (e.memoizedState = i), i;
    }
    function zi(e) {
      Dg.T === null && console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
      var i = Gh(e).next.queue;
      ca(
        e,
        i,
        {},
        He(e)
      );
    }
    function $r() {
      var e = Xi(!1);
      return e = ra.bind(
        null,
        dI,
        e.queue,
        !0,
        !1
      ), xA().memoizedState = e, [!1, e];
    }
    function du() {
      var e = QC(pI)[0], i = JI().memoizedState;
      return [
        typeof e == "boolean" ? e : Qs(e),
        i
      ];
    }
    function Ji() {
      var e = mt(pI)[0], i = JI().memoizedState;
      return [
        typeof e == "boolean" ? e : Qs(e),
        i
      ];
    }
    function se() {
      return fA(ZD);
    }
    function Js() {
      var e = xA(), i = MA.identifierPrefix;
      if (FI) {
        var o = yo, u = ho;
        o = (u & ~(1 << 32 - oC(u) - 1)).toString(32) + o, i = "" + i + "R" + o, o = IB++, 0 < o && (i += "H" + o.toString(32)), i += "";
      } else
        o = FO++, i = "" + i + "r" + o.toString(32) + "";
      return e.memoizedState = i;
    }
    function gl() {
      return xA().memoizedState = Kh.bind(
        null,
        dI
      );
    }
    function Kh(e, i) {
      for (var o = e.return; o !== null; ) {
        switch (o.tag) {
          case 24:
          case 3:
            var u = He(o);
            e = Dt(u);
            var y = Mt(o, e, u);
            y !== null && (YI(y, o, u), Fs(y, o, u)), o = uh(), i != null && y !== null && console.error(
              "The seed argument is not enabled outside experimental channels."
            ), e.payload = { cache: o };
            return;
        }
        o = o.return;
      }
    }
    function Il(e, i, o) {
      var u = arguments;
      typeof u[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), u = He(e);
      var y = {
        lane: u,
        revertLane: 0,
        action: o,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      Li(e) ? Al(i, y) : (y = th(e, i, y, u), y !== null && (YI(y, e, u), Th(y, i, u))), oA(e, u);
    }
    function la(e, i, o) {
      var u = arguments;
      typeof u[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), u = He(e), ca(e, i, o, u), oA(e, u);
    }
    function ca(e, i, o, u) {
      var y = {
        lane: u,
        revertLane: 0,
        action: o,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Li(e)) Al(i, y);
      else {
        var M = e.alternate;
        if (e.lanes === 0 && (M === null || M.lanes === 0) && (M = i.lastRenderedReducer, M !== null)) {
          var G = Dg.H;
          Dg.H = Dn;
          try {
            var P = i.lastRenderedState, W = M(P, o);
            if (y.hasEagerState = !0, y.eagerState = W, We(W, P))
              return Qc(e, i, y, 0), MA === null && Xc(), !1;
          } catch {
          } finally {
            Dg.H = G;
          }
        }
        if (o = th(e, i, y, u), o !== null)
          return YI(o, e, u), Th(o, i, u), !0;
      }
      return !1;
    }
    function fu(e, i, o, u) {
      if (Dg.T === null && Xl === 0 && console.error(
        "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
      ), u = {
        lane: 2,
        revertLane: Wu(),
        action: u,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, Li(e)) {
        if (i)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        i = th(
          e,
          o,
          u,
          2
        ), i !== null && YI(i, e, 2);
      oA(e, 2);
    }
    function Li(e) {
      var i = e.alternate;
      return e === dI || i !== null && i === dI;
    }
    function Al(e, i) {
      Hd = gB = !0;
      var o = e.pending;
      o === null ? i.next = i : (i.next = o.next, o.next = i), e.pending = i;
    }
    function Th(e, i, o) {
      if ((o & 4194048) !== 0) {
        var u = i.lanes;
        u &= e.pendingLanes, o |= u, i.lanes = o, eC(e, o);
      }
    }
    function LA(e) {
      var i = GI;
      return e != null && (GI = i === null ? e : i.concat(e)), i;
    }
    function ua(e, i, o) {
      for (var u = Object.keys(e.props), y = 0; y < u.length; y++) {
        var M = u[y];
        if (M !== "children" && M !== "key") {
          i === null && (i = Nr(e, o.mode, 0), i._debugInfo = GI, i.return = o), gI(
            i,
            function(G) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                G
              );
            },
            M
          );
          break;
        }
      }
    }
    function St(e) {
      var i = fD;
      return fD += 1, Ed === null && (Ed = yh()), Dh(Ed, e, i);
    }
    function hI(e, i) {
      i = i.props.ref, e.ref = i !== void 0 ? i : null;
    }
    function XI(e, i) {
      throw i.$$typeof === X0 ? Error(
        `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
      ) : (e = Object.prototype.toString.call(i), Error(
        "Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."
      ));
    }
    function KA(e, i) {
      var o = ig(e) || "Component";
      mT[o] || (mT[o] = !0, i = i.displayName || i.name || "Component", e.tag === 3 ? console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
        i,
        i,
        i
      ) : console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
        i,
        i,
        o,
        i,
        o
      ));
    }
    function Ls(e, i) {
      var o = ig(e) || "Component";
      bT[o] || (bT[o] = !0, i = String(i), e.tag === 3 ? console.error(
        `Symbols are not valid as a React child.
  root.render(%s)`,
        i
      ) : console.error(
        `Symbols are not valid as a React child.
  <%s>%s</%s>`,
        o,
        i,
        o
      ));
    }
    function qs(e) {
      function i($, gg) {
        if (e) {
          var Ig = $.deletions;
          Ig === null ? ($.deletions = [gg], $.flags |= 16) : Ig.push(gg);
        }
      }
      function o($, gg) {
        if (!e) return null;
        for (; gg !== null; )
          i($, gg), gg = gg.sibling;
        return null;
      }
      function u($) {
        for (var gg = /* @__PURE__ */ new Map(); $ !== null; )
          $.key !== null ? gg.set($.key, $) : gg.set($.index, $), $ = $.sibling;
        return gg;
      }
      function y($, gg) {
        return $ = ei($, gg), $.index = 0, $.sibling = null, $;
      }
      function M($, gg, Ig) {
        return $.index = Ig, e ? (Ig = $.alternate, Ig !== null ? (Ig = Ig.index, Ig < gg ? ($.flags |= 67108866, gg) : Ig) : ($.flags |= 67108866, gg)) : ($.flags |= 1048576, gg);
      }
      function G($) {
        return e && $.alternate === null && ($.flags |= 67108866), $;
      }
      function P($, gg, Ig, Pg) {
        return gg === null || gg.tag !== 6 ? (gg = sh(
          Ig,
          $.mode,
          Pg
        ), gg.return = $, gg._debugOwner = $, gg._debugTask = $._debugTask, gg._debugInfo = GI, gg) : (gg = y(gg, Ig), gg.return = $, gg._debugInfo = GI, gg);
      }
      function W($, gg, Ig, Pg) {
        var Fg = Ig.type;
        return Fg === ns ? (gg = wg(
          $,
          gg,
          Ig.props.children,
          Pg,
          Ig.key
        ), ua(Ig, gg, $), gg) : gg !== null && (gg.elementType === Fg || QM(gg, Ig) || typeof Fg == "object" && Fg !== null && Fg.$$typeof === Ne && za(Fg) === gg.type) ? (gg = y(gg, Ig.props), hI(gg, Ig), gg.return = $, gg._debugOwner = Ig._owner, gg._debugInfo = GI, gg) : (gg = Nr(Ig, $.mode, Pg), hI(gg, Ig), gg.return = $, gg._debugInfo = GI, gg);
      }
      function _($, gg, Ig, Pg) {
        return gg === null || gg.tag !== 4 || gg.stateNode.containerInfo !== Ig.containerInfo || gg.stateNode.implementation !== Ig.implementation ? (gg = oh(Ig, $.mode, Pg), gg.return = $, gg._debugInfo = GI, gg) : (gg = y(gg, Ig.children || []), gg.return = $, gg._debugInfo = GI, gg);
      }
      function wg($, gg, Ig, Pg, Fg) {
        return gg === null || gg.tag !== 7 ? (gg = Le(
          Ig,
          $.mode,
          Pg,
          Fg
        ), gg.return = $, gg._debugOwner = $, gg._debugTask = $._debugTask, gg._debugInfo = GI, gg) : (gg = y(gg, Ig), gg.return = $, gg._debugInfo = GI, gg);
      }
      function Gg($, gg, Ig) {
        if (typeof gg == "string" && gg !== "" || typeof gg == "number" || typeof gg == "bigint")
          return gg = sh(
            "" + gg,
            $.mode,
            Ig
          ), gg.return = $, gg._debugOwner = $, gg._debugTask = $._debugTask, gg._debugInfo = GI, gg;
        if (typeof gg == "object" && gg !== null) {
          switch (gg.$$typeof) {
            case an:
              return Ig = Nr(
                gg,
                $.mode,
                Ig
              ), hI(Ig, gg), Ig.return = $, $ = LA(gg._debugInfo), Ig._debugInfo = GI, GI = $, Ig;
            case DI:
              return gg = oh(
                gg,
                $.mode,
                Ig
              ), gg.return = $, gg._debugInfo = GI, gg;
            case Ne:
              var Pg = LA(gg._debugInfo);
              return gg = za(gg), $ = Gg($, gg, Ig), GI = Pg, $;
          }
          if (gC(gg) || L(gg))
            return Ig = Le(
              gg,
              $.mode,
              Ig,
              null
            ), Ig.return = $, Ig._debugOwner = $, Ig._debugTask = $._debugTask, $ = LA(gg._debugInfo), Ig._debugInfo = GI, GI = $, Ig;
          if (typeof gg.then == "function")
            return Pg = LA(gg._debugInfo), $ = Gg(
              $,
              St(gg),
              Ig
            ), GI = Pg, $;
          if (gg.$$typeof === De)
            return Gg(
              $,
              Wr($, gg),
              Ig
            );
          XI($, gg);
        }
        return typeof gg == "function" && KA($, gg), typeof gg == "symbol" && Ls($, gg), null;
      }
      function yg($, gg, Ig, Pg) {
        var Fg = gg !== null ? gg.key : null;
        if (typeof Ig == "string" && Ig !== "" || typeof Ig == "number" || typeof Ig == "bigint")
          return Fg !== null ? null : P($, gg, "" + Ig, Pg);
        if (typeof Ig == "object" && Ig !== null) {
          switch (Ig.$$typeof) {
            case an:
              return Ig.key === Fg ? (Fg = LA(Ig._debugInfo), $ = W(
                $,
                gg,
                Ig,
                Pg
              ), GI = Fg, $) : null;
            case DI:
              return Ig.key === Fg ? _($, gg, Ig, Pg) : null;
            case Ne:
              return Fg = LA(Ig._debugInfo), Ig = za(Ig), $ = yg(
                $,
                gg,
                Ig,
                Pg
              ), GI = Fg, $;
          }
          if (gC(Ig) || L(Ig))
            return Fg !== null ? null : (Fg = LA(Ig._debugInfo), $ = wg(
              $,
              gg,
              Ig,
              Pg,
              null
            ), GI = Fg, $);
          if (typeof Ig.then == "function")
            return Fg = LA(Ig._debugInfo), $ = yg(
              $,
              gg,
              St(Ig),
              Pg
            ), GI = Fg, $;
          if (Ig.$$typeof === De)
            return yg(
              $,
              gg,
              Wr($, Ig),
              Pg
            );
          XI($, Ig);
        }
        return typeof Ig == "function" && KA($, Ig), typeof Ig == "symbol" && Ls($, Ig), null;
      }
      function Tg($, gg, Ig, Pg, Fg) {
        if (typeof Pg == "string" && Pg !== "" || typeof Pg == "number" || typeof Pg == "bigint")
          return $ = $.get(Ig) || null, P(gg, $, "" + Pg, Fg);
        if (typeof Pg == "object" && Pg !== null) {
          switch (Pg.$$typeof) {
            case an:
              return Ig = $.get(
                Pg.key === null ? Ig : Pg.key
              ) || null, $ = LA(Pg._debugInfo), gg = W(
                gg,
                Ig,
                Pg,
                Fg
              ), GI = $, gg;
            case DI:
              return $ = $.get(
                Pg.key === null ? Ig : Pg.key
              ) || null, _(gg, $, Pg, Fg);
            case Ne:
              var MI = LA(Pg._debugInfo);
              return Pg = za(Pg), gg = Tg(
                $,
                gg,
                Ig,
                Pg,
                Fg
              ), GI = MI, gg;
          }
          if (gC(Pg) || L(Pg))
            return Ig = $.get(Ig) || null, $ = LA(Pg._debugInfo), gg = wg(
              gg,
              Ig,
              Pg,
              Fg,
              null
            ), GI = $, gg;
          if (typeof Pg.then == "function")
            return MI = LA(Pg._debugInfo), gg = Tg(
              $,
              gg,
              Ig,
              St(Pg),
              Fg
            ), GI = MI, gg;
          if (Pg.$$typeof === De)
            return Tg(
              $,
              gg,
              Ig,
              Wr(gg, Pg),
              Fg
            );
          XI(gg, Pg);
        }
        return typeof Pg == "function" && KA(gg, Pg), typeof Pg == "symbol" && Ls(gg, Pg), null;
      }
      function qg($, gg, Ig, Pg) {
        if (typeof Ig != "object" || Ig === null) return Pg;
        switch (Ig.$$typeof) {
          case an:
          case DI:
            h($, gg, Ig);
            var Fg = Ig.key;
            if (typeof Fg != "string") break;
            if (Pg === null) {
              Pg = /* @__PURE__ */ new Set(), Pg.add(Fg);
              break;
            }
            if (!Pg.has(Fg)) {
              Pg.add(Fg);
              break;
            }
            gI(gg, function() {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",
                Fg
              );
            });
            break;
          case Ne:
            Ig = za(Ig), qg($, gg, Ig, Pg);
        }
        return Pg;
      }
      function aI($, gg, Ig, Pg) {
        for (var Fg = null, MI = null, $g = null, wI = gg, bI = gg = 0, SA = null; wI !== null && bI < Ig.length; bI++) {
          wI.index > bI ? (SA = wI, wI = null) : SA = wI.sibling;
          var AC = yg(
            $,
            wI,
            Ig[bI],
            Pg
          );
          if (AC === null) {
            wI === null && (wI = SA);
            break;
          }
          Fg = qg(
            $,
            AC,
            Ig[bI],
            Fg
          ), e && wI && AC.alternate === null && i($, wI), gg = M(AC, gg, bI), $g === null ? MI = AC : $g.sibling = AC, $g = AC, wI = SA;
        }
        if (bI === Ig.length)
          return o($, wI), FI && Ws($, bI), MI;
        if (wI === null) {
          for (; bI < Ig.length; bI++)
            wI = Gg($, Ig[bI], Pg), wI !== null && (Fg = qg(
              $,
              wI,
              Ig[bI],
              Fg
            ), gg = M(
              wI,
              gg,
              bI
            ), $g === null ? MI = wI : $g.sibling = wI, $g = wI);
          return FI && Ws($, bI), MI;
        }
        for (wI = u(wI); bI < Ig.length; bI++)
          SA = Tg(
            wI,
            $,
            bI,
            Ig[bI],
            Pg
          ), SA !== null && (Fg = qg(
            $,
            SA,
            Ig[bI],
            Fg
          ), e && SA.alternate !== null && wI.delete(
            SA.key === null ? bI : SA.key
          ), gg = M(
            SA,
            gg,
            bI
          ), $g === null ? MI = SA : $g.sibling = SA, $g = SA);
        return e && wI.forEach(function(Go) {
          return i($, Go);
        }), FI && Ws($, bI), MI;
      }
      function wA($, gg, Ig, Pg) {
        if (Ig == null)
          throw Error("An iterable object provided no iterator.");
        for (var Fg = null, MI = null, $g = gg, wI = gg = 0, bI = null, SA = null, AC = Ig.next(); $g !== null && !AC.done; wI++, AC = Ig.next()) {
          $g.index > wI ? (bI = $g, $g = null) : bI = $g.sibling;
          var Go = yg($, $g, AC.value, Pg);
          if (Go === null) {
            $g === null && ($g = bI);
            break;
          }
          SA = qg(
            $,
            Go,
            AC.value,
            SA
          ), e && $g && Go.alternate === null && i($, $g), gg = M(Go, gg, wI), MI === null ? Fg = Go : MI.sibling = Go, MI = Go, $g = bI;
        }
        if (AC.done)
          return o($, $g), FI && Ws($, wI), Fg;
        if ($g === null) {
          for (; !AC.done; wI++, AC = Ig.next())
            $g = Gg($, AC.value, Pg), $g !== null && (SA = qg(
              $,
              $g,
              AC.value,
              SA
            ), gg = M(
              $g,
              gg,
              wI
            ), MI === null ? Fg = $g : MI.sibling = $g, MI = $g);
          return FI && Ws($, wI), Fg;
        }
        for ($g = u($g); !AC.done; wI++, AC = Ig.next())
          bI = Tg(
            $g,
            $,
            wI,
            AC.value,
            Pg
          ), bI !== null && (SA = qg(
            $,
            bI,
            AC.value,
            SA
          ), e && bI.alternate !== null && $g.delete(
            bI.key === null ? wI : bI.key
          ), gg = M(
            bI,
            gg,
            wI
          ), MI === null ? Fg = bI : MI.sibling = bI, MI = bI);
        return e && $g.forEach(function(DN) {
          return i($, DN);
        }), FI && Ws($, wI), Fg;
      }
      function NI($, gg, Ig, Pg) {
        if (typeof Ig == "object" && Ig !== null && Ig.type === ns && Ig.key === null && (ua(Ig, null, $), Ig = Ig.props.children), typeof Ig == "object" && Ig !== null) {
          switch (Ig.$$typeof) {
            case an:
              var Fg = LA(Ig._debugInfo);
              g: {
                for (var MI = Ig.key; gg !== null; ) {
                  if (gg.key === MI) {
                    if (MI = Ig.type, MI === ns) {
                      if (gg.tag === 7) {
                        o(
                          $,
                          gg.sibling
                        ), Pg = y(
                          gg,
                          Ig.props.children
                        ), Pg.return = $, Pg._debugOwner = Ig._owner, Pg._debugInfo = GI, ua(Ig, Pg, $), $ = Pg;
                        break g;
                      }
                    } else if (gg.elementType === MI || QM(
                      gg,
                      Ig
                    ) || typeof MI == "object" && MI !== null && MI.$$typeof === Ne && za(MI) === gg.type) {
                      o(
                        $,
                        gg.sibling
                      ), Pg = y(gg, Ig.props), hI(Pg, Ig), Pg.return = $, Pg._debugOwner = Ig._owner, Pg._debugInfo = GI, $ = Pg;
                      break g;
                    }
                    o($, gg);
                    break;
                  } else i($, gg);
                  gg = gg.sibling;
                }
                Ig.type === ns ? (Pg = Le(
                  Ig.props.children,
                  $.mode,
                  Pg,
                  Ig.key
                ), Pg.return = $, Pg._debugOwner = $, Pg._debugTask = $._debugTask, Pg._debugInfo = GI, ua(Ig, Pg, $), $ = Pg) : (Pg = Nr(
                  Ig,
                  $.mode,
                  Pg
                ), hI(Pg, Ig), Pg.return = $, Pg._debugInfo = GI, $ = Pg);
              }
              return $ = G($), GI = Fg, $;
            case DI:
              g: {
                for (Fg = Ig, Ig = Fg.key; gg !== null; ) {
                  if (gg.key === Ig)
                    if (gg.tag === 4 && gg.stateNode.containerInfo === Fg.containerInfo && gg.stateNode.implementation === Fg.implementation) {
                      o(
                        $,
                        gg.sibling
                      ), Pg = y(
                        gg,
                        Fg.children || []
                      ), Pg.return = $, $ = Pg;
                      break g;
                    } else {
                      o($, gg);
                      break;
                    }
                  else i($, gg);
                  gg = gg.sibling;
                }
                Pg = oh(
                  Fg,
                  $.mode,
                  Pg
                ), Pg.return = $, $ = Pg;
              }
              return G($);
            case Ne:
              return Fg = LA(Ig._debugInfo), Ig = za(Ig), $ = NI(
                $,
                gg,
                Ig,
                Pg
              ), GI = Fg, $;
          }
          if (gC(Ig))
            return Fg = LA(Ig._debugInfo), $ = aI(
              $,
              gg,
              Ig,
              Pg
            ), GI = Fg, $;
          if (L(Ig)) {
            if (Fg = LA(Ig._debugInfo), MI = L(Ig), typeof MI != "function")
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var $g = MI.call(Ig);
            return $g === Ig ? ($.tag !== 0 || Object.prototype.toString.call($.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call($g) !== "[object Generator]") && (BT || console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            ), BT = !0) : Ig.entries !== MI || Dm || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), Dm = !0), $ = wA(
              $,
              gg,
              $g,
              Pg
            ), GI = Fg, $;
          }
          if (typeof Ig.then == "function")
            return Fg = LA(Ig._debugInfo), $ = NI(
              $,
              gg,
              St(Ig),
              Pg
            ), GI = Fg, $;
          if (Ig.$$typeof === De)
            return NI(
              $,
              gg,
              Wr($, Ig),
              Pg
            );
          XI($, Ig);
        }
        return typeof Ig == "string" && Ig !== "" || typeof Ig == "number" || typeof Ig == "bigint" ? (Fg = "" + Ig, gg !== null && gg.tag === 6 ? (o(
          $,
          gg.sibling
        ), Pg = y(gg, Fg), Pg.return = $, $ = Pg) : (o($, gg), Pg = sh(
          Fg,
          $.mode,
          Pg
        ), Pg.return = $, Pg._debugOwner = $, Pg._debugTask = $._debugTask, Pg._debugInfo = GI, $ = Pg), G($)) : (typeof Ig == "function" && KA($, Ig), typeof Ig == "symbol" && Ls($, Ig), o($, gg));
      }
      return function($, gg, Ig, Pg) {
        var Fg = GI;
        GI = null;
        try {
          fD = 0;
          var MI = NI(
            $,
            gg,
            Ig,
            Pg
          );
          return Ed = null, MI;
        } catch (SA) {
          if (SA === lD || SA === Lw) throw SA;
          var $g = S(29, SA, null, $.mode);
          $g.lanes = Pg, $g.return = $;
          var wI = $g._debugInfo = GI;
          if ($g._debugOwner = $._debugOwner, $g._debugTask = $._debugTask, wI != null) {
            for (var bI = wI.length - 1; 0 <= bI; bI--)
              if (typeof wI[bI].stack == "string") {
                $g._debugOwner = wI[bI], $g._debugTask = wI[bI].debugTask;
                break;
              }
          }
          return $g;
        } finally {
          GI = Fg;
        }
      };
    }
    function oe(e) {
      var i = e.alternate;
      mg(
        GC,
        GC.current & Od,
        e
      ), mg(Gi, e, e), fs === null && (i === null || jd.current !== null || i.memoizedState !== null) && (fs = e);
    }
    function Cl(e) {
      if (e.tag === 22) {
        if (mg(GC, GC.current, e), mg(Gi, e, e), fs === null) {
          var i = e.alternate;
          i !== null && i.memoizedState !== null && (fs = e);
        }
      } else It(e);
    }
    function It(e) {
      mg(GC, GC.current, e), mg(
        Gi,
        Gi.current,
        e
      );
    }
    function ae(e) {
      Kg(Gi, e), fs === e && (fs = null), Kg(GC, e);
    }
    function hu(e) {
      for (var i = e; i !== null; ) {
        if (i.tag === 13) {
          var o = i.memoizedState;
          if (o !== null && (o = o.dehydrated, o === null || o.data === mo || es(o)))
            return i;
        } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
          if ((i.flags & 128) !== 0) return i;
        } else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === e) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === e) return null;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return null;
    }
    function TA(e) {
      if (e !== null && typeof e != "function") {
        var i = String(e);
        RT.has(i) || (RT.add(i), console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          e
        ));
      }
    }
    function el(e, i, o, u) {
      var y = e.memoizedState, M = o(u, y);
      if (e.mode & we) {
        Wg(!0);
        try {
          M = o(u, y);
        } finally {
          Wg(!1);
        }
      }
      M === void 0 && (i = eg(i) || "Component", jT.has(i) || (jT.add(i), console.error(
        "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
        i
      ))), y = M == null ? y : uI({}, y, M), e.memoizedState = y, e.lanes === 0 && (e.updateQueue.baseState = y);
    }
    function yu(e, i, o, u, y, M, G) {
      var P = e.stateNode;
      if (typeof P.shouldComponentUpdate == "function") {
        if (o = P.shouldComponentUpdate(
          u,
          M,
          G
        ), e.mode & we) {
          Wg(!0);
          try {
            o = P.shouldComponentUpdate(
              u,
              M,
              G
            );
          } finally {
            Wg(!1);
          }
        }
        return o === void 0 && console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          eg(i) || "Component"
        ), o;
      }
      return i.prototype && i.prototype.isPureReactComponent ? !Or(o, u) || !Or(y, M) : !0;
    }
    function Yh(e, i, o, u) {
      var y = i.state;
      typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(o, u), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(o, u), i.state !== y && (e = ig(e) || "Component", KT.has(e) || (KT.add(e), console.error(
        "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        e
      )), Mm.enqueueReplaceState(
        i,
        i.state,
        null
      ));
    }
    function Fn(e, i) {
      var o = i;
      if ("ref" in i) {
        o = {};
        for (var u in i)
          u !== "ref" && (o[u] = i[u]);
      }
      if (e = e.defaultProps) {
        o === i && (o = uI({}, o));
        for (var y in e)
          o[y] === void 0 && (o[y] = e[y]);
      }
      return o;
    }
    function qM(e) {
      wm(e), console.warn(
        `%s

%s
`,
        Nd ? "An error occurred in the <" + Nd + "> component." : "An error occurred in one of your React components.",
        `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
      );
    }
    function Du(e) {
      var i = Nd ? "The above error occurred in the <" + Nd + "> component." : "The above error occurred in one of your React components.", o = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((Bm || "Anonymous") + ".");
      if (typeof e == "object" && e !== null && typeof e.environmentName == "string") {
        var u = e.environmentName;
        e = [
          `%o

%s

%s
`,
          e,
          i,
          o
        ].slice(0), typeof e[0] == "string" ? e.splice(
          0,
          1,
          dY + e[0],
          fY,
          wB + u + wB,
          hY
        ) : e.splice(
          0,
          0,
          dY,
          fY,
          wB + u + wB,
          hY
        ), e.unshift(console), u = hN.apply(console.error, e), u();
      } else
        console.error(
          `%o

%s

%s
`,
          e,
          i,
          o
        );
    }
    function Mu(e) {
      wm(e);
    }
    function da(e, i) {
      try {
        Nd = i.source ? ig(i.source) : null, Bm = null;
        var o = i.value;
        if (Dg.actQueue !== null)
          Dg.thrownErrors.push(o);
        else {
          var u = e.onUncaughtError;
          u(o, { componentStack: i.stack });
        }
      } catch (y) {
        setTimeout(function() {
          throw y;
        });
      }
    }
    function zC(e, i, o) {
      try {
        Nd = o.source ? ig(o.source) : null, Bm = ig(i);
        var u = e.onCaughtError;
        u(o.value, {
          componentStack: o.stack,
          errorBoundary: i.tag === 1 ? i.stateNode : null
        });
      } catch (y) {
        setTimeout(function() {
          throw y;
        });
      }
    }
    function ZA(e, i, o) {
      return o = Dt(o), o.tag = rm, o.payload = { element: null }, o.callback = function() {
        gI(i.source, da, e, i);
      }, o;
    }
    function tl(e) {
      return e = Dt(e), e.tag = rm, e;
    }
    function $s(e, i, o, u) {
      var y = o.type.getDerivedStateFromError;
      if (typeof y == "function") {
        var M = u.value;
        e.payload = function() {
          return y(M);
        }, e.callback = function() {
          Jc(o), gI(
            u.source,
            zC,
            i,
            o,
            u
          );
        };
      }
      var G = o.stateNode;
      G !== null && typeof G.componentDidCatch == "function" && (e.callback = function() {
        Jc(o), gI(
          u.source,
          zC,
          i,
          o,
          u
        ), typeof y != "function" && ($a === null ? $a = /* @__PURE__ */ new Set([this]) : $a.add(this)), QO(this, u), typeof y == "function" || (o.lanes & 2) === 0 && console.error(
          "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
          ig(o) || "Unknown"
        );
      });
    }
    function wu(e, i, o, u, y) {
      if (o.flags |= 32768, nt && io(e, y), u !== null && typeof u == "object" && typeof u.then == "function") {
        if (i = o.alternate, i !== null && Vi(
          i,
          o,
          y,
          !0
        ), FI && (Do = !0), o = Gi.current, o !== null) {
          switch (o.tag) {
            case 13:
              return fs === null ? Hu() : o.alternate === null && QA === po && (QA = Sm), o.flags &= -257, o.flags |= 65536, o.lanes = y, u === am ? o.flags |= 16384 : (i = o.updateQueue, i === null ? o.updateQueue = /* @__PURE__ */ new Set([u]) : i.add(u), ly(e, u, y)), !1;
            case 22:
              return o.flags |= 65536, u === am ? o.flags |= 16384 : (i = o.updateQueue, i === null ? (i = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([u])
              }, o.updateQueue = i) : (o = i.retryQueue, o === null ? i.retryQueue = /* @__PURE__ */ new Set([u]) : o.add(u)), ly(e, u, y)), !1;
          }
          throw Error(
            "Unexpected Suspense handler tag (" + o.tag + "). This is a bug in React."
          );
        }
        return ly(e, u, y), Hu(), !1;
      }
      if (FI)
        return Do = !0, i = Gi.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = y, u !== im && zo(
          Ae(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
              { cause: u }
            ),
            o
          )
        )) : (u !== im && zo(
          Ae(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
              { cause: u }
            ),
            o
          )
        ), e = e.current.alternate, e.flags |= 65536, y &= -y, e.lanes |= y, u = Ae(u, o), y = ZA(
          e.stateNode,
          u,
          y
        ), _i(e, y), QA !== Ll && (QA = xd)), !1;
      var M = Ae(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: u }
        ),
        o
      );
      if (mD === null ? mD = [M] : mD.push(M), QA !== Ll && (QA = xd), i === null) return !0;
      u = Ae(u, o), o = i;
      do {
        switch (o.tag) {
          case 3:
            return o.flags |= 65536, e = y & -y, o.lanes |= e, e = ZA(
              o.stateNode,
              u,
              e
            ), _i(o, e), !1;
          case 1:
            if (i = o.type, M = o.stateNode, (o.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && ($a === null || !$a.has(M))))
              return o.flags |= 65536, y &= -y, o.lanes |= y, y = tl(y), $s(
                y,
                e,
                o,
                u
              ), _i(o, y), !1;
        }
        o = o.return;
      } while (o !== null);
      return !1;
    }
    function qA(e, i, o, u) {
      i.child = e === null ? ST(i, null, o, u) : Rd(
        i,
        e.child,
        o,
        u
      );
    }
    function si(e, i, o, u, y) {
      o = o.render;
      var M = i.ref;
      if ("ref" in u) {
        var G = {};
        for (var P in u)
          P !== "ref" && (G[P] = u[P]);
      } else G = u;
      return Rn(i), sI(i), u = ga(
        e,
        i,
        o,
        G,
        M,
        y
      ), P = Ui(), Ug(), e !== null && !NC ? (Bt(e, i, y), oi(e, i, y)) : (FI && P && $c(i), i.flags |= 1, qA(e, i, u, y), i.child);
    }
    function il(e, i, o, u, y) {
      if (e === null) {
        var M = o.type;
        return typeof M == "function" && !Lc(M) && M.defaultProps === void 0 && o.compare === null ? (o = Ns(M), i.tag = 15, i.type = o, sl(i, M), Bu(
          e,
          i,
          o,
          u,
          y
        )) : (e = qc(
          o.type,
          null,
          u,
          i,
          i.mode,
          y
        ), e.ref = i.ref, e.return = i, i.child = e);
      }
      if (M = e.child, !kh(e, y)) {
        var G = M.memoizedProps;
        if (o = o.compare, o = o !== null ? o : Or, o(G, u) && e.ref === i.ref)
          return oi(
            e,
            i,
            y
          );
      }
      return i.flags |= 1, e = ei(M, u), e.ref = i.ref, e.return = i, i.child = e;
    }
    function Bu(e, i, o, u, y) {
      if (e !== null) {
        var M = e.memoizedProps;
        if (Or(M, u) && e.ref === i.ref && i.type === e.type)
          if (NC = !1, i.pendingProps = u = M, kh(e, y))
            (e.flags & 131072) !== 0 && (NC = !0);
          else
            return i.lanes = e.lanes, oi(e, i, y);
      }
      return mu(
        e,
        i,
        o,
        u,
        y
      );
    }
    function pu(e, i, o) {
      var u = i.pendingProps, y = u.children, M = e !== null ? e.memoizedState : null;
      if (u.mode === "hidden") {
        if ((i.flags & 128) !== 0) {
          if (u = M !== null ? M.baseLanes | o : o, e !== null) {
            for (y = i.child = e.child, M = 0; y !== null; )
              M = M | y.lanes | y.childLanes, y = y.sibling;
            i.childLanes = M & ~u;
          } else i.childLanes = 0, i.child = null;
          return Ph(
            e,
            i,
            u,
            o
          );
        }
        if ((o & 536870912) !== 0)
          i.memoizedState = { baseLanes: 0, cachePool: null }, e !== null && eu(
            i,
            M !== null ? M.cachePool : null
          ), M !== null ? iu(i, M) : wt(i), Cl(i);
        else
          return i.lanes = i.childLanes = 536870912, Ph(
            e,
            i,
            M !== null ? M.baseLanes | o : o,
            o
          );
      } else
        M !== null ? (eu(i, M.cachePool), iu(i, M), It(i), i.memoizedState = null) : (e !== null && eu(i, null), wt(i), It(i));
      return qA(e, i, y, o), i.child;
    }
    function Ph(e, i, o, u) {
      var y = fh();
      return y = y === null ? null : {
        parent: bC._currentValue,
        pool: y
      }, i.memoizedState = {
        baseLanes: o,
        cachePool: y
      }, e !== null && eu(i, null), wt(i), Cl(i), e !== null && Vi(e, i, u, !0), null;
    }
    function nl(e, i) {
      var o = i.ref;
      if (o === null)
        e !== null && e.ref !== null && (i.flags |= 4194816);
      else {
        if (typeof o != "function" && typeof o != "object")
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        (e === null || e.ref !== o) && (i.flags |= 4194816);
      }
    }
    function mu(e, i, o, u, y) {
      if (o.prototype && typeof o.prototype.render == "function") {
        var M = eg(o) || "Unknown";
        NT[M] || (console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          M,
          M
        ), NT[M] = !0);
      }
      return i.mode & we && yn.recordLegacyContextWarning(
        i,
        null
      ), e === null && (sl(i, i.type), o.contextTypes && (M = eg(o) || "Unknown", WT[M] || (WT[M] = !0, console.error(
        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
        M
      )))), Rn(i), sI(i), o = ga(
        e,
        i,
        o,
        u,
        void 0,
        y
      ), u = Ui(), Ug(), e !== null && !NC ? (Bt(e, i, y), oi(e, i, y)) : (FI && u && $c(i), i.flags |= 1, qA(e, i, o, y), i.child);
    }
    function Zh(e, i, o, u, y, M) {
      return Rn(i), sI(i), wo = -1, dD = e !== null && e.type !== i.type, i.updateQueue = null, o = ie(
        i,
        u,
        o,
        y
      ), _r(e, i), u = Ui(), Ug(), e !== null && !NC ? (Bt(e, i, M), oi(e, i, M)) : (FI && u && $c(i), i.flags |= 1, qA(e, i, o, M), i.child);
    }
    function jh(e, i, o, u, y) {
      switch (d(i)) {
        case !1:
          var M = i.stateNode, G = new i.type(
            i.memoizedProps,
            M.context
          ).state;
          M.updater.enqueueSetState(M, G, null);
          break;
        case !0:
          i.flags |= 128, i.flags |= 65536, M = Error("Simulated error coming from DevTools");
          var P = y & -y;
          if (i.lanes |= P, G = MA, G === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          P = tl(P), $s(
            P,
            G,
            i,
            Ae(M, i)
          ), _i(i, P);
      }
      if (Rn(i), i.stateNode === null) {
        if (G = Fa, M = o.contextType, "contextType" in o && M !== null && (M === void 0 || M.$$typeof !== De) && !ET.has(o) && (ET.add(o), P = M === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof M != "object" ? " However, it is set to a " + typeof M + "." : M.$$typeof === Yl ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(M).join(", ") + "}.", console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          eg(o) || "Component",
          P
        )), typeof M == "object" && M !== null && (G = fA(M)), M = new o(u, G), i.mode & we) {
          Wg(!0);
          try {
            M = new o(u, G);
          } finally {
            Wg(!1);
          }
        }
        if (G = i.memoizedState = M.state !== null && M.state !== void 0 ? M.state : null, M.updater = Mm, i.stateNode = M, M._reactInternals = i, M._reactInternalInstance = GT, typeof o.getDerivedStateFromProps == "function" && G === null && (G = eg(o) || "Component", TT.has(G) || (TT.add(G), console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          G,
          M.state === null ? "null" : "undefined",
          G
        ))), typeof o.getDerivedStateFromProps == "function" || typeof M.getSnapshotBeforeUpdate == "function") {
          var W = P = G = null;
          if (typeof M.componentWillMount == "function" && M.componentWillMount.__suppressDeprecationWarning !== !0 ? G = "componentWillMount" : typeof M.UNSAFE_componentWillMount == "function" && (G = "UNSAFE_componentWillMount"), typeof M.componentWillReceiveProps == "function" && M.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? P = "componentWillReceiveProps" : typeof M.UNSAFE_componentWillReceiveProps == "function" && (P = "UNSAFE_componentWillReceiveProps"), typeof M.componentWillUpdate == "function" && M.componentWillUpdate.__suppressDeprecationWarning !== !0 ? W = "componentWillUpdate" : typeof M.UNSAFE_componentWillUpdate == "function" && (W = "UNSAFE_componentWillUpdate"), G !== null || P !== null || W !== null) {
            M = eg(o) || "Component";
            var _ = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            PT.has(M) || (PT.add(M), console.error(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
              M,
              _,
              G !== null ? `
  ` + G : "",
              P !== null ? `
  ` + P : "",
              W !== null ? `
  ` + W : ""
            ));
          }
        }
        M = i.stateNode, G = eg(o) || "Component", M.render || (o.prototype && typeof o.prototype.render == "function" ? console.error(
          "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
          G
        ) : console.error(
          "No `render` method found on the %s instance: you may have forgotten to define `render`.",
          G
        )), !M.getInitialState || M.getInitialState.isReactClassApproved || M.state || console.error(
          "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
          G
        ), M.getDefaultProps && !M.getDefaultProps.isReactClassApproved && console.error(
          "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
          G
        ), M.contextType && console.error(
          "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
          G
        ), o.childContextTypes && !HT.has(o) && (HT.add(o), console.error(
          "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
          G
        )), o.contextTypes && !vT.has(o) && (vT.add(o), console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
          G
        )), typeof M.componentShouldUpdate == "function" && console.error(
          "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
          G
        ), o.prototype && o.prototype.isPureReactComponent && typeof M.shouldComponentUpdate < "u" && console.error(
          "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
          eg(o) || "A pure component"
        ), typeof M.componentDidUnmount == "function" && console.error(
          "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
          G
        ), typeof M.componentDidReceiveProps == "function" && console.error(
          "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
          G
        ), typeof M.componentWillRecieveProps == "function" && console.error(
          "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
          G
        ), typeof M.UNSAFE_componentWillRecieveProps == "function" && console.error(
          "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
          G
        ), P = M.props !== u, M.props !== void 0 && P && console.error(
          "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          G
        ), M.defaultProps && console.error(
          "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
          G,
          G
        ), typeof M.getSnapshotBeforeUpdate != "function" || typeof M.componentDidUpdate == "function" || YT.has(o) || (YT.add(o), console.error(
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
          eg(o)
        )), typeof M.getDerivedStateFromProps == "function" && console.error(
          "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          G
        ), typeof M.getDerivedStateFromError == "function" && console.error(
          "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          G
        ), typeof o.getSnapshotBeforeUpdate == "function" && console.error(
          "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
          G
        ), (P = M.state) && (typeof P != "object" || gC(P)) && console.error("%s.state: must be set to an object or null", G), typeof M.getChildContext == "function" && typeof o.childContextTypes != "object" && console.error(
          "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
          G
        ), M = i.stateNode, M.props = u, M.state = i.memoizedState, M.refs = {}, Nn(i), G = o.contextType, M.context = typeof G == "object" && G !== null ? fA(G) : Fa, M.state === u && (G = eg(o) || "Component", ZT.has(G) || (ZT.add(G), console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          G
        ))), i.mode & we && yn.recordLegacyContextWarning(
          i,
          M
        ), yn.recordUnsafeLifecycleWarnings(
          i,
          M
        ), M.state = i.memoizedState, G = o.getDerivedStateFromProps, typeof G == "function" && (el(
          i,
          o,
          G,
          u
        ), M.state = i.memoizedState), typeof o.getDerivedStateFromProps == "function" || typeof M.getSnapshotBeforeUpdate == "function" || typeof M.UNSAFE_componentWillMount != "function" && typeof M.componentWillMount != "function" || (G = M.state, typeof M.componentWillMount == "function" && M.componentWillMount(), typeof M.UNSAFE_componentWillMount == "function" && M.UNSAFE_componentWillMount(), G !== M.state && (console.error(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          ig(i) || "Component"
        ), Mm.enqueueReplaceState(
          M,
          M.state,
          null
        )), kn(i, u, M, y), qo(), M.state = i.memoizedState), typeof M.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & hn) !== bA && (i.flags |= 134217728), M = !0;
      } else if (e === null) {
        M = i.stateNode;
        var wg = i.memoizedProps;
        P = Fn(o, wg), M.props = P;
        var Gg = M.context;
        W = o.contextType, G = Fa, typeof W == "object" && W !== null && (G = fA(W)), _ = o.getDerivedStateFromProps, W = typeof _ == "function" || typeof M.getSnapshotBeforeUpdate == "function", wg = i.pendingProps !== wg, W || typeof M.UNSAFE_componentWillReceiveProps != "function" && typeof M.componentWillReceiveProps != "function" || (wg || Gg !== G) && Yh(
          i,
          M,
          u,
          G
        ), Xa = !1;
        var yg = i.memoizedState;
        M.state = yg, kn(i, u, M, y), qo(), Gg = i.memoizedState, wg || yg !== Gg || Xa ? (typeof _ == "function" && (el(
          i,
          o,
          _,
          u
        ), Gg = i.memoizedState), (P = Xa || yu(
          i,
          o,
          P,
          u,
          yg,
          Gg,
          G
        )) ? (W || typeof M.UNSAFE_componentWillMount != "function" && typeof M.componentWillMount != "function" || (typeof M.componentWillMount == "function" && M.componentWillMount(), typeof M.UNSAFE_componentWillMount == "function" && M.UNSAFE_componentWillMount()), typeof M.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & hn) !== bA && (i.flags |= 134217728)) : (typeof M.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & hn) !== bA && (i.flags |= 134217728), i.memoizedProps = u, i.memoizedState = Gg), M.props = u, M.state = Gg, M.context = G, M = P) : (typeof M.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & hn) !== bA && (i.flags |= 134217728), M = !1);
      } else {
        M = i.stateNode, xr(e, i), G = i.memoizedProps, W = Fn(o, G), M.props = W, _ = i.pendingProps, yg = M.context, Gg = o.contextType, P = Fa, typeof Gg == "object" && Gg !== null && (P = fA(Gg)), wg = o.getDerivedStateFromProps, (Gg = typeof wg == "function" || typeof M.getSnapshotBeforeUpdate == "function") || typeof M.UNSAFE_componentWillReceiveProps != "function" && typeof M.componentWillReceiveProps != "function" || (G !== _ || yg !== P) && Yh(
          i,
          M,
          u,
          P
        ), Xa = !1, yg = i.memoizedState, M.state = yg, kn(i, u, M, y), qo();
        var Tg = i.memoizedState;
        G !== _ || yg !== Tg || Xa || e !== null && e.dependencies !== null && kr(e.dependencies) ? (typeof wg == "function" && (el(
          i,
          o,
          wg,
          u
        ), Tg = i.memoizedState), (W = Xa || yu(
          i,
          o,
          W,
          u,
          yg,
          Tg,
          P
        ) || e !== null && e.dependencies !== null && kr(e.dependencies)) ? (Gg || typeof M.UNSAFE_componentWillUpdate != "function" && typeof M.componentWillUpdate != "function" || (typeof M.componentWillUpdate == "function" && M.componentWillUpdate(u, Tg, P), typeof M.UNSAFE_componentWillUpdate == "function" && M.UNSAFE_componentWillUpdate(
          u,
          Tg,
          P
        )), typeof M.componentDidUpdate == "function" && (i.flags |= 4), typeof M.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof M.componentDidUpdate != "function" || G === e.memoizedProps && yg === e.memoizedState || (i.flags |= 4), typeof M.getSnapshotBeforeUpdate != "function" || G === e.memoizedProps && yg === e.memoizedState || (i.flags |= 1024), i.memoizedProps = u, i.memoizedState = Tg), M.props = u, M.state = Tg, M.context = P, M = W) : (typeof M.componentDidUpdate != "function" || G === e.memoizedProps && yg === e.memoizedState || (i.flags |= 4), typeof M.getSnapshotBeforeUpdate != "function" || G === e.memoizedProps && yg === e.memoizedState || (i.flags |= 1024), M = !1);
      }
      if (P = M, nl(e, i), G = (i.flags & 128) !== 0, P || G) {
        if (P = i.stateNode, Pn(i), G && typeof o.getDerivedStateFromError != "function")
          o = null, st = -1;
        else {
          if (sI(i), o = lT(P), i.mode & we) {
            Wg(!0);
            try {
              lT(P);
            } finally {
              Wg(!1);
            }
          }
          Ug();
        }
        i.flags |= 1, e !== null && G ? (i.child = Rd(
          i,
          e.child,
          null,
          y
        ), i.child = Rd(
          i,
          null,
          o,
          y
        )) : qA(e, i, o, y), i.memoizedState = P.state, e = i.child;
      } else
        e = oi(
          e,
          i,
          y
        );
      return y = i.stateNode, M && y.props !== u && (kd || console.error(
        "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
        ig(i) || "a component"
      ), kd = !0), e;
    }
    function vh(e, i, o, u) {
      return Qo(), i.flags |= 256, qA(e, i, o, u), i.child;
    }
    function sl(e, i) {
      i && i.childContextTypes && console.error(
        `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
        i.displayName || i.name || "Component"
      ), typeof i.getDerivedStateFromProps == "function" && (e = eg(i) || "Unknown", VT[e] || (console.error(
        "%s: Function components do not support getDerivedStateFromProps.",
        e
      ), VT[e] = !0)), typeof i.contextType == "object" && i.contextType !== null && (i = eg(i) || "Unknown", kT[i] || (console.error(
        "%s: Function components do not support contextType.",
        i
      ), kT[i] = !0));
    }
    function bu(e) {
      return { baseLanes: e, cachePool: hh() };
    }
    function Hh(e, i, o) {
      return e = e !== null ? e.childLanes & ~o : 0, i && (e |= Vt), e;
    }
    function Eh(e, i, o) {
      var u, y = i.pendingProps;
      l(i) && (i.flags |= 128);
      var M = !1, G = (i.flags & 128) !== 0;
      if ((u = G) || (u = e !== null && e.memoizedState === null ? !1 : (GC.current & hD) !== 0), u && (M = !0, i.flags &= -129), u = (i.flags & 32) !== 0, i.flags &= -33, e === null) {
        if (FI) {
          if (M ? oe(i) : It(i), FI) {
            var P = XA, W;
            if (!(W = !P)) {
              g: {
                var _ = P;
                for (W = us; _.nodeType !== 8; ) {
                  if (!W) {
                    W = null;
                    break g;
                  }
                  if (_ = he(_.nextSibling), _ === null) {
                    W = null;
                    break g;
                  }
                }
                W = _;
              }
              W !== null ? (ht(), i.memoizedState = {
                dehydrated: W,
                treeContext: _l !== null ? { id: ho, overflow: yo } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, _ = S(18, null, null, bA), _.stateNode = W, _.return = i, i.child = _, Ve = i, XA = null, W = !0) : W = !1, W = !W;
            }
            W && (Xo(
              i,
              P
            ), Hn(i));
          }
          if (P = i.memoizedState, P !== null && (P = P.dehydrated, P !== null))
            return es(P) ? i.lanes = 32 : i.lanes = 536870912, null;
          ae(i);
        }
        return P = y.children, y = y.fallback, M ? (It(i), M = i.mode, P = ol(
          {
            mode: "hidden",
            children: P
          },
          M
        ), y = Le(
          y,
          M,
          o,
          null
        ), P.return = i, y.return = i, P.sibling = y, i.child = P, M = i.child, M.memoizedState = bu(o), M.childLanes = Hh(
          e,
          u,
          o
        ), i.memoizedState = mm, y) : (oe(i), Su(
          i,
          P
        ));
      }
      var wg = e.memoizedState;
      if (wg !== null && (P = wg.dehydrated, P !== null)) {
        if (G)
          i.flags & 256 ? (oe(i), i.flags &= -257, i = al(
            e,
            i,
            o
          )) : i.memoizedState !== null ? (It(i), i.child = e.child, i.flags |= 128, i = null) : (It(i), M = y.fallback, P = i.mode, y = ol(
            {
              mode: "visible",
              children: y.children
            },
            P
          ), M = Le(
            M,
            P,
            o,
            null
          ), M.flags |= 2, y.return = i, M.return = i, y.sibling = M, i.child = y, Rd(
            i,
            e.child,
            null,
            o
          ), y = i.child, y.memoizedState = bu(o), y.childLanes = Hh(
            e,
            u,
            o
          ), i.memoizedState = mm, i = M);
        else if (oe(i), FI && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        ), es(P)) {
          if (u = P.nextSibling && P.nextSibling.dataset, u) {
            W = u.dgst;
            var Gg = u.msg;
            _ = u.stck;
            var yg = u.cstck;
          }
          P = Gg, u = W, y = _, W = M = yg, M = Error(P || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), M.stack = y || "", M.digest = u, u = W === void 0 ? null : W, y = {
            value: M,
            source: null,
            stack: u
          }, typeof u == "string" && em.set(
            M,
            y
          ), zo(y), i = al(
            e,
            i,
            o
          );
        } else if (NC || Vi(
          e,
          i,
          o,
          !1
        ), u = (o & e.childLanes) !== 0, NC || u) {
          if (u = MA, u !== null && (y = o & -o, y = (y & 42) !== 0 ? 1 : PC(
            y
          ), y = (y & (u.suspendedLanes | o)) !== 0 ? 0 : y, y !== 0 && y !== wg.retryLane))
            throw wg.retryLane = y, Ce(
              e,
              y
            ), YI(
              u,
              e,
              y
            ), OT;
          P.data === mo || Hu(), i = al(
            e,
            i,
            o
          );
        } else
          P.data === mo ? (i.flags |= 192, i.child = e.child, i = null) : (e = wg.treeContext, XA = he(
            P.nextSibling
          ), Ve = i, FI = !0, Ul = null, Do = !1, pi = null, us = !1, e !== null && (ht(), wi[Bi++] = ho, wi[Bi++] = yo, wi[Bi++] = _l, ho = e.id, yo = e.overflow, _l = i), i = Su(
            i,
            y.children
          ), i.flags |= 4096);
        return i;
      }
      return M ? (It(i), M = y.fallback, P = i.mode, W = e.child, _ = W.sibling, y = ei(
        W,
        {
          mode: "hidden",
          children: y.children
        }
      ), y.subtreeFlags = W.subtreeFlags & 65011712, _ !== null ? M = ei(
        _,
        M
      ) : (M = Le(
        M,
        P,
        o,
        null
      ), M.flags |= 2), M.return = i, y.return = i, y.sibling = M, i.child = y, y = M, M = i.child, P = e.child.memoizedState, P === null ? P = bu(o) : (W = P.cachePool, W !== null ? (_ = bC._currentValue, W = W.parent !== _ ? { parent: _, pool: _ } : W) : W = hh(), P = {
        baseLanes: P.baseLanes | o,
        cachePool: W
      }), M.memoizedState = P, M.childLanes = Hh(
        e,
        u,
        o
      ), i.memoizedState = mm, y) : (oe(i), o = e.child, e = o.sibling, o = ei(o, {
        mode: "visible",
        children: y.children
      }), o.return = i, o.sibling = null, e !== null && (u = i.deletions, u === null ? (i.deletions = [e], i.flags |= 16) : u.push(e)), i.child = o, i.memoizedState = null, o);
    }
    function Su(e, i) {
      return i = ol(
        { mode: "visible", children: i },
        e.mode
      ), i.return = e, e.child = i;
    }
    function ol(e, i) {
      return e = S(22, e, null, i), e.lanes = 0, e.stateNode = {
        _visibility: xw,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, e;
    }
    function al(e, i, o) {
      return Rd(i, e.child, null, o), e = Su(
        i,
        i.pendingProps.children
      ), e.flags |= 2, i.memoizedState = null, e;
    }
    function Rh(e, i, o) {
      e.lanes |= i;
      var u = e.alternate;
      u !== null && (u.lanes |= i), ch(
        e.return,
        i,
        o
      );
    }
    function Oh(e, i) {
      var o = gC(e);
      return e = !o && typeof L(e) == "function", o || e ? (o = o ? "array" : "iterable", console.error(
        "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
        o,
        i,
        o
      ), !1) : !0;
    }
    function Gu(e, i, o, u, y) {
      var M = e.memoizedState;
      M === null ? e.memoizedState = {
        isBackwards: i,
        rendering: null,
        renderingStartTime: 0,
        last: u,
        tail: o,
        tailMode: y
      } : (M.isBackwards = i, M.rendering = null, M.renderingStartTime = 0, M.last = u, M.tail = o, M.tailMode = y);
    }
    function Nh(e, i, o) {
      var u = i.pendingProps, y = u.revealOrder, M = u.tail;
      if (u = u.children, y !== void 0 && y !== "forwards" && y !== "backwards" && y !== "together" && !xT[y])
        if (xT[y] = !0, typeof y == "string")
          switch (y.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                y,
                y.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                y,
                y.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                y
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            y
          );
      M === void 0 || pm[M] || (M !== "collapsed" && M !== "hidden" ? (pm[M] = !0, console.error(
        '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
        M
      )) : y !== "forwards" && y !== "backwards" && (pm[M] = !0, console.error(
        '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
        M
      )));
      g: if ((y === "forwards" || y === "backwards") && u !== void 0 && u !== null && u !== !1)
        if (gC(u)) {
          for (var G = 0; G < u.length; G++)
            if (!Oh(u[G], G)) break g;
        } else if (G = L(u), typeof G == "function") {
          if (G = G.call(u))
            for (var P = G.next(), W = 0; !P.done; P = G.next()) {
              if (!Oh(P.value, W)) break g;
              W++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            y
          );
      if (qA(e, i, u, o), u = GC.current, (u & hD) !== 0)
        u = u & Od | hD, i.flags |= 128;
      else {
        if (e !== null && (e.flags & 128) !== 0)
          g: for (e = i.child; e !== null; ) {
            if (e.tag === 13)
              e.memoizedState !== null && Rh(
                e,
                o,
                i
              );
            else if (e.tag === 19)
              Rh(e, o, i);
            else if (e.child !== null) {
              e.child.return = e, e = e.child;
              continue;
            }
            if (e === i) break g;
            for (; e.sibling === null; ) {
              if (e.return === null || e.return === i)
                break g;
              e = e.return;
            }
            e.sibling.return = e.return, e = e.sibling;
          }
        u &= Od;
      }
      switch (mg(GC, u, i), y) {
        case "forwards":
          for (o = i.child, y = null; o !== null; )
            e = o.alternate, e !== null && hu(e) === null && (y = o), o = o.sibling;
          o = y, o === null ? (y = i.child, i.child = null) : (y = o.sibling, o.sibling = null), Gu(
            i,
            !1,
            y,
            o,
            M
          );
          break;
        case "backwards":
          for (o = null, y = i.child, i.child = null; y !== null; ) {
            if (e = y.alternate, e !== null && hu(e) === null) {
              i.child = y;
              break;
            }
            e = y.sibling, y.sibling = o, o = y, y = e;
          }
          Gu(
            i,
            !0,
            o,
            null,
            M
          );
          break;
        case "together":
          Gu(i, !1, null, null, void 0);
          break;
        default:
          i.memoizedState = null;
      }
      return i.child;
    }
    function oi(e, i, o) {
      if (e !== null && (i.dependencies = e.dependencies), st = -1, La |= i.lanes, (o & i.childLanes) === 0)
        if (e !== null) {
          if (Vi(
            e,
            i,
            o,
            !1
          ), (o & i.childLanes) === 0)
            return null;
        } else return null;
      if (e !== null && i.child !== e.child)
        throw Error("Resuming work not yet implemented.");
      if (i.child !== null) {
        for (e = i.child, o = ei(e, e.pendingProps), i.child = o, o.return = i; e.sibling !== null; )
          e = e.sibling, o = o.sibling = ei(e, e.pendingProps), o.return = i;
        o.sibling = null;
      }
      return i.child;
    }
    function kh(e, i) {
      return (e.lanes & i) !== 0 ? !0 : (e = e.dependencies, !!(e !== null && kr(e)));
    }
    function $M(e, i, o) {
      switch (i.tag) {
        case 3:
          cg(
            i,
            i.stateNode.containerInfo
          ), En(
            i,
            bC,
            e.memoizedState.cache
          ), Qo();
          break;
        case 27:
        case 5:
          Bg(i);
          break;
        case 4:
          cg(
            i,
            i.stateNode.containerInfo
          );
          break;
        case 10:
          En(
            i,
            i.type,
            i.memoizedProps.value
          );
          break;
        case 12:
          (o & i.childLanes) !== 0 && (i.flags |= 4), i.flags |= 2048;
          var u = i.stateNode;
          u.effectDuration = -0, u.passiveEffectDuration = -0;
          break;
        case 13:
          if (u = i.memoizedState, u !== null)
            return u.dehydrated !== null ? (oe(i), i.flags |= 128, null) : (o & i.child.childLanes) !== 0 ? Eh(
              e,
              i,
              o
            ) : (oe(i), e = oi(
              e,
              i,
              o
            ), e !== null ? e.sibling : null);
          oe(i);
          break;
        case 19:
          var y = (e.flags & 128) !== 0;
          if (u = (o & i.childLanes) !== 0, u || (Vi(
            e,
            i,
            o,
            !1
          ), u = (o & i.childLanes) !== 0), y) {
            if (u)
              return Nh(
                e,
                i,
                o
              );
            i.flags |= 128;
          }
          if (y = i.memoizedState, y !== null && (y.rendering = null, y.tail = null, y.lastEffect = null), mg(
            GC,
            GC.current,
            i
          ), u) break;
          return null;
        case 22:
        case 23:
          return i.lanes = 0, pu(e, i, o);
        case 24:
          En(
            i,
            bC,
            e.memoizedState.cache
          );
      }
      return oi(e, i, o);
    }
    function Xn(e, i, o) {
      if (i._debugNeedsRemount && e !== null) {
        o = qc(
          i.type,
          i.key,
          i.pendingProps,
          i._debugOwner || null,
          i.mode,
          i.lanes
        ), o._debugStack = i._debugStack, o._debugTask = i._debugTask;
        var u = i.return;
        if (u === null) throw Error("Cannot swap the root fiber.");
        if (e.alternate = null, i.alternate = null, o.index = i.index, o.sibling = i.sibling, o.return = i.return, o.ref = i.ref, o._debugInfo = i._debugInfo, i === u.child)
          u.child = o;
        else {
          var y = u.child;
          if (y === null)
            throw Error("Expected parent to have a child.");
          for (; y.sibling !== i; )
            if (y = y.sibling, y === null)
              throw Error("Expected to find the previous sibling.");
          y.sibling = o;
        }
        return i = u.deletions, i === null ? (u.deletions = [e], u.flags |= 16) : i.push(e), o.flags |= 2, o;
      }
      if (e !== null)
        if (e.memoizedProps !== i.pendingProps || i.type !== e.type)
          NC = !0;
        else {
          if (!kh(e, o) && (i.flags & 128) === 0)
            return NC = !1, $M(
              e,
              i,
              o
            );
          NC = (e.flags & 131072) !== 0;
        }
      else
        NC = !1, (u = FI) && (ht(), u = (i.flags & 1048576) !== 0), u && (u = i.index, ht(), ah(i, Uw, u));
      switch (i.lanes = 0, i.tag) {
        case 16:
          g: if (u = i.pendingProps, e = za(i.elementType), i.type = e, typeof e == "function")
            Lc(e) ? (u = Fn(
              e,
              u
            ), i.tag = 1, i.type = e = Ns(e), i = jh(
              null,
              i,
              e,
              u,
              o
            )) : (i.tag = 0, sl(i, e), i.type = e = Ns(e), i = mu(
              null,
              i,
              e,
              u,
              o
            ));
          else {
            if (e != null) {
              if (y = e.$$typeof, y === ss) {
                i.tag = 11, i.type = e = ih(e), i = si(
                  null,
                  i,
                  e,
                  u,
                  o
                );
                break g;
              } else if (y === nd) {
                i.tag = 14, i = il(
                  null,
                  i,
                  e,
                  u,
                  o
                );
                break g;
              }
            }
            throw i = "", e !== null && typeof e == "object" && e.$$typeof === Ne && (i = " Did you wrap a component in React.lazy() more than once?"), e = eg(e) || e, Error(
              "Element type is invalid. Received a promise that resolves to: " + e + ". Lazy element type must resolve to a class or function." + i
            );
          }
          return i;
        case 0:
          return mu(
            e,
            i,
            i.type,
            i.pendingProps,
            o
          );
        case 1:
          return u = i.type, y = Fn(
            u,
            i.pendingProps
          ), jh(
            e,
            i,
            u,
            y,
            o
          );
        case 3:
          g: {
            if (cg(
              i,
              i.stateNode.containerInfo
            ), e === null)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            u = i.pendingProps;
            var M = i.memoizedState;
            y = M.element, xr(e, i), kn(i, u, null, o);
            var G = i.memoizedState;
            if (u = G.cache, En(i, bC, u), u !== M.cache && XC(
              i,
              [bC],
              o,
              !0
            ), qo(), u = G.element, M.isDehydrated)
              if (M = {
                element: u,
                isDehydrated: !1,
                cache: G.cache
              }, i.updateQueue.baseState = M, i.memoizedState = M, i.flags & 256) {
                i = vh(
                  e,
                  i,
                  u,
                  o
                );
                break g;
              } else if (u !== y) {
                y = Ae(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  i
                ), zo(y), i = vh(
                  e,
                  i,
                  u,
                  o
                );
                break g;
              } else {
                switch (e = i.stateNode.containerInfo, e.nodeType) {
                  case 9:
                    e = e.body;
                    break;
                  default:
                    e = e.nodeName === "HTML" ? e.ownerDocument.body : e;
                }
                for (XA = he(e.firstChild), Ve = i, FI = !0, Ul = null, Do = !1, pi = null, us = !0, e = ST(
                  i,
                  null,
                  u,
                  o
                ), i.child = e; e; )
                  e.flags = e.flags & -3 | 4096, e = e.sibling;
              }
            else {
              if (Qo(), u === y) {
                i = oi(
                  e,
                  i,
                  o
                );
                break g;
              }
              qA(
                e,
                i,
                u,
                o
              );
            }
            i = i.child;
          }
          return i;
        case 26:
          return nl(e, i), e === null ? (e = pl(
            i.type,
            null,
            i.pendingProps,
            null
          )) ? i.memoizedState = e : FI || (e = i.type, o = i.pendingProps, u = Ng(
            li.current
          ), u = _I(
            u
          ).createElement(e), u[OC] = i, u[Me] = o, sC(u, e, o), og(u), i.stateNode = u) : i.memoizedState = pl(
            i.type,
            e.memoizedProps,
            i.pendingProps,
            e.memoizedState
          ), null;
        case 27:
          return Bg(i), e === null && FI && (u = Ng(li.current), y = Q(), u = i.stateNode = ye(
            i.type,
            i.pendingProps,
            u,
            y,
            !1
          ), Do || (y = ZI(
            u,
            i.type,
            i.pendingProps,
            y
          ), y !== null && (xs(i, 0).serverProps = y)), Ve = i, us = !0, y = XA, $A(i.type) ? (Xm = y, XA = he(
            u.firstChild
          )) : XA = y), qA(
            e,
            i,
            i.pendingProps.children,
            o
          ), nl(e, i), e === null && (i.flags |= 4194304), i.child;
        case 5:
          return e === null && FI && (M = Q(), u = kc(
            i.type,
            M.ancestorInfo
          ), y = XA, (G = !y) || (G = wC(
            y,
            i.type,
            i.pendingProps,
            us
          ), G !== null ? (i.stateNode = G, Do || (M = ZI(
            G,
            i.type,
            i.pendingProps,
            M
          ), M !== null && (xs(i, 0).serverProps = M)), Ve = i, XA = he(
            G.firstChild
          ), us = !1, M = !0) : M = !1, G = !M), G && (u && Xo(i, y), Hn(i))), Bg(i), y = i.type, M = i.pendingProps, G = e !== null ? e.memoizedProps : null, u = M.children, gs(y, M) ? u = null : G !== null && gs(y, G) && (i.flags |= 32), i.memoizedState !== null && (y = ga(
            e,
            i,
            $e,
            null,
            null,
            o
          ), ZD._currentValue = y), nl(e, i), qA(
            e,
            i,
            u,
            o
          ), i.child;
        case 6:
          return e === null && FI && (e = i.pendingProps, o = Q(), u = o.ancestorInfo.current, e = u != null ? xo(
            e,
            u.tag,
            o.ancestorInfo.implicitRootScope
          ) : !0, o = XA, (u = !o) || (u = Cs(
            o,
            i.pendingProps,
            us
          ), u !== null ? (i.stateNode = u, Ve = i, XA = null, u = !0) : u = !1, u = !u), u && (e && Xo(i, o), Hn(i))), null;
        case 13:
          return Eh(e, i, o);
        case 4:
          return cg(
            i,
            i.stateNode.containerInfo
          ), u = i.pendingProps, e === null ? i.child = Rd(
            i,
            null,
            u,
            o
          ) : qA(
            e,
            i,
            u,
            o
          ), i.child;
        case 11:
          return si(
            e,
            i,
            i.type,
            i.pendingProps,
            o
          );
        case 7:
          return qA(
            e,
            i,
            i.pendingProps,
            o
          ), i.child;
        case 8:
          return qA(
            e,
            i,
            i.pendingProps.children,
            o
          ), i.child;
        case 12:
          return i.flags |= 4, i.flags |= 2048, u = i.stateNode, u.effectDuration = -0, u.passiveEffectDuration = -0, qA(
            e,
            i,
            i.pendingProps.children,
            o
          ), i.child;
        case 10:
          return u = i.type, y = i.pendingProps, M = y.value, "value" in y || _T || (_T = !0, console.error(
            "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
          )), En(i, u, M), qA(
            e,
            i,
            y.children,
            o
          ), i.child;
        case 9:
          return y = i.type._context, u = i.pendingProps.children, typeof u != "function" && console.error(
            "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
          ), Rn(i), y = fA(y), sI(i), u = hm(
            u,
            y,
            void 0
          ), Ug(), i.flags |= 1, qA(
            e,
            i,
            u,
            o
          ), i.child;
        case 14:
          return il(
            e,
            i,
            i.type,
            i.pendingProps,
            o
          );
        case 15:
          return Bu(
            e,
            i,
            i.type,
            i.pendingProps,
            o
          );
        case 19:
          return Nh(
            e,
            i,
            o
          );
        case 31:
          return u = i.pendingProps, o = i.mode, u = {
            mode: u.mode,
            children: u.children
          }, e === null ? (e = ol(
            u,
            o
          ), e.ref = i.ref, i.child = e, e.return = i, i = e) : (e = ei(e.child, u), e.ref = i.ref, i.child = e, e.return = i, i = e), i;
        case 22:
          return pu(e, i, o);
        case 24:
          return Rn(i), u = fA(bC), e === null ? (y = fh(), y === null && (y = MA, M = uh(), y.pooledCache = M, qe(M), M !== null && (y.pooledCacheLanes |= o), y = M), i.memoizedState = {
            parent: u,
            cache: y
          }, Nn(i), En(i, bC, y)) : ((e.lanes & o) !== 0 && (xr(e, i), kn(i, null, null, o), qo()), y = e.memoizedState, M = i.memoizedState, y.parent !== u ? (y = {
            parent: u,
            cache: u
          }, i.memoizedState = y, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = y), En(i, bC, u)) : (u = M.cache, En(i, bC, u), u !== y.cache && XC(
            i,
            [bC],
            o,
            !0
          ))), qA(
            e,
            i,
            i.pendingProps.children,
            o
          ), i.child;
        case 29:
          throw i.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function At(e) {
      e.flags |= 4;
    }
    function Wh(e, i) {
      if (i.type !== "stylesheet" || (i.state.loading & Ki) !== ic)
        e.flags &= -16777217;
      else if (e.flags |= 16777216, !Ty(i)) {
        if (i = Gi.current, i !== null && ((OI & 4194048) === OI ? fs !== null : (OI & 62914560) !== OI && (OI & 536870912) === 0 || i !== fs))
          throw cD = am, gT;
        e.flags |= 8192;
      }
    }
    function go(e, i) {
      i !== null && (e.flags |= 4), e.flags & 16384 && (i = e.tag !== 22 ? lt() : 536870912, e.lanes |= i, gc |= i);
    }
    function qi(e, i) {
      if (!FI)
        switch (e.tailMode) {
          case "hidden":
            i = e.tail;
            for (var o = null; i !== null; )
              i.alternate !== null && (o = i), i = i.sibling;
            o === null ? e.tail = null : o.sibling = null;
            break;
          case "collapsed":
            o = e.tail;
            for (var u = null; o !== null; )
              o.alternate !== null && (u = o), o = o.sibling;
            u === null ? i || e.tail === null ? e.tail = null : e.tail.sibling = null : u.sibling = null;
        }
    }
    function hA(e) {
      var i = e.alternate !== null && e.alternate.child === e.child, o = 0, u = 0;
      if (i)
        if ((e.mode & LC) !== bA) {
          for (var y = e.selfBaseDuration, M = e.child; M !== null; )
            o |= M.lanes | M.childLanes, u |= M.subtreeFlags & 65011712, u |= M.flags & 65011712, y += M.treeBaseDuration, M = M.sibling;
          e.treeBaseDuration = y;
        } else
          for (y = e.child; y !== null; )
            o |= y.lanes | y.childLanes, u |= y.subtreeFlags & 65011712, u |= y.flags & 65011712, y.return = e, y = y.sibling;
      else if ((e.mode & LC) !== bA) {
        y = e.actualDuration, M = e.selfBaseDuration;
        for (var G = e.child; G !== null; )
          o |= G.lanes | G.childLanes, u |= G.subtreeFlags, u |= G.flags, y += G.actualDuration, M += G.treeBaseDuration, G = G.sibling;
        e.actualDuration = y, e.treeBaseDuration = M;
      } else
        for (y = e.child; y !== null; )
          o |= y.lanes | y.childLanes, u |= y.subtreeFlags, u |= y.flags, y.return = e, y = y.sibling;
      return e.subtreeFlags |= u, e.childLanes = o, i;
    }
    function gw(e, i, o) {
      var u = i.pendingProps;
      switch (Vs(i), i.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return hA(i), null;
        case 1:
          return hA(i), null;
        case 3:
          return o = i.stateNode, u = null, e !== null && (u = e.memoizedState.cache), i.memoizedState.cache !== u && (i.flags |= 2048), Wi(bC, i), z(i), o.pendingContext && (o.context = o.pendingContext, o.pendingContext = null), (e === null || e.child === null) && (_s(i) ? (zM(), At(i)) : e === null || e.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, lh())), hA(i), null;
        case 26:
          return o = i.memoizedState, e === null ? (At(i), o !== null ? (hA(i), Wh(
            i,
            o
          )) : (hA(i), i.flags &= -16777217)) : o ? o !== e.memoizedState ? (At(i), hA(i), Wh(
            i,
            o
          )) : (hA(i), i.flags &= -16777217) : (e.memoizedProps !== u && At(i), hA(i), i.flags &= -16777217), null;
        case 27:
          Rg(i), o = Ng(li.current);
          var y = i.type;
          if (e !== null && i.stateNode != null)
            e.memoizedProps !== u && At(i);
          else {
            if (!u) {
              if (i.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return hA(i), null;
            }
            e = Q(), _s(i) ? rh(i) : (e = ye(
              y,
              u,
              o,
              e,
              !0
            ), i.stateNode = e, At(i));
          }
          return hA(i), null;
        case 5:
          if (Rg(i), o = i.type, e !== null && i.stateNode != null)
            e.memoizedProps !== u && At(i);
          else {
            if (!u) {
              if (i.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return hA(i), null;
            }
            if (y = Q(), _s(i))
              rh(i);
            else {
              switch (e = Ng(li.current), kc(o, y.ancestorInfo), y = y.context, e = _I(e), y) {
                case zd:
                  e = e.createElementNS(fn, o);
                  break;
                case yB:
                  e = e.createElementNS(
                    Dd,
                    o
                  );
                  break;
                default:
                  switch (o) {
                    case "svg":
                      e = e.createElementNS(
                        fn,
                        o
                      );
                      break;
                    case "math":
                      e = e.createElementNS(
                        Dd,
                        o
                      );
                      break;
                    case "script":
                      e = e.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild);
                      break;
                    case "select":
                      e = typeof u.is == "string" ? e.createElement("select", { is: u.is }) : e.createElement("select"), u.multiple ? e.multiple = !0 : u.size && (e.size = u.size);
                      break;
                    default:
                      e = typeof u.is == "string" ? e.createElement(o, {
                        is: u.is
                      }) : e.createElement(o), o.indexOf("-") === -1 && (o !== o.toLowerCase() && console.error(
                        "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                        o
                      ), Object.prototype.toString.call(e) !== "[object HTMLUnknownElement]" || ci.call(
                        oY,
                        o
                      ) || (oY[o] = !0, console.error(
                        "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                        o
                      )));
                  }
              }
              e[OC] = i, e[Me] = u;
              g: for (y = i.child; y !== null; ) {
                if (y.tag === 5 || y.tag === 6)
                  e.appendChild(y.stateNode);
                else if (y.tag !== 4 && y.tag !== 27 && y.child !== null) {
                  y.child.return = y, y = y.child;
                  continue;
                }
                if (y === i) break g;
                for (; y.sibling === null; ) {
                  if (y.return === null || y.return === i)
                    break g;
                  y = y.return;
                }
                y.sibling.return = y.return, y = y.sibling;
              }
              i.stateNode = e;
              g: switch (sC(e, o, u), o) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  e = !!u.autoFocus;
                  break g;
                case "img":
                  e = !0;
                  break g;
                default:
                  e = !1;
              }
              e && At(i);
            }
          }
          return hA(i), i.flags &= -16777217, null;
        case 6:
          if (e && i.stateNode != null)
            e.memoizedProps !== u && At(i);
          else {
            if (typeof u != "string" && i.stateNode === null)
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            if (e = Ng(li.current), o = Q(), _s(i)) {
              e = i.stateNode, o = i.memoizedProps, y = !Do, u = null;
              var M = Ve;
              if (M !== null)
                switch (M.tag) {
                  case 3:
                    y && (y = by(
                      e,
                      o,
                      u
                    ), y !== null && (xs(i, 0).serverProps = y));
                    break;
                  case 27:
                  case 5:
                    u = M.memoizedProps, y && (y = by(
                      e,
                      o,
                      u
                    ), y !== null && (xs(
                      i,
                      0
                    ).serverProps = y));
                }
              e[OC] = i, e = !!(e.nodeValue === o || u !== null && u.suppressHydrationWarning === !0 || so(e.nodeValue, o)), e || Hn(i);
            } else
              y = o.ancestorInfo.current, y != null && xo(
                u,
                y.tag,
                o.ancestorInfo.implicitRootScope
              ), e = _I(e).createTextNode(
                u
              ), e[OC] = i, i.stateNode = e;
          }
          return hA(i), null;
        case 13:
          if (u = i.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            if (y = _s(i), u !== null && u.dehydrated !== null) {
              if (e === null) {
                if (!y)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                if (y = i.memoizedState, y = y !== null ? y.dehydrated : null, !y)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                y[OC] = i, hA(i), (i.mode & LC) !== bA && u !== null && (y = i.child, y !== null && (i.treeBaseDuration -= y.treeBaseDuration));
              } else
                zM(), Qo(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4, hA(i), (i.mode & LC) !== bA && u !== null && (y = i.child, y !== null && (i.treeBaseDuration -= y.treeBaseDuration));
              y = !1;
            } else
              y = lh(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = y), y = !0;
            if (!y)
              return i.flags & 256 ? (ae(i), i) : (ae(i), null);
          }
          return ae(i), (i.flags & 128) !== 0 ? (i.lanes = o, (i.mode & LC) !== bA && Vr(i), i) : (o = u !== null, e = e !== null && e.memoizedState !== null, o && (u = i.child, y = null, u.alternate !== null && u.alternate.memoizedState !== null && u.alternate.memoizedState.cachePool !== null && (y = u.alternate.memoizedState.cachePool.pool), M = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (M = u.memoizedState.cachePool.pool), M !== y && (u.flags |= 2048)), o !== e && o && (i.child.flags |= 8192), go(i, i.updateQueue), hA(i), (i.mode & LC) !== bA && o && (e = i.child, e !== null && (i.treeBaseDuration -= e.treeBaseDuration)), null);
        case 4:
          return z(i), e === null && Ml(
            i.stateNode.containerInfo
          ), hA(i), null;
        case 10:
          return Wi(i.type, i), hA(i), null;
        case 19:
          if (Kg(GC, i), y = i.memoizedState, y === null) return hA(i), null;
          if (u = (i.flags & 128) !== 0, M = y.rendering, M === null)
            if (u) qi(y, !1);
            else {
              if (QA !== po || e !== null && (e.flags & 128) !== 0)
                for (e = i.child; e !== null; ) {
                  if (M = hu(e), M !== null) {
                    for (i.flags |= 128, qi(y, !1), e = M.updateQueue, i.updateQueue = e, go(i, e), i.subtreeFlags = 0, e = o, o = i.child; o !== null; )
                      nh(o, e), o = o.sibling;
                    return mg(
                      GC,
                      GC.current & Od | hD,
                      i
                    ), i.child;
                  }
                  e = e.sibling;
                }
              y.tail !== null && BC() > iB && (i.flags |= 128, u = !0, qi(y, !1), i.lanes = 4194304);
            }
          else {
            if (!u)
              if (e = hu(M), e !== null) {
                if (i.flags |= 128, u = !0, e = e.updateQueue, i.updateQueue = e, go(i, e), qi(y, !0), y.tail === null && y.tailMode === "hidden" && !M.alternate && !FI)
                  return hA(i), null;
              } else
                2 * BC() - y.renderingStartTime > iB && o !== 536870912 && (i.flags |= 128, u = !0, qi(y, !1), i.lanes = 4194304);
            y.isBackwards ? (M.sibling = i.child, i.child = M) : (e = y.last, e !== null ? e.sibling = M : i.child = M, y.last = M);
          }
          return y.tail !== null ? (e = y.tail, y.rendering = e, y.tail = e.sibling, y.renderingStartTime = BC(), e.sibling = null, o = GC.current, o = u ? o & Od | hD : o & Od, mg(GC, o, i), e) : (hA(i), null);
        case 22:
        case 23:
          return ae(i), nu(i), u = i.memoizedState !== null, e !== null ? e.memoizedState !== null !== u && (i.flags |= 8192) : u && (i.flags |= 8192), u ? (o & 536870912) !== 0 && (i.flags & 128) === 0 && (hA(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : hA(i), o = i.updateQueue, o !== null && go(i, o.retryQueue), o = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (o = e.memoizedState.cachePool.pool), u = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (u = i.memoizedState.cachePool.pool), u !== o && (i.flags |= 2048), e !== null && Kg(Ql, i), null;
        case 24:
          return o = null, e !== null && (o = e.memoizedState.cache), i.memoizedState.cache !== o && (i.flags |= 2048), Wi(bC, i), hA(i), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Iw(e, i) {
      switch (Vs(i), i.tag) {
        case 1:
          return e = i.flags, e & 65536 ? (i.flags = e & -65537 | 128, (i.mode & LC) !== bA && Vr(i), i) : null;
        case 3:
          return Wi(bC, i), z(i), e = i.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (i.flags = e & -65537 | 128, i) : null;
        case 26:
        case 27:
        case 5:
          return Rg(i), null;
        case 13:
          if (ae(i), e = i.memoizedState, e !== null && e.dehydrated !== null) {
            if (i.alternate === null)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            Qo();
          }
          return e = i.flags, e & 65536 ? (i.flags = e & -65537 | 128, (i.mode & LC) !== bA && Vr(i), i) : null;
        case 19:
          return Kg(GC, i), null;
        case 4:
          return z(i), null;
        case 10:
          return Wi(i.type, i), null;
        case 22:
        case 23:
          return ae(i), nu(i), e !== null && Kg(Ql, i), e = i.flags, e & 65536 ? (i.flags = e & -65537 | 128, (i.mode & LC) !== bA && Vr(i), i) : null;
        case 24:
          return Wi(bC, i), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function Vh(e, i) {
      switch (Vs(i), i.tag) {
        case 3:
          Wi(bC, i), z(i);
          break;
        case 26:
        case 27:
        case 5:
          Rg(i);
          break;
        case 4:
          z(i);
          break;
        case 13:
          ae(i);
          break;
        case 19:
          Kg(GC, i);
          break;
        case 10:
          Wi(i.type, i);
          break;
        case 22:
        case 23:
          ae(i), nu(i), e !== null && Kg(Ql, i);
          break;
        case 24:
          Wi(bC, i);
      }
    }
    function Gt(e) {
      return (e.mode & LC) !== bA;
    }
    function xh(e, i) {
      Gt(e) ? (HC(), fa(i, e), yt()) : fa(i, e);
    }
    function rl(e, i, o) {
      Gt(e) ? (HC(), Io(
        o,
        e,
        i
      ), yt()) : Io(
        o,
        e,
        i
      );
    }
    function fa(e, i) {
      try {
        var o = i.updateQueue, u = o !== null ? o.lastEffect : null;
        if (u !== null) {
          var y = u.next;
          o = y;
          do {
            if ((o.tag & e) === e && ((e & SC) !== mi ? Qg !== null && typeof Qg.markComponentPassiveEffectMountStarted == "function" && Qg.markComponentPassiveEffectMountStarted(
              i
            ) : (e & qC) !== mi && Qg !== null && typeof Qg.markComponentLayoutEffectMountStarted == "function" && Qg.markComponentLayoutEffectMountStarted(
              i
            ), u = void 0, (e & xe) !== mi && (Xd = !0), u = gI(
              i,
              zO,
              o
            ), (e & xe) !== mi && (Xd = !1), (e & SC) !== mi ? Qg !== null && typeof Qg.markComponentPassiveEffectMountStopped == "function" && Qg.markComponentPassiveEffectMountStopped() : (e & qC) !== mi && Qg !== null && typeof Qg.markComponentLayoutEffectMountStopped == "function" && Qg.markComponentLayoutEffectMountStopped(), u !== void 0 && typeof u != "function")) {
              var M = void 0;
              M = (o.tag & qC) !== 0 ? "useLayoutEffect" : (o.tag & xe) !== 0 ? "useInsertionEffect" : "useEffect";
              var G = void 0;
              G = u === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof u.then == "function" ? `

It looks like you wrote ` + M + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + M + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + u, gI(
                i,
                function(P, W) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    P,
                    W
                  );
                },
                M,
                G
              );
            }
            o = o.next;
          } while (o !== y);
        }
      } catch (P) {
        AA(i, i.return, P);
      }
    }
    function Io(e, i, o) {
      try {
        var u = i.updateQueue, y = u !== null ? u.lastEffect : null;
        if (y !== null) {
          var M = y.next;
          u = M;
          do {
            if ((u.tag & e) === e) {
              var G = u.inst, P = G.destroy;
              P !== void 0 && (G.destroy = void 0, (e & SC) !== mi ? Qg !== null && typeof Qg.markComponentPassiveEffectUnmountStarted == "function" && Qg.markComponentPassiveEffectUnmountStarted(
                i
              ) : (e & qC) !== mi && Qg !== null && typeof Qg.markComponentLayoutEffectUnmountStarted == "function" && Qg.markComponentLayoutEffectUnmountStarted(
                i
              ), (e & xe) !== mi && (Xd = !0), y = i, gI(
                y,
                JO,
                y,
                o,
                P
              ), (e & xe) !== mi && (Xd = !1), (e & SC) !== mi ? Qg !== null && typeof Qg.markComponentPassiveEffectUnmountStopped == "function" && Qg.markComponentPassiveEffectUnmountStopped() : (e & qC) !== mi && Qg !== null && typeof Qg.markComponentLayoutEffectUnmountStopped == "function" && Qg.markComponentLayoutEffectUnmountStopped());
            }
            u = u.next;
          } while (u !== M);
        }
      } catch (W) {
        AA(i, i.return, W);
      }
    }
    function Ku(e, i) {
      Gt(e) ? (HC(), fa(i, e), yt()) : fa(i, e);
    }
    function Tu(e, i, o) {
      Gt(e) ? (HC(), Io(
        o,
        e,
        i
      ), yt()) : Io(
        o,
        e,
        i
      );
    }
    function _h(e) {
      var i = e.updateQueue;
      if (i !== null) {
        var o = e.stateNode;
        e.type.defaultProps || "ref" in e.memoizedProps || kd || (o.props !== e.memoizedProps && console.error(
          "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          ig(e) || "instance"
        ), o.state !== e.memoizedState && console.error(
          "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          ig(e) || "instance"
        ));
        try {
          gI(
            e,
            te,
            i,
            o
          );
        } catch (u) {
          AA(e, e.return, u);
        }
      }
    }
    function W0(e, i, o) {
      return e.getSnapshotBeforeUpdate(i, o);
    }
    function Uh(e, i) {
      var o = i.memoizedProps, u = i.memoizedState;
      i = e.stateNode, e.type.defaultProps || "ref" in e.memoizedProps || kd || (i.props !== e.memoizedProps && console.error(
        "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
        ig(e) || "instance"
      ), i.state !== e.memoizedState && console.error(
        "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
        ig(e) || "instance"
      ));
      try {
        var y = Fn(
          e.type,
          o,
          e.elementType === e.type
        ), M = gI(
          e,
          W0,
          i,
          y,
          u
        );
        o = UT, M !== void 0 || o.has(e.type) || (o.add(e.type), gI(e, function() {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            ig(e)
          );
        })), i.__reactInternalSnapshotBeforeUpdate = M;
      } catch (G) {
        AA(e, e.return, G);
      }
    }
    function Fh(e, i, o) {
      o.props = Fn(
        e.type,
        e.memoizedProps
      ), o.state = e.memoizedState, Gt(e) ? (HC(), gI(
        e,
        yT,
        e,
        i,
        o
      ), yt()) : gI(
        e,
        yT,
        e,
        i,
        o
      );
    }
    function Aw(e) {
      var i = e.ref;
      if (i !== null) {
        switch (e.tag) {
          case 26:
          case 27:
          case 5:
            var o = e.stateNode;
            break;
          case 30:
            o = e.stateNode;
            break;
          default:
            o = e.stateNode;
        }
        if (typeof i == "function")
          if (Gt(e))
            try {
              HC(), e.refCleanup = i(o);
            } finally {
              yt();
            }
          else e.refCleanup = i(o);
        else
          typeof i == "string" ? console.error("String refs are no longer supported.") : i.hasOwnProperty("current") || console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            ig(e)
          ), i.current = o;
      }
    }
    function Ao(e, i) {
      try {
        gI(e, Aw, e);
      } catch (o) {
        AA(e, i, o);
      }
    }
    function Kt(e, i) {
      var o = e.ref, u = e.refCleanup;
      if (o !== null)
        if (typeof u == "function")
          try {
            if (Gt(e))
              try {
                HC(), gI(e, u);
              } finally {
                yt(e);
              }
            else gI(e, u);
          } catch (y) {
            AA(e, i, y);
          } finally {
            e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null);
          }
        else if (typeof o == "function")
          try {
            if (Gt(e))
              try {
                HC(), gI(e, o, null);
              } finally {
                yt(e);
              }
            else gI(e, o, null);
          } catch (y) {
            AA(e, i, y);
          }
        else o.current = null;
    }
    function Xh(e, i, o, u) {
      var y = e.memoizedProps, M = y.id, G = y.onCommit;
      y = y.onRender, i = i === null ? "mount" : "update", Qw && (i = "nested-update"), typeof y == "function" && y(
        M,
        i,
        e.actualDuration,
        e.treeBaseDuration,
        e.actualStartTime,
        o
      ), typeof G == "function" && G(
        e.memoizedProps.id,
        i,
        u,
        o
      );
    }
    function V0(e, i, o, u) {
      var y = e.memoizedProps;
      e = y.id, y = y.onPostCommit, i = i === null ? "mount" : "update", Qw && (i = "nested-update"), typeof y == "function" && y(
        e,
        i,
        u,
        o
      );
    }
    function Cw(e) {
      var i = e.type, o = e.memoizedProps, u = e.stateNode;
      try {
        gI(
          e,
          vA,
          u,
          i,
          o,
          e
        );
      } catch (y) {
        AA(e, e.return, y);
      }
    }
    function Yu(e, i, o) {
      try {
        gI(
          e,
          Is,
          e.stateNode,
          e.type,
          o,
          i,
          e
        );
      } catch (u) {
        AA(e, e.return, u);
      }
    }
    function ha(e) {
      return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 && $A(e.type) || e.tag === 4;
    }
    function ll(e) {
      g: for (; ; ) {
        for (; e.sibling === null; ) {
          if (e.return === null || ha(e.return)) return null;
          e = e.return;
        }
        for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
          if (e.tag === 27 && $A(e.type) || e.flags & 2 || e.child === null || e.tag === 4) continue g;
          e.child.return = e, e = e.child;
        }
        if (!(e.flags & 2)) return e.stateNode;
      }
    }
    function ya(e, i, o) {
      var u = e.tag;
      if (u === 5 || u === 6)
        e = e.stateNode, i ? (o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o).insertBefore(e, i) : (i = o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, i.appendChild(e), o = o._reactRootContainer, o != null || i.onclick !== null || (i.onclick = qn));
      else if (u !== 4 && (u === 27 && $A(e.type) && (o = e.stateNode, i = null), e = e.child, e !== null))
        for (ya(e, i, o), e = e.sibling; e !== null; )
          ya(e, i, o), e = e.sibling;
    }
    function cl(e, i, o) {
      var u = e.tag;
      if (u === 5 || u === 6)
        e = e.stateNode, i ? o.insertBefore(e, i) : o.appendChild(e);
      else if (u !== 4 && (u === 27 && $A(e.type) && (o = e.stateNode), e = e.child, e !== null))
        for (cl(e, i, o), e = e.sibling; e !== null; )
          cl(e, i, o), e = e.sibling;
    }
    function ew(e) {
      for (var i, o = e.return; o !== null; ) {
        if (ha(o)) {
          i = o;
          break;
        }
        o = o.return;
      }
      if (i == null)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (i.tag) {
        case 27:
          i = i.stateNode, o = ll(e), cl(
            e,
            o,
            i
          );
          break;
        case 5:
          o = i.stateNode, i.flags & 32 && (As(o), i.flags &= -33), i = ll(e), cl(
            e,
            i,
            o
          );
          break;
        case 3:
        case 4:
          i = i.stateNode.containerInfo, o = ll(e), ya(
            e,
            o,
            i
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function ul(e) {
      var i = e.stateNode, o = e.memoizedProps;
      try {
        gI(
          e,
          Dw,
          e.type,
          o,
          i,
          e
        );
      } catch (u) {
        AA(e, e.return, u);
      }
    }
    function tw(e, i) {
      if (e = e.containerInfo, _m = BB, e = FM(e), eh(e)) {
        if ("selectionStart" in e)
          var o = {
            start: e.selectionStart,
            end: e.selectionEnd
          };
        else
          g: {
            o = (o = e.ownerDocument) && o.defaultView || window;
            var u = o.getSelection && o.getSelection();
            if (u && u.rangeCount !== 0) {
              o = u.anchorNode;
              var y = u.anchorOffset, M = u.focusNode;
              u = u.focusOffset;
              try {
                o.nodeType, M.nodeType;
              } catch {
                o = null;
                break g;
              }
              var G = 0, P = -1, W = -1, _ = 0, wg = 0, Gg = e, yg = null;
              I: for (; ; ) {
                for (var Tg; Gg !== o || y !== 0 && Gg.nodeType !== 3 || (P = G + y), Gg !== M || u !== 0 && Gg.nodeType !== 3 || (W = G + u), Gg.nodeType === 3 && (G += Gg.nodeValue.length), (Tg = Gg.firstChild) !== null; )
                  yg = Gg, Gg = Tg;
                for (; ; ) {
                  if (Gg === e) break I;
                  if (yg === o && ++_ === y && (P = G), yg === M && ++wg === u && (W = G), (Tg = Gg.nextSibling) !== null) break;
                  Gg = yg, yg = Gg.parentNode;
                }
                Gg = Tg;
              }
              o = P === -1 || W === -1 ? null : { start: P, end: W };
            } else o = null;
          }
        o = o || { start: 0, end: 0 };
      } else o = null;
      for (Um = {
        focusedElem: e,
        selectionRange: o
      }, BB = !1, kC = i; kC !== null; )
        if (i = kC, e = i.child, (i.subtreeFlags & 1024) !== 0 && e !== null)
          e.return = i, kC = e;
        else
          for (; kC !== null; ) {
            switch (e = i = kC, o = e.alternate, y = e.flags, e.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                (y & 1024) !== 0 && o !== null && Uh(e, o);
                break;
              case 3:
                if ((y & 1024) !== 0) {
                  if (e = e.stateNode.containerInfo, o = e.nodeType, o === 9)
                    ai(e);
                  else if (o === 1)
                    switch (e.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        ai(e);
                        break;
                      default:
                        e.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((y & 1024) !== 0)
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            if (e = i.sibling, e !== null) {
              e.return = i.return, kC = e;
              break;
            }
            kC = i.return;
          }
    }
    function Qh(e, i, o) {
      var u = o.flags;
      switch (o.tag) {
        case 0:
        case 11:
        case 15:
          UA(e, o), u & 4 && xh(o, qC | bi);
          break;
        case 1:
          if (UA(e, o), u & 4)
            if (e = o.stateNode, i === null)
              o.type.defaultProps || "ref" in o.memoizedProps || kd || (e.props !== o.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                ig(o) || "instance"
              ), e.state !== o.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                ig(o) || "instance"
              )), Gt(o) ? (HC(), gI(
                o,
                ym,
                o,
                e
              ), yt()) : gI(
                o,
                ym,
                o,
                e
              );
            else {
              var y = Fn(
                o.type,
                i.memoizedProps
              );
              i = i.memoizedState, o.type.defaultProps || "ref" in o.memoizedProps || kd || (e.props !== o.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                ig(o) || "instance"
              ), e.state !== o.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                ig(o) || "instance"
              )), Gt(o) ? (HC(), gI(
                o,
                dT,
                o,
                e,
                y,
                i,
                e.__reactInternalSnapshotBeforeUpdate
              ), yt()) : gI(
                o,
                dT,
                o,
                e,
                y,
                i,
                e.__reactInternalSnapshotBeforeUpdate
              );
            }
          u & 64 && _h(o), u & 512 && Ao(o, o.return);
          break;
        case 3:
          if (i = Pe(), UA(e, o), u & 64 && (u = o.updateQueue, u !== null)) {
            if (y = null, o.child !== null)
              switch (o.child.tag) {
                case 27:
                case 5:
                  y = o.child.stateNode;
                  break;
                case 1:
                  y = o.child.stateNode;
              }
            try {
              gI(
                o,
                te,
                u,
                y
              );
            } catch (G) {
              AA(o, o.return, G);
            }
          }
          e.effectDuration += Jo(i);
          break;
        case 27:
          i === null && u & 4 && ul(o);
        case 26:
        case 5:
          UA(e, o), i === null && u & 4 && Cw(o), u & 512 && Ao(o, o.return);
          break;
        case 12:
          if (u & 4) {
            u = Pe(), UA(e, o), e = o.stateNode, e.effectDuration += Lo(u);
            try {
              gI(
                o,
                Xh,
                o,
                i,
                Xw,
                e.effectDuration
              );
            } catch (G) {
              AA(o, o.return, G);
            }
          } else UA(e, o);
          break;
        case 13:
          UA(e, o), u & 4 && dl(e, o), u & 64 && (e = o.memoizedState, e !== null && (e = e.dehydrated, e !== null && (o = Jn.bind(
            null,
            o
          ), Ya(e, o))));
          break;
        case 22:
          if (u = o.memoizedState !== null || Bo, !u) {
            i = i !== null && i.memoizedState !== null || IC, y = Bo;
            var M = IC;
            Bo = u, (IC = i) && !M ? EC(
              e,
              o,
              (o.subtreeFlags & 8772) !== 0
            ) : UA(e, o), Bo = y, IC = M;
          }
          break;
        case 30:
          break;
        default:
          UA(e, o);
      }
    }
    function iw(e) {
      var i = e.alternate;
      i !== null && (e.alternate = null, iw(i)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (i = e.stateNode, i !== null && Te(i)), e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
    }
    function re(e, i, o) {
      for (o = o.child; o !== null; )
        Da(
          e,
          i,
          o
        ), o = o.sibling;
    }
    function Da(e, i, o) {
      if (pC && typeof pC.onCommitFiberUnmount == "function")
        try {
          pC.onCommitFiberUnmount(co, o);
        } catch (M) {
          kA || (kA = !0, console.error(
            "React instrumentation encountered an error: %s",
            M
          ));
        }
      switch (o.tag) {
        case 26:
          IC || Kt(o, i), re(
            e,
            i,
            o
          ), o.memoizedState ? o.memoizedState.count-- : o.stateNode && (o = o.stateNode, o.parentNode.removeChild(o));
          break;
        case 27:
          IC || Kt(o, i);
          var u = cC, y = ot;
          $A(o.type) && (cC = o.stateNode, ot = !1), re(
            e,
            i,
            o
          ), gI(
            o,
            Za,
            o.stateNode
          ), cC = u, ot = y;
          break;
        case 5:
          IC || Kt(o, i);
        case 6:
          if (u = cC, y = ot, cC = null, re(
            e,
            i,
            o
          ), cC = u, ot = y, cC !== null)
            if (ot)
              try {
                gI(
                  o,
                  Bl,
                  cC,
                  o.stateNode
                );
              } catch (M) {
                AA(
                  o,
                  i,
                  M
                );
              }
            else
              try {
                gI(
                  o,
                  Ta,
                  cC,
                  o.stateNode
                );
              } catch (M) {
                AA(
                  o,
                  i,
                  M
                );
              }
          break;
        case 18:
          cC !== null && (ot ? (e = cC, JC(
            e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e,
            o.stateNode
          ), Ra(e)) : JC(cC, o.stateNode));
          break;
        case 4:
          u = cC, y = ot, cC = o.stateNode.containerInfo, ot = !0, re(
            e,
            i,
            o
          ), cC = u, ot = y;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          IC || Io(
            xe,
            o,
            i
          ), IC || rl(
            o,
            i,
            qC
          ), re(
            e,
            i,
            o
          );
          break;
        case 1:
          IC || (Kt(o, i), u = o.stateNode, typeof u.componentWillUnmount == "function" && Fh(
            o,
            i,
            u
          )), re(
            e,
            i,
            o
          );
          break;
        case 21:
          re(
            e,
            i,
            o
          );
          break;
        case 22:
          IC = (u = IC) || o.memoizedState !== null, re(
            e,
            i,
            o
          ), IC = u;
          break;
        default:
          re(
            e,
            i,
            o
          );
      }
    }
    function dl(e, i) {
      if (i.memoizedState === null && (e = i.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null))))
        try {
          gI(
            i,
            yw,
            e
          );
        } catch (o) {
          AA(i, i.return, o);
        }
    }
    function fl(e) {
      switch (e.tag) {
        case 13:
        case 19:
          var i = e.stateNode;
          return i === null && (i = e.stateNode = new FT()), i;
        case 22:
          return e = e.stateNode, i = e._retryCache, i === null && (i = e._retryCache = new FT()), i;
        default:
          throw Error(
            "Unexpected Suspense handler tag (" + e.tag + "). This is a bug in React."
          );
      }
    }
    function Ma(e, i) {
      var o = fl(e);
      i.forEach(function(u) {
        var y = lw.bind(null, e, u);
        if (!o.has(u)) {
          if (o.add(u), nt)
            if (Wd !== null && Vd !== null)
              io(Vd, Wd);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          u.then(y, y);
        }
      });
    }
    function le(e, i) {
      var o = i.deletions;
      if (o !== null)
        for (var u = 0; u < o.length; u++) {
          var y = e, M = i, G = o[u], P = M;
          g: for (; P !== null; ) {
            switch (P.tag) {
              case 27:
                if ($A(P.type)) {
                  cC = P.stateNode, ot = !1;
                  break g;
                }
                break;
              case 5:
                cC = P.stateNode, ot = !1;
                break g;
              case 3:
              case 4:
                cC = P.stateNode.containerInfo, ot = !0;
                break g;
            }
            P = P.return;
          }
          if (cC === null)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          Da(y, M, G), cC = null, ot = !1, y = G, M = y.alternate, M !== null && (M.return = null), y.return = null;
        }
      if (i.subtreeFlags & 13878)
        for (i = i.child; i !== null; )
          zh(i, e), i = i.sibling;
    }
    function zh(e, i) {
      var o = e.alternate, u = e.flags;
      switch (e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          le(i, e), iC(e), u & 4 && (Io(
            xe | bi,
            e,
            e.return
          ), fa(xe | bi, e), rl(
            e,
            e.return,
            qC | bi
          ));
          break;
        case 1:
          le(i, e), iC(e), u & 512 && (IC || o === null || Kt(o, o.return)), u & 64 && Bo && (e = e.updateQueue, e !== null && (u = e.callbacks, u !== null && (o = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = o === null ? u : o.concat(u))));
          break;
        case 26:
          var y = Mn;
          if (le(i, e), iC(e), u & 512 && (IC || o === null || Kt(o, o.return)), u & 4)
            if (i = o !== null ? o.memoizedState : null, u = e.memoizedState, o === null)
              if (u === null)
                if (e.stateNode === null) {
                  g: {
                    u = e.type, o = e.memoizedProps, i = y.ownerDocument || y;
                    I: switch (u) {
                      case "title":
                        y = i.getElementsByTagName("title")[0], (!y || y[Hl] || y[OC] || y.namespaceURI === fn || y.hasAttribute("itemprop")) && (y = i.createElement(u), i.head.insertBefore(
                          y,
                          i.querySelector("head > title")
                        )), sC(y, u, o), y[OC] = e, og(y), u = y;
                        break g;
                      case "link":
                        var M = Ky(
                          "link",
                          "href",
                          i
                        ).get(u + (o.href || ""));
                        if (M) {
                          for (var G = 0; G < M.length; G++)
                            if (y = M[G], y.getAttribute("href") === (o.href == null || o.href === "" ? null : o.href) && y.getAttribute("rel") === (o.rel == null ? null : o.rel) && y.getAttribute("title") === (o.title == null ? null : o.title) && y.getAttribute("crossorigin") === (o.crossOrigin == null ? null : o.crossOrigin)) {
                              M.splice(G, 1);
                              break I;
                            }
                        }
                        y = i.createElement(u), sC(y, u, o), i.head.appendChild(y);
                        break;
                      case "meta":
                        if (M = Ky(
                          "meta",
                          "content",
                          i
                        ).get(u + (o.content || ""))) {
                          for (G = 0; G < M.length; G++)
                            if (y = M[G], Cg(
                              o.content,
                              "content"
                            ), y.getAttribute("content") === (o.content == null ? null : "" + o.content) && y.getAttribute("name") === (o.name == null ? null : o.name) && y.getAttribute("property") === (o.property == null ? null : o.property) && y.getAttribute("http-equiv") === (o.httpEquiv == null ? null : o.httpEquiv) && y.getAttribute("charset") === (o.charSet == null ? null : o.charSet)) {
                              M.splice(G, 1);
                              break I;
                            }
                        }
                        y = i.createElement(u), sC(y, u, o), i.head.appendChild(y);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' + u + '". This is a bug in React.'
                        );
                    }
                    y[OC] = e, og(y), u = y;
                  }
                  e.stateNode = u;
                } else
                  ao(
                    y,
                    e.type,
                    e.stateNode
                  );
              else
                e.stateNode = ww(
                  y,
                  u,
                  e.memoizedProps
                );
            else
              i !== u ? (i === null ? o.stateNode !== null && (o = o.stateNode, o.parentNode.removeChild(o)) : i.count--, u === null ? ao(
                y,
                e.type,
                e.stateNode
              ) : ww(
                y,
                u,
                e.memoizedProps
              )) : u === null && e.stateNode !== null && Yu(
                e,
                e.memoizedProps,
                o.memoizedProps
              );
          break;
        case 27:
          le(i, e), iC(e), u & 512 && (IC || o === null || Kt(o, o.return)), o !== null && u & 4 && Yu(
            e,
            e.memoizedProps,
            o.memoizedProps
          );
          break;
        case 5:
          if (le(i, e), iC(e), u & 512 && (IC || o === null || Kt(o, o.return)), e.flags & 32) {
            i = e.stateNode;
            try {
              gI(e, As, i);
            } catch (wg) {
              AA(e, e.return, wg);
            }
          }
          u & 4 && e.stateNode != null && (i = e.memoizedProps, Yu(
            e,
            i,
            o !== null ? o.memoizedProps : i
          )), u & 1024 && (bm = !0, e.type !== "form" && console.error(
            "Unexpected host component type. Expected a form. This is a bug in React."
          ));
          break;
        case 6:
          if (le(i, e), iC(e), u & 4) {
            if (e.stateNode === null)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            u = e.memoizedProps, o = o !== null ? o.memoizedProps : u, i = e.stateNode;
            try {
              gI(
                e,
                By,
                i,
                o,
                u
              );
            } catch (wg) {
              AA(e, e.return, wg);
            }
          }
          break;
        case 3:
          if (y = Pe(), DB = null, M = Mn, Mn = Xu(i.containerInfo), le(i, e), Mn = M, iC(e), u & 4 && o !== null && o.memoizedState.isDehydrated)
            try {
              gI(
                e,
                Oe,
                i.containerInfo
              );
            } catch (wg) {
              AA(e, e.return, wg);
            }
          bm && (bm = !1, Jh(e)), i.effectDuration += Jo(y);
          break;
        case 4:
          u = Mn, Mn = Xu(
            e.stateNode.containerInfo
          ), le(i, e), iC(e), Mn = u;
          break;
        case 12:
          u = Pe(), le(i, e), iC(e), e.stateNode.effectDuration += Lo(u);
          break;
        case 13:
          le(i, e), iC(e), e.child.flags & 8192 && e.memoizedState !== null != (o !== null && o.memoizedState !== null) && (Pm = BC()), u & 4 && (u = e.updateQueue, u !== null && (e.updateQueue = null, Ma(e, u)));
          break;
        case 22:
          y = e.memoizedState !== null;
          var P = o !== null && o.memoizedState !== null, W = Bo, _ = IC;
          if (Bo = W || y, IC = _ || P, le(i, e), IC = _, Bo = W, iC(e), u & 8192)
            g: for (i = e.stateNode, i._visibility = y ? i._visibility & ~xw : i._visibility | xw, y && (o === null || P || Bo || IC || ce(e)), o = null, i = e; ; ) {
              if (i.tag === 5 || i.tag === 26) {
                if (o === null) {
                  P = o = i;
                  try {
                    M = P.stateNode, y ? gI(P, py, M) : gI(
                      P,
                      xu,
                      P.stateNode,
                      P.memoizedProps
                    );
                  } catch (wg) {
                    AA(P, P.return, wg);
                  }
                }
              } else if (i.tag === 6) {
                if (o === null) {
                  P = i;
                  try {
                    G = P.stateNode, y ? gI(P, my, G) : gI(
                      P,
                      _u,
                      G,
                      P.memoizedProps
                    );
                  } catch (wg) {
                    AA(P, P.return, wg);
                  }
                }
              } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === e) && i.child !== null) {
                i.child.return = i, i = i.child;
                continue;
              }
              if (i === e) break g;
              for (; i.sibling === null; ) {
                if (i.return === null || i.return === e)
                  break g;
                o === i && (o = null), i = i.return;
              }
              o === i && (o = null), i.sibling.return = i.return, i = i.sibling;
            }
          u & 4 && (u = e.updateQueue, u !== null && (o = u.retryQueue, o !== null && (u.retryQueue = null, Ma(e, o))));
          break;
        case 19:
          le(i, e), iC(e), u & 4 && (u = e.updateQueue, u !== null && (e.updateQueue = null, Ma(e, u)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          le(i, e), iC(e);
      }
    }
    function iC(e) {
      var i = e.flags;
      if (i & 2) {
        try {
          gI(e, ew, e);
        } catch (o) {
          AA(e, e.return, o);
        }
        e.flags &= -3;
      }
      i & 4096 && (e.flags &= -4097);
    }
    function Jh(e) {
      if (e.subtreeFlags & 1024)
        for (e = e.child; e !== null; ) {
          var i = e;
          Jh(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), e = e.sibling;
        }
    }
    function UA(e, i) {
      if (i.subtreeFlags & 8772)
        for (i = i.child; i !== null; )
          Qh(e, i.alternate, i), i = i.sibling;
    }
    function Tt(e) {
      switch (e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          rl(
            e,
            e.return,
            qC
          ), ce(e);
          break;
        case 1:
          Kt(e, e.return);
          var i = e.stateNode;
          typeof i.componentWillUnmount == "function" && Fh(
            e,
            e.return,
            i
          ), ce(e);
          break;
        case 27:
          gI(
            e,
            Za,
            e.stateNode
          );
        case 26:
        case 5:
          Kt(e, e.return), ce(e);
          break;
        case 22:
          e.memoizedState === null && ce(e);
          break;
        case 30:
          ce(e);
          break;
        default:
          ce(e);
      }
    }
    function ce(e) {
      for (e = e.child; e !== null; )
        Tt(e), e = e.sibling;
    }
    function Lh(e, i, o, u) {
      var y = o.flags;
      switch (o.tag) {
        case 0:
        case 11:
        case 15:
          EC(
            e,
            o,
            u
          ), xh(o, qC);
          break;
        case 1:
          if (EC(
            e,
            o,
            u
          ), i = o.stateNode, typeof i.componentDidMount == "function" && gI(
            o,
            ym,
            o,
            i
          ), i = o.updateQueue, i !== null) {
            e = o.stateNode;
            try {
              gI(
                o,
                k0,
                i,
                e
              );
            } catch (M) {
              AA(o, o.return, M);
            }
          }
          u && y & 64 && _h(o), Ao(o, o.return);
          break;
        case 27:
          ul(o);
        case 26:
        case 5:
          EC(
            e,
            o,
            u
          ), u && i === null && y & 4 && Cw(o), Ao(o, o.return);
          break;
        case 12:
          if (u && y & 4) {
            y = Pe(), EC(
              e,
              o,
              u
            ), u = o.stateNode, u.effectDuration += Lo(y);
            try {
              gI(
                o,
                Xh,
                o,
                i,
                Xw,
                u.effectDuration
              );
            } catch (M) {
              AA(o, o.return, M);
            }
          } else
            EC(
              e,
              o,
              u
            );
          break;
        case 13:
          EC(
            e,
            o,
            u
          ), u && y & 4 && dl(e, o);
          break;
        case 22:
          o.memoizedState === null && EC(
            e,
            o,
            u
          ), Ao(o, o.return);
          break;
        case 30:
          break;
        default:
          EC(
            e,
            o,
            u
          );
      }
    }
    function EC(e, i, o) {
      for (o = o && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; )
        Lh(
          e,
          i.alternate,
          i,
          o
        ), i = i.sibling;
    }
    function Yt(e, i) {
      var o = null;
      e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (o = e.memoizedState.cachePool.pool), e = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (e = i.memoizedState.cachePool.pool), e !== o && (e != null && qe(e), o != null && Us(o));
    }
    function NA(e, i) {
      e = null, i.alternate !== null && (e = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== e && (qe(i), e != null && Us(e));
    }
    function ve(e, i, o, u) {
      if (i.subtreeFlags & 10256)
        for (i = i.child; i !== null; )
          Pu(
            e,
            i,
            o,
            u
          ), i = i.sibling;
    }
    function Pu(e, i, o, u) {
      var y = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          ve(
            e,
            i,
            o,
            u
          ), y & 2048 && Ku(i, SC | bi);
          break;
        case 1:
          ve(
            e,
            i,
            o,
            u
          );
          break;
        case 3:
          var M = Pe();
          ve(
            e,
            i,
            o,
            u
          ), y & 2048 && (o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (qe(i), o != null && Us(o))), e.passiveEffectDuration += Jo(M);
          break;
        case 12:
          if (y & 2048) {
            y = Pe(), ve(
              e,
              i,
              o,
              u
            ), e = i.stateNode, e.passiveEffectDuration += Lo(y);
            try {
              gI(
                i,
                V0,
                i,
                i.alternate,
                Xw,
                e.passiveEffectDuration
              );
            } catch (P) {
              AA(i, i.return, P);
            }
          } else
            ve(
              e,
              i,
              o,
              u
            );
          break;
        case 13:
          ve(
            e,
            i,
            o,
            u
          );
          break;
        case 23:
          break;
        case 22:
          M = i.stateNode;
          var G = i.alternate;
          i.memoizedState !== null ? M._visibility & fo ? ve(
            e,
            i,
            o,
            u
          ) : wa(
            e,
            i
          ) : M._visibility & fo ? ve(
            e,
            i,
            o,
            u
          ) : (M._visibility |= fo, Qn(
            e,
            i,
            o,
            u,
            (i.subtreeFlags & 10256) !== 0
          )), y & 2048 && Yt(G, i);
          break;
        case 24:
          ve(
            e,
            i,
            o,
            u
          ), y & 2048 && NA(i.alternate, i);
          break;
        default:
          ve(
            e,
            i,
            o,
            u
          );
      }
    }
    function Qn(e, i, o, u, y) {
      for (y = y && (i.subtreeFlags & 10256) !== 0, i = i.child; i !== null; )
        qh(
          e,
          i,
          o,
          u,
          y
        ), i = i.sibling;
    }
    function qh(e, i, o, u, y) {
      var M = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          Qn(
            e,
            i,
            o,
            u,
            y
          ), Ku(i, SC);
          break;
        case 23:
          break;
        case 22:
          var G = i.stateNode;
          i.memoizedState !== null ? G._visibility & fo ? Qn(
            e,
            i,
            o,
            u,
            y
          ) : wa(
            e,
            i
          ) : (G._visibility |= fo, Qn(
            e,
            i,
            o,
            u,
            y
          )), y && M & 2048 && Yt(
            i.alternate,
            i
          );
          break;
        case 24:
          Qn(
            e,
            i,
            o,
            u,
            y
          ), y && M & 2048 && NA(i.alternate, i);
          break;
        default:
          Qn(
            e,
            i,
            o,
            u,
            y
          );
      }
    }
    function wa(e, i) {
      if (i.subtreeFlags & 10256)
        for (i = i.child; i !== null; ) {
          var o = e, u = i, y = u.flags;
          switch (u.tag) {
            case 22:
              wa(
                o,
                u
              ), y & 2048 && Yt(
                u.alternate,
                u
              );
              break;
            case 24:
              wa(
                o,
                u
              ), y & 2048 && NA(
                u.alternate,
                u
              );
              break;
            default:
              wa(
                o,
                u
              );
          }
          i = i.sibling;
        }
    }
    function Ct(e) {
      if (e.subtreeFlags & yD)
        for (e = e.child; e !== null; )
          hl(e), e = e.sibling;
    }
    function hl(e) {
      switch (e.tag) {
        case 26:
          Ct(e), e.flags & yD && e.memoizedState !== null && pw(
            Mn,
            e.memoizedState,
            e.memoizedProps
          );
          break;
        case 5:
          Ct(e);
          break;
        case 3:
        case 4:
          var i = Mn;
          Mn = Xu(
            e.stateNode.containerInfo
          ), Ct(e), Mn = i;
          break;
        case 22:
          e.memoizedState === null && (i = e.alternate, i !== null && i.memoizedState !== null ? (i = yD, yD = 16777216, Ct(e), yD = i) : Ct(e));
          break;
        default:
          Ct(e);
      }
    }
    function $h(e) {
      var i = e.alternate;
      if (i !== null && (e = i.child, e !== null)) {
        i.child = null;
        do
          i = e.sibling, e.sibling = null, e = i;
        while (e !== null);
      }
    }
    function Ba(e) {
      var i = e.deletions;
      if ((e.flags & 16) !== 0) {
        if (i !== null)
          for (var o = 0; o < i.length; o++) {
            var u = i[o];
            kC = u, Zu(
              u,
              e
            );
          }
        $h(e);
      }
      if (e.subtreeFlags & 10256)
        for (e = e.child; e !== null; )
          gy(e), e = e.sibling;
    }
    function gy(e) {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          Ba(e), e.flags & 2048 && Tu(
            e,
            e.return,
            SC | bi
          );
          break;
        case 3:
          var i = Pe();
          Ba(e), e.stateNode.passiveEffectDuration += Jo(i);
          break;
        case 12:
          i = Pe(), Ba(e), e.stateNode.passiveEffectDuration += Lo(i);
          break;
        case 22:
          i = e.stateNode, e.memoizedState !== null && i._visibility & fo && (e.return === null || e.return.tag !== 13) ? (i._visibility &= ~fo, Co(e)) : Ba(e);
          break;
        default:
          Ba(e);
      }
    }
    function Co(e) {
      var i = e.deletions;
      if ((e.flags & 16) !== 0) {
        if (i !== null)
          for (var o = 0; o < i.length; o++) {
            var u = i[o];
            kC = u, Zu(
              u,
              e
            );
          }
        $h(e);
      }
      for (e = e.child; e !== null; )
        Iy(e), e = e.sibling;
    }
    function Iy(e) {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          Tu(
            e,
            e.return,
            SC
          ), Co(e);
          break;
        case 22:
          var i = e.stateNode;
          i._visibility & fo && (i._visibility &= ~fo, Co(e));
          break;
        default:
          Co(e);
      }
    }
    function Zu(e, i) {
      for (; kC !== null; ) {
        var o = kC, u = o;
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            Tu(
              u,
              i,
              SC
            );
            break;
          case 23:
          case 22:
            u.memoizedState !== null && u.memoizedState.cachePool !== null && (u = u.memoizedState.cachePool.pool, u != null && qe(u));
            break;
          case 24:
            Us(u.memoizedState.cache);
        }
        if (u = o.child, u !== null) u.return = o, kC = u;
        else
          g: for (o = e; kC !== null; ) {
            u = kC;
            var y = u.sibling, M = u.return;
            if (iw(u), u === o) {
              kC = null;
              break g;
            }
            if (y !== null) {
              y.return = M, kC = y;
              break g;
            }
            kC = M;
          }
      }
    }
    function nw() {
      qO.forEach(function(e) {
        return e();
      });
    }
    function Ay() {
      var e = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return e || Dg.actQueue === null || console.error(
        "The current testing environment is not configured to support act(...)"
      ), e;
    }
    function He(e) {
      if ((qI & _e) !== kt && OI !== 0)
        return OI & -OI;
      var i = Dg.T;
      return i !== null ? (i._updatedFibers || (i._updatedFibers = /* @__PURE__ */ new Set()), i._updatedFibers.add(e), e = Xl, e !== 0 ? e : Wu()) : gi();
    }
    function Cy() {
      Vt === 0 && (Vt = (OI & 536870912) === 0 || FI ? rI() : 536870912);
      var e = Gi.current;
      return e !== null && (e.flags |= 32), Vt;
    }
    function YI(e, i, o) {
      if (Xd && console.error("useInsertionEffect must not schedule updates."), Em && (nB = !0), (e === MA && (iA === ql || iA === $l) || e.cancelPendingCommit !== null) && (gn(e, 0), $i(
        e,
        OI,
        Vt,
        !1
      )), ct(e, o), (qI & _e) !== 0 && e === MA) {
        if (di)
          switch (i.tag) {
            case 0:
            case 11:
            case 15:
              e = HI && ig(HI) || "Unknown", AY.has(e) || (AY.add(e), i = ig(i) || "Unknown", console.error(
                "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                i,
                e,
                e
              ));
              break;
            case 1:
              IY || (console.error(
                "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
              ), IY = !0);
          }
      } else
        nt && pA(e, i, o), uy(i), e === MA && ((qI & _e) === kt && (qa |= o), QA === Ll && $i(
          e,
          OI,
          Vt,
          !1
        )), et(e);
    }
    function nC(e, i, o) {
      if ((qI & (_e | wn)) !== kt)
        throw Error("Should not already be working.");
      var u = !o && (i & 124) === 0 && (i & e.expiredLanes) === 0 || hC(e, i), y = u ? ny(e, i) : yl(e, i, !0), M = u;
      do {
        if (y === po) {
          Ud && !u && $i(e, i, 0, !1);
          break;
        } else {
          if (o = e.current.alternate, M && !sw(o)) {
            y = yl(e, i, !1), M = !1;
            continue;
          }
          if (y === xd) {
            if (M = i, e.errorRecoveryDisabledLanes & M)
              var G = 0;
            else
              G = e.pendingLanes & -536870913, G = G !== 0 ? G : G & 536870912 ? 536870912 : 0;
            if (G !== 0) {
              i = G;
              g: {
                y = e;
                var P = G;
                G = mD;
                var W = y.current.memoizedState.isDehydrated;
                if (W && (gn(
                  y,
                  P
                ).flags |= 256), P = yl(
                  y,
                  P,
                  !1
                ), P !== xd) {
                  if (Tm && !W) {
                    y.errorRecoveryDisabledLanes |= M, qa |= M, y = Ll;
                    break g;
                  }
                  y = Ue, Ue = G, y !== null && (Ue === null ? Ue = y : Ue.push.apply(
                    Ue,
                    y
                  ));
                }
                y = P;
              }
              if (M = !1, y !== xd) continue;
            }
          }
          if (y === MD) {
            gn(e, 0), $i(e, i, 0, !0);
            break;
          }
          g: {
            switch (u = e, y) {
              case po:
              case MD:
                throw Error("Root did not complete. This is a bug in React.");
              case Ll:
                if ((i & 4194048) !== i) break;
              case eB:
                $i(
                  u,
                  i,
                  Vt,
                  !Ja
                );
                break g;
              case xd:
                Ue = null;
                break;
              case Sm:
              case XT:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (Dg.actQueue !== null)
              Pt(
                u,
                o,
                i,
                Ue,
                bD,
                tB,
                Vt,
                qa,
                gc
              );
            else {
              if ((i & 62914560) === i && (M = Pm + zT - BC(), 10 < M)) {
                if ($i(
                  u,
                  i,
                  Vt,
                  !Ja
                ), CC(u, 0, !0) !== 0) break g;
                u.timeoutHandle = aY(
                  ey.bind(
                    null,
                    u,
                    o,
                    Ue,
                    bD,
                    tB,
                    i,
                    Vt,
                    qa,
                    gc,
                    Ja,
                    y,
                    AN,
                    LK,
                    0
                  ),
                  M
                );
                break g;
              }
              ey(
                u,
                o,
                Ue,
                bD,
                tB,
                i,
                Vt,
                qa,
                gc,
                Ja,
                y,
                gN,
                LK,
                0
              );
            }
          }
        }
        break;
      } while (!0);
      et(e);
    }
    function ey(e, i, o, u, y, M, G, P, W, _, wg, Gg, yg, Tg) {
      if (e.timeoutHandle = tc, Gg = i.subtreeFlags, (Gg & 8192 || (Gg & 16785408) === 16785408) && (PD = { stylesheets: null, count: 0, unsuspend: Bw }, hl(i), Gg = mw(), Gg !== null)) {
        e.cancelPendingCommit = Gg(
          Pt.bind(
            null,
            e,
            i,
            M,
            o,
            u,
            y,
            G,
            P,
            W,
            wg,
            IN,
            yg,
            Tg
          )
        ), $i(
          e,
          M,
          G,
          !_
        );
        return;
      }
      Pt(
        e,
        i,
        M,
        o,
        u,
        y,
        G,
        P,
        W
      );
    }
    function sw(e) {
      for (var i = e; ; ) {
        var o = i.tag;
        if ((o === 0 || o === 11 || o === 15) && i.flags & 16384 && (o = i.updateQueue, o !== null && (o = o.stores, o !== null)))
          for (var u = 0; u < o.length; u++) {
            var y = o[u], M = y.getSnapshot;
            y = y.value;
            try {
              if (!We(M(), y)) return !1;
            } catch {
              return !1;
            }
          }
        if (o = i.child, i.subtreeFlags & 16384 && o !== null)
          o.return = i, i = o;
        else {
          if (i === e) break;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === e) return !0;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
      }
      return !0;
    }
    function $i(e, i, o, u) {
      i &= ~Ym, i &= ~qa, e.suspendedLanes |= i, e.pingedLanes &= ~i, u && (e.warmLanes |= i), u = e.expirationTimes;
      for (var y = i; 0 < y; ) {
        var M = 31 - oC(y), G = 1 << M;
        u[M] = -1, y &= ~G;
      }
      o !== 0 && Qe(e, o, i);
    }
    function eo() {
      return (qI & (_e | wn)) === kt ? (Ln(0), !1) : !0;
    }
    function ju() {
      if (HI !== null) {
        if (iA === at)
          var e = HI.return;
        else
          e = HI, Iu(), pt(e), Ed = null, fD = 0, e = HI;
        for (; e !== null; )
          Vh(e.alternate, e), e = e.return;
        HI = null;
      }
    }
    function gn(e, i) {
      var o = e.timeoutHandle;
      o !== tc && (e.timeoutHandle = tc, dN(o)), o = e.cancelPendingCommit, o !== null && (e.cancelPendingCommit = null, o()), ju(), MA = e, HI = o = ei(e.current, null), OI = i, iA = at, Wt = null, Ja = !1, Ud = hC(e, i), Tm = !1, QA = po, gc = Vt = Ym = qa = La = 0, Ue = mD = null, tB = !1, (i & 8) !== 0 && (i |= i & 32);
      var u = e.entangledLanes;
      if (u !== 0)
        for (e = e.entanglements, u &= i; 0 < u; ) {
          var y = 31 - oC(u), M = 1 << y;
          i |= e[y], u &= ~M;
        }
      return hs = i, Xc(), i = zK(), 1e3 < i - QK && (Dg.recentlyCreatedOwnerStacks = 0, QK = i), yn.discardPendingWarnings(), o;
    }
    function vu(e, i) {
      dI = null, Dg.H = AB, Dg.getCurrentStack = null, di = !1, mC = null, i === lD || i === Lw ? (i = Ze(), iA = BD) : i === gT ? (i = Ze(), iA = QT) : iA = i === OT ? Km : i !== null && typeof i == "object" && typeof i.then == "function" ? _d : wD, Wt = i;
      var o = HI;
      if (o === null)
        QA = MD, da(
          e,
          Ae(i, e.current)
        );
      else
        switch (o.mode & LC && On(o), Ug(), iA) {
          case wD:
            Qg !== null && typeof Qg.markComponentErrored == "function" && Qg.markComponentErrored(
              o,
              i,
              OI
            );
            break;
          case ql:
          case $l:
          case BD:
          case _d:
          case pD:
            Qg !== null && typeof Qg.markComponentSuspended == "function" && Qg.markComponentSuspended(
              o,
              i,
              OI
            );
        }
    }
    function ty() {
      var e = Dg.H;
      return Dg.H = AB, e === null ? AB : e;
    }
    function iy() {
      var e = Dg.A;
      return Dg.A = LO, e;
    }
    function Hu() {
      QA = Ll, Ja || (OI & 4194048) !== OI && Gi.current !== null || (Ud = !0), (La & 134217727) === 0 && (qa & 134217727) === 0 || MA === null || $i(
        MA,
        OI,
        Vt,
        !1
      );
    }
    function yl(e, i, o) {
      var u = qI;
      qI |= _e;
      var y = ty(), M = iy();
      if (MA !== e || OI !== i) {
        if (nt) {
          var G = e.memoizedUpdaters;
          0 < G.size && (io(e, OI), G.clear()), Ri(e, i);
        }
        bD = null, gn(e, i);
      }
      fI(i), i = !1, G = QA;
      g: do
        try {
          if (iA !== at && HI !== null) {
            var P = HI, W = Wt;
            switch (iA) {
              case Km:
                ju(), G = eB;
                break g;
              case BD:
              case ql:
              case $l:
              case _d:
                Gi.current === null && (i = !0);
                var _ = iA;
                if (iA = at, Wt = null, to(e, P, W, _), o && Ud) {
                  G = po;
                  break g;
                }
                break;
              default:
                _ = iA, iA = at, Wt = null, to(e, P, W, _);
            }
          }
          Eu(), G = QA;
          break;
        } catch (wg) {
          vu(e, wg);
        }
      while (!0);
      return i && e.shellSuspendCounter++, Iu(), qI = u, Dg.H = y, Dg.A = M, VI(), HI === null && (MA = null, OI = 0, Xc()), G;
    }
    function Eu() {
      for (; HI !== null; ) Ru(HI);
    }
    function ny(e, i) {
      var o = qI;
      qI |= _e;
      var u = ty(), y = iy();
      if (MA !== e || OI !== i) {
        if (nt) {
          var M = e.memoizedUpdaters;
          0 < M.size && (io(e, OI), M.clear()), Ri(e, i);
        }
        bD = null, iB = BC() + JT, gn(e, i);
      } else
        Ud = hC(
          e,
          i
        );
      fI(i);
      g: do
        try {
          if (iA !== at && HI !== null)
            I: switch (i = HI, M = Wt, iA) {
              case wD:
                iA = at, Wt = null, to(
                  e,
                  i,
                  M,
                  wD
                );
                break;
              case ql:
              case $l:
                if (tu(M)) {
                  iA = at, Wt = null, Dl(i);
                  break;
                }
                i = function() {
                  iA !== ql && iA !== $l || MA !== e || (iA = pD), et(e);
                }, M.then(i, i);
                break g;
              case BD:
                iA = pD;
                break g;
              case QT:
                iA = Gm;
                break g;
              case pD:
                tu(M) ? (iA = at, Wt = null, Dl(i)) : (iA = at, Wt = null, to(
                  e,
                  i,
                  M,
                  pD
                ));
                break;
              case Gm:
                var G = null;
                switch (HI.tag) {
                  case 26:
                    G = HI.memoizedState;
                  case 5:
                  case 27:
                    var P = HI;
                    if (!G || Ty(G)) {
                      iA = at, Wt = null;
                      var W = P.sibling;
                      if (W !== null) HI = W;
                      else {
                        var _ = P.return;
                        _ !== null ? (HI = _, pa(_)) : HI = null;
                      }
                      break I;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                iA = at, Wt = null, to(
                  e,
                  i,
                  M,
                  Gm
                );
                break;
              case _d:
                iA = at, Wt = null, to(
                  e,
                  i,
                  M,
                  _d
                );
                break;
              case Km:
                ju(), QA = eB;
                break g;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          Dg.actQueue !== null ? Eu() : ow();
          break;
        } catch (wg) {
          vu(e, wg);
        }
      while (!0);
      return Iu(), Dg.H = u, Dg.A = y, qI = o, HI !== null ? (Qg !== null && typeof Qg.markRenderYielded == "function" && Qg.markRenderYielded(), po) : (VI(), MA = null, OI = 0, Xc(), QA);
    }
    function ow() {
      for (; HI !== null && !Q0(); )
        Ru(HI);
    }
    function Ru(e) {
      var i = e.alternate;
      (e.mode & LC) !== bA ? (xi(e), i = gI(
        e,
        Xn,
        i,
        e,
        hs
      ), On(e)) : i = gI(
        e,
        Xn,
        i,
        e,
        hs
      ), e.memoizedProps = e.pendingProps, i === null ? pa(e) : HI = i;
    }
    function Dl(e) {
      var i = gI(e, sy, e);
      e.memoizedProps = e.pendingProps, i === null ? pa(e) : HI = i;
    }
    function sy(e) {
      var i = e.alternate, o = (e.mode & LC) !== bA;
      switch (o && xi(e), e.tag) {
        case 15:
        case 0:
          i = Zh(
            i,
            e,
            e.pendingProps,
            e.type,
            void 0,
            OI
          );
          break;
        case 11:
          i = Zh(
            i,
            e,
            e.pendingProps,
            e.type.render,
            e.ref,
            OI
          );
          break;
        case 5:
          pt(e);
        default:
          Vh(i, e), e = HI = nh(e, hs), i = Xn(i, e, hs);
      }
      return o && On(e), i;
    }
    function to(e, i, o, u) {
      Iu(), pt(i), Ed = null, fD = 0;
      var y = i.return;
      try {
        if (wu(
          e,
          y,
          i,
          o,
          OI
        )) {
          QA = MD, da(
            e,
            Ae(o, e.current)
          ), HI = null;
          return;
        }
      } catch (M) {
        if (y !== null) throw HI = y, M;
        QA = MD, da(
          e,
          Ae(o, e.current)
        ), HI = null;
        return;
      }
      i.flags & 32768 ? (FI || u === wD ? e = !0 : Ud || (OI & 536870912) !== 0 ? e = !1 : (Ja = e = !0, (u === ql || u === $l || u === BD || u === _d) && (u = Gi.current, u !== null && u.tag === 13 && (u.flags |= 16384))), oy(i, e)) : pa(i);
    }
    function pa(e) {
      var i = e;
      do {
        if ((i.flags & 32768) !== 0) {
          oy(
            i,
            Ja
          );
          return;
        }
        var o = i.alternate;
        if (e = i.return, xi(i), o = gI(
          i,
          gw,
          o,
          i,
          hs
        ), (i.mode & LC) !== bA && Cu(i), o !== null) {
          HI = o;
          return;
        }
        if (i = i.sibling, i !== null) {
          HI = i;
          return;
        }
        HI = i = e;
      } while (i !== null);
      QA === po && (QA = XT);
    }
    function oy(e, i) {
      do {
        var o = Iw(e.alternate, e);
        if (o !== null) {
          o.flags &= 32767, HI = o;
          return;
        }
        if ((e.mode & LC) !== bA) {
          Cu(e), o = e.actualDuration;
          for (var u = e.child; u !== null; )
            o += u.actualDuration, u = u.sibling;
          e.actualDuration = o;
        }
        if (o = e.return, o !== null && (o.flags |= 32768, o.subtreeFlags = 0, o.deletions = null), !i && (e = e.sibling, e !== null)) {
          HI = e;
          return;
        }
        HI = e = o;
      } while (e !== null);
      QA = eB, HI = null;
    }
    function Pt(e, i, o, u, y, M, G, P, W) {
      e.cancelPendingCommit = null;
      do
        zn();
      while ($C !== Ic);
      if (yn.flushLegacyContextWarning(), yn.flushPendingUnsafeLifecycleWarnings(), (qI & (_e | wn)) !== kt)
        throw Error("Should not already be working.");
      if (Qg !== null && typeof Qg.markCommitStarted == "function" && Qg.markCommitStarted(o), i === null) nI();
      else {
        if (o === 0 && console.error(
          "finishedLanes should not be empty during a commit. This is a bug in React."
        ), i === e.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        if (M = i.lanes | i.childLanes, M |= tm, Eo(
          e,
          o,
          M,
          G,
          P,
          W
        ), e === MA && (HI = MA = null, OI = 0), Fd = i, gr = e, Ir = o, jm = M, vm = y, gY = u, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (e.callbackNode = null, e.callbackPriority = 0, cw(Na, function() {
          return ma(), null;
        })) : (e.callbackNode = null, e.callbackPriority = 0), Xw = Pd(), u = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || u) {
          u = Dg.T, Dg.T = null, y = QI.p, QI.p = ke, G = qI, qI |= wn;
          try {
            tw(e, i, o);
          } finally {
            qI = G, QI.p = y, Dg.T = u;
          }
        }
        $C = LT, Ou(), aw(), ay();
      }
    }
    function Ou() {
      if ($C === LT) {
        $C = Ic;
        var e = gr, i = Fd, o = Ir, u = (i.flags & 13878) !== 0;
        if ((i.subtreeFlags & 13878) !== 0 || u) {
          u = Dg.T, Dg.T = null;
          var y = QI.p;
          QI.p = ke;
          var M = qI;
          qI |= wn;
          try {
            Wd = o, Vd = e, zh(i, e), Vd = Wd = null, o = Um;
            var G = FM(e.containerInfo), P = o.focusedElem, W = o.selectionRange;
            if (G !== P && P && P.ownerDocument && UM(
              P.ownerDocument.documentElement,
              P
            )) {
              if (W !== null && eh(P)) {
                var _ = W.start, wg = W.end;
                if (wg === void 0 && (wg = _), "selectionStart" in P)
                  P.selectionStart = _, P.selectionEnd = Math.min(
                    wg,
                    P.value.length
                  );
                else {
                  var Gg = P.ownerDocument || document, yg = Gg && Gg.defaultView || window;
                  if (yg.getSelection) {
                    var Tg = yg.getSelection(), qg = P.textContent.length, aI = Math.min(
                      W.start,
                      qg
                    ), wA = W.end === void 0 ? aI : Math.min(W.end, qg);
                    !Tg.extend && aI > wA && (G = wA, wA = aI, aI = G);
                    var NI = _M(
                      P,
                      aI
                    ), $ = _M(
                      P,
                      wA
                    );
                    if (NI && $ && (Tg.rangeCount !== 1 || Tg.anchorNode !== NI.node || Tg.anchorOffset !== NI.offset || Tg.focusNode !== $.node || Tg.focusOffset !== $.offset)) {
                      var gg = Gg.createRange();
                      gg.setStart(NI.node, NI.offset), Tg.removeAllRanges(), aI > wA ? (Tg.addRange(gg), Tg.extend($.node, $.offset)) : (gg.setEnd($.node, $.offset), Tg.addRange(gg));
                    }
                  }
                }
              }
              for (Gg = [], Tg = P; Tg = Tg.parentNode; )
                Tg.nodeType === 1 && Gg.push({
                  element: Tg,
                  left: Tg.scrollLeft,
                  top: Tg.scrollTop
                });
              for (typeof P.focus == "function" && P.focus(), P = 0; P < Gg.length; P++) {
                var Ig = Gg[P];
                Ig.element.scrollLeft = Ig.left, Ig.element.scrollTop = Ig.top;
              }
            }
            BB = !!_m, Um = _m = null;
          } finally {
            qI = M, QI.p = y, Dg.T = u;
          }
        }
        e.current = i, $C = qT;
      }
    }
    function aw() {
      if ($C === qT) {
        $C = Ic;
        var e = gr, i = Fd, o = Ir, u = (i.flags & 8772) !== 0;
        if ((i.subtreeFlags & 8772) !== 0 || u) {
          u = Dg.T, Dg.T = null;
          var y = QI.p;
          QI.p = ke;
          var M = qI;
          qI |= wn;
          try {
            Qg !== null && typeof Qg.markLayoutEffectsStarted == "function" && Qg.markLayoutEffectsStarted(o), Wd = o, Vd = e, Qh(
              e,
              i.alternate,
              i
            ), Vd = Wd = null, Qg !== null && typeof Qg.markLayoutEffectsStopped == "function" && Qg.markLayoutEffectsStopped();
          } finally {
            qI = M, QI.p = y, Dg.T = u;
          }
        }
        $C = $T;
      }
    }
    function ay() {
      if ($C === CN || $C === $T) {
        $C = Ic, z0();
        var e = gr, i = Fd, o = Ir, u = gY, y = (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0;
        y ? $C = Zm : ($C = Ic, Fd = gr = null, ry(e, e.pendingLanes), Ac = 0, GD = null);
        var M = e.pendingLanes;
        if (M === 0 && ($a = null), y || Zt(e), y = $t(o), i = i.stateNode, pC && typeof pC.onCommitFiberRoot == "function")
          try {
            var G = (i.current.flags & 128) === 128;
            switch (y) {
              case ke:
                var P = jl;
                break;
              case ui:
                P = Ey;
                break;
              case un:
                P = Na;
                break;
              case rd:
                P = Oy;
                break;
              default:
                P = Na;
            }
            pC.onCommitFiberRoot(
              co,
              i,
              P,
              G
            );
          } catch (Gg) {
            kA || (kA = !0, console.error(
              "React instrumentation encountered an error: %s",
              Gg
            ));
          }
        if (nt && e.memoizedUpdaters.clear(), nw(), u !== null) {
          G = Dg.T, P = QI.p, QI.p = ke, Dg.T = null;
          try {
            var W = e.onRecoverableError;
            for (i = 0; i < u.length; i++) {
              var _ = u[i], wg = In(_.stack);
              gI(
                _.source,
                W,
                _.value,
                wg
              );
            }
          } finally {
            Dg.T = G, QI.p = P;
          }
        }
        (Ir & 3) !== 0 && zn(), et(e), M = e.pendingLanes, (o & 4194090) !== 0 && (M & 42) !== 0 ? (zw = !0, e === Hm ? SD++ : (SD = 0, Hm = e)) : SD = 0, Ln(0), nI();
      }
    }
    function In(e) {
      return e = { componentStack: e }, Object.defineProperty(e, "digest", {
        get: function() {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      }), e;
    }
    function ry(e, i) {
      (e.pooledCacheLanes &= i) === 0 && (i = e.pooledCache, i != null && (e.pooledCache = null, Us(i)));
    }
    function zn(e) {
      return Ou(), aw(), ay(), ma();
    }
    function ma() {
      if ($C !== Zm) return !1;
      var e = gr, i = jm;
      jm = 0;
      var o = $t(Ir), u = un > o ? un : o;
      o = Dg.T;
      var y = QI.p;
      try {
        QI.p = u, Dg.T = null, u = vm, vm = null;
        var M = gr, G = Ir;
        if ($C = Ic, Fd = gr = null, Ir = 0, (qI & (_e | wn)) !== kt)
          throw Error("Cannot flush passive effects while already rendering.");
        Em = !0, nB = !1, Qg !== null && typeof Qg.markPassiveEffectsStarted == "function" && Qg.markPassiveEffectsStarted(G);
        var P = qI;
        if (qI |= wn, gy(M.current), Pu(
          M,
          M.current,
          G,
          u
        ), Qg !== null && typeof Qg.markPassiveEffectsStopped == "function" && Qg.markPassiveEffectsStopped(), Zt(M), qI = P, Ln(0, !1), nB ? M === GD ? Ac++ : (Ac = 0, GD = M) : Ac = 0, nB = Em = !1, pC && typeof pC.onPostCommitFiberRoot == "function")
          try {
            pC.onPostCommitFiberRoot(co, M);
          } catch (_) {
            kA || (kA = !0, console.error(
              "React instrumentation encountered an error: %s",
              _
            ));
          }
        var W = M.current.stateNode;
        return W.effectDuration = 0, W.passiveEffectDuration = 0, !0;
      } finally {
        QI.p = y, Dg.T = o, ry(e, i);
      }
    }
    function mA(e, i, o) {
      i = Ae(o, i), i = ZA(e.stateNode, i, 2), e = Mt(e, i, 2), e !== null && (ct(e, 2), et(e));
    }
    function AA(e, i, o) {
      if (Xd = !1, e.tag === 3)
        mA(e, e, o);
      else {
        for (; i !== null; ) {
          if (i.tag === 3) {
            mA(
              i,
              e,
              o
            );
            return;
          }
          if (i.tag === 1) {
            var u = i.stateNode;
            if (typeof i.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && ($a === null || !$a.has(u))) {
              e = Ae(o, e), o = tl(2), u = Mt(i, o, 2), u !== null && ($s(
                o,
                u,
                i,
                e
              ), ct(u, 2), et(u));
              return;
            }
          }
          i = i.return;
        }
        console.error(
          `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
          o
        );
      }
    }
    function ly(e, i, o) {
      var u = e.pingCache;
      if (u === null) {
        u = e.pingCache = new $O();
        var y = /* @__PURE__ */ new Set();
        u.set(i, y);
      } else
        y = u.get(i), y === void 0 && (y = /* @__PURE__ */ new Set(), u.set(i, y));
      y.has(o) || (Tm = !0, y.add(o), u = rw.bind(null, e, i, o), nt && io(e, o), i.then(u, u));
    }
    function rw(e, i, o) {
      var u = e.pingCache;
      u !== null && u.delete(i), e.pingedLanes |= e.suspendedLanes & o, e.warmLanes &= ~o, Ay() && Dg.actQueue === null && console.error(
        `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
      ), MA === e && (OI & o) === o && (QA === Ll || QA === Sm && (OI & 62914560) === OI && BC() - Pm < zT ? (qI & _e) === kt && gn(e, 0) : Ym |= o, gc === OI && (gc = 0)), et(e);
    }
    function ba(e, i) {
      i === 0 && (i = lt()), e = Ce(e, i), e !== null && (ct(e, i), et(e));
    }
    function Jn(e) {
      var i = e.memoizedState, o = 0;
      i !== null && (o = i.retryLane), ba(e, o);
    }
    function lw(e, i) {
      var o = 0;
      switch (e.tag) {
        case 13:
          var u = e.stateNode, y = e.memoizedState;
          y !== null && (o = y.retryLane);
          break;
        case 19:
          u = e.stateNode;
          break;
        case 22:
          u = e.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      u !== null && u.delete(i), ba(e, o);
    }
    function Nu(e, i, o) {
      if ((i.subtreeFlags & 67117056) !== 0)
        for (i = i.child; i !== null; ) {
          var u = e, y = i, M = y.type === ro;
          M = o || M, y.tag !== 22 ? y.flags & 67108864 ? M && gI(
            y,
            Sa,
            u,
            y,
            (y.mode & UK) === bA
          ) : Nu(
            u,
            y,
            M
          ) : y.memoizedState === null && (M && y.flags & 8192 ? gI(
            y,
            Sa,
            u,
            y
          ) : y.subtreeFlags & 67108864 && gI(
            y,
            Nu,
            u,
            y,
            M
          )), i = i.sibling;
        }
    }
    function Sa(e, i) {
      var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
      Wg(!0);
      try {
        Tt(i), o && Iy(i), Lh(e, i.alternate, i, !1), o && qh(e, i, 0, null, !1, 0);
      } finally {
        Wg(!1);
      }
    }
    function Zt(e) {
      var i = !0;
      e.current.mode & (we | hn) || (i = !1), Nu(
        e,
        e.current,
        i
      );
    }
    function cy(e) {
      if ((qI & _e) === kt) {
        var i = e.tag;
        if (i === 3 || i === 1 || i === 0 || i === 11 || i === 14 || i === 15) {
          if (i = ig(e) || "ReactComponent", sB !== null) {
            if (sB.has(i)) return;
            sB.add(i);
          } else sB = /* @__PURE__ */ new Set([i]);
          gI(e, function() {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function io(e, i) {
      nt && e.memoizedUpdaters.forEach(function(o) {
        pA(e, o, i);
      });
    }
    function cw(e, i) {
      var o = Dg.actQueue;
      return o !== null ? (o.push(i), iN) : Hy(e, i);
    }
    function uy(e) {
      Ay() && Dg.actQueue === null && gI(e, function() {
        console.error(
          `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
          ig(e)
        );
      });
    }
    function et(e) {
      e !== Qd && e.next === null && (Qd === null ? oB = Qd = e : Qd = Qd.next = e), aB = !0, Dg.actQueue !== null ? Om || (Om = !0, dw()) : Rm || (Rm = !0, dw());
    }
    function Ln(e, i) {
      if (!Nm && aB) {
        Nm = !0;
        do
          for (var o = !1, u = oB; u !== null; ) {
            if (e !== 0) {
              var y = u.pendingLanes;
              if (y === 0) var M = 0;
              else {
                var G = u.suspendedLanes, P = u.pingedLanes;
                M = (1 << 31 - oC(42 | e) + 1) - 1, M &= y & ~(G & ~P), M = M & 201326741 ? M & 201326741 | 1 : M ? M | 2 : 0;
              }
              M !== 0 && (o = !0, dy(u, M));
            } else
              M = OI, M = CC(
                u,
                u === MA ? M : 0,
                u.cancelPendingCommit !== null || u.timeoutHandle !== tc
              ), (M & 3) === 0 || hC(u, M) || (o = !0, dy(u, M));
            u = u.next;
          }
        while (o);
        Nm = !1;
      }
    }
    function uw() {
      jt();
    }
    function jt() {
      aB = Om = Rm = !1;
      var e = 0;
      Cc !== 0 && (wy() && (e = Cc), Cc = 0);
      for (var i = BC(), o = null, u = oB; u !== null; ) {
        var y = u.next, M = jA(u, i);
        M === 0 ? (u.next = null, o === null ? oB = y : o.next = y, y === null && (Qd = o)) : (o = u, (e !== 0 || (M & 3) !== 0) && (aB = !0)), u = y;
      }
      Ln(e);
    }
    function jA(e, i) {
      for (var o = e.suspendedLanes, u = e.pingedLanes, y = e.expirationTimes, M = e.pendingLanes & -62914561; 0 < M; ) {
        var G = 31 - oC(M), P = 1 << G, W = y[G];
        W === -1 ? ((P & o) === 0 || (P & u) !== 0) && (y[G] = Lt(P, i)) : W <= i && (e.expiredLanes |= P), M &= ~P;
      }
      if (i = MA, o = OI, o = CC(
        e,
        e === i ? o : 0,
        e.cancelPendingCommit !== null || e.timeoutHandle !== tc
      ), u = e.callbackNode, o === 0 || e === i && (iA === ql || iA === $l) || e.cancelPendingCommit !== null)
        return u !== null && FA(u), e.callbackNode = null, e.callbackPriority = 0;
      if ((o & 3) === 0 || hC(e, o)) {
        if (i = o & -o, i !== e.callbackPriority || Dg.actQueue !== null && u !== km)
          FA(u);
        else return i;
        switch ($t(o)) {
          case ke:
          case ui:
            o = Ey;
            break;
          case un:
            o = Na;
            break;
          case rd:
            o = Oy;
            break;
          default:
            o = Na;
        }
        return u = ku.bind(null, e), Dg.actQueue !== null ? (Dg.actQueue.push(u), o = km) : o = Hy(o, u), e.callbackPriority = i, e.callbackNode = o, i;
      }
      return u !== null && FA(u), e.callbackPriority = 2, e.callbackNode = null, 2;
    }
    function ku(e, i) {
      if (zw = Qw = !1, $C !== Ic && $C !== Zm)
        return e.callbackNode = null, e.callbackPriority = 0, null;
      var o = e.callbackNode;
      if (zn() && e.callbackNode !== o)
        return null;
      var u = OI;
      return u = CC(
        e,
        e === MA ? u : 0,
        e.cancelPendingCommit !== null || e.timeoutHandle !== tc
      ), u === 0 ? null : (nC(
        e,
        u,
        i
      ), jA(e, BC()), e.callbackNode != null && e.callbackNode === o ? ku.bind(null, e) : null);
    }
    function dy(e, i) {
      if (zn()) return null;
      Qw = zw, zw = !1, nC(e, i, !0);
    }
    function FA(e) {
      e !== km && e !== null && Pw(e);
    }
    function dw() {
      Dg.actQueue !== null && Dg.actQueue.push(function() {
        return jt(), null;
      }), fN(function() {
        (qI & (_e | wn)) !== kt ? Hy(
          jl,
          uw
        ) : jt();
      });
    }
    function Wu() {
      return Cc === 0 && (Cc = rI()), Cc;
    }
    function fy(e) {
      return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : (Cg(e, "action"), ki("" + e));
    }
    function yA(e, i) {
      var o = i.ownerDocument.createElement("input");
      return o.name = i.name, o.value = i.value, e.id && o.setAttribute("form", e.id), i.parentNode.insertBefore(o, i), e = new FormData(e), o.parentNode.removeChild(o), e;
    }
    function ue(e, i, o, u, y) {
      if (i === "submit" && o && o.stateNode === y) {
        var M = fy(
          (y[Me] || null).action
        ), G = u.submitter;
        G && (i = (i = G[Me] || null) ? fy(i.formAction) : G.getAttribute("formAction"), i !== null && (M = i, G = null));
        var P = new zI(
          "action",
          "action",
          null,
          u,
          y
        );
        e.push({
          event: P,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (u.defaultPrevented) {
                  if (Cc !== 0) {
                    var W = G ? yA(
                      y,
                      G
                    ) : new FormData(y), _ = {
                      pending: !0,
                      data: W,
                      method: y.method,
                      action: M
                    };
                    Object.freeze(_), uu(
                      o,
                      _,
                      null,
                      W
                    );
                  }
                } else
                  typeof M == "function" && (P.preventDefault(), W = G ? yA(
                    y,
                    G
                  ) : new FormData(y), _ = {
                    pending: !0,
                    data: W,
                    method: y.method,
                    action: M
                  }, Object.freeze(_), uu(
                    o,
                    _,
                    M,
                    W
                  ));
              },
              currentTarget: y
            }
          ]
        });
      }
    }
    function tt(e, i, o) {
      e.currentTarget = o;
      try {
        i(e);
      } catch (u) {
        wm(u);
      }
      e.currentTarget = null;
    }
    function hy(e, i) {
      i = (i & 4) !== 0;
      for (var o = 0; o < e.length; o++) {
        var u = e[o];
        g: {
          var y = void 0, M = u.event;
          if (u = u.listeners, i)
            for (var G = u.length - 1; 0 <= G; G--) {
              var P = u[G], W = P.instance, _ = P.currentTarget;
              if (P = P.listener, W !== y && M.isPropagationStopped())
                break g;
              W !== null ? gI(
                W,
                tt,
                M,
                P,
                _
              ) : tt(M, P, _), y = W;
            }
          else
            for (G = 0; G < u.length; G++) {
              if (P = u[G], W = P.instance, _ = P.currentTarget, P = P.listener, W !== y && M.isPropagationStopped())
                break g;
              W !== null ? gI(
                W,
                tt,
                M,
                P,
                _
              ) : tt(M, P, _), y = W;
            }
        }
      }
    }
    function PI(e, i) {
      Wm.has(e) || console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        e
      );
      var o = i[ld];
      o === void 0 && (o = i[ld] = /* @__PURE__ */ new Set());
      var u = e + "__bubble";
      o.has(u) || (de(i, e, 2, !1), o.add(u));
    }
    function yy(e, i, o) {
      Wm.has(e) && !i && console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        e
      );
      var u = 0;
      i && (u |= 4), de(
        o,
        e,
        u,
        i
      );
    }
    function Ml(e) {
      if (!e[rB]) {
        e[rB] = !0, uo.forEach(function(o) {
          o !== "selectionchange" && (Wm.has(o) || yy(o, !1, e), yy(o, !0, e));
        });
        var i = e.nodeType === 9 ? e : e.ownerDocument;
        i === null || i[rB] || (i[rB] = !0, yy("selectionchange", !1, i));
      }
    }
    function de(e, i, o, u) {
      switch (is(i)) {
        case ke:
          var y = gd;
          break;
        case ui:
          y = Ha;
          break;
        default:
          y = Sl;
      }
      o = y.bind(
        null,
        i,
        o,
        e
      ), y = void 0, !jg || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (y = !0), u ? y !== void 0 ? e.addEventListener(i, o, {
        capture: !0,
        passive: y
      }) : e.addEventListener(i, o, !0) : y !== void 0 ? e.addEventListener(i, o, {
        passive: y
      }) : e.addEventListener(
        i,
        o,
        !1
      );
    }
    function Ee(e, i, o, u, y) {
      var M = u;
      if ((i & 1) === 0 && (i & 2) === 0 && u !== null)
        g: for (; ; ) {
          if (u === null) return;
          var G = u.tag;
          if (G === 3 || G === 4) {
            var P = u.stateNode.containerInfo;
            if (P === y) break;
            if (G === 4)
              for (G = u.return; G !== null; ) {
                var W = G.tag;
                if ((W === 3 || W === 4) && G.stateNode.containerInfo === y)
                  return;
                G = G.return;
              }
            for (; P !== null; ) {
              if (G = JA(P), G === null) return;
              if (W = G.tag, W === 5 || W === 6 || W === 26 || W === 27) {
                u = M = G;
                continue g;
              }
              P = P.parentNode;
            }
          }
          u = u.return;
        }
      Uo(function() {
        var _ = M, wg = dt(o), Gg = [];
        g: {
          var yg = _K.get(e);
          if (yg !== void 0) {
            var Tg = zI, qg = e;
            switch (e) {
              case "keypress":
                if (Es(o) === 0) break g;
              case "keydown":
              case "keyup":
                Tg = pO;
                break;
              case "focusin":
                qg = "focus", Tg = yi;
                break;
              case "focusout":
                qg = "blur", Tg = yi;
                break;
              case "beforeblur":
              case "afterblur":
                Tg = yi;
                break;
              case "click":
                if (o.button === 2) break g;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                Tg = CI;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                Tg = rC;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                Tg = SO;
                break;
              case kK:
              case WK:
              case VK:
                Tg = uO;
                break;
              case xK:
                Tg = KO;
                break;
              case "scroll":
              case "scrollend":
                Tg = Ag;
                break;
              case "wheel":
                Tg = YO;
                break;
              case "copy":
              case "cut":
              case "paste":
                Tg = fO;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                Tg = ZK;
                break;
              case "toggle":
              case "beforetoggle":
                Tg = ZO;
            }
            var aI = (i & 4) !== 0, wA = !aI && (e === "scroll" || e === "scrollend"), NI = aI ? yg !== null ? yg + "Capture" : null : yg;
            aI = [];
            for (var $ = _, gg; $ !== null; ) {
              var Ig = $;
              if (gg = Ig.stateNode, Ig = Ig.tag, Ig !== 5 && Ig !== 26 && Ig !== 27 || gg === null || NI === null || (Ig = Je($, NI), Ig != null && aI.push(
                Ga(
                  $,
                  Ig,
                  gg
                )
              )), wA) break;
              $ = $.return;
            }
            0 < aI.length && (yg = new Tg(
              yg,
              qg,
              null,
              o,
              wg
            ), Gg.push({
              event: yg,
              listeners: aI
            }));
          }
        }
        if ((i & 7) === 0) {
          g: {
            if (yg = e === "mouseover" || e === "pointerover", Tg = e === "mouseout" || e === "pointerout", yg && o !== m && (qg = o.relatedTarget || o.fromElement) && (JA(qg) || qg[rs]))
              break g;
            if ((Tg || yg) && (yg = wg.window === wg ? wg : (yg = wg.ownerDocument) ? yg.defaultView || yg.parentWindow : window, Tg ? (qg = o.relatedTarget || o.toElement, Tg = _, qg = qg ? JA(qg) : null, qg !== null && (wA = H(qg), aI = qg.tag, qg !== wA || aI !== 5 && aI !== 27 && aI !== 6) && (qg = null)) : (Tg = null, qg = _), Tg !== qg)) {
              if (aI = CI, Ig = "onMouseLeave", NI = "onMouseEnter", $ = "mouse", (e === "pointerout" || e === "pointerover") && (aI = ZK, Ig = "onPointerLeave", NI = "onPointerEnter", $ = "pointer"), wA = Tg == null ? yg : Ie(Tg), gg = qg == null ? yg : Ie(qg), yg = new aI(
                Ig,
                $ + "leave",
                Tg,
                o,
                wg
              ), yg.target = wA, yg.relatedTarget = gg, Ig = null, JA(wg) === _ && (aI = new aI(
                NI,
                $ + "enter",
                qg,
                o,
                wg
              ), aI.target = gg, aI.relatedTarget = wA, Ig = aI), wA = Ig, Tg && qg)
                I: {
                  for (aI = Tg, NI = qg, $ = 0, gg = aI; gg; gg = no(gg))
                    $++;
                  for (gg = 0, Ig = NI; Ig; Ig = no(Ig))
                    gg++;
                  for (; 0 < $ - gg; )
                    aI = no(aI), $--;
                  for (; 0 < gg - $; )
                    NI = no(NI), gg--;
                  for (; $--; ) {
                    if (aI === NI || NI !== null && aI === NI.alternate)
                      break I;
                    aI = no(aI), NI = no(NI);
                  }
                  aI = null;
                }
              else aI = null;
              Tg !== null && An(
                Gg,
                yg,
                Tg,
                aI,
                !1
              ), qg !== null && wA !== null && An(
                Gg,
                wA,
                qg,
                aI,
                !0
              );
            }
          }
          g: {
            if (yg = _ ? Ie(_) : window, Tg = yg.nodeName && yg.nodeName.toLowerCase(), Tg === "select" || Tg === "input" && yg.type === "file")
              var Pg = WM;
            else if (_c(yg))
              if (OK)
                Pg = E0;
              else {
                Pg = v0;
                var Fg = Ah;
              }
            else
              Tg = yg.nodeName, !Tg || Tg.toLowerCase() !== "input" || yg.type !== "checkbox" && yg.type !== "radio" ? _ && vs(_.elementType) && (Pg = WM) : Pg = H0;
            if (Pg && (Pg = Pg(e, _))) {
              Fo(
                Gg,
                Pg,
                o,
                wg
              );
              break g;
            }
            Fg && Fg(e, yg, _), e === "focusout" && _ && yg.type === "number" && _.memoizedProps.value != null && Ec(yg, "number", yg.value);
          }
          switch (Fg = _ ? Ie(_) : window, e) {
            case "focusin":
              (_c(Fg) || Fg.contentEditable === "true") && (pd = Fg, gm = _, eD = null);
              break;
            case "focusout":
              eD = gm = pd = null;
              break;
            case "mousedown":
              Im = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Im = !1, Fc(
                Gg,
                o,
                wg
              );
              break;
            case "selectionchange":
              if (EO) break;
            case "keydown":
            case "keyup":
              Fc(
                Gg,
                o,
                wg
              );
          }
          var MI;
          if ($0)
            g: {
              switch (e) {
                case "compositionstart":
                  var $g = "onCompositionStart";
                  break g;
                case "compositionend":
                  $g = "onCompositionEnd";
                  break g;
                case "compositionupdate":
                  $g = "onCompositionUpdate";
                  break g;
              }
              $g = void 0;
            }
          else
            Bd ? vn(e, o) && ($g = "onCompositionEnd") : e === "keydown" && o.keyCode === jK && ($g = "onCompositionStart");
          $g && (vK && o.locale !== "ko" && (Bd || $g !== "onCompositionStart" ? $g === "onCompositionEnd" && Bd && (MI = xc()) : (hg = wg, pg = "value" in hg ? hg.value : hg.textContent, Bd = !0)), Fg = RC(
            _,
            $g
          ), 0 < Fg.length && ($g = new PK(
            $g,
            e,
            null,
            o,
            wg
          ), Gg.push({
            event: $g,
            listeners: Fg
          }), MI ? $g.data = MI : (MI = Hr(o), MI !== null && ($g.data = MI)))), (MI = vO ? Er(e, o) : j0(e, o)) && ($g = RC(
            _,
            "onBeforeInput"
          ), 0 < $g.length && (Fg = new yO(
            "onBeforeInput",
            "beforeinput",
            null,
            o,
            wg
          ), Gg.push({
            event: Fg,
            listeners: $g
          }), Fg.data = MI)), ue(
            Gg,
            e,
            _,
            o,
            wg
          );
        }
        hy(Gg, i);
      });
    }
    function Ga(e, i, o) {
      return {
        instance: e,
        listener: i,
        currentTarget: o
      };
    }
    function RC(e, i) {
      for (var o = i + "Capture", u = []; e !== null; ) {
        var y = e, M = y.stateNode;
        if (y = y.tag, y !== 5 && y !== 26 && y !== 27 || M === null || (y = Je(e, o), y != null && u.unshift(
          Ga(e, y, M)
        ), y = Je(e, i), y != null && u.push(
          Ga(e, y, M)
        )), e.tag === 3) return u;
        e = e.return;
      }
      return [];
    }
    function no(e) {
      if (e === null) return null;
      do
        e = e.return;
      while (e && e.tag !== 5 && e.tag !== 27);
      return e || null;
    }
    function An(e, i, o, u, y) {
      for (var M = i._reactName, G = []; o !== null && o !== u; ) {
        var P = o, W = P.alternate, _ = P.stateNode;
        if (P = P.tag, W !== null && W === u) break;
        P !== 5 && P !== 26 && P !== 27 || _ === null || (W = _, y ? (_ = Je(o, M), _ != null && G.unshift(
          Ga(o, _, W)
        )) : y || (_ = Je(o, M), _ != null && G.push(
          Ga(o, _, W)
        ))), o = o.return;
      }
      G.length !== 0 && e.push({ event: i, listeners: G });
    }
    function Cn(e, i) {
      OM(e, i), e !== "input" && e !== "textarea" && e !== "select" || i == null || i.value !== null || Vw || (Vw = !0, e === "select" && i.multiple ? console.error(
        "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
        e
      ) : console.error(
        "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
        e
      ));
      var o = {
        registrationNameDependencies: Ot,
        possibleRegistrationNames: cd
      };
      vs(e) || typeof i.is == "string" || NM(e, i, o), i.contentEditable && !i.suppressContentEditableWarning && i.children != null && console.error(
        "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
      );
    }
    function DA(e, i, o, u) {
      i !== o && (o = en(o), en(i) !== o && (u[e] = i));
    }
    function Dy(e, i, o) {
      i.forEach(function(u) {
        o[Ka(u)] = u === "style" ? Vu(e) : e.getAttribute(u);
      });
    }
    function it(e, i) {
      i === !1 ? console.error(
        "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
        e,
        e,
        e
      ) : console.error(
        "Expected `%s` listener to be a function, instead got a value of `%s` type.",
        e,
        typeof i
      );
    }
    function vt(e, i) {
      return e = e.namespaceURI === Dd || e.namespaceURI === fn ? e.ownerDocument.createElementNS(
        e.namespaceURI,
        e.tagName
      ) : e.ownerDocument.createElement(e.tagName), e.innerHTML = i, e.innerHTML;
    }
    function en(e) {
      return F(e) && (console.error(
        "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
        N(e)
      ), rg(e)), (typeof e == "string" ? e : "" + e).replace(nN, `
`).replace(sN, "");
    }
    function so(e, i) {
      return i = en(i), en(e) === i;
    }
    function qn() {
    }
    function xI(e, i, o, u, y, M) {
      switch (o) {
        case "children":
          typeof u == "string" ? (xo(u, i, !1), i === "body" || i === "textarea" && u === "" || Pr(e, u)) : (typeof u == "number" || typeof u == "bigint") && (xo("" + u, i, !1), i !== "body" && Pr(e, "" + u));
          break;
        case "className":
          cI(e, "class", u);
          break;
        case "tabIndex":
          cI(e, "tabindex", u);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          cI(e, o, u);
          break;
        case "style":
          Wc(e, u, M);
          break;
        case "data":
          if (i !== "object") {
            cI(e, "data", u);
            break;
          }
        case "src":
        case "href":
          if (u === "" && (i !== "a" || o !== "href")) {
            console.error(
              o === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              o,
              o
            ), e.removeAttribute(o);
            break;
          }
          if (u == null || typeof u == "function" || typeof u == "symbol" || typeof u == "boolean") {
            e.removeAttribute(o);
            break;
          }
          Cg(u, o), u = ki("" + u), e.setAttribute(o, u);
          break;
        case "action":
        case "formAction":
          if (u != null && (i === "form" ? o === "formAction" ? console.error(
            "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
          ) : typeof u == "function" && (y.encType == null && y.method == null || uB || (uB = !0, console.error(
            "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
          )), y.target == null || cB || (cB = !0, console.error(
            "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
          ))) : i === "input" || i === "button" ? o === "action" ? console.error(
            "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
          ) : i !== "input" || y.type === "submit" || y.type === "image" || lB ? i !== "button" || y.type == null || y.type === "submit" || lB ? typeof u == "function" && (y.name == null || tY || (tY = !0, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          )), y.formEncType == null && y.formMethod == null || uB || (uB = !0, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          )), y.formTarget == null || cB || (cB = !0, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ))) : (lB = !0, console.error(
            'A button can only specify a formAction along with type="submit" or no type.'
          )) : (lB = !0, console.error(
            'An input can only specify a formAction along with type="submit" or type="image".'
          )) : console.error(
            o === "action" ? "You can only pass the action prop to <form>." : "You can only pass the formAction prop to <input> or <button>."
          )), typeof u == "function") {
            e.setAttribute(
              o,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof M == "function" && (o === "formAction" ? (i !== "input" && xI(e, i, "name", y.name, y, null), xI(
              e,
              i,
              "formEncType",
              y.formEncType,
              y,
              null
            ), xI(
              e,
              i,
              "formMethod",
              y.formMethod,
              y,
              null
            ), xI(
              e,
              i,
              "formTarget",
              y.formTarget,
              y,
              null
            )) : (xI(
              e,
              i,
              "encType",
              y.encType,
              y,
              null
            ), xI(e, i, "method", y.method, y, null), xI(
              e,
              i,
              "target",
              y.target,
              y,
              null
            )));
          if (u == null || typeof u == "symbol" || typeof u == "boolean") {
            e.removeAttribute(o);
            break;
          }
          Cg(u, o), u = ki("" + u), e.setAttribute(o, u);
          break;
        case "onClick":
          u != null && (typeof u != "function" && it(o, u), e.onclick = qn);
          break;
        case "onScroll":
          u != null && (typeof u != "function" && it(o, u), PI("scroll", e));
          break;
        case "onScrollEnd":
          u != null && (typeof u != "function" && it(o, u), PI("scrollend", e));
          break;
        case "dangerouslySetInnerHTML":
          if (u != null) {
            if (typeof u != "object" || !("__html" in u))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (o = u.__html, o != null) {
              if (y.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              e.innerHTML = o;
            }
          }
          break;
        case "multiple":
          e.multiple = u && typeof u != "function" && typeof u != "symbol";
          break;
        case "muted":
          e.muted = u && typeof u != "function" && typeof u != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (u == null || typeof u == "function" || typeof u == "boolean" || typeof u == "symbol") {
            e.removeAttribute("xlink:href");
            break;
          }
          Cg(u, o), o = ki("" + u), e.setAttributeNS(ec, "xlink:href", o);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          u != null && typeof u != "function" && typeof u != "symbol" ? (Cg(u, o), e.setAttribute(o, "" + u)) : e.removeAttribute(o);
          break;
        case "inert":
          u !== "" || dB[o] || (dB[o] = !0, console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            o
          ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          u && typeof u != "function" && typeof u != "symbol" ? e.setAttribute(o, "") : e.removeAttribute(o);
          break;
        case "capture":
        case "download":
          u === !0 ? e.setAttribute(o, "") : u !== !1 && u != null && typeof u != "function" && typeof u != "symbol" ? (Cg(u, o), e.setAttribute(o, u)) : e.removeAttribute(o);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          u != null && typeof u != "function" && typeof u != "symbol" && !isNaN(u) && 1 <= u ? (Cg(u, o), e.setAttribute(o, u)) : e.removeAttribute(o);
          break;
        case "rowSpan":
        case "start":
          u == null || typeof u == "function" || typeof u == "symbol" || isNaN(u) ? e.removeAttribute(o) : (Cg(u, o), e.setAttribute(o, u));
          break;
        case "popover":
          PI("beforetoggle", e), PI("toggle", e), TI(e, "popover", u);
          break;
        case "xlinkActuate":
          VA(
            e,
            ec,
            "xlink:actuate",
            u
          );
          break;
        case "xlinkArcrole":
          VA(
            e,
            ec,
            "xlink:arcrole",
            u
          );
          break;
        case "xlinkRole":
          VA(
            e,
            ec,
            "xlink:role",
            u
          );
          break;
        case "xlinkShow":
          VA(
            e,
            ec,
            "xlink:show",
            u
          );
          break;
        case "xlinkTitle":
          VA(
            e,
            ec,
            "xlink:title",
            u
          );
          break;
        case "xlinkType":
          VA(
            e,
            ec,
            "xlink:type",
            u
          );
          break;
        case "xmlBase":
          VA(
            e,
            Vm,
            "xml:base",
            u
          );
          break;
        case "xmlLang":
          VA(
            e,
            Vm,
            "xml:lang",
            u
          );
          break;
        case "xmlSpace":
          VA(
            e,
            Vm,
            "xml:space",
            u
          );
          break;
        case "is":
          M != null && console.error(
            'Cannot update the "is" prop after it has been initialized.'
          ), TI(e, "is", u);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          iY || u == null || typeof u != "object" || (iY = !0, console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            u
          ));
        default:
          !(2 < o.length) || o[0] !== "o" && o[0] !== "O" || o[1] !== "n" && o[1] !== "N" ? (o = Hs(o), TI(e, o, u)) : Ot.hasOwnProperty(o) && u != null && typeof u != "function" && it(o, u);
      }
    }
    function $n(e, i, o, u, y, M) {
      switch (o) {
        case "style":
          Wc(e, u, M);
          break;
        case "dangerouslySetInnerHTML":
          if (u != null) {
            if (typeof u != "object" || !("__html" in u))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (o = u.__html, o != null) {
              if (y.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              e.innerHTML = o;
            }
          }
          break;
        case "children":
          typeof u == "string" ? Pr(e, u) : (typeof u == "number" || typeof u == "bigint") && Pr(e, "" + u);
          break;
        case "onScroll":
          u != null && (typeof u != "function" && it(o, u), PI("scroll", e));
          break;
        case "onScrollEnd":
          u != null && (typeof u != "function" && it(o, u), PI("scrollend", e));
          break;
        case "onClick":
          u != null && (typeof u != "function" && it(o, u), e.onclick = qn);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (Ot.hasOwnProperty(o))
            u != null && typeof u != "function" && it(o, u);
          else
            g: {
              if (o[0] === "o" && o[1] === "n" && (y = o.endsWith("Capture"), i = o.slice(2, y ? o.length - 7 : void 0), M = e[Me] || null, M = M != null ? M[o] : null, typeof M == "function" && e.removeEventListener(i, M, y), typeof u == "function")) {
                typeof M != "function" && M !== null && (o in e ? e[o] = null : e.hasAttribute(o) && e.removeAttribute(o)), e.addEventListener(i, u, y);
                break g;
              }
              o in e ? e[o] = u : u === !0 ? e.setAttribute(o, "") : TI(e, o, u);
            }
      }
    }
    function sC(e, i, o) {
      switch (Cn(i, o), i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          PI("error", e), PI("load", e);
          var u = !1, y = !1, M;
          for (M in o)
            if (o.hasOwnProperty(M)) {
              var G = o[M];
              if (G != null)
                switch (M) {
                  case "src":
                    u = !0;
                    break;
                  case "srcSet":
                    y = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    xI(e, i, M, G, o, null);
                }
            }
          y && xI(e, i, "srcSet", o.srcSet, o, null), u && xI(e, i, "src", o.src, o, null);
          return;
        case "input":
          Jg("input", o), PI("invalid", e);
          var P = M = G = y = null, W = null, _ = null;
          for (u in o)
            if (o.hasOwnProperty(u)) {
              var wg = o[u];
              if (wg != null)
                switch (u) {
                  case "name":
                    y = wg;
                    break;
                  case "type":
                    G = wg;
                    break;
                  case "checked":
                    W = wg;
                    break;
                  case "defaultChecked":
                    _ = wg;
                    break;
                  case "value":
                    M = wg;
                    break;
                  case "defaultValue":
                    P = wg;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (wg != null)
                      throw Error(
                        i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    xI(e, i, u, wg, o, null);
                }
            }
          Ps(e, o), Ff(
            e,
            M,
            P,
            W,
            _,
            G,
            y,
            !1
          ), OA(e);
          return;
        case "select":
          Jg("select", o), PI("invalid", e), u = G = M = null;
          for (y in o)
            if (o.hasOwnProperty(y) && (P = o[y], P != null))
              switch (y) {
                case "value":
                  M = P;
                  break;
                case "defaultValue":
                  G = P;
                  break;
                case "multiple":
                  u = P;
                default:
                  xI(
                    e,
                    i,
                    y,
                    P,
                    o,
                    null
                  );
              }
          Ci(e, o), i = M, o = G, e.multiple = !!u, i != null ? Oi(e, !!u, i, !1) : o != null && Oi(e, !!u, o, !0);
          return;
        case "textarea":
          Jg("textarea", o), PI("invalid", e), M = y = u = null;
          for (G in o)
            if (o.hasOwnProperty(G) && (P = o[G], P != null))
              switch (G) {
                case "value":
                  u = P;
                  break;
                case "defaultValue":
                  y = P;
                  break;
                case "children":
                  M = P;
                  break;
                case "dangerouslySetInnerHTML":
                  if (P != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  xI(
                    e,
                    i,
                    G,
                    P,
                    o,
                    null
                  );
              }
          Rc(e, o), Zs(e, u, y, M), OA(e);
          return;
        case "option":
          RM(e, o);
          for (W in o)
            if (o.hasOwnProperty(W) && (u = o[W], u != null))
              switch (W) {
                case "selected":
                  e.selected = u && typeof u != "function" && typeof u != "symbol";
                  break;
                default:
                  xI(e, i, W, u, o, null);
              }
          return;
        case "dialog":
          PI("beforetoggle", e), PI("toggle", e), PI("cancel", e), PI("close", e);
          break;
        case "iframe":
        case "object":
          PI("load", e);
          break;
        case "video":
        case "audio":
          for (u = 0; u < KD.length; u++)
            PI(KD[u], e);
          break;
        case "image":
          PI("error", e), PI("load", e);
          break;
        case "details":
          PI("toggle", e);
          break;
        case "embed":
        case "source":
        case "link":
          PI("error", e), PI("load", e);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (_ in o)
            if (o.hasOwnProperty(_) && (u = o[_], u != null))
              switch (_) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  xI(e, i, _, u, o, null);
              }
          return;
        default:
          if (vs(i)) {
            for (wg in o)
              o.hasOwnProperty(wg) && (u = o[wg], u !== void 0 && $n(
                e,
                i,
                wg,
                u,
                o,
                void 0
              ));
            return;
          }
      }
      for (P in o)
        o.hasOwnProperty(P) && (u = o[P], u != null && xI(e, i, P, u, o, null));
    }
    function fw(e, i, o, u) {
      switch (Cn(i, u), i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var y = null, M = null, G = null, P = null, W = null, _ = null, wg = null;
          for (Tg in o) {
            var Gg = o[Tg];
            if (o.hasOwnProperty(Tg) && Gg != null)
              switch (Tg) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  W = Gg;
                default:
                  u.hasOwnProperty(Tg) || xI(
                    e,
                    i,
                    Tg,
                    null,
                    u,
                    Gg
                  );
              }
          }
          for (var yg in u) {
            var Tg = u[yg];
            if (Gg = o[yg], u.hasOwnProperty(yg) && (Tg != null || Gg != null))
              switch (yg) {
                case "type":
                  M = Tg;
                  break;
                case "name":
                  y = Tg;
                  break;
                case "checked":
                  _ = Tg;
                  break;
                case "defaultChecked":
                  wg = Tg;
                  break;
                case "value":
                  G = Tg;
                  break;
                case "defaultValue":
                  P = Tg;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Tg != null)
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  Tg !== Gg && xI(
                    e,
                    i,
                    yg,
                    Tg,
                    u,
                    Gg
                  );
              }
          }
          i = o.type === "checkbox" || o.type === "radio" ? o.checked != null : o.value != null, u = u.type === "checkbox" || u.type === "radio" ? u.checked != null : u.value != null, i || !u || eY || (console.error(
            "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), eY = !0), !i || u || CY || (console.error(
            "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), CY = !0), Uf(
            e,
            G,
            P,
            W,
            _,
            wg,
            M,
            y
          );
          return;
        case "select":
          Tg = G = P = yg = null;
          for (M in o)
            if (W = o[M], o.hasOwnProperty(M) && W != null)
              switch (M) {
                case "value":
                  break;
                case "multiple":
                  Tg = W;
                default:
                  u.hasOwnProperty(M) || xI(
                    e,
                    i,
                    M,
                    null,
                    u,
                    W
                  );
              }
          for (y in u)
            if (M = u[y], W = o[y], u.hasOwnProperty(y) && (M != null || W != null))
              switch (y) {
                case "value":
                  yg = M;
                  break;
                case "defaultValue":
                  P = M;
                  break;
                case "multiple":
                  G = M;
                default:
                  M !== W && xI(
                    e,
                    i,
                    y,
                    M,
                    u,
                    W
                  );
              }
          u = P, i = G, o = Tg, yg != null ? Oi(e, !!i, yg, !1) : !!o != !!i && (u != null ? Oi(e, !!i, u, !0) : Oi(e, !!i, i ? [] : "", !1));
          return;
        case "textarea":
          Tg = yg = null;
          for (P in o)
            if (y = o[P], o.hasOwnProperty(P) && y != null && !u.hasOwnProperty(P))
              switch (P) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  xI(e, i, P, null, u, y);
              }
          for (G in u)
            if (y = u[G], M = o[G], u.hasOwnProperty(G) && (y != null || M != null))
              switch (G) {
                case "value":
                  yg = y;
                  break;
                case "defaultValue":
                  Tg = y;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (y != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  y !== M && xI(e, i, G, y, u, M);
              }
          Xf(e, yg, Tg);
          return;
        case "option":
          for (var qg in o)
            if (yg = o[qg], o.hasOwnProperty(qg) && yg != null && !u.hasOwnProperty(qg))
              switch (qg) {
                case "selected":
                  e.selected = !1;
                  break;
                default:
                  xI(
                    e,
                    i,
                    qg,
                    null,
                    u,
                    yg
                  );
              }
          for (W in u)
            if (yg = u[W], Tg = o[W], u.hasOwnProperty(W) && yg !== Tg && (yg != null || Tg != null))
              switch (W) {
                case "selected":
                  e.selected = yg && typeof yg != "function" && typeof yg != "symbol";
                  break;
                default:
                  xI(
                    e,
                    i,
                    W,
                    yg,
                    u,
                    Tg
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var aI in o)
            yg = o[aI], o.hasOwnProperty(aI) && yg != null && !u.hasOwnProperty(aI) && xI(
              e,
              i,
              aI,
              null,
              u,
              yg
            );
          for (_ in u)
            if (yg = u[_], Tg = o[_], u.hasOwnProperty(_) && yg !== Tg && (yg != null || Tg != null))
              switch (_) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (yg != null)
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  xI(
                    e,
                    i,
                    _,
                    yg,
                    u,
                    Tg
                  );
              }
          return;
        default:
          if (vs(i)) {
            for (var wA in o)
              yg = o[wA], o.hasOwnProperty(wA) && yg !== void 0 && !u.hasOwnProperty(wA) && $n(
                e,
                i,
                wA,
                void 0,
                u,
                yg
              );
            for (wg in u)
              yg = u[wg], Tg = o[wg], !u.hasOwnProperty(wg) || yg === Tg || yg === void 0 && Tg === void 0 || $n(
                e,
                i,
                wg,
                yg,
                u,
                Tg
              );
            return;
          }
      }
      for (var NI in o)
        yg = o[NI], o.hasOwnProperty(NI) && yg != null && !u.hasOwnProperty(NI) && xI(e, i, NI, null, u, yg);
      for (Gg in u)
        yg = u[Gg], Tg = o[Gg], !u.hasOwnProperty(Gg) || yg === Tg || yg == null && Tg == null || xI(e, i, Gg, yg, u, Tg);
    }
    function Ka(e) {
      switch (e) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return e;
      }
    }
    function Vu(e) {
      var i = {};
      e = e.style;
      for (var o = 0; o < e.length; o++) {
        var u = e[o];
        i[u] = e.getPropertyValue(u);
      }
      return i;
    }
    function wl(e, i, o) {
      if (i != null && typeof i != "object")
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var u, y = u = "", M;
        for (M in i)
          if (i.hasOwnProperty(M)) {
            var G = i[M];
            G != null && typeof G != "boolean" && G !== "" && (M.indexOf("--") === 0 ? (Sg(G, M), u += y + M + ":" + ("" + G).trim()) : typeof G != "number" || G === 0 || gD.has(M) ? (Sg(G, M), u += y + M.replace(dn, "-$1").toLowerCase().replace(_a, "-ms-") + ":" + ("" + G).trim()) : u += y + M.replace(dn, "-$1").toLowerCase().replace(_a, "-ms-") + ":" + G + "px", y = ";");
          }
        u = u || null, i = e.getAttribute("style"), i !== u && (u = en(u), en(i) !== u && (o.style = Vu(e)));
      }
    }
    function Re(e, i, o, u, y, M) {
      if (y.delete(o), e = e.getAttribute(o), e === null)
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (u != null)
        switch (typeof u) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (Cg(u, i), e === "" + u)
              return;
        }
      DA(i, e, u, M);
    }
    function hw(e, i, o, u, y, M) {
      if (y.delete(o), e = e.getAttribute(o), e === null) {
        switch (typeof u) {
          case "function":
          case "symbol":
            return;
        }
        if (!u) return;
      } else
        switch (typeof u) {
          case "function":
          case "symbol":
            break;
          default:
            if (u) return;
        }
      DA(i, e, u, M);
    }
    function My(e, i, o, u, y, M) {
      if (y.delete(o), e = e.getAttribute(o), e === null)
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (u != null)
        switch (typeof u) {
          case "function":
          case "symbol":
            break;
          default:
            if (Cg(u, o), e === "" + u)
              return;
        }
      DA(i, e, u, M);
    }
    function LI(e, i, o, u, y, M) {
      if (y.delete(o), e = e.getAttribute(o), e === null)
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(u)) return;
        }
      else if (u != null)
        switch (typeof u) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(u) && (Cg(u, i), e === "" + u))
              return;
        }
      DA(i, e, u, M);
    }
    function CA(e, i, o, u, y, M) {
      if (y.delete(o), e = e.getAttribute(o), e === null)
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (u != null)
        switch (typeof u) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (Cg(u, i), o = ki("" + u), e === o)
              return;
        }
      DA(i, e, u, M);
    }
    function ZI(e, i, o, u) {
      for (var y = {}, M = /* @__PURE__ */ new Set(), G = e.attributes, P = 0; P < G.length; P++)
        switch (G[P].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            M.add(G[P].name);
        }
      if (vs(i)) {
        for (var W in o)
          if (o.hasOwnProperty(W)) {
            var _ = o[W];
            if (_ != null) {
              if (Ot.hasOwnProperty(W))
                typeof _ != "function" && it(W, _);
              else if (o.suppressHydrationWarning !== !0)
                switch (W) {
                  case "children":
                    typeof _ != "string" && typeof _ != "number" || DA(
                      "children",
                      e.textContent,
                      _,
                      y
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    G = e.innerHTML, _ = _ ? _.__html : void 0, _ != null && (_ = vt(e, _), DA(
                      W,
                      G,
                      _,
                      y
                    ));
                    continue;
                  case "style":
                    M.delete(W), wl(e, _, y);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    M.delete(W.toLowerCase()), console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      W
                    );
                    continue;
                  case "className":
                    M.delete("class"), G = lI(
                      e,
                      "class",
                      _
                    ), DA(
                      "className",
                      G,
                      _,
                      y
                    );
                    continue;
                  default:
                    u.context === bo && i !== "svg" && i !== "math" ? M.delete(W.toLowerCase()) : M.delete(W), G = lI(
                      e,
                      W,
                      _
                    ), DA(
                      W,
                      G,
                      _,
                      y
                    );
                }
            }
          }
      } else
        for (_ in o)
          if (o.hasOwnProperty(_) && (W = o[_], W != null)) {
            if (Ot.hasOwnProperty(_))
              typeof W != "function" && it(_, W);
            else if (o.suppressHydrationWarning !== !0)
              switch (_) {
                case "children":
                  typeof W != "string" && typeof W != "number" || DA(
                    "children",
                    e.textContent,
                    W,
                    y
                  );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  G = e.innerHTML, W = W ? W.__html : void 0, W != null && (W = vt(e, W), G !== W && (y[_] = { __html: G }));
                  continue;
                case "className":
                  Re(
                    e,
                    _,
                    "class",
                    W,
                    M,
                    y
                  );
                  continue;
                case "tabIndex":
                  Re(
                    e,
                    _,
                    "tabindex",
                    W,
                    M,
                    y
                  );
                  continue;
                case "style":
                  M.delete(_), wl(e, W, y);
                  continue;
                case "multiple":
                  M.delete(_), DA(
                    _,
                    e.multiple,
                    W,
                    y
                  );
                  continue;
                case "muted":
                  M.delete(_), DA(
                    _,
                    e.muted,
                    W,
                    y
                  );
                  continue;
                case "autoFocus":
                  M.delete("autofocus"), DA(
                    _,
                    e.autofocus,
                    W,
                    y
                  );
                  continue;
                case "data":
                  if (i !== "object") {
                    M.delete(_), G = e.getAttribute("data"), DA(
                      _,
                      G,
                      W,
                      y
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (!(W !== "" || i === "a" && _ === "href" || i === "object" && _ === "data")) {
                    console.error(
                      _ === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                      _,
                      _
                    );
                    continue;
                  }
                  CA(
                    e,
                    _,
                    _,
                    W,
                    M,
                    y
                  );
                  continue;
                case "action":
                case "formAction":
                  if (G = e.getAttribute(_), typeof W == "function") {
                    M.delete(_.toLowerCase()), _ === "formAction" ? (M.delete("name"), M.delete("formenctype"), M.delete("formmethod"), M.delete("formtarget")) : (M.delete("enctype"), M.delete("method"), M.delete("target"));
                    continue;
                  } else if (G === oN) {
                    M.delete(_.toLowerCase()), DA(
                      _,
                      "function",
                      W,
                      y
                    );
                    continue;
                  }
                  CA(
                    e,
                    _,
                    _.toLowerCase(),
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkHref":
                  CA(
                    e,
                    _,
                    "xlink:href",
                    W,
                    M,
                    y
                  );
                  continue;
                case "contentEditable":
                  My(
                    e,
                    _,
                    "contenteditable",
                    W,
                    M,
                    y
                  );
                  continue;
                case "spellCheck":
                  My(
                    e,
                    _,
                    "spellcheck",
                    W,
                    M,
                    y
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  My(
                    e,
                    _,
                    _,
                    W,
                    M,
                    y
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  hw(
                    e,
                    _,
                    _.toLowerCase(),
                    W,
                    M,
                    y
                  );
                  continue;
                case "capture":
                case "download":
                  g: {
                    P = e;
                    var wg = G = _, Gg = y;
                    if (M.delete(wg), P = P.getAttribute(wg), P === null)
                      switch (typeof W) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break g;
                        default:
                          if (W === !1) break g;
                      }
                    else if (W != null)
                      switch (typeof W) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (W === !0 && P === "") break g;
                          break;
                        default:
                          if (Cg(W, G), P === "" + W)
                            break g;
                      }
                    DA(
                      G,
                      P,
                      W,
                      Gg
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  g: {
                    if (P = e, wg = G = _, Gg = y, M.delete(wg), P = P.getAttribute(wg), P === null)
                      switch (typeof W) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break g;
                        default:
                          if (isNaN(W) || 1 > W) break g;
                      }
                    else if (W != null)
                      switch (typeof W) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(W) || 1 > W) && (Cg(W, G), P === "" + W))
                            break g;
                      }
                    DA(
                      G,
                      P,
                      W,
                      Gg
                    );
                  }
                  continue;
                case "rowSpan":
                  LI(
                    e,
                    _,
                    "rowspan",
                    W,
                    M,
                    y
                  );
                  continue;
                case "start":
                  LI(
                    e,
                    _,
                    _,
                    W,
                    M,
                    y
                  );
                  continue;
                case "xHeight":
                  Re(
                    e,
                    _,
                    "x-height",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkActuate":
                  Re(
                    e,
                    _,
                    "xlink:actuate",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkArcrole":
                  Re(
                    e,
                    _,
                    "xlink:arcrole",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkRole":
                  Re(
                    e,
                    _,
                    "xlink:role",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkShow":
                  Re(
                    e,
                    _,
                    "xlink:show",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkTitle":
                  Re(
                    e,
                    _,
                    "xlink:title",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xlinkType":
                  Re(
                    e,
                    _,
                    "xlink:type",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xmlBase":
                  Re(
                    e,
                    _,
                    "xml:base",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xmlLang":
                  Re(
                    e,
                    _,
                    "xml:lang",
                    W,
                    M,
                    y
                  );
                  continue;
                case "xmlSpace":
                  Re(
                    e,
                    _,
                    "xml:space",
                    W,
                    M,
                    y
                  );
                  continue;
                case "inert":
                  W !== "" || dB[_] || (dB[_] = !0, console.error(
                    "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                    _
                  )), hw(
                    e,
                    _,
                    _,
                    W,
                    M,
                    y
                  );
                  continue;
                default:
                  if (!(2 < _.length) || _[0] !== "o" && _[0] !== "O" || _[1] !== "n" && _[1] !== "N") {
                    P = Hs(_), G = !1, u.context === bo && i !== "svg" && i !== "math" ? M.delete(P.toLowerCase()) : (wg = _.toLowerCase(), wg = xl.hasOwnProperty(
                      wg
                    ) && xl[wg] || null, wg !== null && wg !== _ && (G = !0, M.delete(wg)), M.delete(P));
                    g: if (wg = e, Gg = P, P = W, yI(Gg))
                      if (wg.hasAttribute(Gg))
                        wg = wg.getAttribute(
                          Gg
                        ), Cg(
                          P,
                          Gg
                        ), P = wg === "" + P ? P : wg;
                      else {
                        switch (typeof P) {
                          case "function":
                          case "symbol":
                            break g;
                          case "boolean":
                            if (wg = Gg.toLowerCase().slice(0, 5), wg !== "data-" && wg !== "aria-")
                              break g;
                        }
                        P = P === void 0 ? void 0 : null;
                      }
                    else P = void 0;
                    G || DA(
                      _,
                      P,
                      W,
                      y
                    );
                  }
              }
          }
      return 0 < M.size && o.suppressHydrationWarning !== !0 && Dy(e, M, y), Object.keys(y).length === 0 ? null : y;
    }
    function WI(e, i) {
      switch (e.length) {
        case 0:
          return "";
        case 1:
          return e[0];
        case 2:
          return e[0] + " " + i + " " + e[1];
        default:
          return e.slice(0, -1).join(", ") + ", " + i + " " + e[e.length - 1];
      }
    }
    function _I(e) {
      return e.nodeType === 9 ? e : e.ownerDocument;
    }
    function fe(e) {
      switch (e) {
        case fn:
          return zd;
        case Dd:
          return yB;
        default:
          return bo;
      }
    }
    function tn(e, i) {
      if (e === bo)
        switch (i) {
          case "svg":
            return zd;
          case "math":
            return yB;
          default:
            return bo;
        }
      return e === zd && i === "foreignObject" ? bo : e;
    }
    function gs(e, i) {
      return e === "textarea" || e === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
    }
    function wy() {
      var e = window.event;
      return e && e.type === "popstate" ? e === Fm ? !1 : (Fm = e, !0) : (Fm = null, !1);
    }
    function nn(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function vA(e, i, o) {
      switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          o.autoFocus && e.focus();
          break;
        case "img":
          o.src ? e.src = o.src : o.srcSet && (e.srcset = o.srcSet);
      }
    }
    function Is(e, i, o, u) {
      fw(e, i, o, u), e[Me] = u;
    }
    function As(e) {
      Pr(e, "");
    }
    function By(e, i, o) {
      e.nodeValue = o;
    }
    function $A(e) {
      return e === "head";
    }
    function Ta(e, i) {
      e.removeChild(i);
    }
    function Bl(e, i) {
      (e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e).removeChild(i);
    }
    function JC(e, i) {
      var o = i, u = 0, y = 0;
      do {
        var M = o.nextSibling;
        if (e.removeChild(o), M && M.nodeType === 8)
          if (o = M.data, o === hB) {
            if (0 < u && 8 > u) {
              o = u;
              var G = e.ownerDocument;
              if (o & rN && Za(G.documentElement), o & lN && Za(G.body), o & cN)
                for (o = G.head, Za(o), G = o.firstChild; G; ) {
                  var P = G.nextSibling, W = G.nodeName;
                  G[Hl] || W === "SCRIPT" || W === "STYLE" || W === "LINK" && G.rel.toLowerCase() === "stylesheet" || o.removeChild(G), G = P;
                }
            }
            if (y === 0) {
              e.removeChild(M), Ra(i);
              return;
            }
            y--;
          } else
            o === fB || o === mo || o === TD ? y++ : u = o.charCodeAt(0) - 48;
        else u = 0;
        o = M;
      } while (o);
      Ra(i);
    }
    function py(e) {
      e = e.style, typeof e.setProperty == "function" ? e.setProperty("display", "none", "important") : e.display = "none";
    }
    function my(e) {
      e.nodeValue = "";
    }
    function xu(e, i) {
      i = i[uN], i = i != null && i.hasOwnProperty("display") ? i.display : null, e.style.display = i == null || typeof i == "boolean" ? "" : ("" + i).trim();
    }
    function _u(e, i) {
      e.nodeValue = i;
    }
    function ai(e) {
      var i = e.firstChild;
      for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
        var o = i;
        switch (i = i.nextSibling, o.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            ai(o), Te(o);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (o.rel.toLowerCase() === "stylesheet") continue;
        }
        e.removeChild(o);
      }
    }
    function wC(e, i, o, u) {
      for (; e.nodeType === 1; ) {
        var y = o;
        if (e.nodeName.toLowerCase() !== i.toLowerCase()) {
          if (!u && (e.nodeName !== "INPUT" || e.type !== "hidden"))
            break;
        } else if (u) {
          if (!e[Hl])
            switch (i) {
              case "meta":
                if (!e.hasAttribute("itemprop")) break;
                return e;
              case "link":
                if (M = e.getAttribute("rel"), M === "stylesheet" && e.hasAttribute("data-precedence"))
                  break;
                if (M !== y.rel || e.getAttribute("href") !== (y.href == null || y.href === "" ? null : y.href) || e.getAttribute("crossorigin") !== (y.crossOrigin == null ? null : y.crossOrigin) || e.getAttribute("title") !== (y.title == null ? null : y.title))
                  break;
                return e;
              case "style":
                if (e.hasAttribute("data-precedence")) break;
                return e;
              case "script":
                if (M = e.getAttribute("src"), (M !== (y.src == null ? null : y.src) || e.getAttribute("type") !== (y.type == null ? null : y.type) || e.getAttribute("crossorigin") !== (y.crossOrigin == null ? null : y.crossOrigin)) && M && e.hasAttribute("async") && !e.hasAttribute("itemprop"))
                  break;
                return e;
              default:
                return e;
            }
        } else if (i === "input" && e.type === "hidden") {
          Cg(y.name, "name");
          var M = y.name == null ? null : "" + y.name;
          if (y.type === "hidden" && e.getAttribute("name") === M)
            return e;
        } else return e;
        if (e = he(e.nextSibling), e === null) break;
      }
      return null;
    }
    function Cs(e, i, o) {
      if (i === "") return null;
      for (; e.nodeType !== 3; )
        if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !o || (e = he(e.nextSibling), e === null)) return null;
      return e;
    }
    function es(e) {
      return e.data === TD || e.data === mo && e.ownerDocument.readyState === sY;
    }
    function Ya(e, i) {
      var o = e.ownerDocument;
      if (e.data !== mo || o.readyState === sY)
        i();
      else {
        var u = function() {
          i(), o.removeEventListener("DOMContentLoaded", u);
        };
        o.addEventListener("DOMContentLoaded", u), e._reactRetry = u;
      }
    }
    function he(e) {
      for (; e != null; e = e.nextSibling) {
        var i = e.nodeType;
        if (i === 1 || i === 3) break;
        if (i === 8) {
          if (i = e.data, i === fB || i === TD || i === mo || i === xm || i === nY)
            break;
          if (i === hB) return null;
        }
      }
      return e;
    }
    function Uu(e) {
      if (e.nodeType === 1) {
        for (var i = e.nodeName.toLowerCase(), o = {}, u = e.attributes, y = 0; y < u.length; y++) {
          var M = u[y];
          o[Ka(M.name)] = M.name.toLowerCase() === "style" ? Vu(e) : M.value;
        }
        return { type: i, props: o };
      }
      return e.nodeType === 8 ? { type: "Suspense", props: {} } : e.nodeValue;
    }
    function by(e, i, o) {
      return o === null || o[aN] !== !0 ? (e.nodeValue === i ? e = null : (i = en(i), e = en(e.nodeValue) === i ? null : e.nodeValue), e) : null;
    }
    function Pa(e) {
      e = e.nextSibling;
      for (var i = 0; e; ) {
        if (e.nodeType === 8) {
          var o = e.data;
          if (o === hB) {
            if (i === 0)
              return he(e.nextSibling);
            i--;
          } else
            o !== fB && o !== TD && o !== mo || i++;
        }
        e = e.nextSibling;
      }
      return null;
    }
    function Fu(e) {
      e = e.previousSibling;
      for (var i = 0; e; ) {
        if (e.nodeType === 8) {
          var o = e.data;
          if (o === fB || o === TD || o === mo) {
            if (i === 0) return e;
            i--;
          } else o === hB && i++;
        }
        e = e.previousSibling;
      }
      return null;
    }
    function Oe(e) {
      Ra(e);
    }
    function yw(e) {
      Ra(e);
    }
    function ye(e, i, o, u, y) {
      switch (y && kc(e, u.ancestorInfo), i = _I(o), e) {
        case "html":
          if (e = i.documentElement, !e)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return e;
        case "head":
          if (e = i.head, !e)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return e;
        case "body":
          if (e = i.body, !e)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return e;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function Dw(e, i, o, u) {
      if (!o[rs] && ZC(o)) {
        var y = o.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          y,
          y,
          y
        );
      }
      switch (e) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (y = o.attributes; y.length; )
        o.removeAttributeNode(y[0]);
      sC(o, e, i), o[OC] = u, o[Me] = i;
    }
    function Za(e) {
      for (var i = e.attributes; i.length; )
        e.removeAttributeNode(i[0]);
      Te(e);
    }
    function Xu(e) {
      return typeof e.getRootNode == "function" ? e.getRootNode() : e.nodeType === 9 ? e : e.ownerDocument;
    }
    function sn(e, i, o) {
      var u = Jd;
      if (u && typeof i == "string" && i) {
        var y = tC(i);
        y = 'link[rel="' + e + '"][href="' + y + '"]', typeof o == "string" && (y += '[crossorigin="' + o + '"]'), uY.has(y) || (uY.add(y), e = { rel: e, crossOrigin: o, href: i }, u.querySelector(y) === null && (i = u.createElement("link"), sC(i, "link", e), og(i), u.head.appendChild(i)));
      }
    }
    function pl(e, i, o, u) {
      var y = (y = li.current) ? Xu(y) : null;
      if (!y)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (e) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof o.precedence == "string" && typeof o.href == "string" ? (o = Ht(o.href), i = k(y).hoistableStyles, u = i.get(o), u || (u = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, i.set(o, u)), u) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (o.rel === "stylesheet" && typeof o.href == "string" && typeof o.precedence == "string") {
            e = Ht(o.href);
            var M = k(y).hoistableStyles, G = M.get(e);
            if (!G && (y = y.ownerDocument || y, G = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: ic, preload: null }
            }, M.set(e, G), (M = y.querySelector(
              va(e)
            )) && !M._p && (G.instance = M, G.state.loading = YD | Ki), !Ti.has(e))) {
              var P = {
                rel: "preload",
                as: "style",
                href: o.href,
                crossOrigin: o.crossOrigin,
                integrity: o.integrity,
                media: o.media,
                hrefLang: o.hrefLang,
                referrerPolicy: o.referrerPolicy
              };
              Ti.set(e, P), M || Mw(
                y,
                e,
                P,
                G.state
              );
            }
            if (i && u === null)
              throw o = `

  - ` + ja(i) + `
  + ` + ja(o), Error(
                "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + o
              );
            return G;
          }
          if (i && u !== null)
            throw o = `

  - ` + ja(i) + `
  + ` + ja(o), Error(
              "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + o
            );
          return null;
        case "script":
          return i = o.async, o = o.src, typeof o == "string" && i && typeof i != "function" && typeof i != "symbol" ? (o = ts(o), i = k(y).hoistableScripts, u = i.get(o), u || (u = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, i.set(o, u)), u) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' + e + '". this is a bug in React.'
          );
      }
    }
    function ja(e) {
      var i = 0, o = "<link";
      return typeof e.rel == "string" ? (i++, o += ' rel="' + e.rel + '"') : ci.call(e, "rel") && (i++, o += ' rel="' + (e.rel === null ? "null" : "invalid type " + typeof e.rel) + '"'), typeof e.href == "string" ? (i++, o += ' href="' + e.href + '"') : ci.call(e, "href") && (i++, o += ' href="' + (e.href === null ? "null" : "invalid type " + typeof e.href) + '"'), typeof e.precedence == "string" ? (i++, o += ' precedence="' + e.precedence + '"') : ci.call(e, "precedence") && (i++, o += " precedence={" + (e.precedence === null ? "null" : "invalid type " + typeof e.precedence) + "}"), Object.getOwnPropertyNames(e).length > i && (o += " ..."), o + " />";
    }
    function Ht(e) {
      return 'href="' + tC(e) + '"';
    }
    function va(e) {
      return 'link[rel="stylesheet"][' + e + "]";
    }
    function Sy(e) {
      return uI({}, e, {
        "data-precedence": e.precedence,
        precedence: null
      });
    }
    function Mw(e, i, o, u) {
      e.querySelector(
        'link[rel="preload"][as="style"][' + i + "]"
      ) ? u.loading = YD : (i = e.createElement("link"), u.preload = i, i.addEventListener("load", function() {
        return u.loading |= YD;
      }), i.addEventListener("error", function() {
        return u.loading |= lY;
      }), sC(i, "link", o), og(i), e.head.appendChild(i));
    }
    function ts(e) {
      return '[src="' + tC(e) + '"]';
    }
    function oo(e) {
      return "script[async]" + e;
    }
    function ww(e, i, o) {
      if (i.count++, i.instance === null)
        switch (i.type) {
          case "style":
            var u = e.querySelector(
              'style[data-href~="' + tC(o.href) + '"]'
            );
            if (u)
              return i.instance = u, og(u), u;
            var y = uI({}, o, {
              "data-href": o.href,
              "data-precedence": o.precedence,
              href: null,
              precedence: null
            });
            return u = (e.ownerDocument || e).createElement("style"), og(u), sC(u, "style", y), Qu(u, o.precedence, e), i.instance = u;
          case "stylesheet":
            y = Ht(o.href);
            var M = e.querySelector(
              va(y)
            );
            if (M)
              return i.state.loading |= Ki, i.instance = M, og(M), M;
            u = Sy(o), (y = Ti.get(y)) && Gy(u, y), M = (e.ownerDocument || e).createElement("link"), og(M);
            var G = M;
            return G._p = new Promise(function(P, W) {
              G.onload = P, G.onerror = W;
            }), sC(M, "link", u), i.state.loading |= Ki, Qu(M, o.precedence, e), i.instance = M;
          case "script":
            return M = ts(o.src), (y = e.querySelector(
              oo(M)
            )) ? (i.instance = y, og(y), y) : (u = o, (y = Ti.get(M)) && (u = uI({}, o), zu(u, y)), e = e.ownerDocument || e, y = e.createElement("script"), og(y), sC(y, "link", u), e.head.appendChild(y), i.instance = y);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' + i.type + '". this is a bug in React.'
            );
        }
      else
        i.type === "stylesheet" && (i.state.loading & Ki) === ic && (u = i.instance, i.state.loading |= Ki, Qu(u, o.precedence, e));
      return i.instance;
    }
    function Qu(e, i, o) {
      for (var u = o.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), y = u.length ? u[u.length - 1] : null, M = y, G = 0; G < u.length; G++) {
        var P = u[G];
        if (P.dataset.precedence === i) M = P;
        else if (M !== y) break;
      }
      M ? M.parentNode.insertBefore(e, M.nextSibling) : (i = o.nodeType === 9 ? o.head : o, i.insertBefore(e, i.firstChild));
    }
    function Gy(e, i) {
      e.crossOrigin == null && (e.crossOrigin = i.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = i.referrerPolicy), e.title == null && (e.title = i.title);
    }
    function zu(e, i) {
      e.crossOrigin == null && (e.crossOrigin = i.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = i.referrerPolicy), e.integrity == null && (e.integrity = i.integrity);
    }
    function Ky(e, i, o) {
      if (DB === null) {
        var u = /* @__PURE__ */ new Map(), y = DB = /* @__PURE__ */ new Map();
        y.set(o, u);
      } else
        y = DB, u = y.get(o), u || (u = /* @__PURE__ */ new Map(), y.set(o, u));
      if (u.has(e)) return u;
      for (u.set(e, null), o = o.getElementsByTagName(e), y = 0; y < o.length; y++) {
        var M = o[y];
        if (!(M[Hl] || M[OC] || e === "link" && M.getAttribute("rel") === "stylesheet") && M.namespaceURI !== fn) {
          var G = M.getAttribute(i) || "";
          G = e + G;
          var P = u.get(G);
          P ? P.push(M) : u.set(G, [M]);
        }
      }
      return u;
    }
    function ao(e, i, o) {
      e = e.ownerDocument || e, e.head.insertBefore(
        o,
        i === "title" ? e.querySelector("head > title") : null
      );
    }
    function Ju(e, i, o) {
      var u = !o.ancestorInfo.containerTagInScope;
      if (o.context === zd || i.itemProp != null)
        return !u || i.itemProp == null || e !== "meta" && e !== "title" && e !== "style" && e !== "link" && e !== "script" || console.error(
          "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
          e,
          e
        ), !1;
      switch (e) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "") {
            u && console.error(
              'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
            );
            break;
          }
          return !0;
        case "link":
          if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError) {
            if (i.rel === "stylesheet" && typeof i.precedence == "string") {
              e = i.href;
              var y = i.onError, M = i.disabled;
              o = [], i.onLoad && o.push("`onLoad`"), y && o.push("`onError`"), M != null && o.push("`disabled`"), y = WI(o, "and"), y += o.length === 1 ? " prop" : " props", M = o.length === 1 ? "an " + y : "the " + y, o.length && console.error(
                'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                e,
                M,
                y
              );
            }
            u && (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" ? console.error(
              "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
            ) : (i.onError || i.onLoad) && console.error(
              "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ));
            break;
          }
          switch (i.rel) {
            case "stylesheet":
              return e = i.precedence, i = i.disabled, typeof e != "string" && u && console.error(
                'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
              ), typeof e == "string" && i == null;
            default:
              return !0;
          }
        case "script":
          if (e = i.async && typeof i.async != "function" && typeof i.async != "symbol", !e || i.onLoad || i.onError || !i.src || typeof i.src != "string") {
            u && (e ? i.onLoad || i.onError ? console.error(
              "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
            ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          u && console.error(
            "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
            e
          );
      }
      return !1;
    }
    function Ty(e) {
      return !(e.type === "stylesheet" && (e.state.loading & cY) === ic);
    }
    function Bw() {
    }
    function pw(e, i, o) {
      if (PD === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var u = PD;
      if (i.type === "stylesheet" && (typeof o.media != "string" || matchMedia(o.media).matches !== !1) && (i.state.loading & Ki) === ic) {
        if (i.instance === null) {
          var y = Ht(o.href), M = e.querySelector(
            va(y)
          );
          if (M) {
            e = M._p, e !== null && typeof e == "object" && typeof e.then == "function" && (u.count++, u = ml.bind(u), e.then(u, u)), i.state.loading |= Ki, i.instance = M, og(M);
            return;
          }
          M = e.ownerDocument || e, o = Sy(o), (y = Ti.get(y)) && Gy(o, y), M = M.createElement("link"), og(M);
          var G = M;
          G._p = new Promise(function(P, W) {
            G.onload = P, G.onerror = W;
          }), sC(M, "link", o), i.instance = M;
        }
        u.stylesheets === null && (u.stylesheets = /* @__PURE__ */ new Map()), u.stylesheets.set(i, e), (e = i.state.preload) && (i.state.loading & cY) === ic && (u.count++, i = ml.bind(u), e.addEventListener("load", i), e.addEventListener("error", i));
      }
    }
    function mw() {
      if (PD === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var e = PD;
      return e.stylesheets && e.count === 0 && Lu(e, e.stylesheets), 0 < e.count ? function(i) {
        var o = setTimeout(function() {
          if (e.stylesheets && Lu(e, e.stylesheets), e.unsuspend) {
            var u = e.unsuspend;
            e.unsuspend = null, u();
          }
        }, 6e4);
        return e.unsuspend = i, function() {
          e.unsuspend = null, clearTimeout(o);
        };
      } : null;
    }
    function ml() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets)
          Lu(this, this.stylesheets);
        else if (this.unsuspend) {
          var e = this.unsuspend;
          this.unsuspend = null, e();
        }
      }
    }
    function Lu(e, i) {
      e.stylesheets = null, e.unsuspend !== null && (e.count++, MB = /* @__PURE__ */ new Map(), i.forEach(qu, e), MB = null, ml.call(e));
    }
    function qu(e, i) {
      if (!(i.state.loading & Ki)) {
        var o = MB.get(e);
        if (o) var u = o.get(Qm);
        else {
          o = /* @__PURE__ */ new Map(), MB.set(e, o);
          for (var y = e.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), M = 0; M < y.length; M++) {
            var G = y[M];
            (G.nodeName === "LINK" || G.getAttribute("media") !== "not all") && (o.set(G.dataset.precedence, G), u = G);
          }
          u && o.set(Qm, u);
        }
        y = i.instance, G = y.getAttribute("data-precedence"), M = o.get(G) || u, M === u && o.set(Qm, y), o.set(G, y), this.count++, u = ml.bind(this), y.addEventListener("load", u), y.addEventListener("error", u), M ? M.parentNode.insertBefore(y, M.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(y, e.firstChild)), i.state.loading |= Ki;
      }
    }
    function bw(e, i, o, u, y, M, G, P) {
      for (this.tag = 1, this.containerInfo = e, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = tc, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = qt(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = qt(0), this.hiddenUpdates = qt(null), this.identifierPrefix = u, this.onUncaughtError = y, this.onCaughtError = M, this.onRecoverableError = G, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = P, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), e = this.pendingUpdatersLaneMap = [], i = 0; 31 > i; i++) e.push(/* @__PURE__ */ new Set());
      this._debugRootType = o ? "hydrateRoot()" : "createRoot()";
    }
    function Yy(e, i, o, u, y, M, G, P, W, _, wg, Gg) {
      return e = new bw(
        e,
        i,
        o,
        G,
        P,
        W,
        _,
        Gg
      ), i = kO, M === !0 && (i |= we | hn), nt && (i |= LC), M = S(3, null, null, i), e.current = M, M.stateNode = e, i = uh(), qe(i), e.pooledCache = i, qe(i), M.memoizedState = {
        element: u,
        isDehydrated: o,
        cache: i
      }, Nn(M), e;
    }
    function eA(e) {
      return e ? (e = Fa, e) : Fa;
    }
    function bl(e, i, o, u, y, M) {
      if (pC && typeof pC.onScheduleFiberRoot == "function")
        try {
          pC.onScheduleFiberRoot(co, u, o);
        } catch (G) {
          kA || (kA = !0, console.error(
            "React instrumentation encountered an error: %s",
            G
          ));
        }
      Qg !== null && typeof Qg.markRenderScheduled == "function" && Qg.markRenderScheduled(i), y = eA(y), u.context === null ? u.context = y : u.pendingContext = y, di && mC !== null && !yY && (yY = !0, console.error(
        `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
        ig(mC) || "Unknown"
      )), u = Dt(i), u.payload = { element: o }, M = M === void 0 ? null : M, M !== null && (typeof M != "function" && console.error(
        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
        M
      ), u.callback = M), o = Mt(e, u, i), o !== null && (YI(o, e, i), Fs(o, e, i));
    }
    function Sw(e, i) {
      if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
        var o = e.retryLane;
        e.retryLane = o !== 0 && o < i ? o : i;
      }
    }
    function $u(e, i) {
      Sw(e, i), (e = e.alternate) && Sw(e, i);
    }
    function Gw(e) {
      if (e.tag === 13) {
        var i = Ce(e, 67108864);
        i !== null && YI(i, e, 67108864), $u(e, 67108864);
      }
    }
    function x0() {
      return mC;
    }
    function _0() {
      for (var e = /* @__PURE__ */ new Map(), i = 1, o = 0; 31 > o; o++) {
        var u = UC(i);
        e.set(i, u), i *= 2;
      }
      return e;
    }
    function gd(e, i, o, u) {
      var y = Dg.T;
      Dg.T = null;
      var M = QI.p;
      try {
        QI.p = ke, Sl(e, i, o, u);
      } finally {
        QI.p = M, Dg.T = y;
      }
    }
    function Ha(e, i, o, u) {
      var y = Dg.T;
      Dg.T = null;
      var M = QI.p;
      try {
        QI.p = ui, Sl(e, i, o, u);
      } finally {
        QI.p = M, Dg.T = y;
      }
    }
    function Sl(e, i, o, u) {
      if (BB) {
        var y = Ea(u);
        if (y === null)
          Ee(
            e,
            i,
            u,
            pB,
            o
          ), Et(e, u);
        else if (U0(
          y,
          e,
          i,
          o,
          u
        ))
          u.stopPropagation();
        else if (Et(e, u), i & 4 && -1 < yN.indexOf(e)) {
          for (; y !== null; ) {
            var M = ZC(y);
            if (M !== null)
              switch (M.tag) {
                case 3:
                  if (M = M.stateNode, M.current.memoizedState.isDehydrated) {
                    var G = vI(M.pendingLanes);
                    if (G !== 0) {
                      var P = M;
                      for (P.pendingLanes |= 2, P.entangledLanes |= 2; G; ) {
                        var W = 1 << 31 - oC(G);
                        P.entanglements[1] |= W, G &= ~W;
                      }
                      et(M), (qI & (_e | wn)) === kt && (iB = BC() + JT, Ln(0));
                    }
                  }
                  break;
                case 13:
                  P = Ce(M, 2), P !== null && YI(P, M, 2), eo(), $u(M, 2);
              }
            if (M = Ea(u), M === null && Ee(
              e,
              i,
              u,
              pB,
              o
            ), M === y) break;
            y = M;
          }
          y !== null && u.stopPropagation();
        } else
          Ee(
            e,
            i,
            u,
            null,
            o
          );
      }
    }
    function Ea(e) {
      return e = dt(e), Gl(e);
    }
    function Gl(e) {
      if (pB = null, e = JA(e), e !== null) {
        var i = H(e);
        if (i === null) e = null;
        else {
          var o = i.tag;
          if (o === 13) {
            if (e = R(i), e !== null) return e;
            e = null;
          } else if (o === 3) {
            if (i.stateNode.current.memoizedState.isDehydrated)
              return i.tag === 3 ? i.stateNode.containerInfo : null;
            e = null;
          } else i !== e && (e = null);
        }
      }
      return pB = e, null;
    }
    function is(e) {
      switch (e) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ke;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ui;
        case "message":
          switch (Zw()) {
            case jl:
              return ke;
            case Ey:
              return ui;
            case Na:
            case Ry:
              return un;
            case Oy:
              return rd;
            default:
              return un;
          }
        default:
          return un;
      }
    }
    function Et(e, i) {
      switch (e) {
        case "focusin":
        case "focusout":
          Ar = null;
          break;
        case "dragenter":
        case "dragleave":
          Cr = null;
          break;
        case "mouseover":
        case "mouseout":
          er = null;
          break;
        case "pointerover":
        case "pointerout":
          jD.delete(i.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          vD.delete(i.pointerId);
      }
    }
    function on(e, i, o, u, y, M) {
      return e === null || e.nativeEvent !== M ? (e = {
        blockedOn: i,
        domEventName: o,
        eventSystemFlags: u,
        nativeEvent: M,
        targetContainers: [y]
      }, i !== null && (i = ZC(i), i !== null && Gw(i)), e) : (e.eventSystemFlags |= u, i = e.targetContainers, y !== null && i.indexOf(y) === -1 && i.push(y), e);
    }
    function U0(e, i, o, u, y) {
      switch (i) {
        case "focusin":
          return Ar = on(
            Ar,
            e,
            i,
            o,
            u,
            y
          ), !0;
        case "dragenter":
          return Cr = on(
            Cr,
            e,
            i,
            o,
            u,
            y
          ), !0;
        case "mouseover":
          return er = on(
            er,
            e,
            i,
            o,
            u,
            y
          ), !0;
        case "pointerover":
          var M = y.pointerId;
          return jD.set(
            M,
            on(
              jD.get(M) || null,
              e,
              i,
              o,
              u,
              y
            )
          ), !0;
        case "gotpointercapture":
          return M = y.pointerId, vD.set(
            M,
            on(
              vD.get(M) || null,
              e,
              i,
              o,
              u,
              y
            )
          ), !0;
      }
      return !1;
    }
    function Py(e) {
      var i = JA(e.target);
      if (i !== null) {
        var o = H(i);
        if (o !== null) {
          if (i = o.tag, i === 13) {
            if (i = R(o), i !== null) {
              e.blockedOn = i, ut(e.priority, function() {
                if (o.tag === 13) {
                  var u = He(o);
                  u = PC(u);
                  var y = Ce(
                    o,
                    u
                  );
                  y !== null && YI(y, o, u), $u(o, u);
                }
              });
              return;
            }
          } else if (i === 3 && o.stateNode.current.memoizedState.isDehydrated) {
            e.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null;
            return;
          }
        }
      }
      e.blockedOn = null;
    }
    function Kl(e) {
      if (e.blockedOn !== null) return !1;
      for (var i = e.targetContainers; 0 < i.length; ) {
        var o = Ea(e.nativeEvent);
        if (o === null) {
          o = e.nativeEvent;
          var u = new o.constructor(
            o.type,
            o
          ), y = u;
          m !== null && console.error(
            "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
          ), m = y, o.target.dispatchEvent(u), m === null && console.error(
            "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
          ), m = null;
        } else
          return i = ZC(o), i !== null && Gw(i), e.blockedOn = o, !1;
        i.shift();
      }
      return !0;
    }
    function Zy(e, i, o) {
      Kl(e) && o.delete(i);
    }
    function Kw() {
      zm = !1, Ar !== null && Kl(Ar) && (Ar = null), Cr !== null && Kl(Cr) && (Cr = null), er !== null && Kl(er) && (er = null), jD.forEach(Zy), vD.forEach(Zy);
    }
    function Id(e, i) {
      e.blockedOn === i && (e.blockedOn = null, zm || (zm = !0, HA.unstable_scheduleCallback(
        HA.unstable_NormalPriority,
        Kw
      )));
    }
    function Ad(e) {
      mB !== e && (mB = e, HA.unstable_scheduleCallback(
        HA.unstable_NormalPriority,
        function() {
          mB === e && (mB = null);
          for (var i = 0; i < e.length; i += 3) {
            var o = e[i], u = e[i + 1], y = e[i + 2];
            if (typeof u != "function") {
              if (Gl(u || o) === null)
                continue;
              break;
            }
            var M = ZC(o);
            M !== null && (e.splice(i, 3), i -= 3, o = {
              pending: !0,
              data: y,
              method: o.method,
              action: u
            }, Object.freeze(o), uu(
              M,
              o,
              u,
              y
            ));
          }
        }
      ));
    }
    function Ra(e) {
      function i(W) {
        return Id(W, e);
      }
      Ar !== null && Id(Ar, e), Cr !== null && Id(Cr, e), er !== null && Id(er, e), jD.forEach(i), vD.forEach(i);
      for (var o = 0; o < tr.length; o++) {
        var u = tr[o];
        u.blockedOn === e && (u.blockedOn = null);
      }
      for (; 0 < tr.length && (o = tr[0], o.blockedOn === null); )
        Py(o), o.blockedOn === null && tr.shift();
      if (o = (e.ownerDocument || e).$$reactFormReplay, o != null)
        for (u = 0; u < o.length; u += 3) {
          var y = o[u], M = o[u + 1], G = y[Me] || null;
          if (typeof M == "function")
            G || Ad(o);
          else if (G) {
            var P = null;
            if (M && M.hasAttribute("formAction")) {
              if (y = M, G = M[Me] || null)
                P = G.formAction;
              else if (Gl(y) !== null) continue;
            } else P = G.action;
            typeof P == "function" ? o[u + 1] = P : (o.splice(u, 3), u -= 3), Ad(o);
          }
        }
    }
    function Cd(e) {
      this._internalRoot = e;
    }
    function ed(e) {
      this._internalRoot = e;
    }
    function td(e) {
      e[rs] && (e._reactRootContainer ? console.error(
        "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
      ) : console.error(
        "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
      ));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var HA = WZ(), jy = Yc(), F0 = eG(), uI = Object.assign, X0 = Symbol.for("react.element"), an = Symbol.for("react.transitional.element"), DI = Symbol.for("react.portal"), ns = Symbol.for("react.fragment"), ro = Symbol.for("react.strict_mode"), Tl = Symbol.for("react.profiler"), Tw = Symbol.for("react.provider"), Yl = Symbol.for("react.consumer"), De = Symbol.for("react.context"), ss = Symbol.for("react.forward_ref"), os = Symbol.for("react.suspense"), id = Symbol.for("react.suspense_list"), nd = Symbol.for("react.memo"), Ne = Symbol.for("react.lazy"), sd = Symbol.for("react.activity"), Yw = Symbol.for("react.memo_cache_sentinel"), Pl = Symbol.iterator, tA = Symbol.for("react.client.reference"), gC = Array.isArray, Dg = jy.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, QI = F0.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, vy = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }), Zl = [], Oa = [], ri = -1, rn = Zg(null), lo = Zg(null), li = Zg(null), od = Zg(null), ci = Object.prototype.hasOwnProperty, Hy = HA.unstable_scheduleCallback, Pw = HA.unstable_cancelCallback, Q0 = HA.unstable_shouldYield, z0 = HA.unstable_requestPaint, BC = HA.unstable_now, Zw = HA.unstable_getCurrentPriorityLevel, jl = HA.unstable_ImmediatePriority, Ey = HA.unstable_UserBlockingPriority, Na = HA.unstable_NormalPriority, Ry = HA.unstable_LowPriority, Oy = HA.unstable_IdlePriority, Rt = HA.log, Ny = HA.unstable_setDisableYieldValue, co = null, pC = null, Qg = null, kA = !1, nt = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", oC = Math.clz32 ? Math.clz32 : _C, ln = Math.log, J0 = Math.LN2, ad = 256, cn = 4194304, ke = 2, ui = 8, un = 32, rd = 268435456, as = Math.random().toString(36).slice(2), OC = "__reactFiber$" + as, Me = "__reactProps$" + as, rs = "__reactContainer$" + as, ld = "__reactEvents$" + as, ka = "__reactListeners$" + as, vl = "__reactHandles$" + as, ky = "__reactResources$" + as, Hl = "__reactMarker$" + as, uo = /* @__PURE__ */ new Set(), Ot = {}, cd = {}, ud = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    }, Wy = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), dd = {}, El = {}, Wa = 0, Vy, jw, xy, Va, vw, Hw, Ew;
    Ii.__reactDisabledLog = !0;
    var xa, Rl, Ol = !1, _y = new (typeof WeakMap == "function" ? WeakMap : Map)(), mC = null, di = !1, Rw = /[\n"\\]/g, Uy = !1, Fy = !1, Xy = !1, fd = !1, Qy = !1, Nl = !1, Ow = ["value", "defaultValue"], Nw = !1, hd = /["'&<>\n\t]|^\s|\s$/, zy = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
      " "
    ), kl = "applet caption html table td th marquee object template foreignObject desc title".split(
      " "
    ), Jy = kl.concat(["button"]), kw = "dd dt li option optgroup p rp rt".split(" "), yd = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: !1
    }, Nt = {}, fi = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
        " "
      ),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
        " "
      ),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
        " "
      ),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
        " "
      ),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
        " "
      ),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
        " "
      ),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
        " "
      ),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, dn = /([A-Z])/g, _a = /^ms-/, Wl = /^(?:webkit|moz|o)[A-Z]/, ls = /^-ms-/, L0 = /-(.)/g, Ly = /;\s*$/, hi = {}, qy = {}, $y = !1, Vl = !1, gD = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    ), Dd = "http://www.w3.org/1998/Math/MathML", fn = "http://www.w3.org/2000/svg", Md = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), xl = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Ua = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, cs = {}, wd = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Ww = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Vw = !1, aC = {}, n = /^on./, a = /^on[^A-Z]/, c = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), f = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), B = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, m = null, j = null, O = null, q = !1, ug = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), jg = !1;
    if (ug)
      try {
        var Hg = {};
        Object.defineProperty(Hg, "passive", {
          get: function() {
            jg = !0;
          }
        }), window.addEventListener("test", Hg, Hg), window.removeEventListener("test", Hg, Hg);
      } catch {
        jg = !1;
      }
    var hg = null, pg = null, tI = null, eI = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, zI = DC(eI), ag = uI({}, eI, { view: 0, detail: 0 }), Ag = DC(ag), dg, vg, Lg, mI = uI({}, ag, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: vC,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (e !== Lg && (Lg && e.type === "mousemove" ? (dg = e.screenX - Lg.screenX, vg = e.screenY - Lg.screenY) : vg = dg = 0, Lg = e), dg);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : vg;
      }
    }), CI = DC(mI), iI = uI({}, mI, { dataTransfer: 0 }), rC = DC(iI), UI = uI({}, ag, { relatedTarget: 0 }), yi = DC(UI), q0 = uI({}, eI, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), uO = DC(q0), dO = uI({}, eI, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), fO = DC(dO), hO = uI({}, eI, { data: 0 }), PK = DC(
      hO
    ), yO = PK, DO = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, MO = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, wO = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, BO = uI({}, ag, {
      key: function(e) {
        if (e.key) {
          var i = DO[e.key] || e.key;
          if (i !== "Unidentified") return i;
        }
        return e.type === "keypress" ? (e = Es(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? MO[e.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: vC,
      charCode: function(e) {
        return e.type === "keypress" ? Es(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? Es(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), pO = DC(BO), mO = uI({}, mI, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), ZK = DC(mO), bO = uI({}, ag, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: vC
    }), SO = DC(bO), GO = uI({}, eI, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), KO = DC(GO), TO = uI({}, mI, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), YO = DC(TO), PO = uI({}, eI, {
      newState: 0,
      oldState: 0
    }), ZO = DC(PO), jO = [9, 13, 27, 32], jK = 229, $0 = ug && "CompositionEvent" in window, ID = null;
    ug && "documentMode" in document && (ID = document.documentMode);
    var vO = ug && "TextEvent" in window && !ID, vK = ug && (!$0 || ID && 8 < ID && 11 >= ID), HK = 32, EK = String.fromCharCode(HK), RK = !1, Bd = !1, HO = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    }, AD = null, CD = null, OK = !1;
    ug && (OK = Ih("input") && (!document.documentMode || 9 < document.documentMode));
    var We = typeof Object.is == "function" ? Object.is : R0, EO = ug && "documentMode" in document && 11 >= document.documentMode, pd = null, gm = null, eD = null, Im = !1, md = {
      animationend: Rs("Animation", "AnimationEnd"),
      animationiteration: Rs("Animation", "AnimationIteration"),
      animationstart: Rs("Animation", "AnimationStart"),
      transitionrun: Rs("Transition", "TransitionRun"),
      transitionstart: Rs("Transition", "TransitionStart"),
      transitioncancel: Rs("Transition", "TransitionCancel"),
      transitionend: Rs("Transition", "TransitionEnd")
    }, Am = {}, NK = {};
    ug && (NK = document.createElement("div").style, "AnimationEvent" in window || (delete md.animationend.animation, delete md.animationiteration.animation, delete md.animationstart.animation), "TransitionEvent" in window || delete md.transitionend.transition);
    var kK = Os("animationend"), WK = Os("animationiteration"), VK = Os("animationstart"), RO = Os("transitionrun"), OO = Os("transitionstart"), NO = Os("transitioncancel"), xK = Os("transitionend"), _K = /* @__PURE__ */ new Map(), Cm = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    Cm.push("scrollEnd");
    var em = /* @__PURE__ */ new WeakMap(), xw = 1, fo = 2, Di = [], bd = 0, tm = 0, Fa = {};
    Object.freeze(Fa);
    var Mi = null, Sd = null, bA = 0, kO = 1, LC = 2, we = 8, hn = 16, UK = 64, FK = !1;
    try {
      var XK = Object.preventExtensions({});
    } catch {
      FK = !0;
    }
    var Gd = [], Kd = 0, _w = null, Uw = 0, wi = [], Bi = 0, _l = null, ho = 1, yo = "", Ve = null, XA = null, FI = !1, Do = !1, pi = null, Ul = null, us = !1, im = Error(
      "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), QK = 0;
    if (typeof performance == "object" && typeof performance.now == "function")
      var WO = performance, zK = function() {
        return WO.now();
      };
    else {
      var VO = Date;
      zK = function() {
        return VO.now();
      };
    }
    var nm = Zg(null), sm = Zg(null), JK = {}, Fw = null, Td = null, Yd = !1, xO = typeof AbortController < "u" ? AbortController : function() {
      var e = [], i = this.signal = {
        aborted: !1,
        addEventListener: function(o, u) {
          e.push(u);
        }
      };
      this.abort = function() {
        i.aborted = !0, e.forEach(function(o) {
          return o();
        });
      };
    }, _O = HA.unstable_scheduleCallback, UO = HA.unstable_NormalPriority, bC = {
      $$typeof: De,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, Pd = HA.unstable_now, LK = -0, Xw = -0, st = -1.1, Fl = -0, Qw = !1, zw = !1, tD = null, om = 0, Xl = 0, Zd = null, qK = Dg.S;
    Dg.S = function(e, i) {
      typeof i == "object" && i !== null && typeof i.then == "function" && JM(e, i), qK !== null && qK(e, i);
    };
    var Ql = Zg(null), yn = {
      recordUnsafeLifecycleWarnings: function() {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function() {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    }, iD = [], nD = [], sD = [], oD = [], aD = [], rD = [], zl = /* @__PURE__ */ new Set();
    yn.recordUnsafeLifecycleWarnings = function(e, i) {
      zl.has(e.type) || (typeof i.componentWillMount == "function" && i.componentWillMount.__suppressDeprecationWarning !== !0 && iD.push(e), e.mode & we && typeof i.UNSAFE_componentWillMount == "function" && nD.push(e), typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && sD.push(e), e.mode & we && typeof i.UNSAFE_componentWillReceiveProps == "function" && oD.push(e), typeof i.componentWillUpdate == "function" && i.componentWillUpdate.__suppressDeprecationWarning !== !0 && aD.push(e), e.mode & we && typeof i.UNSAFE_componentWillUpdate == "function" && rD.push(e));
    }, yn.flushPendingUnsafeLifecycleWarnings = function() {
      var e = /* @__PURE__ */ new Set();
      0 < iD.length && (iD.forEach(function(P) {
        e.add(
          ig(P) || "Component"
        ), zl.add(P.type);
      }), iD = []);
      var i = /* @__PURE__ */ new Set();
      0 < nD.length && (nD.forEach(function(P) {
        i.add(
          ig(P) || "Component"
        ), zl.add(P.type);
      }), nD = []);
      var o = /* @__PURE__ */ new Set();
      0 < sD.length && (sD.forEach(function(P) {
        o.add(
          ig(P) || "Component"
        ), zl.add(P.type);
      }), sD = []);
      var u = /* @__PURE__ */ new Set();
      0 < oD.length && (oD.forEach(
        function(P) {
          u.add(
            ig(P) || "Component"
          ), zl.add(P.type);
        }
      ), oD = []);
      var y = /* @__PURE__ */ new Set();
      0 < aD.length && (aD.forEach(function(P) {
        y.add(
          ig(P) || "Component"
        ), zl.add(P.type);
      }), aD = []);
      var M = /* @__PURE__ */ new Set();
      if (0 < rD.length && (rD.forEach(function(P) {
        M.add(
          ig(P) || "Component"
        ), zl.add(P.type);
      }), rD = []), 0 < i.size) {
        var G = b(
          i
        );
        console.error(
          `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
          G
        );
      }
      0 < u.size && (G = b(
        u
      ), console.error(
        `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
        G
      )), 0 < M.size && (G = b(
        M
      ), console.error(
        `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
        G
      )), 0 < e.size && (G = b(e), console.warn(
        `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        G
      )), 0 < o.size && (G = b(
        o
      ), console.warn(
        `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        G
      )), 0 < y.size && (G = b(y), console.warn(
        `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        G
      ));
    };
    var Jw = /* @__PURE__ */ new Map(), $K = /* @__PURE__ */ new Set();
    yn.recordLegacyContextWarning = function(e, i) {
      for (var o = null, u = e; u !== null; )
        u.mode & we && (o = u), u = u.return;
      o === null ? console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      ) : !$K.has(e.type) && (u = Jw.get(o), e.type.contextTypes != null || e.type.childContextTypes != null || i !== null && typeof i.getChildContext == "function") && (u === void 0 && (u = [], Jw.set(o, u)), u.push(e));
    }, yn.flushLegacyContextWarning = function() {
      Jw.forEach(function(e) {
        if (e.length !== 0) {
          var i = e[0], o = /* @__PURE__ */ new Set();
          e.forEach(function(y) {
            o.add(ig(y) || "Component"), $K.add(y.type);
          });
          var u = b(o);
          gI(i, function() {
            console.error(
              `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
              u
            );
          });
        }
      });
    }, yn.discardPendingWarnings = function() {
      iD = [], nD = [], sD = [], oD = [], aD = [], rD = [], Jw = /* @__PURE__ */ new Map();
    };
    var lD = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    ), gT = Error(
      "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), Lw = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
    ), am = {
      then: function() {
        console.error(
          'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
        );
      }
    }, cD = null, qw = !1, mi = 0, bi = 1, xe = 2, qC = 4, SC = 8, IT = 0, AT = 1, CT = 2, rm = 3, Xa = !1, eT = !1, lm = null, cm = !1, jd = Zg(null), $w = Zg(0), vd, tT = /* @__PURE__ */ new Set(), iT = /* @__PURE__ */ new Set(), um = /* @__PURE__ */ new Set(), nT = /* @__PURE__ */ new Set(), Qa = 0, dI = null, rA = null, lC = null, gB = !1, Hd = !1, Jl = !1, IB = 0, uD = 0, Mo = null, FO = 0, XO = 25, bg = null, Si = null, wo = -1, dD = !1, AB = {
      readContext: fA,
      use: PA,
      useCallback: aA,
      useContext: aA,
      useEffect: aA,
      useImperativeHandle: aA,
      useLayoutEffect: aA,
      useInsertionEffect: aA,
      useMemo: aA,
      useReducer: aA,
      useRef: aA,
      useState: aA,
      useDebugValue: aA,
      useDeferredValue: aA,
      useTransition: aA,
      useSyncExternalStore: aA,
      useId: aA,
      useHostTransitionStatus: aA,
      useFormState: aA,
      useActionState: aA,
      useOptimistic: aA,
      useMemoCache: aA,
      useCacheRefresh: aA
    }, dm = null, sT = null, fm = null, oT = null, ds = null, Dn = null, CB = null;
    dm = {
      readContext: function(e) {
        return fA(e);
      },
      use: PA,
      useCallback: function(e, i) {
        return bg = "useCallback", BI(), Wn(i), sa(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", BI(), fA(e);
      },
      useEffect: function(e, i) {
        return bg = "useEffect", BI(), Wn(i), Jr(e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", BI(), Wn(o), Qi(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        bg = "useInsertionEffect", BI(), Wn(i), gt(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", BI(), Wn(i), ph(e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", BI(), Wn(i);
        var o = Dg.H;
        Dg.H = ds;
        try {
          return zs(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", BI();
        var u = Dg.H;
        Dg.H = ds;
        try {
          return Fi(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function(e) {
        return bg = "useRef", BI(), Un(e);
      },
      useState: function(e) {
        bg = "useState", BI();
        var i = Dg.H;
        Dg.H = ds;
        try {
          return bt(e);
        } finally {
          Dg.H = i;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", BI();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", BI(), oa(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", BI(), $r();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", BI(), su(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", BI(), Js();
      },
      useFormState: function(e, i) {
        return bg = "useFormState", BI(), $o(), ta(e, i);
      },
      useActionState: function(e, i) {
        return bg = "useActionState", BI(), ta(e, i);
      },
      useOptimistic: function(e) {
        return bg = "useOptimistic", BI(), ti(e);
      },
      useHostTransitionStatus: se,
      useMemoCache: IA,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", BI(), gl();
      }
    }, sT = {
      readContext: function(e) {
        return fA(e);
      },
      use: PA,
      useCallback: function(e, i) {
        return bg = "useCallback", Og(), sa(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", Og(), fA(e);
      },
      useEffect: function(e, i) {
        return bg = "useEffect", Og(), Jr(e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", Og(), Qi(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        bg = "useInsertionEffect", Og(), gt(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", Og(), ph(e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", Og();
        var o = Dg.H;
        Dg.H = ds;
        try {
          return zs(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", Og();
        var u = Dg.H;
        Dg.H = ds;
        try {
          return Fi(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function(e) {
        return bg = "useRef", Og(), Un(e);
      },
      useState: function(e) {
        bg = "useState", Og();
        var i = Dg.H;
        Dg.H = ds;
        try {
          return bt(e);
        } finally {
          Dg.H = i;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", Og();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", Og(), oa(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", Og(), $r();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", Og(), su(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", Og(), Js();
      },
      useActionState: function(e, i) {
        return bg = "useActionState", Og(), ta(e, i);
      },
      useFormState: function(e, i) {
        return bg = "useFormState", Og(), $o(), ta(e, i);
      },
      useOptimistic: function(e) {
        return bg = "useOptimistic", Og(), ti(e);
      },
      useHostTransitionStatus: se,
      useMemoCache: IA,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", Og(), gl();
      }
    }, fm = {
      readContext: function(e) {
        return fA(e);
      },
      use: PA,
      useCallback: function(e, i) {
        return bg = "useCallback", Og(), Lr(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", Og(), fA(e);
      },
      useEffect: function(e, i) {
        bg = "useEffect", Og(), ne(2048, SC, e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", Og(), na(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        return bg = "useInsertionEffect", Og(), ne(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", Og(), ne(4, qC, e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", Og();
        var o = Dg.H;
        Dg.H = Dn;
        try {
          return qr(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", Og();
        var u = Dg.H;
        Dg.H = Dn;
        try {
          return QC(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function() {
        return bg = "useRef", Og(), JI().memoizedState;
      },
      useState: function() {
        bg = "useState", Og();
        var e = Dg.H;
        Dg.H = Dn;
        try {
          return QC(pI);
        } finally {
          Dg.H = e;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", Og();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", Og(), cu(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", Og(), du();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", Og(), Xr(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", Og(), JI().memoizedState;
      },
      useFormState: function(e) {
        return bg = "useFormState", Og(), $o(), lu(e);
      },
      useActionState: function(e) {
        return bg = "useActionState", Og(), lu(e);
      },
      useOptimistic: function(e, i) {
        return bg = "useOptimistic", Og(), ii(e, i);
      },
      useHostTransitionStatus: se,
      useMemoCache: IA,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", Og(), JI().memoizedState;
      }
    }, oT = {
      readContext: function(e) {
        return fA(e);
      },
      use: PA,
      useCallback: function(e, i) {
        return bg = "useCallback", Og(), Lr(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", Og(), fA(e);
      },
      useEffect: function(e, i) {
        bg = "useEffect", Og(), ne(2048, SC, e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", Og(), na(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        return bg = "useInsertionEffect", Og(), ne(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", Og(), ne(4, qC, e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", Og();
        var o = Dg.H;
        Dg.H = CB;
        try {
          return qr(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", Og();
        var u = Dg.H;
        Dg.H = CB;
        try {
          return mt(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function() {
        return bg = "useRef", Og(), JI().memoizedState;
      },
      useState: function() {
        bg = "useState", Og();
        var e = Dg.H;
        Dg.H = CB;
        try {
          return mt(pI);
        } finally {
          Dg.H = e;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", Og();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", Og(), bh(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", Og(), Ji();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", Og(), Xr(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", Og(), JI().memoizedState;
      },
      useFormState: function(e) {
        return bg = "useFormState", Og(), $o(), _n(e);
      },
      useActionState: function(e) {
        return bg = "useActionState", Og(), _n(e);
      },
      useOptimistic: function(e, i) {
        return bg = "useOptimistic", Og(), ru(e, i);
      },
      useHostTransitionStatus: se,
      useMemoCache: IA,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", Og(), JI().memoizedState;
      }
    }, ds = {
      readContext: function(e) {
        return w(), fA(e);
      },
      use: function(e) {
        return D(), PA(e);
      },
      useCallback: function(e, i) {
        return bg = "useCallback", D(), BI(), sa(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", D(), BI(), fA(e);
      },
      useEffect: function(e, i) {
        return bg = "useEffect", D(), BI(), Jr(e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", D(), BI(), Qi(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        bg = "useInsertionEffect", D(), BI(), gt(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", D(), BI(), ph(e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", D(), BI();
        var o = Dg.H;
        Dg.H = ds;
        try {
          return zs(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", D(), BI();
        var u = Dg.H;
        Dg.H = ds;
        try {
          return Fi(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function(e) {
        return bg = "useRef", D(), BI(), Un(e);
      },
      useState: function(e) {
        bg = "useState", D(), BI();
        var i = Dg.H;
        Dg.H = ds;
        try {
          return bt(e);
        } finally {
          Dg.H = i;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", D(), BI();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", D(), BI(), oa(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", D(), BI(), $r();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", D(), BI(), su(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", D(), BI(), Js();
      },
      useFormState: function(e, i) {
        return bg = "useFormState", D(), BI(), ta(e, i);
      },
      useActionState: function(e, i) {
        return bg = "useActionState", D(), BI(), ta(e, i);
      },
      useOptimistic: function(e) {
        return bg = "useOptimistic", D(), BI(), ti(e);
      },
      useMemoCache: function(e) {
        return D(), IA(e);
      },
      useHostTransitionStatus: se,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", BI(), gl();
      }
    }, Dn = {
      readContext: function(e) {
        return w(), fA(e);
      },
      use: function(e) {
        return D(), PA(e);
      },
      useCallback: function(e, i) {
        return bg = "useCallback", D(), Og(), Lr(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", D(), Og(), fA(e);
      },
      useEffect: function(e, i) {
        bg = "useEffect", D(), Og(), ne(2048, SC, e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", D(), Og(), na(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        return bg = "useInsertionEffect", D(), Og(), ne(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", D(), Og(), ne(4, qC, e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", D(), Og();
        var o = Dg.H;
        Dg.H = Dn;
        try {
          return qr(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", D(), Og();
        var u = Dg.H;
        Dg.H = Dn;
        try {
          return QC(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function() {
        return bg = "useRef", D(), Og(), JI().memoizedState;
      },
      useState: function() {
        bg = "useState", D(), Og();
        var e = Dg.H;
        Dg.H = Dn;
        try {
          return QC(pI);
        } finally {
          Dg.H = e;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", D(), Og();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", D(), Og(), cu(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", D(), Og(), du();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", D(), Og(), Xr(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", D(), Og(), JI().memoizedState;
      },
      useFormState: function(e) {
        return bg = "useFormState", D(), Og(), lu(e);
      },
      useActionState: function(e) {
        return bg = "useActionState", D(), Og(), lu(e);
      },
      useOptimistic: function(e, i) {
        return bg = "useOptimistic", D(), Og(), ii(e, i);
      },
      useMemoCache: function(e) {
        return D(), IA(e);
      },
      useHostTransitionStatus: se,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", Og(), JI().memoizedState;
      }
    }, CB = {
      readContext: function(e) {
        return w(), fA(e);
      },
      use: function(e) {
        return D(), PA(e);
      },
      useCallback: function(e, i) {
        return bg = "useCallback", D(), Og(), Lr(e, i);
      },
      useContext: function(e) {
        return bg = "useContext", D(), Og(), fA(e);
      },
      useEffect: function(e, i) {
        bg = "useEffect", D(), Og(), ne(2048, SC, e, i);
      },
      useImperativeHandle: function(e, i, o) {
        return bg = "useImperativeHandle", D(), Og(), na(e, i, o);
      },
      useInsertionEffect: function(e, i) {
        return bg = "useInsertionEffect", D(), Og(), ne(4, xe, e, i);
      },
      useLayoutEffect: function(e, i) {
        return bg = "useLayoutEffect", D(), Og(), ne(4, qC, e, i);
      },
      useMemo: function(e, i) {
        bg = "useMemo", D(), Og();
        var o = Dg.H;
        Dg.H = Dn;
        try {
          return qr(e, i);
        } finally {
          Dg.H = o;
        }
      },
      useReducer: function(e, i, o) {
        bg = "useReducer", D(), Og();
        var u = Dg.H;
        Dg.H = Dn;
        try {
          return mt(e, i, o);
        } finally {
          Dg.H = u;
        }
      },
      useRef: function() {
        return bg = "useRef", D(), Og(), JI().memoizedState;
      },
      useState: function() {
        bg = "useState", D(), Og();
        var e = Dg.H;
        Dg.H = Dn;
        try {
          return mt(pI);
        } finally {
          Dg.H = e;
        }
      },
      useDebugValue: function() {
        bg = "useDebugValue", D(), Og();
      },
      useDeferredValue: function(e, i) {
        return bg = "useDeferredValue", D(), Og(), bh(e, i);
      },
      useTransition: function() {
        return bg = "useTransition", D(), Og(), Ji();
      },
      useSyncExternalStore: function(e, i, o) {
        return bg = "useSyncExternalStore", D(), Og(), Xr(
          e,
          i,
          o
        );
      },
      useId: function() {
        return bg = "useId", D(), Og(), JI().memoizedState;
      },
      useFormState: function(e) {
        return bg = "useFormState", D(), Og(), _n(e);
      },
      useActionState: function(e) {
        return bg = "useActionState", D(), Og(), _n(e);
      },
      useOptimistic: function(e, i) {
        return bg = "useOptimistic", D(), Og(), ru(e, i);
      },
      useMemoCache: function(e) {
        return D(), IA(e);
      },
      useHostTransitionStatus: se,
      useCacheRefresh: function() {
        return bg = "useCacheRefresh", Og(), JI().memoizedState;
      }
    };
    var aT = {
      react_stack_bottom_frame: function(e, i, o) {
        var u = di;
        di = !0;
        try {
          return e(i, o);
        } finally {
          di = u;
        }
      }
    }, hm = aT.react_stack_bottom_frame.bind(aT), rT = {
      react_stack_bottom_frame: function(e) {
        var i = di;
        di = !0;
        try {
          return e.render();
        } finally {
          di = i;
        }
      }
    }, lT = rT.react_stack_bottom_frame.bind(rT), cT = {
      react_stack_bottom_frame: function(e, i) {
        try {
          i.componentDidMount();
        } catch (o) {
          AA(e, e.return, o);
        }
      }
    }, ym = cT.react_stack_bottom_frame.bind(
      cT
    ), uT = {
      react_stack_bottom_frame: function(e, i, o, u, y) {
        try {
          i.componentDidUpdate(o, u, y);
        } catch (M) {
          AA(e, e.return, M);
        }
      }
    }, dT = uT.react_stack_bottom_frame.bind(
      uT
    ), fT = {
      react_stack_bottom_frame: function(e, i) {
        var o = i.stack;
        e.componentDidCatch(i.value, {
          componentStack: o !== null ? o : ""
        });
      }
    }, QO = fT.react_stack_bottom_frame.bind(
      fT
    ), hT = {
      react_stack_bottom_frame: function(e, i, o) {
        try {
          o.componentWillUnmount();
        } catch (u) {
          AA(e, i, u);
        }
      }
    }, yT = hT.react_stack_bottom_frame.bind(
      hT
    ), DT = {
      react_stack_bottom_frame: function(e) {
        e.resourceKind != null && console.error(
          "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
          e.resourceKind
        );
        var i = e.create;
        return e = e.inst, i = i(), e.destroy = i;
      }
    }, zO = DT.react_stack_bottom_frame.bind(DT), MT = {
      react_stack_bottom_frame: function(e, i, o) {
        try {
          o();
        } catch (u) {
          AA(e, i, u);
        }
      }
    }, JO = MT.react_stack_bottom_frame.bind(MT), wT = {
      react_stack_bottom_frame: function(e) {
        var i = e._init;
        return i(e._payload);
      }
    }, za = wT.react_stack_bottom_frame.bind(wT), Ed = null, fD = 0, GI = null, Dm, BT = Dm = !1, pT = {}, mT = {}, bT = {};
    h = function(e, i, o) {
      if (o !== null && typeof o == "object" && o._store && (!o._store.validated && o.key == null || o._store.validated === 2)) {
        if (typeof o._store != "object")
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        o._store.validated = 1;
        var u = ig(e), y = u || "null";
        if (!pT[y]) {
          pT[y] = !0, o = o._owner, e = e._debugOwner;
          var M = "";
          e && typeof e.tag == "number" && (y = ig(e)) && (M = `

Check the render method of \`` + y + "`."), M || u && (M = `

Check the top-level render call using <` + u + ">.");
          var G = "";
          o != null && e !== o && (u = null, typeof o.tag == "number" ? u = ig(o) : typeof o.name == "string" && (u = o.name), u && (G = " It was passed a child from " + u + ".")), gI(i, function() {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              M,
              G
            );
          });
        }
      }
    };
    var Rd = qs(!0), ST = qs(!1), Gi = Zg(null), fs = null, Od = 1, hD = 2, GC = Zg(0), GT = {}, KT = /* @__PURE__ */ new Set(), TT = /* @__PURE__ */ new Set(), YT = /* @__PURE__ */ new Set(), PT = /* @__PURE__ */ new Set(), ZT = /* @__PURE__ */ new Set(), jT = /* @__PURE__ */ new Set(), vT = /* @__PURE__ */ new Set(), HT = /* @__PURE__ */ new Set(), ET = /* @__PURE__ */ new Set(), RT = /* @__PURE__ */ new Set();
    Object.freeze(GT);
    var Mm = {
      enqueueSetState: function(e, i, o) {
        e = e._reactInternals;
        var u = He(e), y = Dt(u);
        y.payload = i, o != null && (TA(o), y.callback = o), i = Mt(e, y, u), i !== null && (YI(i, e, u), Fs(i, e, u)), oA(e, u);
      },
      enqueueReplaceState: function(e, i, o) {
        e = e._reactInternals;
        var u = He(e), y = Dt(u);
        y.tag = AT, y.payload = i, o != null && (TA(o), y.callback = o), i = Mt(e, y, u), i !== null && (YI(i, e, u), Fs(i, e, u)), oA(e, u);
      },
      enqueueForceUpdate: function(e, i) {
        e = e._reactInternals;
        var o = He(e), u = Dt(o);
        u.tag = CT, i != null && (TA(i), u.callback = i), i = Mt(e, u, o), i !== null && (YI(i, e, o), Fs(i, e, o)), Qg !== null && typeof Qg.markForceUpdateScheduled == "function" && Qg.markForceUpdateScheduled(e, o);
      }
    }, wm = typeof reportError == "function" ? reportError : function(e) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var i = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e),
          error: e
        });
        if (!window.dispatchEvent(i)) return;
      } else if (typeof A == "object" && typeof A.emit == "function") {
        A.emit("uncaughtException", e);
        return;
      }
      console.error(e);
    }, Nd = null, Bm = null, OT = Error(
      "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
    ), NC = !1, NT = {}, kT = {}, WT = {}, VT = {}, kd = !1, xT = {}, pm = {}, mm = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, _T = !1, UT = null;
    UT = /* @__PURE__ */ new Set();
    var Bo = !1, IC = !1, bm = !1, FT = typeof WeakSet == "function" ? WeakSet : Set, kC = null, Wd = null, Vd = null, cC = null, ot = !1, Mn = null, yD = 8192, LO = {
      getCacheForType: function(e) {
        var i = fA(bC), o = i.data.get(e);
        return o === void 0 && (o = e(), i.data.set(e, o)), o;
      },
      getOwner: function() {
        return mC;
      }
    };
    if (typeof Symbol == "function" && Symbol.for) {
      var DD = Symbol.for;
      DD("selector.component"), DD("selector.has_pseudo_class"), DD("selector.role"), DD("selector.test_id"), DD("selector.text");
    }
    var qO = [], $O = typeof WeakMap == "function" ? WeakMap : Map, kt = 0, _e = 2, wn = 4, po = 0, MD = 1, xd = 2, Sm = 3, Ll = 4, eB = 6, XT = 5, qI = kt, MA = null, HI = null, OI = 0, at = 0, wD = 1, ql = 2, BD = 3, QT = 4, Gm = 5, _d = 6, pD = 7, Km = 8, $l = 9, iA = at, Wt = null, Ja = !1, Ud = !1, Tm = !1, hs = 0, QA = po, La = 0, qa = 0, Ym = 0, Vt = 0, gc = 0, mD = null, Ue = null, tB = !1, Pm = 0, zT = 300, iB = 1 / 0, JT = 500, bD = null, $a = null, gN = 0, IN = 1, AN = 2, Ic = 0, LT = 1, qT = 2, $T = 3, CN = 4, Zm = 5, $C = 0, gr = null, Fd = null, Ir = 0, jm = 0, vm = null, gY = null, eN = 50, SD = 0, Hm = null, Em = !1, nB = !1, tN = 50, Ac = 0, GD = null, Xd = !1, sB = null, IY = !1, AY = /* @__PURE__ */ new Set(), iN = {}, oB = null, Qd = null, Rm = !1, Om = !1, aB = !1, Nm = !1, Cc = 0, km = {};
    (function() {
      for (var e = 0; e < Cm.length; e++) {
        var i = Cm[e], o = i.toLowerCase();
        i = i[0].toUpperCase() + i.slice(1), ft(o, "on" + i);
      }
      ft(kK, "onAnimationEnd"), ft(WK, "onAnimationIteration"), ft(VK, "onAnimationStart"), ft("dblclick", "onDoubleClick"), ft("focusin", "onFocus"), ft("focusout", "onBlur"), ft(RO, "onTransitionRun"), ft(OO, "onTransitionStart"), ft(NO, "onTransitionCancel"), ft(xK, "onTransitionEnd");
    })(), _g("onMouseEnter", ["mouseout", "mouseover"]), _g("onMouseLeave", ["mouseout", "mouseover"]), _g("onPointerEnter", ["pointerout", "pointerover"]), _g("onPointerLeave", ["pointerout", "pointerover"]), Vg(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ), Vg(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), Vg("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), Vg(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), Vg(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), Vg(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var KD = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), Wm = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(KD)
    ), rB = "_reactListening" + Math.random().toString(36).slice(2), CY = !1, eY = !1, lB = !1, tY = !1, cB = !1, uB = !1, iY = !1, dB = {}, nN = /\r\n?/g, sN = /\u0000|\uFFFD/g, ec = "http://www.w3.org/1999/xlink", Vm = "http://www.w3.org/XML/1998/namespace", oN = "javascript:throw new Error('React form unexpectedly submitted.')", aN = "suppressHydrationWarning", fB = "$", hB = "/$", mo = "$?", TD = "$!", rN = 1, lN = 2, cN = 4, xm = "F!", nY = "F", sY = "complete", uN = "style", bo = 0, zd = 1, yB = 2, _m = null, Um = null, oY = { dialog: !0, webview: !0 }, Fm = null, aY = typeof setTimeout == "function" ? setTimeout : void 0, dN = typeof clearTimeout == "function" ? clearTimeout : void 0, tc = -1, rY = typeof Promise == "function" ? Promise : void 0, fN = typeof queueMicrotask == "function" ? queueMicrotask : typeof rY < "u" ? function(e) {
      return rY.resolve(null).then(e).catch(nn);
    } : aY, Xm = null, ic = 0, YD = 1, lY = 2, cY = 3, Ki = 4, Ti = /* @__PURE__ */ new Map(), uY = /* @__PURE__ */ new Set(), So = QI.d;
    QI.d = {
      f: function() {
        var e = So.f(), i = eo();
        return e || i;
      },
      r: function(e) {
        var i = ZC(e);
        i !== null && i.tag === 5 && i.type === "form" ? zi(i) : So.r(e);
      },
      D: function(e) {
        So.D(e), sn("dns-prefetch", e, null);
      },
      C: function(e, i) {
        So.C(e, i), sn("preconnect", e, i);
      },
      L: function(e, i, o) {
        So.L(e, i, o);
        var u = Jd;
        if (u && e && i) {
          var y = 'link[rel="preload"][as="' + tC(i) + '"]';
          i === "image" && o && o.imageSrcSet ? (y += '[imagesrcset="' + tC(
            o.imageSrcSet
          ) + '"]', typeof o.imageSizes == "string" && (y += '[imagesizes="' + tC(
            o.imageSizes
          ) + '"]')) : y += '[href="' + tC(e) + '"]';
          var M = y;
          switch (i) {
            case "style":
              M = Ht(e);
              break;
            case "script":
              M = ts(e);
          }
          Ti.has(M) || (e = uI(
            {
              rel: "preload",
              href: i === "image" && o && o.imageSrcSet ? void 0 : e,
              as: i
            },
            o
          ), Ti.set(M, e), u.querySelector(y) !== null || i === "style" && u.querySelector(
            va(M)
          ) || i === "script" && u.querySelector(oo(M)) || (i = u.createElement("link"), sC(i, "link", e), og(i), u.head.appendChild(i)));
        }
      },
      m: function(e, i) {
        So.m(e, i);
        var o = Jd;
        if (o && e) {
          var u = i && typeof i.as == "string" ? i.as : "script", y = 'link[rel="modulepreload"][as="' + tC(u) + '"][href="' + tC(e) + '"]', M = y;
          switch (u) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              M = ts(e);
          }
          if (!Ti.has(M) && (e = uI({ rel: "modulepreload", href: e }, i), Ti.set(M, e), o.querySelector(y) === null)) {
            switch (u) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (o.querySelector(oo(M)))
                  return;
            }
            u = o.createElement("link"), sC(u, "link", e), og(u), o.head.appendChild(u);
          }
        }
      },
      X: function(e, i) {
        So.X(e, i);
        var o = Jd;
        if (o && e) {
          var u = k(o).hoistableScripts, y = ts(e), M = u.get(y);
          M || (M = o.querySelector(
            oo(y)
          ), M || (e = uI({ src: e, async: !0 }, i), (i = Ti.get(y)) && zu(e, i), M = o.createElement("script"), og(M), sC(M, "link", e), o.head.appendChild(M)), M = {
            type: "script",
            instance: M,
            count: 1,
            state: null
          }, u.set(y, M));
        }
      },
      S: function(e, i, o) {
        So.S(e, i, o);
        var u = Jd;
        if (u && e) {
          var y = k(u).hoistableStyles, M = Ht(e);
          i = i || "default";
          var G = y.get(M);
          if (!G) {
            var P = { loading: ic, preload: null };
            if (G = u.querySelector(
              va(M)
            ))
              P.loading = YD | Ki;
            else {
              e = uI(
                {
                  rel: "stylesheet",
                  href: e,
                  "data-precedence": i
                },
                o
              ), (o = Ti.get(M)) && Gy(e, o);
              var W = G = u.createElement("link");
              og(W), sC(W, "link", e), W._p = new Promise(function(_, wg) {
                W.onload = _, W.onerror = wg;
              }), W.addEventListener("load", function() {
                P.loading |= YD;
              }), W.addEventListener("error", function() {
                P.loading |= lY;
              }), P.loading |= Ki, Qu(G, i, u);
            }
            G = {
              type: "stylesheet",
              instance: G,
              count: 1,
              state: P
            }, y.set(M, G);
          }
        }
      },
      M: function(e, i) {
        So.M(e, i);
        var o = Jd;
        if (o && e) {
          var u = k(o).hoistableScripts, y = ts(e), M = u.get(y);
          M || (M = o.querySelector(
            oo(y)
          ), M || (e = uI({ src: e, async: !0, type: "module" }, i), (i = Ti.get(y)) && zu(e, i), M = o.createElement("script"), og(M), sC(M, "link", e), o.head.appendChild(M)), M = {
            type: "script",
            instance: M,
            count: 1,
            state: null
          }, u.set(y, M));
        }
      }
    };
    var Jd = typeof document > "u" ? null : document, DB = null, PD = null, Qm = null, MB = null, nc = vy, ZD = {
      $$typeof: De,
      Provider: null,
      Consumer: null,
      _currentValue: nc,
      _currentValue2: nc,
      _threadCount: 0
    }, dY = "%c%s%c ", fY = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", hY = "", wB = " ", hN = Function.prototype.bind, yY = !1, DY = null, MY = null, wY = null, BY = null, pY = null, mY = null, bY = null, SY = null, GY = null;
    DY = function(e, i, o, u) {
      i = I(e, i), i !== null && (o = C(i.memoizedState, o, 0, u), i.memoizedState = o, i.baseState = o, e.memoizedProps = uI({}, e.memoizedProps), o = Ce(e, 2), o !== null && YI(o, e, 2));
    }, MY = function(e, i, o) {
      i = I(e, i), i !== null && (o = r(i.memoizedState, o, 0), i.memoizedState = o, i.baseState = o, e.memoizedProps = uI({}, e.memoizedProps), o = Ce(e, 2), o !== null && YI(o, e, 2));
    }, wY = function(e, i, o, u) {
      i = I(e, i), i !== null && (o = t(i.memoizedState, o, u), i.memoizedState = o, i.baseState = o, e.memoizedProps = uI({}, e.memoizedProps), o = Ce(e, 2), o !== null && YI(o, e, 2));
    }, BY = function(e, i, o) {
      e.pendingProps = C(e.memoizedProps, i, 0, o), e.alternate && (e.alternate.pendingProps = e.pendingProps), i = Ce(e, 2), i !== null && YI(i, e, 2);
    }, pY = function(e, i) {
      e.pendingProps = r(e.memoizedProps, i, 0), e.alternate && (e.alternate.pendingProps = e.pendingProps), i = Ce(e, 2), i !== null && YI(i, e, 2);
    }, mY = function(e, i, o) {
      e.pendingProps = t(
        e.memoizedProps,
        i,
        o
      ), e.alternate && (e.alternate.pendingProps = e.pendingProps), i = Ce(e, 2), i !== null && YI(i, e, 2);
    }, bY = function(e) {
      var i = Ce(e, 2);
      i !== null && YI(i, e, 2);
    }, SY = function(e) {
      d = e;
    }, GY = function(e) {
      l = e;
    };
    var BB = !0, pB = null, zm = !1, Ar = null, Cr = null, er = null, jD = /* @__PURE__ */ new Map(), vD = /* @__PURE__ */ new Map(), tr = [], yN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    ), mB = null;
    if (ed.prototype.render = Cd.prototype.render = function(e) {
      var i = this._internalRoot;
      if (i === null) throw Error("Cannot update an unmounted root.");
      var o = arguments;
      typeof o[1] == "function" ? console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ) : E(o[1]) ? console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      ) : typeof o[1] < "u" && console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      ), o = e;
      var u = i.current, y = He(u);
      bl(u, y, o, i, null, null);
    }, ed.prototype.unmount = Cd.prototype.unmount = function() {
      var e = arguments;
      if (typeof e[0] == "function" && console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ), e = this._internalRoot, e !== null) {
        this._internalRoot = null;
        var i = e.containerInfo;
        (qI & (_e | wn)) !== kt && console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        ), bl(e.current, 2, null, e, null, null), eo(), i[rs] = null;
      }
    }, ed.prototype.unstable_scheduleHydration = function(e) {
      if (e) {
        var i = gi();
        e = { blockedOn: null, target: e, priority: i };
        for (var o = 0; o < tr.length && i !== 0 && i < tr[o].priority; o++) ;
        tr.splice(o, 0, e), o === 0 && Py(e);
      }
    }, (function() {
      var e = jy.version;
      if (e !== "19.1.1")
        throw Error(
          `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (e + `
  - react-dom:  19.1.1
Learn more: https://react.dev/warnings/version-mismatch`)
        );
    })(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    ), QI.findDOMNode = function(e) {
      var i = e._reactInternals;
      if (i === void 0)
        throw typeof e.render == "function" ? Error("Unable to find node on an unmounted component.") : (e = Object.keys(e).join(","), Error(
          "Argument appears to not be a ReactComponent. Keys: " + e
        ));
      return e = U(i), e = e !== null ? J(e) : null, e = e === null ? null : e.stateNode, e;
    }, !(function() {
      var e = {
        bundleType: 1,
        version: "19.1.1",
        rendererPackageName: "react-dom",
        currentDispatcherRef: Dg,
        reconcilerVersion: "19.1.1"
      };
      return e.overrideHookState = DY, e.overrideHookStateDeletePath = MY, e.overrideHookStateRenamePath = wY, e.overrideProps = BY, e.overridePropsDeletePath = pY, e.overridePropsRenamePath = mY, e.scheduleUpdate = bY, e.setErrorHandler = SY, e.setSuspenseHandler = GY, e.scheduleRefresh = Y, e.scheduleRoot = K, e.setRefreshHandler = T, e.getCurrentFiber = x0, e.getLaneLabelMap = _0, e.injectProfilingHooks = Xg, Yg(e);
    })() && ug && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var KY = window.location.protocol;
      /^(https?|file):$/.test(KY) && console.info(
        "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (KY === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""),
        "font-weight:bold"
      );
    }
    OD.createRoot = function(e, i) {
      if (!E(e))
        throw Error("Target container is not a DOM element.");
      td(e);
      var o = !1, u = "", y = qM, M = Du, G = Mu, P = null;
      return i != null && (i.hydrate ? console.warn(
        "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
      ) : typeof i == "object" && i !== null && i.$$typeof === an && console.error(
        `You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`
      ), i.unstable_strictMode === !0 && (o = !0), i.identifierPrefix !== void 0 && (u = i.identifierPrefix), i.onUncaughtError !== void 0 && (y = i.onUncaughtError), i.onCaughtError !== void 0 && (M = i.onCaughtError), i.onRecoverableError !== void 0 && (G = i.onRecoverableError), i.unstable_transitionCallbacks !== void 0 && (P = i.unstable_transitionCallbacks)), i = Yy(
        e,
        1,
        !1,
        null,
        null,
        o,
        u,
        y,
        M,
        G,
        P,
        null
      ), e[rs] = i.current, Ml(e), new Cd(i);
    }, OD.hydrateRoot = function(e, i, o) {
      if (!E(e))
        throw Error("Target container is not a DOM element.");
      td(e), i === void 0 && console.error(
        "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
      );
      var u = !1, y = "", M = qM, G = Du, P = Mu, W = null, _ = null;
      return o != null && (o.unstable_strictMode === !0 && (u = !0), o.identifierPrefix !== void 0 && (y = o.identifierPrefix), o.onUncaughtError !== void 0 && (M = o.onUncaughtError), o.onCaughtError !== void 0 && (G = o.onCaughtError), o.onRecoverableError !== void 0 && (P = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (W = o.unstable_transitionCallbacks), o.formState !== void 0 && (_ = o.formState)), i = Yy(
        e,
        1,
        !0,
        i,
        o ?? null,
        u,
        y,
        M,
        G,
        P,
        W,
        _
      ), i.context = eA(null), o = i.current, u = He(o), u = PC(u), y = Dt(u), y.callback = null, Mt(o, y, u), o = u, i.current.lanes = o, ct(i, o), et(i), e[rs] = i.current, Ml(e), new ed(i);
    }, OD.version = "19.1.1", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })(), OD;
}
var xY;
function ZN() {
  if (xY) return GB.exports;
  xY = 1;
  var A = {};
  function g() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (A.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(g);
      } catch (I) {
        console.error(I);
      }
    }
  }
  return A.NODE_ENV === "production" ? (g(), GB.exports = YN()) : GB.exports = PN(), GB.exports;
}
var _Y = ZN();
const UY = globalThis, FY = globalThis.process || {}, jN = globalThis.navigator || {};
var XY = {};
function VZ(A) {
  if (typeof window < "u" && window.process?.type === "renderer" || typeof XY < "u" && XY.versions?.electron)
    return !0;
  const I = typeof navigator < "u" && navigator.userAgent;
  return !!(I && I.indexOf("Electron") >= 0);
}
var qm = {};
function Pc() {
  return !// @ts-expect-error
  (typeof qm == "object" && String(qm) === "[object process]" && !qm?.browser) || VZ();
}
function vN(A) {
  return Pc() ? VZ() ? "Electron" : (jN.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const xZ = "4.1.0";
var $m = {};
function QY() {
  let A;
  if (typeof window < "u" && window.performance)
    A = window.performance.now();
  else if (typeof $m < "u" && $m.hrtime) {
    const g = $m.hrtime();
    A = g[0] * 1e3 + g[1] / 1e6;
  } else
    A = Date.now();
  return A;
}
class zY {
  constructor(g, I) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = g, this.type = I, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(g) {
    return this.sampleSize = g, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(g) {
    return this._count += g, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(g) {
    return this._count -= g, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(g) {
    return this._time += g, this.lastTiming = g, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = QY(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(QY() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class Qp {
  constructor(g) {
    this.stats = {}, this.id = g.id, this.stats = {}, this._initializeStats(g.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(g, I = "count") {
    return this._getOrCreate({ name: g, type: I });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const g of Object.values(this.stats))
      g.reset();
    return this;
  }
  forEach(g) {
    for (const I of Object.values(this.stats))
      g(I);
  }
  getTable() {
    const g = {};
    return this.forEach((I) => {
      g[I.name] = {
        time: I.time || 0,
        count: I.count || 0,
        average: I.getAverageTime() || 0,
        hz: I.getHz() || 0
      };
    }), g;
  }
  _initializeStats(g = []) {
    g.forEach((I) => this._getOrCreate(I));
  }
  _getOrCreate(g) {
    const { name: I, type: C } = g;
    let t = this.stats[I];
    return t || (g instanceof zY ? t = g : t = new zY(I, C), this.stats[I] = t), t;
  }
}
class HN {
  stats = /* @__PURE__ */ new Map();
  getStats(g) {
    return this.get(g);
  }
  get(g) {
    return this.stats.has(g) || this.stats.set(g, new Qp({ id: g })), this.stats.get(g);
  }
}
const _Z = new HN();
function EN(A) {
  try {
    const g = window[A], I = "__storage_test__";
    return g.setItem(I, I), g.removeItem(I), g;
  } catch {
    return null;
  }
}
class RN {
  constructor(g, I, C = "sessionStorage") {
    this.storage = EN(C), this.id = g, this.config = I, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(g) {
    if (Object.assign(this.config, g), this.storage) {
      const I = JSON.stringify(this.config);
      this.storage.setItem(this.id, I);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let g = {};
    if (this.storage) {
      const I = this.storage.getItem(this.id);
      g = I ? JSON.parse(I) : {};
    }
    return Object.assign(this.config, g), this;
  }
}
function ON(A) {
  let g;
  return A < 10 ? g = `${A.toFixed(2)}ms` : A < 100 ? g = `${A.toFixed(1)}ms` : A < 1e3 ? g = `${A.toFixed(0)}ms` : g = `${(A / 1e3).toFixed(2)}s`, g;
}
function NN(A, g = 8) {
  const I = Math.max(g - A.length, 0);
  return `${" ".repeat(I)}${A}`;
}
var up;
(function(A) {
  A[A.BLACK = 30] = "BLACK", A[A.RED = 31] = "RED", A[A.GREEN = 32] = "GREEN", A[A.YELLOW = 33] = "YELLOW", A[A.BLUE = 34] = "BLUE", A[A.MAGENTA = 35] = "MAGENTA", A[A.CYAN = 36] = "CYAN", A[A.WHITE = 37] = "WHITE", A[A.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", A[A.BRIGHT_RED = 91] = "BRIGHT_RED", A[A.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", A[A.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", A[A.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", A[A.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", A[A.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", A[A.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(up || (up = {}));
const kN = 10;
function JY(A) {
  return typeof A != "string" ? A : (A = A.toUpperCase(), up[A] || up.WHITE);
}
function WN(A, g, I) {
  return !Pc && typeof A == "string" && (g && (A = `\x1B[${JY(g)}m${A}\x1B[39m`), I && (A = `\x1B[${JY(I) + kN}m${A}\x1B[49m`)), A;
}
function VN(A, g = ["constructor"]) {
  const I = Object.getPrototypeOf(A), C = Object.getOwnPropertyNames(I), t = A;
  for (const s of C) {
    const r = t[s];
    typeof r == "function" && (g.find((l) => s === l) || (t[s] = r.bind(A)));
  }
}
function tG(A, g) {
  if (!A)
    throw new Error("Assertion failed");
}
function Ld() {
  let A;
  if (Pc() && UY.performance)
    A = UY?.performance?.now?.();
  else if ("hrtime" in FY) {
    const g = FY?.hrtime?.();
    A = g[0] * 1e3 + g[1] / 1e6;
  } else
    A = Date.now();
  return A;
}
const qd = {
  debug: Pc() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, xN = {
  enabled: !0,
  level: 0
};
function $d() {
}
const LY = {}, qY = { once: !0 };
class pM {
  constructor({ id: g } = { id: "" }) {
    this.VERSION = xZ, this._startTs = Ld(), this._deltaTs = Ld(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = g, this.userData = {}, this._storage = new RN(`__probe-${this.id}__`, xN), this.timeStamp(`${this.id} started`), VN(this), Object.seal(this);
  }
  set level(g) {
    this.setLevel(g);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((Ld() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((Ld() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(g) {
    this.level = g;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(g = !0) {
    return this._storage.setConfiguration({ enabled: g }), this;
  }
  setLevel(g) {
    return this._storage.setConfiguration({ level: g }), this;
  }
  /** return the current status of the setting */
  get(g) {
    return this._storage.config[g];
  }
  // update the status of the setting
  set(g, I) {
    this._storage.setConfiguration({ [g]: I });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(g, I) {
    if (!g)
      throw new Error(I || "Assertion failed");
  }
  warn(g) {
    return this._getLogFunction(0, g, qd.warn, arguments, qY);
  }
  error(g) {
    return this._getLogFunction(0, g, qd.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(g, I) {
    return this.warn(`\`${g}\` is deprecated and will be removed in a later version. Use \`${I}\` instead`);
  }
  /** Print a removal warning */
  removed(g, I) {
    return this.error(`\`${g}\` has been removed. Use \`${I}\` instead`);
  }
  probe(g, I) {
    return this._getLogFunction(g, I, qd.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(g, I) {
    return this._getLogFunction(g, I, qd.debug, arguments);
  }
  info(g, I) {
    return this._getLogFunction(g, I, console.info, arguments);
  }
  once(g, I) {
    return this._getLogFunction(g, I, qd.debug || qd.info, arguments, qY);
  }
  /** Logs an object as a table */
  table(g, I, C) {
    return I ? this._getLogFunction(g, I, console.table || $d, C && [C], {
      tag: UN(I)
    }) : $d;
  }
  time(g, I) {
    return this._getLogFunction(g, I, console.time ? console.time : console.info);
  }
  timeEnd(g, I) {
    return this._getLogFunction(g, I, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(g, I) {
    return this._getLogFunction(g, I, console.timeStamp || $d);
  }
  group(g, I, C = { collapsed: !1 }) {
    const t = $Y({ logLevel: g, message: I, opts: C }), { collapsed: s } = C;
    return t.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(t);
  }
  groupCollapsed(g, I, C = {}) {
    return this.group(g, I, Object.assign({}, C, { collapsed: !0 }));
  }
  groupEnd(g) {
    return this._getLogFunction(g, "", console.groupEnd || $d);
  }
  // EXPERIMENTAL
  withGroup(g, I, C) {
    this.group(g, I)();
    try {
      C();
    } finally {
      this.groupEnd(g)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(g) {
    return this.isEnabled() && this.getLevel() >= UZ(g);
  }
  _getLogFunction(g, I, C, t, s) {
    if (this._shouldLog(g)) {
      s = $Y({ logLevel: g, message: I, args: t, opts: s }), C = C || s.method, tG(C), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = Ld();
      const r = s.tag || s.message;
      if (s.once && r)
        if (!LY[r])
          LY[r] = Ld();
        else
          return $d;
      return I = _N(this.id, s.message, s), C.bind(console, I, ...s.args);
    }
    return $d;
  }
}
pM.VERSION = xZ;
function UZ(A) {
  if (!A)
    return 0;
  let g;
  switch (typeof A) {
    case "number":
      g = A;
      break;
    case "object":
      g = A.logLevel || A.priority || 0;
      break;
    default:
      return 0;
  }
  return tG(Number.isFinite(g) && g >= 0), g;
}
function $Y(A) {
  const { logLevel: g, message: I } = A;
  A.logLevel = UZ(g);
  const C = A.args ? Array.from(A.args) : [];
  for (; C.length && C.shift() !== I; )
    ;
  switch (typeof g) {
    case "string":
    case "function":
      I !== void 0 && C.unshift(I), A.message = g;
      break;
    case "object":
      Object.assign(A, g);
      break;
  }
  typeof A.message == "function" && (A.message = A.message());
  const t = typeof A.message;
  return tG(t === "string" || t === "object"), Object.assign(A, { args: C }, A.opts);
}
function _N(A, g, I) {
  if (typeof g == "string") {
    const C = I.time ? NN(ON(I.total)) : "";
    g = I.time ? `${A}: ${C}  ${g}` : `${A}: ${g}`, g = WN(g, I.color, I.background);
  }
  return g;
}
function UN(A) {
  for (const g in A)
    for (const I in A[g])
      return I || "untitled";
  return "empty";
}
const xg = new pM({ id: "luma.gl" }), gb = {};
function zp(A = "id") {
  gb[A] = gb[A] || 1;
  const g = gb[A]++;
  return `${A}-${g}`;
}
let dA = class {
  /** Default properties for resource */
  static defaultProps = {
    id: "undefined",
    handle: void 0,
    userData: void 0
  };
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /** props.id, for debugging. */
  id;
  props;
  userData = {};
  _device;
  /** Whether this resource has been destroyed */
  destroyed = !1;
  /** For resources that allocate GPU memory */
  allocatedBytes = 0;
  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
  _attachedResources = /* @__PURE__ */ new Set();
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(g, I, C) {
    if (!g)
      throw new Error("no device");
    this._device = g, this.props = FN(I, C);
    const t = this.props.id !== "undefined" ? this.props.id : zp(this[Symbol.toStringTag]);
    this.props.id = t, this.id = t, this.userData = this.props.userData || {}, this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(g) {
    this._attachedResources.add(g);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(g) {
    this._attachedResources.delete(g);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(g) {
    this._attachedResources.delete(g) && g.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const g of Object.values(this._attachedResources))
      g.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const g = this._device.statsManager.getStats("Resource Counts"), I = this[Symbol.toStringTag];
    g.get(`${I}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(g, I = this[Symbol.toStringTag]) {
    const C = this._device.statsManager.getStats("Resource Counts");
    C.get("GPU Memory").addCount(g), C.get(`${I} Memory`).addCount(g), this.allocatedBytes = g;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(g = this[Symbol.toStringTag]) {
    const I = this._device.statsManager.getStats("Resource Counts");
    I.get("GPU Memory").subtractCount(this.allocatedBytes), I.get(`${g} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const g = this._device.statsManager.getStats("Resource Counts"), I = this[Symbol.toStringTag];
    g.get("Resources Created").incrementCount(), g.get(`${I}s Created`).incrementCount(), g.get(`${I}s Active`).incrementCount();
  }
};
function FN(A, g) {
  const I = { ...g };
  for (const C in A)
    A[C] !== void 0 && (I[C] = A[C]);
  return I;
}
class GA extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: !1
  };
  // Usage Flags
  static MAP_READ = 1;
  static MAP_WRITE = 2;
  static COPY_SRC = 4;
  static COPY_DST = 8;
  /** Index buffer */
  static INDEX = 16;
  /** Vertex buffer */
  static VERTEX = 32;
  /** Uniform buffer */
  static UNIFORM = 64;
  /** Storage buffer */
  static STORAGE = 128;
  static INDIRECT = 256;
  static QUERY_RESOLVE = 512;
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** The usage with which this buffer was created */
  usage;
  /** For index buffers, whether indices are 16 or 32 bit */
  indexType;
  /** "Time" of last update, can be used to check if redraw is needed */
  updateTimestamp;
  constructor(g, I) {
    const C = { ...I };
    (I.usage || 0) & GA.INDEX && !I.indexType && (I.data instanceof Uint32Array ? C.indexType = "uint32" : I.data instanceof Uint16Array && (C.indexType = "uint16")), delete C.data, super(g, C, GA.defaultProps), this.usage = C.usage || 0, this.indexType = C.indexType, this.updateTimestamp = g.incrementTimestamp();
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(g) {
    return this.device.createBuffer({ ...this.props, ...g });
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(g, I) {
    throw new Error("not implemented");
  }
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  static DEBUG_DATA_MAX_LENGTH = 32;
  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
  debugData = new ArrayBuffer(0);
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(g, I, C) {
    const t = ArrayBuffer.isView(g) ? g.buffer : g, s = Math.min(g ? g.byteLength : C, GA.DEBUG_DATA_MAX_LENGTH);
    t === null ? this.debugData = new ArrayBuffer(s) : I === 0 && C === t.byteLength ? this.debugData = t.slice(0, s) : this.debugData = t.slice(I, I + s);
  }
}
function FZ(A) {
  const g = gP[A], I = XN(g), C = A.includes("norm"), t = !C && !A.startsWith("float"), s = A.startsWith("s");
  return {
    dataType: gP[A],
    byteLength: I,
    integer: t,
    signed: s,
    normalized: C
  };
}
function XN(A) {
  return QN[A];
}
const gP = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
}, QN = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
}, me = "texture-compression-bc", lA = "texture-compression-astc", ys = "texture-compression-etc2", zN = "texture-compression-etc1-webgl", YB = "texture-compression-pvrtc-webgl", Ib = "texture-compression-atc-webgl", PB = "float32-renderable-webgl", Ab = "float16-renderable-webgl", JN = "rgb9e5ufloat-renderable-webgl", Cb = "snorm8-renderable-webgl", ND = "norm16-renderable-webgl", eb = "snorm16-renderable-webgl", ZB = "float32-filterable", IP = "float16-filterable-webgl";
function XZ(A) {
  const g = LN[A];
  if (!g)
    throw new Error(`Unsupported texture format ${A}`);
  return g;
}
const LN = {
  // 8-bit formats
  r8unorm: {},
  r8snorm: { render: Cb },
  r8uint: {},
  r8sint: {},
  // 16-bit formats
  rg8unorm: {},
  rg8snorm: { render: Cb },
  rg8uint: {},
  rg8sint: {},
  r16uint: {},
  r16sint: {},
  r16float: { render: Ab, filter: "float16-filterable-webgl" },
  "r16unorm-webgl": { f: ND },
  "r16snorm-webgl": { f: eb },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { channels: "rgba", bitsPerChannel: [4, 4, 4, 4], packed: !0 },
  "rgb565unorm-webgl": { channels: "rgb", bitsPerChannel: [5, 6, 5, 0], packed: !0 },
  "rgb5a1unorm-webgl": { channels: "rgba", bitsPerChannel: [5, 5, 5, 1], packed: !0 },
  // 24-bit formats
  "rgb8unorm-webgl": {},
  "rgb8snorm-webgl": {},
  // 32-bit formats  
  rgba8unorm: {},
  "rgba8unorm-srgb": {},
  rgba8snorm: { render: Cb },
  rgba8uint: {},
  rgba8sint: {},
  // 32-bit, reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: {},
  rg16sint: {},
  rg16float: { render: Ab, filter: IP },
  "rg16unorm-webgl": { render: ND },
  "rg16snorm-webgl": { render: eb },
  r32uint: {},
  r32sint: {},
  r32float: { render: PB, filter: ZB },
  // Packed 32 bit formats
  rgb9e5ufloat: { channels: "rgb", packed: !0, render: JN },
  // , filter: true},
  rg11b10ufloat: { channels: "rgb", bitsPerChannel: [11, 11, 10, 0], packed: !0, p: 1, render: PB },
  rgb10a2unorm: { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: !0, p: 1 },
  "rgb10a2uint-webgl": { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: !0, p: 1, wgpu: !1 },
  // 48-bit formats
  "rgb16unorm-webgl": { f: ND },
  // rgb not renderable
  "rgb16snorm-webgl": { f: ND },
  // rgb not renderable
  // 64-bit formats
  rg32uint: {},
  rg32sint: {},
  rg32float: { render: !1, filter: ZB },
  rgba16uint: {},
  rgba16sint: {},
  rgba16float: { render: Ab, filter: IP },
  "rgba16unorm-webgl": { render: ND },
  "rgba16snorm-webgl": { render: eb },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": { render: PB, filter: ZB },
  // 128-bit formats
  rgba32uint: {},
  rgba32sint: {},
  rgba32float: { render: PB, filter: ZB },
  // Depth/stencil
  // Depth and stencil formats
  stencil8: { attachment: "stencil", bitsPerChannel: [8, 0, 0, 0], dataType: "uint8" },
  depth16unorm: { attachment: "depth", bitsPerChannel: [16, 0, 0, 0], dataType: "uint16" },
  depth24plus: { attachment: "depth", bitsPerChannel: [24, 0, 0, 0], dataType: "uint32" },
  depth32float: { attachment: "depth", bitsPerChannel: [32, 0, 0, 0], dataType: "float32" },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { attachment: "depth-stencil", bitsPerChannel: [24, 8, 0, 0], packed: !0 },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { attachment: "depth-stencil", bitsPerChannel: [32, 8, 0, 0], packed: !0 },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { f: me },
  "bc1-rgb-unorm-srgb-webgl": { f: me },
  "bc1-rgba-unorm": { f: me },
  "bc1-rgba-unorm-srgb": { f: me },
  "bc2-rgba-unorm": { f: me },
  "bc2-rgba-unorm-srgb": { f: me },
  "bc3-rgba-unorm": { f: me },
  "bc3-rgba-unorm-srgb": { f: me },
  "bc4-r-unorm": { f: me },
  "bc4-r-snorm": { f: me },
  "bc5-rg-unorm": { f: me },
  "bc5-rg-snorm": { f: me },
  "bc6h-rgb-ufloat": { f: me },
  "bc6h-rgb-float": { f: me },
  "bc7-rgba-unorm": { f: me },
  "bc7-rgba-unorm-srgb": { f: me },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { f: ys },
  "etc2-rgb8unorm-srgb": { f: ys },
  "etc2-rgb8a1unorm": { f: ys },
  "etc2-rgb8a1unorm-srgb": { f: ys },
  "etc2-rgba8unorm": { f: ys },
  "etc2-rgba8unorm-srgb": { f: ys },
  "eac-r11unorm": { f: ys },
  "eac-r11snorm": { f: ys },
  "eac-rg11unorm": { f: ys },
  "eac-rg11snorm": { f: ys },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { f: lA },
  "astc-4x4-unorm-srgb": { f: lA },
  "astc-5x4-unorm": { f: lA },
  "astc-5x4-unorm-srgb": { f: lA },
  "astc-5x5-unorm": { f: lA },
  "astc-5x5-unorm-srgb": { f: lA },
  "astc-6x5-unorm": { f: lA },
  "astc-6x5-unorm-srgb": { f: lA },
  "astc-6x6-unorm": { f: lA },
  "astc-6x6-unorm-srgb": { f: lA },
  "astc-8x5-unorm": { f: lA },
  "astc-8x5-unorm-srgb": { f: lA },
  "astc-8x6-unorm": { f: lA },
  "astc-8x6-unorm-srgb": { f: lA },
  "astc-8x8-unorm": { f: lA },
  "astc-8x8-unorm-srgb": { f: lA },
  "astc-10x5-unorm": { f: lA },
  "astc-10x5-unorm-srgb": { f: lA },
  "astc-10x6-unorm": { f: lA },
  "astc-10x6-unorm-srgb": { f: lA },
  "astc-10x8-unorm": { f: lA },
  "astc-10x8-unorm-srgb": { f: lA },
  "astc-10x10-unorm": { f: lA },
  "astc-10x10-unorm-srgb": { f: lA },
  "astc-12x10-unorm": { f: lA },
  "astc-12x10-unorm-srgb": { f: lA },
  "astc-12x12-unorm": { f: lA },
  "astc-12x12-unorm-srgb": { f: lA },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { f: YB },
  "pvrtc-rgba4unorm-webgl": { f: YB },
  "pvrtc-rbg2unorm-webgl": { f: YB },
  "pvrtc-rgba2unorm-webgl": { f: YB },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { f: zN },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { f: Ib },
  "atc-rgba-unorm-webgl": { f: Ib },
  "atc-rgbai-unorm-webgl": { f: Ib }
}, qN = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
], $N = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
function QZ(A) {
  return qN.some((g) => A.startsWith(g));
}
function iG(A) {
  let g = g4(A);
  if (QZ(A)) {
    g.channels = "rgb", g.components = 3, g.bytesPerPixel = 1, g.srgb = !1, g.compressed = !0;
    const C = I4(A);
    C && (g.blockWidth = C.blockWidth, g.blockHeight = C.blockHeight);
  }
  const I = $N.exec(A);
  if (I) {
    const [, C, t, s, r, l] = I, d = `${s}${t}`, h = FZ(d), D = h.byteLength * 8, w = C.length, p = [
      D,
      w >= 2 ? D : 0,
      w >= 3 ? D : 0,
      w >= 4 ? D : 0
    ];
    g = {
      format: A,
      attachment: g.attachment,
      dataType: h.dataType,
      components: w,
      channels: C,
      integer: h.integer,
      signed: h.signed,
      normalized: h.normalized,
      bitsPerChannel: p,
      bytesPerPixel: h.byteLength * C.length,
      packed: g.packed,
      srgb: g.srgb
    }, l === "-webgl" && (g.webgl = !0), r === "-srgb" && (g.srgb = !0);
  }
  return A.endsWith("-webgl") && (g.webgl = !0), A.endsWith("-srgb") && (g.srgb = !0), g;
}
function g4(A) {
  const g = XZ(A), I = g.bytesPerPixel || 1, C = g.bitsPerChannel || [8, 8, 8, 8];
  return delete g.bitsPerChannel, delete g.bytesPerPixel, delete g.f, delete g.render, delete g.filter, delete g.blend, delete g.store, {
    ...g,
    format: A,
    attachment: g.attachment || "color",
    channels: g.channels || "r",
    components: g.components || g.channels?.length || 1,
    bytesPerPixel: I,
    bitsPerChannel: C,
    dataType: g.dataType || "uint8",
    srgb: g.srgb ?? !1,
    packed: g.packed ?? !1,
    webgl: g.webgl ?? !1,
    integer: g.integer ?? !1,
    signed: g.signed ?? !1,
    normalized: g.normalized ?? !1,
    compressed: g.compressed ?? !1
  };
}
function I4(A) {
  const I = /.*-(\d+)x(\d+)-.*/.exec(A);
  if (I) {
    const [, C, t] = I;
    return { blockWidth: Number(C), blockHeight: Number(t) };
  }
  return null;
}
function A4(A) {
  const g = XZ(A), I = {
    format: A,
    create: g.f ?? !0,
    render: g.render ?? !0,
    filter: g.filter ?? !0,
    blend: g.blend ?? !0,
    store: g.store ?? !0
  }, C = iG(A), t = A.startsWith("depth") || A.startsWith("stencil"), s = C?.signed, r = C?.integer, l = C?.webgl;
  return I.render &&= !s, I.filter &&= !t && !s && !r && !l, I;
}
class C4 {
}
class e4 {
  features;
  disabledFeatures;
  constructor(g = [], I) {
    this.features = new Set(g), this.disabledFeatures = I || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(g) {
    return !this.disabledFeatures?.[g] && this.features.has(g);
  }
}
class hr {
  static defaultProps = {
    id: null,
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: !1,
    createCanvasContext: void 0,
    // Callbacks
    onError: (g) => xg.error(g.message)(),
    // Experimental
    _reuseDevices: !1,
    _requestMaxLimits: !0,
    _factoryDestroyPolicy: "unused",
    // TODO - Change these after confirming things work as expected
    _initializeFeatures: !0,
    _disabledFeatures: {
      "compilation-status-async-webgl": !0
    },
    _resourceDefaults: {},
    // WebGL specific
    webgl: {},
    debug: xg.get("debug") || void 0,
    debugShaders: xg.get("debug-shaders") || void 0,
    debugFramebuffers: !!xg.get("debug-framebuffers"),
    debugWebGL: !!xg.get("debug-webgl"),
    debugSpectorJS: void 0,
    // Note: log setting is queried by the spector.js code
    debugSpectorJSUrl: void 0,
    // INTERNAL
    _handle: void 0
  };
  get [Symbol.toStringTag]() {
    return "Device";
  }
  constructor(g) {
    this.props = { ...hr.defaultProps, ...g }, this.id = this.props.id || zp(this[Symbol.toStringTag].toLowerCase());
  }
  /** id of this device, primarily for debugging */
  id;
  /** A copy of the device props  */
  props;
  /** Available for the application to store data on the device */
  userData = {};
  /** stats */
  statsManager = _Z;
  /** An abstract timestamp used for change tracking */
  timestamp = 0;
  /** True if this device has been reused during device creation (app has multiple references) */
  _reused = !1;
  /** Used by other luma.gl modules to store data on the device */
  _lumaData = {};
  /** Determines what operations are supported on a texture format, checking against supported device features */
  getTextureFormatCapabilities(g) {
    const I = A4(g), C = (r) => (typeof r == "string" ? this.features.has(r) : r) ?? !0, t = C(I.create), s = {
      format: g,
      create: t,
      render: t && C(I.render),
      filter: t && C(I.filter),
      blend: t && C(I.blend),
      store: t && C(I.store)
    };
    return this._getDeviceSpecificTextureFormatCapabilities(s);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(g, I) {
    return this.getTextureFormatCapabilities(g).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(g) {
    return this.getTextureFormatCapabilities(g).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(g) {
    return this.getTextureFormatCapabilities(g).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(g) {
    return QZ(g);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** Report error (normally called for unhandled device errors) */
  reportError(g) {
    this.props.onError(g);
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    return this.canvasContext;
  }
  createCommandEncoder(g = {}) {
    throw new Error("not implemented");
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(g) {
    this.props.onError(g);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(g, I) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(g, I) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(g) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(g) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(g, I) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(g) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(g) {
    return g.createCanvasContext === !0 ? {} : g.createCanvasContext;
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(g) {
    (g instanceof ArrayBuffer || ArrayBuffer.isView(g)) && (g = { data: g });
    const I = { ...g };
    return (g.usage || 0) & GA.INDEX && !g.indexType && (g.data instanceof Uint32Array ? I.indexType = "uint32" : g.data instanceof Uint16Array ? I.indexType = "uint16" : xg.warn("indices buffer content must be of integer type")()), I;
  }
}
const t4 = Pc() && typeof document < "u", i4 = () => t4 && document.readyState === "complete", n4 = "set luma.log.level=1 (or higher) to trace rendering", AP = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
class rf {
  static defaultProps = {
    ...hr.defaultProps,
    type: "best-available",
    adapters: void 0,
    waitForPageLoad: !0
  };
  /**
   * Page load promise
   * Get a 'lazy' promise that resolves when the DOM is loaded.
   * @note Since there may be limitations on number of `load` event listeners,
   * it is recommended avoid calling this function until actually needed.
   * I.e. don't call it until you know that you will be looking up a string in the DOM.
   */
  static pageLoaded = s4().then(() => {
    xg.probe(2, "DOM is loaded")();
  });
  /** Global stats for all devices */
  stats = _Z;
  /**
   * Global log
   *
   * Assign luma.log.level in console to control logging: \
   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
   */
  log = xg;
  /** Version of luma.gl */
  VERSION = (
    // Version detection using build plugin
    // @ts-expect-error no-undef
    "9.1.9"
  );
  spector;
  preregisteredAdapters = /* @__PURE__ */ new Map();
  constructor() {
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION)
        throw xg.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), xg.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
      xg.error("This version of luma.gl has already been initialized")();
    }
    xg.log(1, `${this.VERSION} - ${n4}`)(), globalThis.luma = this;
  }
  registerAdapters(g) {
    for (const I of g)
      this.preregisteredAdapters.set(I.type, I);
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters(g = []) {
    const I = this.getAdapterMap(g);
    return Array.from(I).map(([, C]) => C).filter((C) => C.isSupported?.()).map((C) => C.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapter(g = []) {
    const I = this.getAdapterMap(g);
    return I.get("webgpu")?.isSupported?.() ? "webgpu" : I.get("webgl")?.isSupported?.() ? "webgl" : null;
  }
  setDefaultDeviceProps(g) {
    Object.assign(rf.defaultProps, g);
  }
  /** Creates a device. Asynchronously. */
  async createDevice(g = {}) {
    g = { ...rf.defaultProps, ...g }, g.waitForPageLoad && await rf.pageLoaded;
    const I = this.getAdapterMap(g.adapters);
    let C = g.type || "";
    C === "best-available" && (C = this.getBestAvailableAdapter(g.adapters) || C);
    const r = await (this.getAdapterMap(g.adapters) || I).get(C)?.create?.(g);
    if (r)
      return r;
    throw new Error(AP);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  async attachDevice(g) {
    const I = this.getAdapterMap(g.adapters);
    let C = "";
    g.handle instanceof WebGL2RenderingContext && (C = "webgl"), g.createCanvasContext && await rf.pageLoaded, g.handle === null && (C = "unknown");
    const s = await I.get(C)?.attach?.(null);
    if (s)
      return s;
    throw new Error(AP);
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2(g = !0, I = []) {
    const t = this.getAdapterMap(I).get("webgl");
    t || xg.warn("enforceWebGL2: webgl adapter not found")(), t?.enforceWebGL2?.(g);
  }
  /** Convert a list of adapters to a map */
  getAdapterMap(g = []) {
    const I = new Map(this.preregisteredAdapters);
    for (const C of g)
      I.set(C.type, C);
    return I;
  }
  // DEPRECATED
  /** @deprecated Use registerAdapters */
  registerDevices(g) {
    xg.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
    for (const I of g) {
      const C = I.adapter;
      C && this.preregisteredAdapters.set(C.type, C);
    }
  }
}
const CS = new rf();
function s4() {
  return i4() || typeof window > "u" ? Promise.resolve() : new Promise((A) => {
    window.addEventListener("load", () => A());
  });
}
class o4 {
}
class nG {
  static defaultProps = {
    canvas: null,
    width: 800,
    // width are height are only used by headless gl
    height: 600,
    useDevicePixels: !0,
    autoResize: !0,
    container: null,
    visible: !0,
    alphaMode: "opaque",
    colorSpace: "srgb"
  };
  id;
  props;
  canvas;
  htmlCanvas;
  offscreenCanvas;
  type;
  width = 1;
  height = 1;
  resizeObserver;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  constructor(g) {
    if (this.props = { ...nG.defaultProps, ...g }, g = this.props, !Pc()) {
      this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
      return;
    }
    if (g.canvas)
      typeof g.canvas == "string" ? this.canvas = r4(g.canvas) : this.canvas = g.canvas;
    else {
      const I = l4(g), C = a4(g?.container || null);
      C.insertBefore(I, C.firstChild), this.canvas = I, g?.visible || (this.canvas.style.visibility = "hidden");
    }
    this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && g.autoResize && (this.resizeObserver = new ResizeObserver((I) => {
      for (const C of I)
        C.target === this.canvas && this.update();
    }), this.resizeObserver.observe(this.canvas));
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(g) {
    return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (g = g === void 0 ? this.props.useDevicePixels : g, !g || g <= 0) ? 1 : g === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : g;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const g = this.getDevicePixelRatio(), I = this.canvas;
        return I.parentElement ? [I.clientWidth * g, I.clientHeight * g] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [g, I] = this.getPixelSize();
    return g / I;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    try {
      const [g] = this.getDrawingBufferSize(), I = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;
      return I ? g / I : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(g, I = !0) {
    const C = this.cssToDeviceRatio(), [t, s] = this.getDrawingBufferSize();
    return c4(g, C, t, s, I);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(g, I = {}) {
    if (!this.htmlCanvas)
      return;
    let C = "width" in I ? I.width : this.htmlCanvas.clientWidth, t = "height" in I ? I.height : this.htmlCanvas.clientHeight;
    (!C || !t) && (xg.log(1, "Canvas clientWidth/clientHeight is 0")(), g = 1, C = this.htmlCanvas.width || 1, t = this.htmlCanvas.height || 1);
    const s = this._canvasSizeInfo;
    if (s.clientWidth !== C || s.clientHeight !== t || s.devicePixelRatio !== g) {
      let r = g;
      const l = Math.floor(C * r), d = Math.floor(t * r);
      if (this.htmlCanvas.width = l, this.htmlCanvas.height = d, this.device.gl) {
        const [D, w] = this.getDrawingBufferSize();
        (D !== l || w !== d) && (r = Math.min(D / C, w / t), this.htmlCanvas.width = Math.floor(C * r), this.htmlCanvas.height = Math.floor(t * r), xg.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = C, this._canvasSizeInfo.clientHeight = t, this._canvasSizeInfo.devicePixelRatio = g;
      }
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const g = this.device.gl;
    return g ? [g.drawingBufferWidth, g.drawingBufferHeight] : this.getPixelSize();
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(g) {
    this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = g);
  }
}
function a4(A) {
  if (typeof A == "string") {
    const g = document.getElementById(A);
    if (!g)
      throw new Error(`${A} is not an HTML element`);
    return g;
  } else if (A)
    return A;
  return document.body;
}
function r4(A) {
  const g = document.getElementById(A);
  if (!(g instanceof HTMLCanvasElement))
    throw new Error("Object is not a canvas element");
  return g;
}
function l4(A) {
  const { width: g, height: I } = A, C = document.createElement("canvas");
  return C.id = zp("lumagl-auto-created-canvas"), C.width = g || 1, C.height = I || 1, C.style.width = Number.isFinite(g) ? `${g}px` : "100%", C.style.height = Number.isFinite(I) ? `${I}px` : "100%", C;
}
function c4(A, g, I, C, t) {
  const s = A, r = CP(s[0], g, I);
  let l = eP(s[1], g, C, t), d = CP(s[0] + 1, g, I);
  const h = d === I - 1 ? d : d - 1;
  d = eP(s[1] + 1, g, C, t);
  let D;
  return t ? (d = d === 0 ? d : d + 1, D = l, l = d) : D = d === C - 1 ? d : d - 1, {
    x: r,
    y: l,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(h - r + 1, 1),
    height: Math.max(D - l + 1, 1)
  };
}
function CP(A, g, I) {
  return Math.min(Math.round(A * g), I - 1);
}
function eP(A, g, I, C) {
  return C ? Math.max(0, I - 1 - Math.round(A * g)) : Math.min(Math.round(A * g), I - 1);
}
class cA extends dA {
  static COPY_SRC = 1;
  static COPY_DST = 2;
  static TEXTURE = 4;
  static STORAGE = 8;
  static RENDER_ATTACHMENT = 16;
  static CubeFaces = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"];
  static defaultProps = {
    ...dA.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: !1,
    compressed: !1,
    usage: 0,
    mipLevels: void 0,
    samples: void 0,
    sampler: {},
    view: void 0,
    flipY: void 0
  };
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /** dimension of this texture */
  dimension;
  /** format of this texture */
  format;
  /** width in pixels of this texture */
  width;
  /** height in pixels of this texture */
  height;
  /** depth of this texture */
  depth;
  /** mip levels in this texture */
  mipLevels;
  /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
  updateTimestamp;
  /** Do not use directly. Create with device.createTexture() */
  constructor(g, I) {
    if (I = cA.normalizeProps(g, I), super(g, I, cA.defaultProps), this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.props.width === void 0 || this.props.height === void 0) {
      const C = cA.getTextureDataSize(this.props.data);
      this.width = C?.width || 1, this.height = C?.height || 1;
    }
    this.props.mipmaps && this.props.mipLevels === void 0 && (this.props.mipLevels = "pyramid"), this.mipLevels = this.props.mipLevels === "pyramid" ? cA.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1, this.updateTimestamp = g.incrementTimestamp();
  }
  /**
   * Create a new texture with the same parameters and optionally, a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(g) {
    return this.device.createTexture({ ...this.props, ...g });
  }
  /** Check if data is an external image */
  static isExternalImage(g) {
    return typeof ImageData < "u" && g instanceof ImageData || typeof ImageBitmap < "u" && g instanceof ImageBitmap || typeof HTMLImageElement < "u" && g instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && g instanceof HTMLVideoElement || typeof VideoFrame < "u" && g instanceof VideoFrame || typeof HTMLCanvasElement < "u" && g instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && g instanceof OffscreenCanvas;
  }
  /** Determine size (width and height) of provided image data */
  static getExternalImageSize(g) {
    if (typeof ImageData < "u" && g instanceof ImageData || typeof ImageBitmap < "u" && g instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && g instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && g instanceof OffscreenCanvas)
      return { width: g.width, height: g.height };
    if (typeof HTMLImageElement < "u" && g instanceof HTMLImageElement)
      return { width: g.naturalWidth, height: g.naturalHeight };
    if (typeof HTMLVideoElement < "u" && g instanceof HTMLVideoElement)
      return { width: g.videoWidth, height: g.videoHeight };
    if (typeof VideoFrame < "u" && g instanceof VideoFrame)
      return { width: g.displayWidth, height: g.displayHeight };
    throw new Error("Unknown image type");
  }
  /** Check if texture data is a typed array */
  static isTextureLevelData(g) {
    const I = g?.data;
    return ArrayBuffer.isView(I);
  }
  /** Get the size of the texture described by the provided TextureData */
  static getTextureDataSize(g) {
    if (!g || ArrayBuffer.isView(g))
      return null;
    if (Array.isArray(g))
      return cA.getTextureDataSize(g[0]);
    if (cA.isExternalImage(g))
      return cA.getExternalImageSize(g);
    if (g && typeof g == "object" && g.constructor === Object) {
      const C = Object.values(g)[0];
      return { width: C.width, height: C.height };
    }
    throw new Error("texture size deduction failed");
  }
  /**
   * Normalize TextureData to an array of TextureLevelData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureLevelData / ExternalImages
   */
  static normalizeTextureData(g, I) {
    let C;
    return ArrayBuffer.isView(g) ? C = [
      {
        // ts-expect-error does data really need to be Uint8ClampedArray?
        data: g,
        width: I.width,
        height: I.height
        // depth: options.depth
      }
    ] : Array.isArray(g) ? C = g : C = [g], C;
  }
  /** Calculate the number of mip levels for a texture of width and height */
  static getMipLevelCount(g, I) {
    return Math.floor(Math.log2(Math.max(g, I))) + 1;
  }
  /** Convert luma.gl cubemap face constants to depth index */
  static getCubeFaceDepth(g) {
    switch (g) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(g);
    }
  }
  /** Default options */
  static defaultCopyExternalImageOptions = {
    image: void 0,
    sourceX: 0,
    sourceY: 0,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all",
    colorSpace: "srgb",
    premultipliedAlpha: !1,
    flipY: !1
  };
  /** Ensure we have integer coordinates */
  static normalizeProps(g, I) {
    const C = { ...I }, t = g?.props?._resourceDefaults?.texture || {};
    Object.assign(C, t);
    const { width: s, height: r } = C;
    return typeof s == "number" && (C.width = Math.max(1, Math.ceil(s))), typeof r == "number" && (C.height = Math.max(1, Math.ceil(r))), C;
  }
}
class Jp extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  };
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(g, I) {
    super(g, I, Jp.defaultProps);
  }
}
function u4(A, g, I) {
  let C = "";
  const t = g.split(/\r?\n/), s = A.slice().sort((r, l) => r.lineNum - l.lineNum);
  switch (I?.showSourceCode || "no") {
    case "all":
      let r = 0;
      for (let l = 1; l <= t.length; l++)
        for (C += zZ(t[l - 1], l, I); s.length > r && s[r].lineNum === l; ) {
          const d = s[r++];
          C += tP(d, t, d.lineNum, {
            ...I,
            inlineSource: !1
          });
        }
      return C;
    case "issues":
    case "no":
      for (const l of A)
        C += tP(l, t, l.lineNum, {
          inlineSource: I?.showSourceCode !== "no"
        });
      return C;
  }
}
function tP(A, g, I, C) {
  if (C?.inlineSource) {
    const s = d4(g, I), r = A.linePos > 0 ? `${" ".repeat(A.linePos + 5)}^^^
` : "";
    return `
${s}${r}${A.type.toUpperCase()}: ${A.message}

`;
  }
  const t = A.type === "error" ? "red" : "#8B4000";
  return C?.html ? `<div class='luma-compiler-log-error' style="color:${t};"><b> ${A.type.toUpperCase()}: ${A.message}</b></div>` : `${A.type.toUpperCase()}: ${A.message}`;
}
function d4(A, g, I) {
  let C = "";
  for (let t = g - 2; t <= g; t++) {
    const s = A[t - 1];
    s !== void 0 && (C += zZ(s, g, I));
  }
  return C;
}
function zZ(A, g, I) {
  const C = I?.html ? h4(A) : A;
  return `${f4(String(g), 4)}: ${C}${I?.html ? "<br/>" : `
`}`;
}
function f4(A, g) {
  let I = "";
  for (let C = A.length; C < g; ++C)
    I += " ";
  return I + A;
}
function h4(A) {
  return A.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
class Lp extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debugShaders: void 0
  };
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** The stage of this shader */
  stage;
  /** The source code of this shader */
  source;
  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
  compilationStatus = "pending";
  /** Create a new Shader instance */
  constructor(g, I) {
    I = { ...I, debugShaders: I.debugShaders || g.props.debugShaders || "errors" }, super(g, { id: y4(I), ...I }, Lp.defaultProps), this.stage = this.props.stage, this.source = this.props.source;
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const g = this.props.debugShaders;
    switch (g) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const I = await this.getCompilationInfo();
    g === "warnings" && I?.length === 0 || this._displayShaderLog(I);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(g) {
    if (typeof document > "u" || !document?.createElement)
      return;
    const I = JZ(this.source), C = `${this.stage} ${I}`;
    let t = u4(g, this.source, { showSourceCode: "all", html: !0 });
    const s = this.getTranslatedSource();
    s && (t += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${s}</pre></code>`);
    const r = document.createElement("Button");
    r.innerHTML = `
<h1>Shader Compilation Error in ${C}</h1><br /><br />
<code style="user-select:text;"><pre>
${t}
</pre></code>`, r.style.top = "10px", r.style.left = "10px", r.style.position = "absolute", r.style.zIndex = "9999", r.style.width = "100%", r.style.textAlign = "left", document.body.appendChild(r), document.getElementsByClassName("luma-compiler-log-error")[0]?.scrollIntoView(), r.onclick = () => {
      const d = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(d);
    };
  }
}
function y4(A) {
  return JZ(A.source) || A.id || zp(`unnamed ${A.stage}-shader`);
}
function JZ(A, g = "unnamed") {
  const C = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(A);
  return C ? C[1] : g;
}
class lM extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "none",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  };
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(g, I) {
    I = lM.normalizeProps(g, I), super(g, I, lM.defaultProps);
  }
  static normalizeProps(g, I) {
    const C = g?.props?._resourceDefaults?.sampler || {};
    return { ...I, ...C };
  }
}
class qp extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  };
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /** Width of all attachments in this framebuffer */
  width;
  /** Height of all attachments in this framebuffer */
  height;
  constructor(g, I = {}) {
    super(g, I, qp.defaultProps), this.width = this.props.width, this.height = this.props.height;
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(g) {
    const I = this.colorAttachments.map((t) => t.texture.clone(g)), C = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(g);
    return this.device.createFramebuffer({ ...this.props, colorAttachments: I, depthStencilAttachment: C });
  }
  resize(g) {
    let I = !g;
    if (g) {
      const [C, t] = Array.isArray(g) ? g : [g.width, g.height];
      I = I || t !== this.height || C !== this.width, this.width = C, this.height = t;
    }
    I && (xg.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((I, C) => {
      if (typeof I == "string") {
        const t = this.createColorTexture(I, C);
        return this.attachResource(t), t.view;
      }
      return I instanceof cA ? I.view : I;
    });
    const g = this.props.depthStencilAttachment;
    if (g)
      if (typeof g == "string") {
        const I = this.createDepthStencilTexture(g);
        this.attachResource(I), this.depthStencilAttachment = I.view;
      } else g instanceof cA ? this.depthStencilAttachment = g.view : this.depthStencilAttachment = g;
  }
  /** Create a color texture */
  createColorTexture(g, I) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${I}`,
      usage: cA.RENDER_ATTACHMENT,
      format: g,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(g) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: cA.RENDER_ATTACHMENT,
      format: g,
      width: this.width,
      height: this.height,
      mipmaps: !1
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(g, I) {
    for (let C = 0; C < this.colorAttachments.length; ++C)
      if (this.colorAttachments[C]) {
        const t = this.colorAttachments[C].texture.clone({
          width: g,
          height: I
        });
        this.destroyAttachedResource(this.colorAttachments[C]), this.colorAttachments[C] = t.view, this.attachResource(t.view);
      }
    if (this.depthStencilAttachment) {
      const C = this.depthStencilAttachment.texture.clone({
        width: g,
        height: I
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = C.view, this.attachResource(C);
    }
    this.updateAttachments();
  }
}
class mf extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    // isInstanced: false,
    // instanceCount: 0,
    // vertexCount: 0,
    bindings: {},
    uniforms: {}
  };
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  /** The merged layout */
  shaderLayout;
  /** Buffer map describing buffer interleaving etc */
  bufferLayout;
  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
  linkStatus = "pending";
  /** The hash of the pipeline */
  hash = "";
  constructor(g, I) {
    super(g, I, mf.defaultProps), this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(g) {
    throw new Error("Use uniform blocks");
  }
}
class rc extends dA {
  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
  static defaultClearColor = [0, 0, 0, 1];
  /** Depth 1.0 represents the far plance */
  static defaultClearDepth = 1;
  /** Clears all stencil bits */
  static defaultClearStencil = 0;
  /** Default properties for RenderPass */
  static defaultProps = {
    ...dA.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: rc.defaultClearColor,
    clearColors: void 0,
    clearDepth: rc.defaultClearDepth,
    clearStencil: rc.defaultClearStencil,
    depthReadOnly: !1,
    stencilReadOnly: !1,
    discard: !1,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  };
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(g, I) {
    I = rc.normalizeProps(g, I), super(g, I, rc.defaultProps);
  }
  static normalizeProps(g, I) {
    return { ...g.props._resourceDefaults?.renderPass, ...I };
  }
}
class dp extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  };
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
  hash = "";
  /** The merged shader layout */
  shaderLayout;
  constructor(g, I) {
    super(g, I, dp.defaultProps), this.shaderLayout = I.shaderLayout;
  }
}
class sG extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    measureExecutionTime: void 0
  };
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(g, I) {
    super(g, I, sG.defaultProps);
  }
}
class oG extends dA {
  static defaultProps = {
    ...dA.defaultProps
  };
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(g, I) {
    super(g, I, oG.defaultProps);
  }
}
function D4(A) {
  const [g, I] = w4[A], C = g === "i32" || g === "u32", t = g !== "u32", s = B4[g] * I, r = M4(g, I);
  return {
    dataType: g,
    components: I,
    defaultVertexFormat: r,
    byteLength: s,
    integer: C,
    signed: t
  };
}
function M4(A, g) {
  let I;
  switch (A) {
    case "f32":
      I = "float32";
      break;
    case "i32":
      I = "sint32";
      break;
    case "u32":
      I = "uint32";
      break;
    case "f16":
      return g <= 2 ? "float16x2" : "float16x4";
  }
  return g === 1 ? I : `${I}x${g}`;
}
const w4 = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, B4 = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function LZ(A) {
  let g;
  A.endsWith("-webgl") && (A.replace("-webgl", ""), g = !0);
  const [I, C] = A.split("x"), t = I, s = C ? parseInt(C) : 1, r = FZ(t), l = {
    type: t,
    components: s,
    byteLength: r.byteLength * s,
    integer: r.integer,
    signed: r.signed,
    normalized: r.normalized
  };
  return g && (l.webglOnly = !0), l;
}
function qZ(A, g) {
  const I = {};
  for (const C of A.attributes) {
    const t = m4(A, g, C.name);
    t && (I[C.name] = t);
  }
  return I;
}
function p4(A, g, I = 16) {
  const C = qZ(A, g), t = new Array(I).fill(null);
  for (const s of Object.values(C))
    t[s.location] = s;
  return t;
}
function m4(A, g, I) {
  const C = b4(A, I), t = S4(g, I);
  if (!C)
    return null;
  const s = D4(C.type), r = t?.vertexFormat || s.defaultVertexFormat, l = LZ(r);
  return {
    attributeName: t?.attributeName || C.name,
    bufferName: t?.bufferName || C.name,
    location: C.location,
    shaderType: C.type,
    shaderDataType: s.dataType,
    shaderComponents: s.components,
    vertexFormat: r,
    bufferDataType: l.type,
    bufferComponents: l.components,
    // normalized is a property of the buffer's vertex format
    normalized: l.normalized,
    // integer is a property of the shader declaration
    integer: s.integer,
    stepMode: t?.stepMode || C.stepMode || "vertex",
    byteOffset: t?.byteOffset || 0,
    byteStride: t?.byteStride || 0
  };
}
function b4(A, g) {
  const I = A.attributes.find((C) => C.name === g);
  return I || xg.warn(`shader layout attribute "${g}" not present in shader`), I || null;
}
function S4(A, g) {
  G4(A);
  let I = K4(A, g);
  return I || (I = T4(A, g), I) ? I : (xg.warn(`layout for attribute "${g}" not present in buffer layout`), null);
}
function G4(A) {
  for (const g of A)
    (g.attributes && g.format || !g.attributes && !g.format) && xg.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function K4(A, g) {
  for (const I of A)
    if (I.format && I.name === g)
      return {
        attributeName: I.name,
        bufferName: g,
        stepMode: I.stepMode,
        vertexFormat: I.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: I.byteStride || 0
      };
  return null;
}
function T4(A, g) {
  for (const I of A) {
    let C = I.byteStride;
    if (typeof I.byteStride != "number")
      for (const s of I.attributes || []) {
        const r = LZ(s.format);
        C += r.byteLength;
      }
    const t = I.attributes?.find((s) => s.attribute === g);
    if (t)
      return {
        attributeName: t.attribute,
        bufferName: I.name,
        stepMode: I.stepMode,
        vertexFormat: t.format,
        byteOffset: t.byteOffset,
        // @ts-ignore
        byteStride: C
      };
  }
  return null;
}
class aG extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    renderPipeline: null
  };
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** Max number of vertex attributes */
  maxVertexAttributes;
  /** Attribute infos indexed by location - TODO only needed by webgl module? */
  attributeInfos;
  /** Index buffer */
  indexBuffer = null;
  /** Attributes indexed by buffer slot */
  attributes;
  constructor(g, I) {
    super(g, I, aG.defaultProps), this.maxVertexAttributes = g.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null);
    const { shaderLayout: C, bufferLayout: t } = I.renderPipeline || {};
    if (!C || !t)
      throw new Error("VertexArray");
    this.attributeInfos = p4(C, t, this.maxVertexAttributes);
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(g, I) {
    this.device.reportError(new Error("constant attributes not supported"));
  }
}
class rG extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    layout: void 0,
    buffers: {}
  };
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(g, I) {
    super(g, I, rG.defaultProps);
  }
}
class lG extends dA {
  static defaultProps = {
    ...dA.defaultProps,
    type: void 0,
    count: void 0
  };
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(g, I) {
    super(g, I, lG.defaultProps);
  }
}
const Y4 = {
  f32: { type: "f32", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 }
};
function P4(A) {
  return Y4[A];
}
function Z4(A, g) {
  switch (g) {
    case 1:
      return A;
    // Pad upwards to even multiple of 2
    case 2:
      return A + A % 2;
    // Pad upwards to even multiple of 2
    default:
      return A + (4 - A % 4) % 4;
  }
}
let jB;
function $Z(A) {
  return (!jB || jB.byteLength < A) && (jB = new ArrayBuffer(A)), jB;
}
function j4(A, g) {
  const I = $Z(A.BYTES_PER_ELEMENT * g);
  return new A(I, 0, g);
}
function v4(A) {
  return ArrayBuffer.isView(A) && !(A instanceof DataView);
}
function fp(A) {
  return Array.isArray(A) ? A.length === 0 || typeof A[0] == "number" : v4(A);
}
const iP = 1024;
class H4 {
  layout = {};
  /** number of bytes needed for buffer allocation */
  byteLength;
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(g) {
    let I = 0;
    for (const [t, s] of Object.entries(g)) {
      const r = P4(s), { type: l, components: d } = r;
      I = Z4(I, d);
      const h = I;
      I += d, this.layout[t] = { type: l, size: d, offset: h };
    }
    I += (4 - I % 4) % 4;
    const C = I * 4;
    this.byteLength = Math.max(C, iP);
  }
  /** Get the data for the complete buffer */
  getData(g) {
    const I = Math.max(this.byteLength, iP), C = $Z(I), t = {
      i32: new Int32Array(C),
      u32: new Uint32Array(C),
      f32: new Float32Array(C),
      // TODO not implemented
      f16: new Uint16Array(C)
    };
    for (const [s, r] of Object.entries(g)) {
      const l = this.layout[s];
      if (!l) {
        xg.warn(`Supplied uniform value ${s} not present in uniform block layout`)();
        continue;
      }
      const { type: d, size: h, offset: D } = l, w = t[d];
      if (h === 1) {
        if (typeof r != "number" && typeof r != "boolean") {
          xg.warn(`Supplied value for single component uniform ${s} is not a number: ${r}`)();
          continue;
        }
        w[D] = Number(r);
      } else {
        if (!fp(r)) {
          xg.warn(`Supplied value for multi component / array uniform ${s} is not a numeric array: ${r}`)();
          continue;
        }
        w.set(r, D);
      }
    }
    return new Uint8Array(C);
  }
  /** Does this layout have a field with specified name */
  has(g) {
    return !!this.layout[g];
  }
  /** Get offset and size for a field with specified name */
  get(g) {
    return this.layout[g];
  }
}
function E4(A, g, I = 16) {
  if (A !== g)
    return !1;
  const C = A, t = g;
  if (!fp(C))
    return !1;
  if (fp(t) && C.length === t.length) {
    for (let s = 0; s < C.length; ++s)
      if (t[s] !== C[s])
        return !1;
  }
  return !0;
}
function R4(A) {
  return fp(A) ? A.slice() : A;
}
class O4 {
  name;
  uniforms = {};
  modifiedUniforms = {};
  modified = !0;
  bindingLayout = {};
  needsRedraw = "initialized";
  constructor(g) {
    if (this.name = g?.name || "unnamed", g?.name && g?.shaderLayout) {
      const I = g?.shaderLayout.bindings?.find((t) => t.type === "uniform" && t.name === g?.name);
      if (!I)
        throw new Error(g?.name);
      const C = I;
      for (const t of C.uniforms || [])
        this.bindingLayout[t.name] = t;
    }
  }
  /** Set a map of uniforms */
  setUniforms(g) {
    for (const [I, C] of Object.entries(g))
      this._setUniform(I, C), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${I}=${C}`);
  }
  setNeedsRedraw(g) {
    this.needsRedraw = this.needsRedraw || g;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(g, I) {
    E4(this.uniforms[g], I) || (this.uniforms[g] = R4(I), this.modifiedUniforms[g] = !0, this.modified = !0);
  }
}
class N4 {
  /** Stores the uniform values for each uniform block */
  uniformBlocks = /* @__PURE__ */ new Map();
  /** Can generate data for a uniform buffer for each block from data */
  uniformBufferLayouts = /* @__PURE__ */ new Map();
  /** Actual buffer for the blocks */
  uniformBuffers = /* @__PURE__ */ new Map();
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(g) {
    for (const [I, C] of Object.entries(g)) {
      const t = I, s = new H4(C.uniformTypes || {});
      this.uniformBufferLayouts.set(t, s);
      const r = new O4({ name: I });
      r.setUniforms(C.defaultUniforms || {}), this.uniformBlocks.set(t, r);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const g of this.uniformBuffers.values())
      g.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(g) {
    for (const [I, C] of Object.entries(g))
      this.uniformBlocks.get(I)?.setUniforms(C);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(g) {
    return this.uniformBufferLayouts.get(g)?.byteLength || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(g) {
    const I = this.uniformBlocks.get(g)?.getAllUniforms() || {};
    return this.uniformBufferLayouts.get(g)?.getData(I);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(g, I, C) {
    C && this.setUniforms(C);
    const t = this.getUniformBufferByteLength(I), s = g.createBuffer({
      usage: GA.UNIFORM | GA.COPY_DST,
      byteLength: t
    }), r = this.getUniformBufferData(I);
    return s.write(r), s;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(g, I) {
    if (!this.uniformBuffers.get(I)) {
      const C = this.getUniformBufferByteLength(I), t = g.createBuffer({
        usage: GA.UNIFORM | GA.COPY_DST,
        byteLength: C
      });
      this.uniformBuffers.set(I, t);
    }
    return this.uniformBuffers.get(I);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let g = !1;
    for (const I of this.uniformBlocks.keys()) {
      const C = this.updateUniformBuffer(I);
      g ||= C;
    }
    return g && xg.log(3, `UniformStore.updateUniformBuffers(): ${g}`)(), g;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(g) {
    const I = this.uniformBlocks.get(g);
    let C = this.uniformBuffers.get(g), t = !1;
    if (C && I?.needsRedraw) {
      t ||= I.needsRedraw;
      const s = this.getUniformBufferData(g);
      C = this.uniformBuffers.get(g), C?.write(s);
      const r = this.uniformBlocks.get(g)?.getAllUniforms();
      xg.log(4, `Writing to uniform buffer ${String(g)}`, s, r)();
    }
    return t;
  }
}
function gj(A) {
  const g = ArrayBuffer.isView(A) ? A.constructor : A;
  switch (g) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(g.constructor.name);
  }
}
function Ij(A) {
  switch (A) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(A);
  }
}
function k4(A, g, I) {
  if (!g || g > 4)
    throw new Error(`size ${g}`);
  const C = g;
  let t = gj(A);
  if (t === "uint8" && I && C === 1)
    return "unorm8-webgl";
  if (t === "uint8" && I && C === 3)
    return "unorm8x3-webgl";
  if (t === "uint8" || t === "sint8") {
    if (C === 1 || C === 3)
      throw new Error(`size: ${g}`);
    return I && (t = t.replace("int", "norm")), `${t}x${C}`;
  }
  if (t === "uint16" || t === "sint16") {
    if (C === 1 || C === 3)
      throw new Error(`size: ${g}`);
    return I && (t = t.replace("int", "norm")), `${t}x${C}`;
  }
  return C === 1 ? t : `${t}x${C}`;
}
class tb {
  bufferLayouts;
  constructor(g) {
    this.bufferLayouts = g;
  }
  getBufferLayout(g) {
    return this.bufferLayouts.find((I) => I.name === g) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(g) {
    return g.attributes ? g.attributes?.map((I) => I.attribute) : [g.name];
  }
  mergeBufferLayouts(g, I) {
    const C = [...g];
    for (const t of I) {
      const s = C.findIndex((r) => r.name === t.name);
      s < 0 ? C.push(t) : C[s] = t;
    }
    return C;
  }
  getBufferIndex(g) {
    const I = this.bufferLayouts.findIndex((C) => C.name === g);
    return I === -1 && xg.warn(`BufferLayout: Missing buffer for "${g}".`)(), I;
  }
}
function W4(A, g) {
  const I = Object.fromEntries(A.attributes.map((t) => [t.name, t.location])), C = g.slice();
  return C.sort((t, s) => {
    const r = t.attributes ? t.attributes.map((D) => D.attribute) : [t.name], l = s.attributes ? s.attributes.map((D) => D.attribute) : [s.name], d = Math.min(...r.map((D) => I[D])), h = Math.min(...l.map((D) => I[D]));
    return d - h;
  }), C;
}
const hp = {
  target: [0, 0, 0],
  rotationX: 60,
  rotationOrbit: 0,
  minZoom: -10,
  maxZoom: 10,
  zoom: 1
}, V4 = {
  target: [0, 0, 0],
  zoom: 1,
  minZoom: -10,
  maxZoom: 10
}, nP = 2, x4 = ({
  onLoad: A,
  // setCategoryColors,
  updateViewState: g,
  setInitialCamera: I,
  setActiveZoom: C,
  annotationConfig: t,
  annotationBins: s
}) => {
  const [r, l] = Z.useState(!1), [d, h] = Z.useState(null), [D, w] = Z.useState(
    null
  ), [p, b] = Z.useState(/* @__PURE__ */ new Set()), S = Z.useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Y) => {
      console.time("Data load");
      const T = Y.header, E = Y.attributes.POSITION, H = new Float64Array(E.value.length);
      for (let J = 0; J < E.value.length; J++)
        H[J] = E.value[J];
      Y.attributes.POSITION.value = H;
      const R = Y.attributes.COLOR_0.value, x = Y.attributes.classification?.value, U = t?.DefaultAnnoType ?? "__default__";
      if (Y.extData = {
        originalColor: R,
        numeric: null,
        annotations: x ? { [U]: x } : {},
        POSITION: Y.attributes.POSITION
      }, Y.attributes.COLOR_0 = void 0, Y.attributes.POSITION = void 0, T.boundingBox) {
        const [J, L] = T.boundingBox;
        g({
          ...hp,
          target: [
            (J[0] + L[0]) / 2,
            (J[1] + L[1]) / 2,
            (J[2] + L[2]) / 2
          ],
          zoom: Math.log2(window.innerWidth / (L[0] - J[0])) - 1
        }), I({
          ...hp,
          target: [
            (J[0] + L[0]) / 2,
            (J[1] + L[1]) / 2,
            (J[2] + L[2]) / 2
          ],
          zoom: Math.log2(window.innerWidth / (L[0] - J[0])) - 1
        }), h(Y), l(!0), C("standard");
      }
      A && A({ count: T.vertexCount, progress: 1 }), console.timeEnd("Data load");
    },
    [
      t?.DefaultAnnoType,
      A,
      C,
      I,
      g
    ]
  );
  Z.useEffect(() => {
    if (!d || !t) return;
    const Y = d.extData, T = Y.annotations ??= {}, E = t.DefaultAnnoType;
    if (T.__default__ && !T[E] && (T[E] = T.__default__, delete T.__default__), s)
      for (const x of t.AvailableAnnoTypes)
        !T[x] && s[x] && (T[x] = s[x]);
    b(new Set(Object.keys(T)));
    const H = t.AnnoMaps?.[E]?.Items ?? [];
    if (H.some((x) => x.Color == null) && T[E] && Y.originalColor) {
      const x = T[E], U = {}, J = Y.originalColor;
      for (let L = 0; L < x.length; L++) {
        const eg = x[L];
        if (U[eg] !== void 0) continue;
        const Mg = L * 4;
        if (U[eg] = [
          J[Mg],
          J[Mg + 1],
          J[Mg + 2]
        ], Object.keys(U).length >= H.length) break;
      }
    }
  }, [d, t, s]);
  const K = Z.useCallback(
    (Y, T) => {
      const E = T || d;
      if (E) {
        if (!Y) {
          E.extData.numeric = null, w(null), h({ ...E });
          return;
        }
        E.extData.numeric = Y, w(Y), h({ ...E });
      }
    },
    [d]
  );
  return {
    isLoaded: r,
    loadedData: d,
    loadedAnnotations: p,
    loadNumericField: K,
    onDataLoad: S,
    numericField: D,
    setLoadedData: h
  };
};
function yp(A, g) {
  if (!A)
    throw new Error(g || "loader assertion failed.");
}
var yf = {};
const cG = (
  // @ts-ignore process does not exist on browser
  !!(typeof yf != "object" || String(yf) !== "[object process]" || yf.browser)
), sP = typeof yf < "u" && yf.version && /v([0-9]*)/.exec(yf.version);
sP && parseFloat(sP[1]);
const ib = "4.3.3", _4 = ib[0] >= "0" && ib[0] <= "9" ? `v${ib}` : "";
function U4() {
  const A = new pM({ id: "loaders.gl" });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = A, globalThis.loaders.version = _4, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = A, A;
}
const F4 = U4();
function X4(A, g) {
  return Aj(A || {}, g);
}
function Aj(A, g, I = 0) {
  if (I > 3)
    return g;
  const C = { ...A };
  for (const [t, s] of Object.entries(g))
    s && typeof s == "object" && !Array.isArray(s) ? C[t] = Aj(C[t] || {}, g[t], I + 1) : C[t] = g[t];
  return C;
}
const Q4 = "latest";
function z4() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.3"), globalThis._loadersgl_.version;
}
const J4 = z4();
function Dr(A, g) {
  if (!A)
    throw new Error(g || "loaders.gl assertion failed.");
}
var Df = {};
const uc = (
  // @ts-ignore process.browser
  typeof Df != "object" || String(Df) !== "[object process]" || Df.browser
), L4 = typeof window < "u" && typeof window.orientation < "u", oP = typeof Df < "u" && Df.version && /v([0-9]*)/.exec(Df.version);
oP && parseFloat(oP[1]);
class q4 {
  name;
  workerThread;
  isRunning = !0;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(g, I) {
    this.name = g, this.workerThread = I, this.result = new Promise((C, t) => {
      this._resolve = C, this._reject = t;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(g, I) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: g,
      payload: I
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(g) {
    Dr(this.isRunning), this.isRunning = !1, this._resolve(g);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(g) {
    Dr(this.isRunning), this.isRunning = !1, this._reject(g);
  }
}
class nb {
  terminate() {
  }
}
const sb = /* @__PURE__ */ new Map();
function $4(A) {
  Dr(A.source && !A.url || !A.source && A.url);
  let g = sb.get(A.source || A.url);
  return g || (A.url && (g = gk(A.url), sb.set(A.url, g)), A.source && (g = Cj(A.source), sb.set(A.source, g))), Dr(g), g;
}
function gk(A) {
  if (!A.startsWith("http"))
    return A;
  const g = Ik(A);
  return Cj(g);
}
function Cj(A) {
  const g = new Blob([A], { type: "application/javascript" });
  return URL.createObjectURL(g);
}
function Ik(A) {
  return `try {
  importScripts('${A}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function ej(A, g = !0, I) {
  const C = I || /* @__PURE__ */ new Set();
  if (A) {
    if (aP(A))
      C.add(A);
    else if (aP(A.buffer))
      C.add(A.buffer);
    else if (!ArrayBuffer.isView(A)) {
      if (g && typeof A == "object")
        for (const t in A)
          ej(A[t], g, C);
    }
  }
  return I === void 0 ? Array.from(C) : [];
}
function aP(A) {
  return A ? A instanceof ArrayBuffer || typeof MessagePort < "u" && A instanceof MessagePort || typeof ImageBitmap < "u" && A instanceof ImageBitmap || typeof OffscreenCanvas < "u" && A instanceof OffscreenCanvas : !1;
}
const ob = () => {
};
class eS {
  name;
  source;
  url;
  terminated = !1;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && uc || typeof nb < "u" && !uc;
  }
  constructor(g) {
    const { name: I, source: C, url: t } = g;
    Dr(C || t), this.name = I, this.source = C, this.url = t, this.onMessage = ob, this.onError = (s) => console.log(s), this.worker = uc ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = ob, this.onError = ob, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(g, I) {
    I = I || ej(g), this.worker.postMessage(g, I);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(g) {
    let I = "Failed to load ";
    return I += `worker ${this.name} from ${this.url}. `, g.message && (I += `${g.message} in `), g.lineno && (I += `:${g.lineno}:${g.colno}`), new Error(I);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = $4({ source: this.source, url: this.url });
    const g = new Worker(this._loadableURL, { name: this.name });
    return g.onmessage = (I) => {
      I.data ? this.onMessage(I.data) : this.onError(new Error("No data received"));
    }, g.onerror = (I) => {
      this.onError(this._getErrorFromErrorEvent(I)), this.terminated = !0;
    }, g.onmessageerror = (I) => console.error(I), g;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let g;
    if (this.url) {
      const C = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      g = new nb(C, { eval: !1 });
    } else if (this.source)
      g = new nb(this.source, { eval: !0 });
    else
      throw new Error("no worker");
    return g.on("message", (I) => {
      this.onMessage(I);
    }), g.on("error", (I) => {
      this.onError(I);
    }), g.on("exit", (I) => {
    }), g;
  }
}
class Ak {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = !0;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = !1;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return eS.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(g) {
    this.source = g.source, this.url = g.url, this.setProps(g);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((g) => g.destroy()), this.isDestroyed = !0;
  }
  setProps(g) {
    this.props = { ...this.props, ...g }, g.name !== void 0 && (this.name = g.name), g.maxConcurrency !== void 0 && (this.maxConcurrency = g.maxConcurrency), g.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = g.maxMobileConcurrency), g.reuseWorkers !== void 0 && (this.reuseWorkers = g.reuseWorkers), g.onDebug !== void 0 && (this.onDebug = g.onDebug);
  }
  async startJob(g, I = (t, s, r) => t.done(r), C = (t, s) => t.error(s)) {
    const t = new Promise((s) => (this.jobQueue.push({ name: g, onMessage: I, onError: C, onStart: s }), this));
    return this._startQueuedJob(), await t;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const g = this._getAvailableWorker();
    if (!g)
      return;
    const I = this.jobQueue.shift();
    if (I) {
      this.onDebug({
        message: "Starting job",
        name: I.name,
        workerThread: g,
        backlog: this.jobQueue.length
      });
      const C = new q4(I.name, g);
      g.onMessage = (t) => I.onMessage(C, t.type, t.payload), g.onError = (t) => I.onError(C, t), I.onStart(C);
      try {
        await C.result;
      } catch (t) {
        console.error(`Worker exception: ${t}`);
      } finally {
        this.returnWorkerToQueue(g);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(g) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !uc || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (g.destroy(), this.count--) : this.idleQueue.push(g), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const g = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new eS({ name: g, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return L4 ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const Ck = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class ur {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return eS.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(g = {}) {
    return ur._workerFarm = ur._workerFarm || new ur({}), ur._workerFarm.setProps(g), ur._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(g) {
    this.props = { ...Ck }, this.setProps(g), this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const g of this.workerPools.values())
      g.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(g) {
    this.props = { ...this.props, ...g };
    for (const I of this.workerPools.values())
      I.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(g) {
    const { name: I, source: C, url: t } = g;
    let s = this.workerPools.get(I);
    return s || (s = new Ak({
      name: I,
      source: C,
      url: t
    }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(I, s)), s;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
function ek(A, g = {}) {
  const I = g[A.id] || {}, C = uc ? `${A.id}-worker.js` : `${A.id}-worker-node.js`;
  let t = I.workerUrl;
  if (!t && A.id === "compression" && (t = g.workerUrl), g._workerType === "test" && (uc ? t = `modules/${A.module}/dist/${C}` : t = `modules/${A.module}/src/workers/${A.id}-worker-node.ts`), !t) {
    let s = A.version;
    s === "latest" && (s = Q4);
    const r = s ? `@${s}` : "";
    t = `https://unpkg.com/@loaders.gl/${A.module}${r}/dist/${C}`;
  }
  return Dr(t), t;
}
function tk(A, g = J4) {
  Dr(A, "no worker provided");
  const I = A.version;
  return !(!g || !I);
}
function ik(A, g) {
  return !ur.isSupported() || !uc && !g?._nodeWorkers ? !1 : A.worker && g?.worker;
}
async function nk(A, g, I, C, t) {
  const s = A.id, r = ek(A, I), d = ur.getWorkerFarm(I).getWorkerPool({ name: s, url: r });
  I = JSON.parse(JSON.stringify(I)), C = JSON.parse(JSON.stringify(C || {}));
  const h = await d.startJob(
    "process-on-worker",
    // @ts-expect-error
    sk.bind(null, t)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return h.postMessage("process", {
    // @ts-ignore
    input: g,
    options: I,
    context: C
  }), await (await h.result).result;
}
async function sk(A, g, I, C) {
  switch (I) {
    case "done":
      g.done(C);
      break;
    case "error":
      g.error(new Error(C.error));
      break;
    case "process":
      const { id: t, input: s, options: r } = C;
      try {
        const l = await A(s, r);
        g.postMessage("done", { id: t, result: l });
      } catch (l) {
        const d = l instanceof Error ? l.message : "unknown error";
        g.postMessage("error", { id: t, error: d });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${I}`);
  }
}
function ok(A, g, I) {
  if (I = I || A.byteLength, A.byteLength < I || g.byteLength < I)
    return !1;
  const C = new Uint8Array(A), t = new Uint8Array(g);
  for (let s = 0; s < C.length; ++s)
    if (C[s] !== t[s])
      return !1;
  return !0;
}
function ak(...A) {
  return rk(A);
}
function rk(A) {
  const g = A.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), I = g.reduce((s, r) => s + r.byteLength, 0), C = new Uint8Array(I);
  let t = 0;
  for (const s of g)
    C.set(s, t), t += s.byteLength;
  return C.buffer;
}
async function lk(A) {
  const g = [];
  for await (const I of A)
    g.push(I);
  return ak(...g);
}
let ck = "";
const rP = {};
function uk(A) {
  for (const g in rP)
    if (A.startsWith(g)) {
      const I = rP[g];
      A = A.replace(g, I);
    }
  return !A.startsWith("http://") && !A.startsWith("https://") && (A = `${ck}${A}`), A;
}
function dk(A) {
  return A && typeof A == "object" && A.isBuffer;
}
function tj(A) {
  if (dk(A))
    return A;
  if (A instanceof ArrayBuffer)
    return A;
  if (ArrayBuffer.isView(A))
    return A.byteOffset === 0 && A.byteLength === A.buffer.byteLength ? A.buffer : A.buffer.slice(A.byteOffset, A.byteOffset + A.byteLength);
  if (typeof A == "string") {
    const g = A;
    return new TextEncoder().encode(g).buffer;
  }
  if (A && typeof A == "object" && A._toArrayBuffer)
    return A._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function ij(A) {
  const g = A ? A.lastIndexOf("/") : -1;
  return g >= 0 ? A.substr(g + 1) : "";
}
function fk(A) {
  const g = A ? A.lastIndexOf("/") : -1;
  return g >= 0 ? A.substr(0, g) : "";
}
const hk = (A) => typeof A == "boolean", CM = (A) => typeof A == "function", mM = (A) => A !== null && typeof A == "object", lP = (A) => mM(A) && A.constructor === {}.constructor, yk = (A) => !!A && typeof A[Symbol.iterator] == "function", Dk = (A) => A && typeof A[Symbol.asyncIterator] == "function", Zc = (A) => typeof Response < "u" && A instanceof Response || A && A.arrayBuffer && A.text && A.json, jc = (A) => typeof Blob < "u" && A instanceof Blob, Mk = (A) => A && typeof A == "object" && A.isBuffer, wk = (A) => typeof ReadableStream < "u" && A instanceof ReadableStream || mM(A) && CM(A.tee) && CM(A.cancel) && CM(A.getReader), Bk = (A) => mM(A) && CM(A.read) && CM(A.pipe) && hk(A.readable), nj = (A) => wk(A) || Bk(A);
class pk extends Error {
  constructor(g, I) {
    super(g), this.reason = I.reason, this.url = I.url, this.response = I.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
}
const mk = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, bk = /^([-\w.]+\/[-\w.+]+)/;
function cP(A, g) {
  return A.toLowerCase() === g.toLowerCase();
}
function Sk(A) {
  const g = bk.exec(A);
  return g ? g[1] : A;
}
function uP(A) {
  const g = mk.exec(A);
  return g ? g[1] : "";
}
const sj = /\?.*/;
function Gk(A) {
  const g = A.match(sj);
  return g && g[0];
}
function uG(A) {
  return A.replace(sj, "");
}
function Kk(A) {
  if (A.length < 50)
    return A;
  const g = A.slice(A.length - 15);
  return `${A.substr(0, 32)}...${g}`;
}
function $p(A) {
  return Zc(A) ? A.url : jc(A) ? A.name || "" : typeof A == "string" ? A : "";
}
function dG(A) {
  if (Zc(A)) {
    const g = A, I = g.headers.get("content-type") || "", C = uG(g.url);
    return Sk(I) || uP(C);
  }
  return jc(A) ? A.type || "" : typeof A == "string" ? uP(A) : "";
}
function Tk(A) {
  return Zc(A) ? A.headers["content-length"] || -1 : jc(A) ? A.size : typeof A == "string" ? A.length : A instanceof ArrayBuffer || ArrayBuffer.isView(A) ? A.byteLength : -1;
}
async function oj(A) {
  if (Zc(A))
    return A;
  const g = {}, I = Tk(A);
  I >= 0 && (g["content-length"] = String(I));
  const C = $p(A), t = dG(A);
  t && (g["content-type"] = t);
  const s = await Zk(A);
  s && (g["x-first-bytes"] = s), typeof A == "string" && (A = new TextEncoder().encode(A));
  const r = new Response(A, { headers: g });
  return Object.defineProperty(r, "url", { value: C }), r;
}
async function Yk(A) {
  if (!A.ok)
    throw await Pk(A);
}
async function Pk(A) {
  const g = Kk(A.url);
  let I = `Failed to fetch resource (${A.status}) ${A.statusText}: ${g}`;
  I = I.length > 100 ? `${I.slice(0, 100)}...` : I;
  const C = {
    reason: A.statusText,
    url: A.url,
    response: A
  };
  try {
    const t = A.headers.get("Content-Type");
    C.reason = !A.bodyUsed && t?.includes("application/json") ? await A.json() : await A.text();
  } catch {
  }
  return new pk(I, C);
}
async function Zk(A) {
  if (typeof A == "string")
    return `data:,${A.slice(0, 5)}`;
  if (A instanceof Blob) {
    const I = A.slice(0, 5);
    return await new Promise((C) => {
      const t = new FileReader();
      t.onload = (s) => C(s?.target?.result), t.readAsDataURL(I);
    });
  }
  if (A instanceof ArrayBuffer) {
    const I = A.slice(0, 5);
    return `data:base64,${jk(I)}`;
  }
  return null;
}
function jk(A) {
  let g = "";
  const I = new Uint8Array(A);
  for (let C = 0; C < I.byteLength; C++)
    g += String.fromCharCode(I[C]);
  return btoa(g);
}
function vk(A) {
  return !Hk(A) && !Ek(A);
}
function Hk(A) {
  return A.startsWith("http:") || A.startsWith("https:");
}
function Ek(A) {
  return A.startsWith("data:");
}
async function dP(A, g) {
  if (typeof A == "string") {
    const I = uk(A);
    return vk(I) && globalThis.loaders?.fetchNode ? globalThis.loaders?.fetchNode(I, g) : await fetch(I, g);
  }
  return await oj(A);
}
const fP = new pM({ id: "loaders.gl" });
class Rk {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class Ok {
  console;
  constructor() {
    this.console = console;
  }
  log(...g) {
    return this.console.log.bind(this.console, ...g);
  }
  info(...g) {
    return this.console.info.bind(this.console, ...g);
  }
  warn(...g) {
    return this.console.warn.bind(this.console, ...g);
  }
  error(...g) {
    return this.console.error.bind(this.console, ...g);
  }
}
const aj = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new Ok(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: cG,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, Nk = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function rj() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders: A } = globalThis;
  return A._state || (A._state = {}), A._state;
}
function lj() {
  const A = rj();
  return A.globalOptions = A.globalOptions || { ...aj }, A.globalOptions;
}
function kk(A, g, I, C) {
  return I = I || [], I = Array.isArray(I) ? I : [I], Wk(A, I), xk(g, A, C);
}
function Wk(A, g) {
  hP(A, null, aj, Nk, g);
  for (const I of g) {
    const C = A && A[I.id] || {}, t = I.options && I.options[I.id] || {}, s = I.deprecatedOptions && I.deprecatedOptions[I.id] || {};
    hP(C, I.id, t, s, g);
  }
}
function hP(A, g, I, C, t) {
  const s = g || "Top level", r = g ? `${g}.` : "";
  for (const l in A) {
    const d = !g && mM(A[l]), h = l === "baseUri" && !g, D = l === "workerUrl" && g;
    if (!(l in I) && !h && !D) {
      if (l in C)
        fP.warn(`${s} loader option '${r}${l}' no longer supported, use '${C[l]}'`)();
      else if (!d) {
        const w = Vk(l, t);
        fP.warn(`${s} loader option '${r}${l}' not recognized. ${w}`)();
      }
    }
  }
}
function Vk(A, g) {
  const I = A.toLowerCase();
  let C = "";
  for (const t of g)
    for (const s in t.options) {
      if (A === s)
        return `Did you mean '${t.id}.${s}'?`;
      const r = s.toLowerCase();
      (I.startsWith(r) || r.startsWith(I)) && (C = C || `Did you mean '${t.id}.${s}'?`);
    }
  return C;
}
function xk(A, g, I) {
  const t = { ...A.options || {} };
  return _k(t, I), t.log === null && (t.log = new Rk()), yP(t, lj()), yP(t, g), t;
}
function yP(A, g) {
  for (const I in g)
    if (I in g) {
      const C = g[I];
      lP(C) && lP(A[I]) ? A[I] = {
        ...A[I],
        ...g[I]
      } : A[I] = g[I];
    }
}
function _k(A, g) {
  g && !("baseUri" in A) && (A.baseUri = g);
}
function fG(A) {
  return A ? (Array.isArray(A) && (A = A[0]), Array.isArray(A?.extensions)) : !1;
}
function hG(A) {
  yp(A, "null loader"), yp(fG(A), "invalid loader");
  let g;
  return Array.isArray(A) && (g = A[1], A = A[0], A = {
    ...A,
    options: { ...A.options, ...g }
  }), (A?.parseTextSync || A?.parseText) && (A.text = !0), A.text || (A.binary = !0), A;
}
const cj = () => {
  const A = rj();
  return A.loaderRegistry = A.loaderRegistry || [], A.loaderRegistry;
};
function Uk(A) {
  const g = cj();
  A = Array.isArray(A) ? A : [A];
  for (const I of A) {
    const C = hG(I);
    g.find((t) => C === t) || g.unshift(C);
  }
}
function Fk() {
  return cj();
}
const Xk = /\.([^.]+)$/;
async function Qk(A, g = [], I, C) {
  if (!uj(A))
    return null;
  let t = DP(A, g, { ...I, nothrow: !0 }, C);
  if (t)
    return t;
  if (jc(A) && (A = await A.slice(0, 10).arrayBuffer(), t = DP(A, g, I, C)), !t && !I?.nothrow)
    throw new Error(dj(A));
  return t;
}
function DP(A, g = [], I, C) {
  if (!uj(A))
    return null;
  if (g && !Array.isArray(g))
    return hG(g);
  let t = [];
  g && (t = t.concat(g)), I?.ignoreRegisteredLoaders || t.push(...Fk()), Jk(t);
  const s = zk(A, t, I, C);
  if (!s && !I?.nothrow)
    throw new Error(dj(A));
  return s;
}
function zk(A, g, I, C) {
  const t = $p(A), s = dG(A), r = uG(t) || C?.url;
  let l = null, d = "";
  return I?.mimeType && (l = ab(g, I?.mimeType), d = `match forced by supplied MIME type ${I?.mimeType}`), l = l || Lk(g, r), d = d || (l ? `matched url ${r}` : ""), l = l || ab(g, s), d = d || (l ? `matched MIME type ${s}` : ""), l = l || $k(g, A), d = d || (l ? `matched initial data ${fj(A)}` : ""), I?.fallbackMimeType && (l = l || ab(g, I?.fallbackMimeType), d = d || (l ? `matched fallback MIME type ${s}` : "")), d && F4.log(1, `selectLoader selected ${l?.name}: ${d}.`), l;
}
function uj(A) {
  return !(A instanceof Response && A.status === 204);
}
function dj(A) {
  const g = $p(A), I = dG(A);
  let C = "No valid loader found (";
  C += g ? `${ij(g)}, ` : "no url provided, ", C += `MIME type: ${I ? `"${I}"` : "not provided"}, `;
  const t = A ? fj(A) : "";
  return C += t ? ` first bytes: "${t}"` : "first bytes: not available", C += ")", C;
}
function Jk(A) {
  for (const g of A)
    hG(g);
}
function Lk(A, g) {
  const I = g && Xk.exec(g), C = I && I[1];
  return C ? qk(A, C) : null;
}
function qk(A, g) {
  g = g.toLowerCase();
  for (const I of A)
    for (const C of I.extensions)
      if (C.toLowerCase() === g)
        return I;
  return null;
}
function ab(A, g) {
  for (const I of A)
    if (I.mimeTypes?.some((C) => cP(g, C)) || cP(g, `application/x.${I.id}`))
      return I;
  return null;
}
function $k(A, g) {
  if (!g)
    return null;
  for (const I of A)
    if (typeof g == "string") {
      if (gW(g, I))
        return I;
    } else if (ArrayBuffer.isView(g)) {
      if (MP(g.buffer, g.byteOffset, I))
        return I;
    } else if (g instanceof ArrayBuffer && MP(g, 0, I))
      return I;
  return null;
}
function gW(A, g) {
  return g.testText ? g.testText(A) : (Array.isArray(g.tests) ? g.tests : [g.tests]).some((C) => A.startsWith(C));
}
function MP(A, g, I) {
  return (Array.isArray(I.tests) ? I.tests : [I.tests]).some((t) => IW(A, g, I, t));
}
function IW(A, g, I, C) {
  if (C instanceof ArrayBuffer)
    return ok(C, A, C.byteLength);
  switch (typeof C) {
    case "function":
      return C(A);
    case "string":
      const t = tS(A, g, C.length);
      return C === t;
    default:
      return !1;
  }
}
function fj(A, g = 5) {
  return typeof A == "string" ? A.slice(0, g) : ArrayBuffer.isView(A) ? tS(A.buffer, A.byteOffset, g) : A instanceof ArrayBuffer ? tS(A, 0, g) : "";
}
function tS(A, g, I) {
  if (A.byteLength < g + I)
    return "";
  const C = new DataView(A);
  let t = "";
  for (let s = 0; s < I; s++)
    t += String.fromCharCode(C.getUint8(g + s));
  return t;
}
const AW = 256 * 1024;
function* CW(A, g) {
  const I = g?.chunkSize || AW;
  let C = 0;
  const t = new TextEncoder();
  for (; C < A.length; ) {
    const s = Math.min(A.length - C, I), r = A.slice(C, C + s);
    C += s, yield t.encode(r);
  }
}
const eW = 256 * 1024;
function* tW(A, g = {}) {
  const { chunkSize: I = eW } = g;
  let C = 0;
  for (; C < A.byteLength; ) {
    const t = Math.min(A.byteLength - C, I), s = new ArrayBuffer(t), r = new Uint8Array(A, C, t);
    new Uint8Array(s).set(r), C += t, yield s;
  }
}
const iW = 1024 * 1024;
async function* nW(A, g) {
  const I = g?.chunkSize || iW;
  let C = 0;
  for (; C < A.size; ) {
    const t = C + I, s = await A.slice(C, t).arrayBuffer();
    C = t, yield s;
  }
}
function wP(A, g) {
  return cG ? sW(A, g) : oW(A);
}
async function* sW(A, g) {
  const I = A.getReader();
  let C;
  try {
    for (; ; ) {
      const t = C || I.read();
      g?._streamReadAhead && (C = I.read());
      const { done: s, value: r } = await t;
      if (s)
        return;
      yield tj(r);
    }
  } catch {
    I.releaseLock();
  }
}
async function* oW(A, g) {
  for await (const I of A)
    yield tj(I);
}
function aW(A, g) {
  if (typeof A == "string")
    return CW(A, g);
  if (A instanceof ArrayBuffer)
    return tW(A, g);
  if (jc(A))
    return nW(A, g);
  if (nj(A))
    return wP(A, g);
  if (Zc(A))
    return wP(A.body, g);
  throw new Error("makeIterator");
}
const hj = "Cannot convert supplied data type";
function rW(A, g, I) {
  if (g.text && typeof A == "string")
    return A;
  if (Mk(A) && (A = A.buffer), A instanceof ArrayBuffer) {
    const C = A;
    return g.text && !g.binary ? new TextDecoder("utf8").decode(C) : C;
  }
  if (ArrayBuffer.isView(A)) {
    if (g.text && !g.binary)
      return new TextDecoder("utf8").decode(A);
    let C = A.buffer;
    const t = A.byteLength || A.length;
    return (A.byteOffset !== 0 || t !== C.byteLength) && (C = C.slice(A.byteOffset, A.byteOffset + t)), C;
  }
  throw new Error(hj);
}
async function lW(A, g, I) {
  const C = A instanceof ArrayBuffer || ArrayBuffer.isView(A);
  if (typeof A == "string" || C)
    return rW(A, g);
  if (jc(A) && (A = await oj(A)), Zc(A)) {
    const t = A;
    return await Yk(t), g.binary ? await t.arrayBuffer() : await t.text();
  }
  if (nj(A) && (A = aW(A, I)), yk(A) || Dk(A))
    return lk(A);
  throw new Error(hj);
}
function yj(A, g) {
  const I = lj(), C = A || I;
  return typeof C.fetch == "function" ? C.fetch : mM(C.fetch) ? (t) => dP(t, C.fetch) : g?.fetch ? g?.fetch : dP;
}
function cW(A, g, I) {
  if (I)
    return I;
  const C = {
    fetch: yj(g, A),
    ...A
  };
  if (C.url) {
    const t = uG(C.url);
    C.baseUrl = t, C.queryString = Gk(C.url), C.filename = ij(t), C.baseUrl = fk(t);
  }
  return Array.isArray(C.loaders) || (C.loaders = null), C;
}
function uW(A, g) {
  if (A && !Array.isArray(A))
    return A;
  let I;
  if (A && (I = Array.isArray(A) ? A : [A]), g && g.loaders) {
    const C = Array.isArray(g.loaders) ? g.loaders : [g.loaders];
    I = I ? [...I, ...C] : C;
  }
  return I && I.length ? I : void 0;
}
async function Dp(A, g, I, C) {
  g && !Array.isArray(g) && !fG(g) && (C = void 0, I = g, g = void 0), A = await A, I = I || {};
  const t = $p(A), r = uW(g, C), l = await Qk(A, r, I);
  return l ? (I = kk(I, l, r, t), C = cW(
    // @ts-expect-error
    { url: t, _parse: Dp, loaders: r },
    I,
    C || null
  ), await dW(l, A, I, C)) : null;
}
async function dW(A, g, I, C) {
  if (tk(A), I = X4(A.options, I), Zc(g)) {
    const s = g, { ok: r, redirected: l, status: d, statusText: h, type: D, url: w } = s, p = Object.fromEntries(s.headers.entries());
    C.response = { headers: p, ok: r, redirected: l, status: d, statusText: h, type: D, url: w };
  }
  g = await lW(g, A, I);
  const t = A;
  if (t.parseTextSync && typeof g == "string")
    return t.parseTextSync(g, I, C);
  if (ik(A, I))
    return await nk(A, g, I, C, Dp);
  if (t.parseText && typeof g == "string")
    return await t.parseText(g, I, C);
  if (t.parse)
    return await t.parse(g, I, C);
  throw Dr(!t.parseSync), new Error(`${A.id} loader - no parser found and worker is disabled`);
}
async function iS(A, g, I, C) {
  let t, s;
  !Array.isArray(g) && !fG(g) ? (t = [], s = g) : (t = g, s = I);
  const r = yj(s);
  let l = A;
  return typeof A == "string" && (l = await r(A)), jc(A) && (l = await r(A)), Array.isArray(t) ? await Dp(l, t, s) : await Dp(l, t, s);
}
const fW = "4.3.3", hW = globalThis.loaders?.parseImageNode, nS = typeof Image < "u", sS = typeof ImageBitmap < "u", yW = !!hW, oS = cG ? !0 : yW;
function DW(A) {
  switch (A) {
    case "auto":
      return sS || nS || oS;
    case "imagebitmap":
      return sS;
    case "image":
      return nS;
    case "data":
      return oS;
    default:
      throw new Error(`@loaders.gl/images: image ${A} not supported in this environment`);
  }
}
function MW() {
  if (sS)
    return "imagebitmap";
  if (nS)
    return "image";
  if (oS)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function wW(A) {
  const g = pW(A);
  if (!g)
    throw new Error("Not an image");
  return g;
}
function BW(A) {
  switch (wW(A)) {
    case "data":
      return A;
    case "image":
    case "imagebitmap":
      const g = document.createElement("canvas"), I = g.getContext("2d");
      if (!I)
        throw new Error("getImageData");
      return g.width = A.width, g.height = A.height, I.drawImage(A, 0, 0), I.getImageData(0, 0, A.width, A.height);
    default:
      throw new Error("getImageData");
  }
}
function pW(A) {
  return typeof ImageBitmap < "u" && A instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && A instanceof Image ? "image" : A && typeof A == "object" && A.data && A.width && A.height ? "data" : null;
}
const mW = /^data:image\/svg\+xml/, bW = /\.svg((\?|#).*)?$/;
function yG(A) {
  return A && (mW.test(A) || bW.test(A));
}
function SW(A, g) {
  if (yG(g)) {
    let C = new TextDecoder().decode(A);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (C = unescape(encodeURIComponent(C)));
    } catch (s) {
      throw new Error(s.message);
    }
    return `data:image/svg+xml;base64,${btoa(C)}`;
  }
  return Dj(A, g);
}
function Dj(A, g) {
  if (yG(g))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(A)]);
}
async function Mj(A, g, I) {
  const C = SW(A, I), t = self.URL || self.webkitURL, s = typeof C != "string" && t.createObjectURL(C);
  try {
    return await GW(s || C, g);
  } finally {
    s && t.revokeObjectURL(s);
  }
}
async function GW(A, g) {
  const I = new Image();
  return I.src = A, g.image && g.image.decode && I.decode ? (await I.decode(), I) : await new Promise((C, t) => {
    try {
      I.onload = () => C(I), I.onerror = (s) => {
        const r = s instanceof Error ? s.message : "error";
        t(new Error(r));
      };
    } catch (s) {
      t(s);
    }
  });
}
const KW = {};
let BP = !0;
async function TW(A, g, I) {
  let C;
  yG(I) ? C = await Mj(A, g, I) : C = Dj(A, I);
  const t = g && g.imagebitmap;
  return await YW(C, t);
}
async function YW(A, g = null) {
  if ((PW(g) || !BP) && (g = null), g)
    try {
      return await createImageBitmap(A, g);
    } catch (I) {
      console.warn(I), BP = !1;
    }
  return await createImageBitmap(A);
}
function PW(A) {
  for (const g in A || KW)
    return !1;
  return !0;
}
function ZW(A) {
  return !EW(A, "ftyp", 4) || (A[8] & 96) === 0 ? null : jW(A);
}
function jW(A) {
  switch (vW(A, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function vW(A, g, I) {
  return String.fromCharCode(...A.slice(g, I));
}
function HW(A) {
  return [...A].map((g) => g.charCodeAt(0));
}
function EW(A, g, I = 0) {
  const C = HW(g);
  for (let t = 0; t < C.length; ++t)
    if (C[t] !== A[t + I])
      return !1;
  return !0;
}
const ws = !1, eM = !0;
function wj(A) {
  const g = bM(A);
  return OW(g) || WW(g) || NW(g) || kW(g) || RW(g);
}
function RW(A) {
  const g = new Uint8Array(A instanceof DataView ? A.buffer : A), I = ZW(g);
  return I ? {
    mimeType: I.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function OW(A) {
  const g = bM(A);
  return g.byteLength >= 24 && g.getUint32(0, ws) === 2303741511 ? {
    mimeType: "image/png",
    width: g.getUint32(16, ws),
    height: g.getUint32(20, ws)
  } : null;
}
function NW(A) {
  const g = bM(A);
  return g.byteLength >= 10 && g.getUint32(0, ws) === 1195984440 ? {
    mimeType: "image/gif",
    width: g.getUint16(6, eM),
    height: g.getUint16(8, eM)
  } : null;
}
function kW(A) {
  const g = bM(A);
  return g.byteLength >= 14 && g.getUint16(0, ws) === 16973 && g.getUint32(2, eM) === g.byteLength ? {
    mimeType: "image/bmp",
    width: g.getUint32(18, eM),
    height: g.getUint32(22, eM)
  } : null;
}
function WW(A) {
  const g = bM(A);
  if (!(g.byteLength >= 3 && g.getUint16(0, ws) === 65496 && g.getUint8(2) === 255))
    return null;
  const { tableMarkers: C, sofMarkers: t } = VW();
  let s = 2;
  for (; s + 9 < g.byteLength; ) {
    const r = g.getUint16(s, ws);
    if (t.has(r))
      return {
        mimeType: "image/jpeg",
        height: g.getUint16(s + 5, ws),
        // Number of lines
        width: g.getUint16(s + 7, ws)
        // Number of pixels per line
      };
    if (!C.has(r))
      return null;
    s += 2, s += g.getUint16(s, ws);
  }
  return null;
}
function VW() {
  const A = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let I = 65504; I < 65520; ++I)
    A.add(I);
  return { tableMarkers: A, sofMarkers: /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]) };
}
function bM(A) {
  if (A instanceof DataView)
    return A;
  if (ArrayBuffer.isView(A))
    return new DataView(A.buffer);
  if (A instanceof ArrayBuffer)
    return new DataView(A);
  throw new Error("toDataView");
}
async function xW(A, g) {
  const { mimeType: I } = wj(A) || {}, C = globalThis.loaders?.parseImageNode;
  return yp(C), await C(A, I);
}
async function _W(A, g, I) {
  g = g || {};
  const t = (g.image || {}).type || "auto", { url: s } = I || {}, r = UW(t);
  let l;
  switch (r) {
    case "imagebitmap":
      l = await TW(A, g, s);
      break;
    case "image":
      l = await Mj(A, g, s);
      break;
    case "data":
      l = await xW(A);
      break;
    default:
      yp(!1);
  }
  return t === "data" && (l = BW(l)), l;
}
function UW(A) {
  switch (A) {
    case "auto":
    case "data":
      return MW();
    default:
      return DW(A), A;
  }
}
const FW = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], XW = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
], QW = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, zW = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: fW,
  mimeTypes: XW,
  extensions: FW,
  parse: _W,
  // TODO: byteOffset, byteLength;
  tests: [(A) => !!wj(new DataView(A))],
  options: QW
}, uA = new pM({ id: "deck" }), ir = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, rb = 1, kD = 2, lb = 3, cb = 4, JW = 2, LW = (A) => ({
  /* Layer events */
  "layer.changeFlag": (g, I, C) => {
    A.log(lb, `${g.id} ${I}: `, C[I])();
  },
  "layer.initialize": (g) => {
    A.log(rb, `Initializing ${g}`)();
  },
  "layer.update": (g, I) => {
    if (I) {
      const C = g.getChangeFlags();
      A.log(kD, `Updating ${g} because: ${Object.keys(C).filter((t) => C[t]).join(", ")}`)();
    } else
      A.log(cb, `${g} does not need update`)();
  },
  "layer.matched": (g, I) => {
    I && A.log(cb, `Matched ${g}, state transfered`)();
  },
  "layer.finalize": (g) => {
    A.log(rb, `Finalizing ${g}`)();
  },
  /* CompositeLayer events */
  "compositeLayer.renderLayers": (g, I, C) => {
    I ? A.log(kD, `Composite layer rendered new subLayers ${g}`, C)() : A.log(cb, `Composite layer reused subLayers ${g}`, C)();
  },
  /* LayerManager events */
  "layerManager.setLayers": (g, I, C) => {
    I && A.log(kD, `Updating ${C.length} deck layers`)();
  },
  "layerManager.activateViewport": (g, I) => {
    A.log(lb, "Viewport changed", I)();
  },
  /* AttributeManager events */
  "attributeManager.invalidate": (g, I, C) => {
    A.log(rb, C ? `invalidated attributes ${C} (${I}) for ${g.id}` : `invalidated all attributes for ${g.id}`)();
  },
  "attributeManager.updateStart": (g) => {
    ir.attributeUpdateMessages.length = 0, ir.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (g, I) => {
    const C = Math.round(Date.now() - ir.attributeManagerUpdateStart);
    A.groupCollapsed(kD, `Updated attributes for ${I} instances in ${g.id} in ${C}ms`)();
    for (const t of ir.attributeUpdateMessages)
      A.log(lb, t)();
    A.groupEnd(kD)();
  },
  /* Attribute events */
  "attribute.updateStart": (g) => {
    ir.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (g, I) => {
    const C = `${g.id} allocated ${I}`;
    ir.attributeUpdateMessages.push(C);
  },
  "attribute.updateEnd": (g, I) => {
    const C = Math.round(Date.now() - ir.attributeUpdateStart), t = `${g.id} updated ${I} in ${C}ms`;
    ir.attributeUpdateMessages.push(t);
  },
  /* Render events */
  "deckRenderer.renderLayers": (g, I, C) => {
    const { pass: t, redrawReason: s, stats: r } = C;
    for (const l of I) {
      const { totalCount: d, visibleCount: h, compositeCount: D, pickableCount: w } = l, b = d - D - h;
      A.log(JW, `RENDER #${g.renderCount}   ${h} (of ${d} layers) to ${t} because ${s}   (${b} hidden, ${D} composite ${w} pickable)`)(), r && r.get("Redraw Layers").add(h);
    }
  }
});
var qW = {};
let Mp = {};
qW.NODE_ENV !== "production" && (Mp = LW(uA));
function $W(A) {
  Mp = A;
}
function Xe(A, g, I, C) {
  uA.level > 0 && Mp[A] && Mp[A].call(null, g, I, C);
}
function gV(A) {
  const g = A[0], I = A[A.length - 1];
  return g === "{" && I === "}" || g === "[" && I === "]";
}
const IV = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: gV,
  parseTextSync: JSON.parse
};
function AV() {
  const A = "9.1.14", g = globalThis.deck && globalThis.deck.VERSION;
  if (g && g !== A)
    throw new Error(`deck.gl - multiple versions detected: ${g} vs ${A}`);
  return g || (uA.log(1, `deck.gl ${A}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: A,
    version: A,
    log: uA,
    // experimental
    _registerLoggers: $W
  }, Uk([
    IV,
    // @ts-expect-error non-standard Loader format
    [zW, { imagebitmap: { premultiplyAlpha: "none" } }]
  ])), A;
}
const CV = AV();
function DG(A, g) {
  if (!A)
    throw new Error(g || "shadertools: assertion failed.");
}
const ub = {
  number: {
    type: "number",
    validate(A, g) {
      return Number.isFinite(A) && typeof g == "object" && (g.max === void 0 || A <= g.max) && (g.min === void 0 || A >= g.min);
    }
  },
  array: {
    type: "array",
    validate(A, g) {
      return Array.isArray(A) || ArrayBuffer.isView(A);
    }
  }
};
function eV(A) {
  const g = {};
  for (const [I, C] of Object.entries(A))
    g[I] = tV(C);
  return g;
}
function tV(A) {
  let g = pP(A);
  if (g !== "object")
    return { value: A, ...ub[g], type: g };
  if (typeof A == "object")
    return A ? A.type !== void 0 ? { ...A, ...ub[A.type], type: A.type } : A.value === void 0 ? { type: "object", value: A } : (g = pP(A.value), { ...A, ...ub[g], type: g }) : { type: "object", value: null };
  throw new Error("props");
}
function pP(A) {
  return Array.isArray(A) || ArrayBuffer.isView(A) ? "array" : typeof A;
}
const iV = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
), nV = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
), sV = {
  vertex: iV,
  fragment: nV
}, mP = /void\s+main\s*\([^)]*\)\s*\{\n?/, bP = /}\n?[^{}]*$/, db = [], Ap = "__LUMA_INJECT_DECLARATIONS__";
function oV(A) {
  const g = { vertex: {}, fragment: {} };
  for (const I in A) {
    let C = A[I];
    const t = aV(I);
    typeof C == "string" && (C = {
      order: 0,
      injection: C
    }), g[t][I] = C;
  }
  return g;
}
function aV(A) {
  const g = A.slice(0, 2);
  switch (g) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(g);
  }
}
function wp(A, g, I, C = !1) {
  const t = g === "vertex";
  for (const s in I) {
    const r = I[s];
    r.sort((d, h) => d.order - h.order), db.length = r.length;
    for (let d = 0, h = r.length; d < h; ++d)
      db[d] = r[d].injection;
    const l = `${db.join(`
`)}
`;
    switch (s) {
      // declarations are injected before the main function
      case "vs:#decl":
        t && (A = A.replace(Ap, l));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        t && (A = A.replace(mP, (d) => d + l));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        t && (A = A.replace(bP, (d) => l + d));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        t || (A = A.replace(Ap, l));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        t || (A = A.replace(mP, (d) => d + l));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        t || (A = A.replace(bP, (d) => l + d));
        break;
      default:
        A = A.replace(s, (d) => d + l);
    }
  }
  return A = A.replace(Ap, ""), C && (A = A.replace(/\}\s*$/, (s) => s + sV[g])), A;
}
function Bp(A) {
  A.map((g) => rV(g));
}
function rV(A) {
  if (A.instance)
    return;
  Bp(A.dependencies || []);
  const {
    propTypes: g = {},
    deprecations: I = [],
    // defines = {},
    inject: C = {}
  } = A, t = {
    normalizedInjections: oV(C),
    parsedDeprecations: lV(I)
  };
  g && (t.propValidators = eV(g)), A.instance = t;
  let s = {};
  g && (s = Object.entries(g).reduce((r, [l, d]) => {
    const h = d?.value;
    return h && (r[l] = h), r;
  }, {})), A.defaultUniforms = { ...A.defaultUniforms, ...s };
}
function Bj(A, g, I) {
  A.deprecations?.forEach((C) => {
    C.regex?.test(g) && (C.deprecated ? I.deprecated(C.old, C.new)() : I.removed(C.old, C.new)());
  });
}
function lV(A) {
  return A.forEach((g) => {
    switch (g.type) {
      case "function":
        g.regex = new RegExp(`\\b${g.old}\\(`);
        break;
      default:
        g.regex = new RegExp(`${g.type} ${g.old};`);
    }
  }), A;
}
function MG(A) {
  Bp(A);
  const g = {}, I = {};
  pj({ modules: A, level: 0, moduleMap: g, moduleDepth: I });
  const C = Object.keys(I).sort((t, s) => I[s] - I[t]).map((t) => g[t]);
  return Bp(C), C;
}
function pj(A) {
  const { modules: g, level: I, moduleMap: C, moduleDepth: t } = A;
  if (I >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const s of g)
    C[s.name] = s, (t[s.name] === void 0 || t[s.name] < I) && (t[s.name] = I);
  for (const s of g)
    s.dependencies && pj({ modules: s.dependencies, level: I + 1, moduleMap: C, moduleDepth: t });
}
function cV(A) {
  switch (A?.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}
function uV(A, g) {
  if (Number(A.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (g) {
    case "vertex":
      return A = SP(A, dV), A;
    case "fragment":
      return A = SP(A, fV), A;
    default:
      throw new Error(g);
  }
}
const mj = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], dV = [
  ...mj,
  // `attribute` keyword replaced with `in`
  [aS("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [aS("varying"), "out $1"]
], fV = [
  ...mj,
  // `varying` keyword replaced with `in`
  [aS("varying"), "in $1"]
];
function SP(A, g) {
  for (const [I, C] of g)
    A = A.replace(I, C);
  return A;
}
function aS(A) {
  return new RegExp(`\\b${A}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function bj(A, g) {
  let I = "";
  for (const C in A) {
    const t = A[C];
    if (I += `void ${t.signature} {
`, t.header && (I += `  ${t.header}`), g[C]) {
      const s = g[C];
      s.sort((r, l) => r.order - l.order);
      for (const r of s)
        I += `  ${r.injection}
`;
    }
    t.footer && (I += `  ${t.footer}`), I += `}
`;
  }
  return I;
}
function Sj(A) {
  const g = { vertex: {}, fragment: {} };
  for (const I of A) {
    let C, t;
    typeof I != "string" ? (C = I, t = C.hook) : (C = {}, t = I), t = t.trim();
    const [s, r] = t.split(":"), l = t.replace(/\(.+/, ""), d = Object.assign(C, { signature: r });
    switch (s) {
      case "vs":
        g.vertex[l] = d;
        break;
      case "fs":
        g.fragment[l] = d;
        break;
      default:
        throw new Error(s);
    }
  }
  return g;
}
function hV(A, g) {
  return {
    name: yV(A, g),
    language: "glsl",
    version: DV(A)
  };
}
function yV(A, g = "unnamed") {
  const C = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(A);
  return C ? C[1] : g;
}
function DV(A) {
  let g = 100;
  const I = A.match(/[^\s]+/g);
  if (I && I.length >= 2 && I[0] === "#version") {
    const C = parseInt(I[1], 10);
    Number.isFinite(C) && (g = C);
  }
  if (g !== 100 && g !== 300)
    throw new Error(`Invalid GLSL version ${g}`);
  return g;
}
const Gj = `

${Ap}
`, MV = (
  /* glsl */
  `precision highp float;
`
);
function wV(A) {
  const g = MG(A.modules || []);
  return {
    source: pV(A.platformInfo, {
      ...A,
      source: A.source,
      stage: "vertex",
      modules: g
    }),
    getUniforms: Kj(g)
  };
}
function BV(A) {
  const { vs: g, fs: I } = A, C = MG(A.modules || []);
  return {
    vs: GP(A.platformInfo, {
      ...A,
      source: g,
      stage: "vertex",
      modules: C
    }),
    fs: GP(A.platformInfo, {
      ...A,
      // @ts-expect-error
      source: I,
      stage: "fragment",
      modules: C
    }),
    getUniforms: Kj(C)
  };
}
function pV(A, g) {
  const {
    // id,
    source: I,
    stage: C,
    modules: t,
    // defines = {},
    hookFunctions: s = [],
    inject: r = {},
    log: l
  } = g;
  DG(typeof I == "string", "shader source must be a string");
  const d = I;
  let h = "";
  const D = Sj(s), w = {}, p = {}, b = {};
  for (const K in r) {
    const Y = typeof r[K] == "string" ? { injection: r[K], order: 0 } : r[K], T = /^(v|f)s:(#)?([\w-]+)$/.exec(K);
    if (T) {
      const E = T[2], H = T[3];
      E ? H === "decl" ? p[K] = [Y] : b[K] = [Y] : w[K] = [Y];
    } else
      b[K] = [Y];
  }
  const S = t;
  for (const K of S) {
    l && Bj(K, d, l);
    const Y = Tj(K, "wgsl");
    h += Y;
    const T = K.injections?.[C] || {};
    for (const E in T) {
      const H = /^(v|f)s:#([\w-]+)$/.exec(E);
      if (H) {
        const x = H[2] === "decl" ? p : b;
        x[E] = x[E] || [], x[E].push(T[E]);
      } else
        w[E] = w[E] || [], w[E].push(T[E]);
    }
  }
  return h += Gj, h = wp(h, C, p), h += bj(D[C], w), h += d, h = wp(h, C, b), h;
}
function GP(A, g) {
  const { id: I, source: C, stage: t, language: s = "glsl", modules: r, defines: l = {}, hookFunctions: d = [], inject: h = {}, prologue: D = !0, log: w } = g;
  DG(typeof C == "string", "shader source must be a string");
  const p = s === "glsl" ? hV(C).version : -1, b = A.shaderLanguageVersion, S = p === 100 ? "#version 100" : "#version 300 es", Y = C.split(`
`).slice(1).join(`
`), T = {};
  r.forEach((J) => {
    Object.assign(T, J.defines);
  }), Object.assign(T, l);
  let E = "";
  switch (s) {
    case "wgsl":
      break;
    case "glsl":
      E = D ? `${S}

// ----- PROLOGUE -------------------------
${mV({ id: I, source: C, stage: t })}
${`#define SHADER_TYPE_${t.toUpperCase()}`}

${cV(A)}
${t === "fragment" ? MV : ""}

// ----- APPLICATION DEFINES -------------------------

${bV(T)}

` : `${S}
`;
      break;
  }
  const H = Sj(d), R = {}, x = {}, U = {};
  for (const J in h) {
    const L = typeof h[J] == "string" ? { injection: h[J], order: 0 } : h[J], eg = /^(v|f)s:(#)?([\w-]+)$/.exec(J);
    if (eg) {
      const Mg = eg[2], ig = eg[3];
      Mg ? ig === "decl" ? x[J] = [L] : U[J] = [L] : R[J] = [L];
    } else
      U[J] = [L];
  }
  for (const J of r) {
    w && Bj(J, Y, w);
    const L = Tj(J, t);
    E += L;
    const eg = J.instance?.normalizedInjections[t] || {};
    for (const Mg in eg) {
      const ig = /^(v|f)s:#([\w-]+)$/.exec(Mg);
      if (ig) {
        const Kg = ig[2] === "decl" ? x : U;
        Kg[Mg] = Kg[Mg] || [], Kg[Mg].push(eg[Mg]);
      } else
        R[Mg] = R[Mg] || [], R[Mg].push(eg[Mg]);
    }
  }
  return E += "// ----- MAIN SHADER SOURCE -------------------------", E += Gj, E = wp(E, t, x), E += bj(H[t], R), E += Y, E = wp(E, t, U), s === "glsl" && p !== b && (E = uV(E, t)), E.trim();
}
function Kj(A) {
  return function(I) {
    const C = {};
    for (const t of A) {
      const s = t.getUniforms?.(I, C);
      Object.assign(C, s);
    }
    return C;
  };
}
function mV(A) {
  const { id: g, source: I, stage: C } = A;
  return g && I.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${g}_${C}` : "";
}
function bV(A = {}) {
  let g = "";
  for (const I in A) {
    const C = A[I];
    (C || Number.isFinite(C)) && (g += `#define ${I.toUpperCase()} ${A[I]}
`);
  }
  return g;
}
function Tj(A, g) {
  let I;
  switch (g) {
    case "vertex":
      I = A.vs || "";
      break;
    case "fragment":
      I = A.fs || "";
      break;
    case "wgsl":
      I = A.source || "";
      break;
    default:
      DG(!1);
  }
  if (!A.name)
    throw new Error("Shader module must have a name");
  const C = A.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let t = `// ----- MODULE ${A.name} ---------------

`;
  return g !== "wgsl" && (t += `#define MODULE_${C}
`), t += `${I}
`, t;
}
const SV = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, GV = /^\s*\#\s*endif\s*$/;
function KV(A, g) {
  const I = A.split(`
`), C = [];
  let t = !0, s = null;
  for (const r of I) {
    const l = r.match(SV), d = r.match(GV);
    l ? (s = l[1], t = !!g?.defines?.[s]) : d ? t = !0 : t && C.push(r);
  }
  return C.join(`
`);
}
class lc {
  /** Default ShaderAssembler instance */
  static defaultShaderAssembler;
  /** Hook functions */
  _hookFunctions = [];
  /** Shader modules */
  _defaultModules = [];
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return lc.defaultShaderAssembler = lc.defaultShaderAssembler || new lc(), lc.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(g) {
    this._defaultModules.find((I) => I.name === (typeof g == "string" ? g : g.name)) || this._defaultModules.push(g);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(g) {
    const I = typeof g == "string" ? g : g.name;
    this._defaultModules = this._defaultModules.filter((C) => C.name !== I);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(g, I) {
    I && (g = Object.assign(I, { hook: g })), this._hookFunctions.push(g);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(g) {
    const I = this._getModuleList(g.modules), C = this._hookFunctions, { source: t, getUniforms: s } = wV({
      ...g,
      // @ts-expect-error
      source: g.source,
      modules: I,
      hookFunctions: C
    });
    return { source: g.platformInfo.shaderLanguage === "wgsl" ? KV(t) : t, getUniforms: s, modules: I };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(g) {
    const I = this._getModuleList(g.modules), C = this._hookFunctions;
    return { ...BV({
      ...g,
      // @ts-expect-error
      vs: g.vs,
      // @ts-expect-error
      fs: g.fs,
      modules: I,
      hookFunctions: C
    }), modules: I };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(g = []) {
    const I = new Array(this._defaultModules.length + g.length), C = {};
    let t = 0;
    for (let s = 0, r = this._defaultModules.length; s < r; ++s) {
      const l = this._defaultModules[s], d = l.name;
      I[t++] = l, C[d] = !0;
    }
    for (let s = 0, r = g.length; s < r; ++s) {
      const l = g[s], d = l.name;
      C[d] || (I[t++] = l, C[d] = !0);
    }
    return I.length = t, Bp(I), I;
  }
}
const TV = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
), YV = `#version 300 es
${TV}`;
function PV(A) {
  const { input: g, inputChannels: I, output: C } = {};
  if (!g)
    return YV;
  if (!I)
    throw new Error("inputChannels");
  const t = ZV(I), s = jV(g, I);
  return `#version 300 es
in ${t} ${g};
out vec4 ${C};
void main() {
  ${C} = ${s};
}`;
}
function ZV(A) {
  switch (A) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${A}`);
  }
}
function jV(A, g) {
  switch (g) {
    case 1:
      return `vec4(${A}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${A}, 0.0, 1.0)`;
    case 3:
      return `vec4(${A}, 1.0)`;
    case 4:
      return A;
    default:
      throw new Error(`invalid channels: ${g}`);
  }
}
class Pi {
  constructor(g, I) {
    this.name = g, this.attributes = I, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
  get isPointer() {
    return !1;
  }
  getTypeName() {
    return this.name;
  }
}
class KP {
  constructor(g, I, C) {
    this.name = g, this.type = I, this.attributes = C, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class dr extends Pi {
  constructor(g, I) {
    super(g, I), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
let yr = class extends Pi {
  constructor(g, I) {
    super(g, I), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
}, rS = class extends Pi {
  constructor(g, I, C) {
    super(g, C), this.format = I;
  }
  get isPointer() {
    return !0;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
};
class Dc extends Pi {
  constructor(g, I, C, t) {
    super(g, C), this.format = I, this.access = t;
  }
  get isTemplate() {
    return !0;
  }
  getTypeName() {
    let g = this.name;
    if (this.format !== null) {
      if (g === "vec2" || g === "vec3" || g === "vec4" || g === "mat2x2" || g === "mat2x3" || g === "mat2x4" || g === "mat3x2" || g === "mat3x3" || g === "mat3x4" || g === "mat4x2" || g === "mat4x3" || g === "mat4x4") {
        if (this.format.name === "f32") return g += "f", g;
        if (this.format.name === "i32") return g += "i", g;
        if (this.format.name === "u32") return g += "u", g;
        if (this.format.name === "bool") return g += "b", g;
        if (this.format.name === "f16") return g += "h", g;
      }
      g += `<${this.format.name}>`;
    } else if (g === "vec2" || g === "vec3" || g === "vec4") return g;
    return g;
  }
}
var cr;
((A) => {
  A[A.Uniform = 0] = "Uniform", A[A.Storage = 1] = "Storage", A[A.Texture = 2] = "Texture", A[A.Sampler = 3] = "Sampler", A[A.StorageTexture = 4] = "StorageTexture";
})(cr || (cr = {}));
class vB {
  constructor(g, I, C, t, s, r, l) {
    this.name = g, this.type = I, this.group = C, this.binding = t, this.attributes = s, this.resourceType = r, this.access = l;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
let vV = class {
  constructor(g, I) {
    this.name = g, this.type = I;
  }
};
class HV {
  constructor(g, I, C, t) {
    this.name = g, this.type = I, this.locationType = C, this.location = t, this.interpolation = null;
  }
}
let TP = class {
  constructor(g, I, C, t) {
    this.name = g, this.type = I, this.locationType = C, this.location = t;
  }
}, EV = class {
  constructor(g, I, C, t) {
    this.name = g, this.type = I, this.attributes = C, this.id = t;
  }
}, RV = class {
  constructor(g, I, C) {
    this.name = g, this.type = I, this.attributes = C;
  }
}, OV = class {
  constructor(g, I = null, C) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = g, this.stage = I, this.attributes = C;
  }
}, NV = class {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
};
function kV(A) {
  var g = (32768 & A) >> 15, I = (31744 & A) >> 10, C = 1023 & A;
  return I == 0 ? (g ? -1 : 1) * Math.pow(2, -14) * (C / Math.pow(2, 10)) : I == 31 ? C ? NaN : 1 / 0 * (g ? -1 : 1) : (g ? -1 : 1) * Math.pow(2, I - 15) * (1 + C / Math.pow(2, 10));
}
const Yj = new Float32Array(1), WV = new Int32Array(Yj.buffer), be = new Uint16Array(1);
function VV(A) {
  Yj[0] = A;
  const g = WV[0], I = g >> 31 & 1;
  let C = g >> 23 & 255, t = 8388607 & g;
  if (C === 255) return be[0] = I << 15 | 31744 | (t !== 0 ? 512 : 0), be[0];
  if (C === 0) {
    if (t === 0) return be[0] = I << 15, be[0];
    t |= 8388608;
    let s = 113;
    for (; !(8388608 & t); ) t <<= 1, s--;
    return C = 127 - s, t &= 8388607, C > 0 ? (t = (t >> 126 - C) + (t >> 127 - C & 1), be[0] = I << 15 | C << 10 | t >> 13, be[0]) : (be[0] = I << 15, be[0]);
  }
  return C = C - 127 + 15, C >= 31 ? (be[0] = I << 15 | 31744, be[0]) : C <= 0 ? C < -10 ? (be[0] = I << 15, be[0]) : (t = (8388608 | t) >> 1 - C, be[0] = I << 15 | t >> 13, be[0]) : (t >>= 13, be[0] = I << 15 | C << 10 | t, be[0]);
}
const wG = new Uint32Array(1), Pj = new Float32Array(wG.buffer, 0, 1);
function YP(A) {
  const g = 112 + (A >> 6 & 31) << 23 | (63 & A) << 17;
  return wG[0] = g, Pj[0];
}
function xV(A, g, I, C, t, s, r, l, d) {
  const h = C * (r >>= t) * (s >>= t) + I * r + g * l;
  switch (d) {
    case "r8unorm":
      return [$I(A, h, "8unorm", 1)[0]];
    case "r8snorm":
      return [$I(A, h, "8snorm", 1)[0]];
    case "r8uint":
      return [$I(A, h, "8uint", 1)[0]];
    case "r8sint":
      return [$I(A, h, "8sint", 1)[0]];
    case "rg8unorm": {
      const D = $I(A, h, "8unorm", 2);
      return [D[0], D[1]];
    }
    case "rg8snorm": {
      const D = $I(A, h, "8snorm", 2);
      return [D[0], D[1]];
    }
    case "rg8uint": {
      const D = $I(A, h, "8uint", 2);
      return [D[0], D[1]];
    }
    case "rg8sint": {
      const D = $I(A, h, "8sint", 2);
      return [D[0], D[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const D = $I(A, h, "8unorm", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba8snorm": {
      const D = $I(A, h, "8snorm", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba8uint": {
      const D = $I(A, h, "8uint", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba8sint": {
      const D = $I(A, h, "8sint", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const D = $I(A, h, "8unorm", 4);
      return [D[2], D[1], D[0], D[3]];
    }
    case "r16uint":
      return [$I(A, h, "16uint", 1)[0]];
    case "r16sint":
      return [$I(A, h, "16sint", 1)[0]];
    case "r16float":
      return [$I(A, h, "16float", 1)[0]];
    case "rg16uint": {
      const D = $I(A, h, "16uint", 2);
      return [D[0], D[1]];
    }
    case "rg16sint": {
      const D = $I(A, h, "16sint", 2);
      return [D[0], D[1]];
    }
    case "rg16float": {
      const D = $I(A, h, "16float", 2);
      return [D[0], D[1]];
    }
    case "rgba16uint": {
      const D = $I(A, h, "16uint", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba16sint": {
      const D = $I(A, h, "16sint", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba16float": {
      const D = $I(A, h, "16float", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "r32uint":
      return [$I(A, h, "32uint", 1)[0]];
    case "r32sint":
      return [$I(A, h, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [$I(A, h, "32float", 1)[0]];
    case "rg32uint": {
      const D = $I(A, h, "32uint", 2);
      return [D[0], D[1]];
    }
    case "rg32sint": {
      const D = $I(A, h, "32sint", 2);
      return [D[0], D[1]];
    }
    case "rg32float": {
      const D = $I(A, h, "32float", 2);
      return [D[0], D[1]];
    }
    case "rgba32uint": {
      const D = $I(A, h, "32uint", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba32sint": {
      const D = $I(A, h, "32sint", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rgba32float": {
      const D = $I(A, h, "32float", 4);
      return [D[0], D[1], D[2], D[3]];
    }
    case "rg11b10ufloat": {
      const D = new Uint32Array(A.buffer, h, 1)[0], w = (4192256 & D) >> 11, p = (4290772992 & D) >> 22;
      return [YP(2047 & D), YP(w), (function(b) {
        const S = 112 + (b >> 5 & 31) << 23 | (31 & b) << 18;
        return wG[0] = S, Pj[0];
      })(p), 1];
    }
  }
  return null;
}
function $I(A, g, I, C) {
  const t = [0, 0, 0, 0];
  for (let s = 0; s < C; ++s) switch (I) {
    case "8unorm":
      t[s] = A[g] / 255, g++;
      break;
    case "8snorm":
      t[s] = A[g] / 255 * 2 - 1, g++;
      break;
    case "8uint":
      t[s] = A[g], g++;
      break;
    case "8sint":
      t[s] = A[g] - 127, g++;
      break;
    case "16uint":
      t[s] = A[g] | A[g + 1] << 8, g += 2;
      break;
    case "16sint":
      t[s] = (A[g] | A[g + 1] << 8) - 32768, g += 2;
      break;
    case "16float":
      t[s] = kV(A[g] | A[g + 1] << 8), g += 2;
      break;
    case "32uint":
    case "32sint":
      t[s] = A[g] | A[g + 1] << 8 | A[g + 2] << 16 | A[g + 3] << 24, g += 4;
      break;
    case "32float":
      t[s] = new Float32Array(A.buffer, g, 1)[0], g += 4;
  }
  return t;
}
function nA(A, g, I, C, t) {
  for (let s = 0; s < C; ++s) switch (I) {
    case "8unorm":
      A[g] = 255 * t[s], g++;
      break;
    case "8snorm":
      A[g] = 0.5 * (t[s] + 1) * 255, g++;
      break;
    case "8uint":
      A[g] = t[s], g++;
      break;
    case "8sint":
      A[g] = t[s] + 127, g++;
      break;
    case "16uint":
      new Uint16Array(A.buffer, g, 1)[0] = t[s], g += 2;
      break;
    case "16sint":
      new Int16Array(A.buffer, g, 1)[0] = t[s], g += 2;
      break;
    case "16float": {
      const r = VV(t[s]);
      new Uint16Array(A.buffer, g, 1)[0] = r, g += 2;
      break;
    }
    case "32uint":
      new Uint32Array(A.buffer, g, 1)[0] = t[s], g += 4;
      break;
    case "32sint":
      new Int32Array(A.buffer, g, 1)[0] = t[s], g += 4;
      break;
    case "32float":
      new Float32Array(A.buffer, g, 1)[0] = t[s], g += 4;
  }
  return t;
}
const fb = { r8unorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r8snorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r8uint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r8sint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, rg8unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg8snorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg8uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg8sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rgba8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, "rgba8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba8snorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba8uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba8sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, bgra8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, "bgra8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, r16uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r16sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r16float: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, rg16uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg16sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg16float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rgba16uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba16sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba16float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, r32uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r32sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, rg32uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg32sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg32float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rgba32uint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba32sint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba32float: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgb10a2uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgb10a2unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rg11b10ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, stencil8: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !1, hasStencil: !0, channels: 1 }, depth16unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !1, channels: 1 }, depth24plus: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !1, depthOnlyFormat: "depth32float", channels: 1 }, "depth24plus-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !0, depthOnlyFormat: "depth32float", channels: 1 }, depth32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !1, channels: 1 }, "depth32float-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !0, stencilOnlyFormat: "depth32float", channels: 1 }, rgb9e5ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, "bc1-rgba-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc1-rgba-unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc2-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc2-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc3-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc3-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc4-r-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 1 }, "bc4-r-snorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 1 }, "bc5-rg-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 2 }, "bc5-rg-snorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 2 }, "bc6h-rgb-ufloat": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc6h-rgb-float": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc7-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc7-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8a1unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8a1unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgba8unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgba8unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "eac-r11unorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 1 }, "eac-r11snorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 1 }, "eac-rg11unorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 2 }, "eac-rg11snorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 2 }, "astc-4x4-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-4x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-5x4-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-5x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-5x5-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-5x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-6x5-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-6x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-6x6-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-6x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-8x5-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-8x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-8x6-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-8x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-8x8-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-8x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-10x5-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-10x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-10x6-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-10x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-10x8-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-10x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-10x10-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-10x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-12x10-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-12x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-12x12-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: !0, channels: 4 }, "astc-12x12-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: !0, channels: 4 } };
class Ei {
  constructor() {
    this.id = Ei._id++, this.line = 0;
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  search(g) {
    g(this);
  }
  searchBlock(g, I) {
    if (g) {
      I(pp.instance);
      for (const C of g) C instanceof Array ? this.searchBlock(C, I) : C.search(I);
      I(mp.instance);
    }
  }
  constEvaluate(g, I) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(g) {
    return this.constEvaluate(g).toString();
  }
}
Ei._id = 0;
class pp extends Ei {
}
pp.instance = new pp();
let mp = class extends Ei {
};
mp.instance = new mp();
const Zj = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
let RA = class extends Ei {
  constructor() {
    super();
  }
}, cM = class extends RA {
  constructor(g, I, C, t, s, r) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = g, this.args = I, this.returnType = C, this.body = t, this.startLine = s, this.endLine = r;
  }
  get astNodeType() {
    return "function";
  }
  search(g) {
    if (this.attributes) for (const I of this.attributes) g(I);
    g(this);
    for (const I of this.args) g(I);
    this.searchBlock(this.body, g);
  }
}, _V = class extends RA {
  constructor(g) {
    super(), this.expression = g;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(g) {
    this.expression.search(g);
  }
}, jj = class extends RA {
  constructor(g, I) {
    super(), this.condition = g, this.body = I;
  }
  get astNodeType() {
    return "while";
  }
  search(g) {
    this.condition.search(g), this.searchBlock(this.body, g);
  }
};
class lS extends RA {
  constructor(g, I) {
    super(), this.body = g, this.loopId = I;
  }
  get astNodeType() {
    return "continuing";
  }
  search(g) {
    this.searchBlock(this.body, g);
  }
}
let vj = class extends RA {
  constructor(g, I, C, t) {
    super(), this.init = g, this.condition = I, this.increment = C, this.body = t;
  }
  get astNodeType() {
    return "for";
  }
  search(g) {
    var I, C, t;
    (I = this.init) === null || I === void 0 || I.search(g), (C = this.condition) === null || C === void 0 || C.search(g), (t = this.increment) === null || t === void 0 || t.search(g), this.searchBlock(this.body, g);
  }
}, Po = class extends RA {
  constructor(g, I, C, t, s) {
    super(), this.attributes = null, this.name = g, this.type = I, this.storage = C, this.access = t, this.value = s;
  }
  get astNodeType() {
    return "var";
  }
  search(g) {
    var I;
    g(this), (I = this.value) === null || I === void 0 || I.search(g);
  }
};
class BG extends RA {
  constructor(g, I, C) {
    super(), this.attributes = null, this.name = g, this.type = I, this.value = C;
  }
  get astNodeType() {
    return "override";
  }
  search(g) {
    var I;
    (I = this.value) === null || I === void 0 || I.search(g);
  }
}
let tM = class extends RA {
  constructor(g, I, C, t, s) {
    super(), this.attributes = null, this.name = g, this.type = I, this.storage = C, this.access = t, this.value = s;
  }
  get astNodeType() {
    return "let";
  }
  search(g) {
    var I;
    g(this), (I = this.value) === null || I === void 0 || I.search(g);
  }
}, Cp = class extends RA {
  constructor(g, I, C, t, s) {
    super(), this.attributes = null, this.name = g, this.type = I, this.storage = C, this.access = t, this.value = s;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(g, I) {
    return this.value.constEvaluate(g, I);
  }
  search(g) {
    var I;
    g(this), (I = this.value) === null || I === void 0 || I.search(g);
  }
};
var lf, zD, fg, ng;
((A) => {
  A.increment = "++", A.decrement = "--";
})(lf || (lf = {})), ((A) => {
  A.parse = function(g) {
    const I = g;
    if (I == "parse") throw new Error("Invalid value for IncrementOperator");
    return A[I];
  };
})(lf || (lf = {}));
class Hj extends RA {
  constructor(g, I) {
    super(), this.operator = g, this.variable = I;
  }
  get astNodeType() {
    return "increment";
  }
  search(g) {
    this.variable.search(g);
  }
}
((A) => {
  A.assign = "=", A.addAssign = "+=", A.subtractAssin = "-=", A.multiplyAssign = "*=", A.divideAssign = "/=", A.moduloAssign = "%=", A.andAssign = "&=", A.orAssign = "|=", A.xorAssign = "^=", A.shiftLeftAssign = "<<=", A.shiftRightAssign = ">>=";
})(zD || (zD = {})), ((A) => {
  A.parse = function(g) {
    const I = g;
    if (I == "parse") throw new Error("Invalid value for AssignOperator");
    return I;
  };
})(zD || (zD = {}));
let Ej = class extends RA {
  constructor(g, I, C) {
    super(), this.operator = g, this.variable = I, this.value = C;
  }
  get astNodeType() {
    return "assign";
  }
  search(g) {
    this.variable.search(g), this.value.search(g);
  }
}, pG = class extends RA {
  constructor(g, I) {
    super(), this.name = g, this.args = I;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return Zj.has(this.name);
  }
  search(g) {
    for (const I of this.args) I.search(g);
    g(this);
  }
};
class Rj extends RA {
  constructor(g, I) {
    super(), this.body = g, this.continuing = I;
  }
  get astNodeType() {
    return "loop";
  }
  search(g) {
    var I;
    this.searchBlock(this.body, g), (I = this.continuing) === null || I === void 0 || I.search(g);
  }
}
let Oj = class extends RA {
  constructor(g, I) {
    super(), this.condition = g, this.cases = I;
  }
  get astNodeType() {
    return "switch";
  }
  search(g) {
    g(this);
    for (const I of this.cases) I.search(g);
  }
}, Nj = class extends RA {
  constructor(g, I, C, t) {
    super(), this.condition = g, this.body = I, this.elseif = C, this.else = t;
  }
  get astNodeType() {
    return "if";
  }
  search(g) {
    this.condition.search(g), this.searchBlock(this.body, g), this.searchBlock(this.elseif, g), this.searchBlock(this.else, g);
  }
}, kj = class extends RA {
  constructor(g) {
    super(), this.value = g;
  }
  get astNodeType() {
    return "return";
  }
  search(g) {
    var I;
    (I = this.value) === null || I === void 0 || I.search(g);
  }
}, UV = class extends RA {
  constructor(g) {
    super(), this.name = g;
  }
  get astNodeType() {
    return "enable";
  }
}, FV = class extends RA {
  constructor(g) {
    super(), this.extensions = g;
  }
  get astNodeType() {
    return "requires";
  }
}, Wj = class extends RA {
  constructor(g, I) {
    super(), this.severity = g, this.rule = I;
  }
  get astNodeType() {
    return "diagnostic";
  }
};
class mG extends RA {
  constructor(g, I) {
    super(), this.name = g, this.type = I;
  }
  get astNodeType() {
    return "alias";
  }
}
class XV extends RA {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class Vj extends RA {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
}
class xj extends RA {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
}
class Eg extends RA {
  constructor(g) {
    super(), this.attributes = null, this.name = g;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
  static maxFormatType(g) {
    let I = g[0];
    if (I.name === "f32") return I;
    for (let C = 1; C < g.length; ++C) {
      const t = Eg._priority.get(I.name);
      Eg._priority.get(g[C].name) < t && (I = g[C]);
    }
    return I.name === "x32" ? Eg.i32 : I;
  }
  getTypeName() {
    return this.name;
  }
}
Eg.x32 = new Eg("x32"), Eg.f32 = new Eg("f32"), Eg.i32 = new Eg("i32"), Eg.u32 = new Eg("u32"), Eg.f16 = new Eg("f16"), Eg.bool = new Eg("bool"), Eg.void = new Eg("void"), Eg._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class PP extends Eg {
  constructor(g) {
    super(g);
  }
}
class To extends Eg {
  constructor(g, I, C, t) {
    super(g), this.members = I, this.startLine = C, this.endLine = t;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  getMemberIndex(g) {
    for (let I = 0; I < this.members.length; I++) if (this.members[I].name == g) return I;
    return -1;
  }
  search(g) {
    for (const I of this.members) g(I);
  }
}
let lg = class extends Eg {
  constructor(g, I, C) {
    super(g), this.format = I, this.access = C;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let g = this.name;
    if (this.format !== null) {
      if (g === "vec2" || g === "vec3" || g === "vec4" || g === "mat2x2" || g === "mat2x3" || g === "mat2x4" || g === "mat3x2" || g === "mat3x3" || g === "mat3x4" || g === "mat4x2" || g === "mat4x3" || g === "mat4x4") {
        if (this.format.name === "f32") return g += "f", g;
        if (this.format.name === "i32") return g += "i", g;
        if (this.format.name === "u32") return g += "u", g;
        if (this.format.name === "bool") return g += "b", g;
        if (this.format.name === "f16") return g += "h", g;
      }
      g += `<${this.format.name}>`;
    } else if (g === "vec2" || g === "vec3" || g === "vec4") return g;
    return g;
  }
};
lg.vec2f = new lg("vec2", Eg.f32, null), lg.vec3f = new lg("vec3", Eg.f32, null), lg.vec4f = new lg("vec4", Eg.f32, null), lg.vec2i = new lg("vec2", Eg.i32, null), lg.vec3i = new lg("vec3", Eg.i32, null), lg.vec4i = new lg("vec4", Eg.i32, null), lg.vec2u = new lg("vec2", Eg.u32, null), lg.vec3u = new lg("vec3", Eg.u32, null), lg.vec4u = new lg("vec4", Eg.u32, null), lg.vec2h = new lg("vec2", Eg.f16, null), lg.vec3h = new lg("vec3", Eg.f16, null), lg.vec4h = new lg("vec4", Eg.f16, null), lg.vec2b = new lg("vec2", Eg.bool, null), lg.vec3b = new lg("vec3", Eg.bool, null), lg.vec4b = new lg("vec4", Eg.bool, null), lg.mat2x2f = new lg("mat2x2", Eg.f32, null), lg.mat2x3f = new lg("mat2x3", Eg.f32, null), lg.mat2x4f = new lg("mat2x4", Eg.f32, null), lg.mat3x2f = new lg("mat3x2", Eg.f32, null), lg.mat3x3f = new lg("mat3x3", Eg.f32, null), lg.mat3x4f = new lg("mat3x4", Eg.f32, null), lg.mat4x2f = new lg("mat4x2", Eg.f32, null), lg.mat4x3f = new lg("mat4x3", Eg.f32, null), lg.mat4x4f = new lg("mat4x4", Eg.f32, null), lg.mat2x2h = new lg("mat2x2", Eg.f16, null), lg.mat2x3h = new lg("mat2x3", Eg.f16, null), lg.mat2x4h = new lg("mat2x4", Eg.f16, null), lg.mat3x2h = new lg("mat3x2", Eg.f16, null), lg.mat3x3h = new lg("mat3x3", Eg.f16, null), lg.mat3x4h = new lg("mat3x4", Eg.f16, null), lg.mat4x2h = new lg("mat4x2", Eg.f16, null), lg.mat4x3h = new lg("mat4x3", Eg.f16, null), lg.mat4x4h = new lg("mat4x4", Eg.f16, null), lg.mat2x2i = new lg("mat2x2", Eg.i32, null), lg.mat2x3i = new lg("mat2x3", Eg.i32, null), lg.mat2x4i = new lg("mat2x4", Eg.i32, null), lg.mat3x2i = new lg("mat3x2", Eg.i32, null), lg.mat3x3i = new lg("mat3x3", Eg.i32, null), lg.mat3x4i = new lg("mat3x4", Eg.i32, null), lg.mat4x2i = new lg("mat4x2", Eg.i32, null), lg.mat4x3i = new lg("mat4x3", Eg.i32, null), lg.mat4x4i = new lg("mat4x4", Eg.i32, null), lg.mat2x2u = new lg("mat2x2", Eg.u32, null), lg.mat2x3u = new lg("mat2x3", Eg.u32, null), lg.mat2x4u = new lg("mat2x4", Eg.u32, null), lg.mat3x2u = new lg("mat3x2", Eg.u32, null), lg.mat3x3u = new lg("mat3x3", Eg.u32, null), lg.mat3x4u = new lg("mat3x4", Eg.u32, null), lg.mat4x2u = new lg("mat4x2", Eg.u32, null), lg.mat4x3u = new lg("mat4x3", Eg.u32, null), lg.mat4x4u = new lg("mat4x4", Eg.u32, null);
let ep = class extends Eg {
  constructor(g, I, C, t) {
    super(g), this.storage = I, this.type = C, this.access = t;
  }
  get astNodeType() {
    return "pointer";
  }
}, iM = class extends Eg {
  constructor(g, I, C, t) {
    super(g), this.attributes = I, this.format = C, this.count = t;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}, JD = class extends Eg {
  constructor(g, I, C) {
    super(g), this.format = I, this.access = C;
  }
  get astNodeType() {
    return "sampler";
  }
}, Kn = class extends Ei {
  constructor() {
    super(), this.postfix = null;
  }
}, Mc = class extends Kn {
  constructor(g) {
    super(), this.value = g;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
}, Ms = class extends Kn {
  constructor(g, I) {
    super(), this.type = g, this.args = I;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(g) {
    if (g(this), this.args) for (const I of this.args) I.search(g);
  }
  constEvaluate(g, I) {
    return I && (I[0] = this.type), g.evalExpression(this, g.context);
  }
}, bG = class extends Kn {
  constructor(g, I) {
    super(), this.cachedReturnValue = null, this.name = g, this.args = I;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(g) {
    this.cachedReturnValue = g;
  }
  get isBuiltin() {
    return Zj.has(this.name);
  }
  constEvaluate(g, I) {
    return g.evalExpression(this, g.context);
  }
  search(g) {
    for (const I of this.args) I.search(g);
    g(this);
  }
};
class Ft extends Kn {
  constructor(g) {
    super(), this.name = g;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(g) {
    g(this), this.postfix && this.postfix.search(g);
  }
  constEvaluate(g, I) {
    return g.evalExpression(this, g.context);
  }
}
let _j = class extends Kn {
  constructor(g, I) {
    super(), this.name = g, this.initializer = I;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(g, I) {
    if (this.initializer) {
      const C = g.evalExpression(this.initializer, g.context);
      return C !== null && this.postfix ? C.getSubData(g, this.postfix, g.context) : C;
    }
    return null;
  }
  search(g) {
    this.initializer.search(g);
  }
}, TC = class extends Kn {
  constructor(g, I) {
    super(), this.value = g, this.type = I;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(g, I) {
    return I !== void 0 && (I[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof tg;
  }
  get isVector() {
    return this.value instanceof X || this.value instanceof oI;
  }
  get scalarValue() {
    return this.value instanceof tg ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof X || this.value instanceof oI ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
}, Uj = class extends Kn {
  constructor(g, I) {
    super(), this.type = g, this.value = I;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(g) {
    this.value.search(g);
  }
}, bf = class extends Kn {
  constructor(g) {
    super(), this.index = g;
  }
  search(g) {
    this.index.search(g);
  }
}, Fj = class extends Kn {
  constructor() {
    super();
  }
}, dC = class extends Fj {
  constructor(g, I) {
    super(), this.operator = g, this.right = I;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(g, I) {
    return g.evalExpression(this, g.context);
  }
  search(g) {
    this.right.search(g);
  }
}, pn = class extends Fj {
  constructor(g, I, C) {
    super(), this.operator = g, this.left = I, this.right = C;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(g, I) {
    return g.name === I.name ? g : g.name === "f32" || I.name === "f32" ? Eg.f32 : g.name === "u32" || I.name === "u32" ? Eg.u32 : Eg.i32;
  }
  constEvaluate(g, I) {
    return g.evalExpression(this, g.context);
  }
  search(g) {
    this.left.search(g), this.right.search(g);
  }
}, Xj = class extends Ei {
  constructor(g) {
    super(), this.body = g;
  }
  search(g) {
    g(this), this.searchBlock(this.body, g);
  }
}, tp = class extends Kn {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
};
class Qj extends Xj {
  constructor(g, I) {
    super(I), this.selectors = g;
  }
  get astNodeType() {
    return "case";
  }
  search(g) {
    this.searchBlock(this.body, g);
  }
}
let zj = class extends Xj {
  constructor(g) {
    super(g);
  }
  get astNodeType() {
    return "default";
  }
  search(g) {
    this.searchBlock(this.body, g);
  }
};
class ZP extends Ei {
  constructor(g, I, C) {
    super(), this.name = g, this.type = I, this.attributes = C;
  }
  get astNodeType() {
    return "argument";
  }
}
class QV extends Ei {
  constructor(g, I) {
    super(), this.condition = g, this.body = I;
  }
  get astNodeType() {
    return "elseif";
  }
  search(g) {
    this.condition.search(g), this.searchBlock(this.body, g);
  }
}
let jP = class extends Ei {
  constructor(g, I, C) {
    super(), this.name = g, this.type = I, this.attributes = C;
  }
  get astNodeType() {
    return "member";
  }
}, Jj = class extends Ei {
  constructor(g, I) {
    super(), this.name = g, this.value = I;
  }
  get astNodeType() {
    return "attribute";
  }
};
class Hi {
  constructor(g, I) {
    this.parent = null, this.typeInfo = g, this.parent = I, this.id = Hi._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(g, I, C, t) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(g, I, C) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
}
Hi._id = 0;
class cS extends Hi {
  constructor() {
    super(new Pi("void", null), null);
  }
  toString() {
    return "void";
  }
}
cS.void = new cS();
class gf extends Hi {
  constructor(g) {
    super(new rS("pointer", g.typeInfo, null), null), this.reference = g;
  }
  clone() {
    return this;
  }
  setDataValue(g, I, C, t) {
    this.reference.setDataValue(g, I, C, t);
  }
  getSubData(g, I, C) {
    return I ? this.reference.getSubData(g, I, C) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
}
class tg extends Hi {
  constructor(g, I, C = null) {
    super(I, C), g instanceof Int32Array || g instanceof Uint32Array || g instanceof Float32Array ? this.data = g : this.typeInfo.name === "x32" ? g - Math.floor(g) !== 0 ? this.data = new Float32Array([g]) : this.data = g >= 0 ? new Uint32Array([g]) : new Int32Array([g]) : this.typeInfo.name === "i32" || this.typeInfo.name === "bool" ? this.data = new Int32Array([g]) : this.typeInfo.name === "u32" ? this.data = new Uint32Array([g]) : this.typeInfo.name === "f32" || this.typeInfo.name === "f16" ? this.data = new Float32Array([g]) : console.error("ScalarData2: Invalid type", I);
  }
  clone() {
    if (this.data instanceof Float32Array) return new tg(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new tg(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new tg(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(g) {
    this.data[0] = g;
  }
  setDataValue(g, I, C, t) {
    if (C) return void console.error("SetDataValue: Scalar data does not support postfix", C);
    if (!(I instanceof tg)) return void console.error("SetDataValue: Invalid value", I);
    let s = I.data[0];
    this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? s = Math.floor(s) : this.typeInfo.name === "bool" && (s = s ? 1 : 0), this.data[0] = s;
  }
  getSubData(g, I, C) {
    return I ? (console.error("getSubData: Scalar data does not support postfix", I), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
}
function zV(A, g, I) {
  const C = g.length;
  return C === 2 ? I === "f32" ? new X(new Float32Array(g), A.getTypeInfo("vec2f")) : I === "i32" || I === "bool" ? new X(new Int32Array(g), A.getTypeInfo("vec2i")) : I === "u32" ? new X(new Uint32Array(g), A.getTypeInfo("vec2u")) : I === "f16" ? new X(new Float32Array(g), A.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${I}`), null) : C === 3 ? I === "f32" ? new X(new Float32Array(g), A.getTypeInfo("vec3f")) : I === "i32" || I === "bool" ? new X(new Int32Array(g), A.getTypeInfo("vec3i")) : I === "u32" ? new X(new Uint32Array(g), A.getTypeInfo("vec3u")) : I === "f16" ? new X(new Float32Array(g), A.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${I}`), null) : C === 4 ? I === "f32" ? new X(new Float32Array(g), A.getTypeInfo("vec4f")) : I === "i32" || I === "bool" ? new X(new Int32Array(g), A.getTypeInfo("vec4i")) : I === "u32" ? new X(new Uint32Array(g), A.getTypeInfo("vec4u")) : I === "f16" ? new X(new Float32Array(g), A.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${I}`), null) : (console.error(`getSubData: Invalid vector size ${g.length}`), null);
}
let X = class LD extends Hi {
  constructor(g, I, C = null) {
    if (super(I, C), g instanceof Float32Array || g instanceof Uint32Array || g instanceof Int32Array) this.data = g;
    else {
      const t = this.typeInfo.name;
      t === "vec2f" || t === "vec3f" || t === "vec4f" ? this.data = new Float32Array(g) : t === "vec2i" || t === "vec3i" || t === "vec4i" ? this.data = new Int32Array(g) : t === "vec2u" || t === "vec3u" || t === "vec4u" ? this.data = new Uint32Array(g) : t === "vec2h" || t === "vec3h" || t === "vec4h" ? this.data = new Float32Array(g) : t === "vec2b" || t === "vec3b" || t === "vec4b" ? this.data = new Int32Array(g) : t === "vec2" || t === "vec3" || t === "vec4" ? this.data = new Float32Array(g) : console.error(`VectorData: Invalid type ${t}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array) return new LD(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new LD(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new LD(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(g, I, C, t) {
    C instanceof Mc ? console.error("TODO: Set vector postfix") : I instanceof LD ? this.data = I.data : console.error("SetDataValue: Invalid value", I);
  }
  getSubData(g, I, C) {
    if (I === null) return this;
    let t = g.getTypeInfo("f32");
    if (this.typeInfo instanceof Dc) t = this.typeInfo.format || t;
    else {
      const r = this.typeInfo.name;
      r === "vec2f" || r === "vec3f" || r === "vec4f" ? t = g.getTypeInfo("f32") : r === "vec2i" || r === "vec3i" || r === "vec4i" ? t = g.getTypeInfo("i32") : r === "vec2b" || r === "vec3b" || r === "vec4b" ? t = g.getTypeInfo("bool") : r === "vec2u" || r === "vec3u" || r === "vec4u" ? t = g.getTypeInfo("u32") : r === "vec2h" || r === "vec3h" || r === "vec4h" ? t = g.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${r}`);
    }
    let s = this;
    for (; I !== null && s !== null; ) {
      if (I instanceof bf) {
        const r = I.index;
        let l = -1;
        if (r instanceof TC) {
          if (!(r.value instanceof tg)) return console.error(`GetSubData: Invalid array index ${r.value}`), null;
          l = r.value.value;
        } else {
          const d = g.evalExpression(r, C);
          if (!(d instanceof tg)) return console.error("GetSubData: Unknown index type", r), null;
          l = d.value;
        }
        if (l < 0 || l >= s.data.length) return console.error("GetSubData: Index out of range", l), null;
        if (s.data instanceof Float32Array) {
          const d = new Float32Array(s.data.buffer, s.data.byteOffset + 4 * l, 1);
          return new tg(d, t);
        }
        if (s.data instanceof Int32Array) {
          const d = new Int32Array(s.data.buffer, s.data.byteOffset + 4 * l, 1);
          return new tg(d, t);
        }
        if (s.data instanceof Uint32Array) {
          const d = new Uint32Array(s.data.buffer, s.data.byteOffset + 4 * l, 1);
          return new tg(d, t);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(I instanceof Mc)) return console.error("GetSubData: Unknown postfix", I), null;
      {
        const r = I.value.toLowerCase();
        if (r.length === 1) {
          let d = 0;
          if (r === "x" || r === "r") d = 0;
          else if (r === "y" || r === "g") d = 1;
          else if (r === "z" || r === "b") d = 2;
          else {
            if (r !== "w" && r !== "a") return console.error(`GetSubData: Unknown member ${r}`), null;
            d = 3;
          }
          if (this.data instanceof Float32Array) {
            let h = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new tg(h, t, this);
          }
          if (this.data instanceof Int32Array) {
            let h = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new tg(h, t, this);
          }
          if (this.data instanceof Uint32Array) {
            let h = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * d, 1);
            return new tg(h, t, this);
          }
        }
        const l = [];
        for (const d of r) d === "x" || d === "r" ? l.push(this.data[0]) : d === "y" || d === "g" ? l.push(this.data[1]) : d === "z" || d === "b" ? l.push(this.data[2]) : d === "w" || d === "a" ? l.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${d}`);
        s = zV(g, l, t.name);
      }
      I = I.postfix;
    }
    return s;
  }
  toString() {
    let g = `${this.data[0]}`;
    for (let I = 1; I < this.data.length; ++I) g += `, ${this.data[I]}`;
    return g;
  }
};
class oI extends Hi {
  constructor(g, I, C = null) {
    super(I, C), g instanceof Float32Array ? this.data = g : this.data = new Float32Array(g);
  }
  clone() {
    return new oI(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(g, I, C, t) {
    C instanceof Mc ? console.error("TODO: Set matrix postfix") : I instanceof oI ? this.data = I.data : console.error("SetDataValue: Invalid value", I);
  }
  getSubData(g, I, C) {
    if (I === null) return this;
    const t = this.typeInfo.name;
    if (g.getTypeInfo("f32"), this.typeInfo instanceof Dc) this.typeInfo.format;
    else if (t.endsWith("f")) g.getTypeInfo("f32");
    else if (t.endsWith("i")) g.getTypeInfo("i32");
    else if (t.endsWith("u")) g.getTypeInfo("u32");
    else {
      if (!t.endsWith("h")) return console.error(`GetDataValue: Unknown type ${t}`), null;
      g.getTypeInfo("f16");
    }
    if (I instanceof bf) {
      const s = I.index;
      let r = -1;
      if (s instanceof TC) {
        if (!(s.value instanceof tg)) return console.error(`GetDataValue: Invalid array index ${s.value}`), null;
        r = s.value.value;
      } else {
        const h = g.evalExpression(s, C);
        if (!(h instanceof tg)) return console.error("GetDataValue: Unknown index type", s), null;
        r = h.value;
      }
      if (r < 0 || r >= this.data.length) return console.error("GetDataValue: Index out of range", r), null;
      const l = t.endsWith("h") ? "h" : "f";
      let d;
      if (t === "mat2x2" || t === "mat2x2f" || t === "mat2x2h" || t === "mat3x2" || t === "mat3x2f" || t === "mat3x2h" || t === "mat4x2" || t === "mat4x2f" || t === "mat4x2h") d = new X(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * r * 4, 2), g.getTypeInfo(`vec2${l}`));
      else if (t === "mat2x3" || t === "mat2x3f" || t === "mat2x3h" || t === "mat3x3" || t === "mat3x3f" || t === "mat3x3h" || t === "mat4x3" || t === "mat4x3f" || t === "mat4x3h") d = new X(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * r * 4, 3), g.getTypeInfo(`vec3${l}`));
      else {
        if (t !== "mat2x4" && t !== "mat2x4f" && t !== "mat2x4h" && t !== "mat3x4" && t !== "mat3x4f" && t !== "mat3x4h" && t !== "mat4x4" && t !== "mat4x4f" && t !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${t}`), null;
        d = new X(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * r * 4, 4), g.getTypeInfo(`vec4${l}`));
      }
      return I.postfix ? d.getSubData(g, I.postfix, C) : d;
    }
    return console.error("GetDataValue: Invalid postfix", I), null;
  }
  toString() {
    let g = `${this.data[0]}`;
    for (let I = 1; I < this.data.length; ++I) g += `, ${this.data[I]}`;
    return g;
  }
}
let VC = class ip extends Hi {
  constructor(g, I, C = 0, t = null) {
    super(I, t), this.buffer = g instanceof ArrayBuffer ? g : g.buffer, this.offset = C;
  }
  clone() {
    const g = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new ip(g.buffer, this.typeInfo, 0, null);
  }
  setDataValue(g, I, C, t) {
    if (I === null) return void console.log("setDataValue: NULL data.");
    let s = this.offset, r = this.typeInfo;
    for (; C; ) {
      if (C instanceof bf) if (r instanceof yr) {
        const l = C.index;
        if (l instanceof TC) {
          if (!(l.value instanceof tg)) return void console.error(`SetDataValue: Invalid index type ${l.value}`);
          s += l.value.value * r.stride;
        } else {
          const d = g.evalExpression(l, t);
          if (!(d instanceof tg)) return void console.error("SetDataValue: Unknown index type", l);
          s += d.value * r.stride;
        }
        r = r.format;
      } else console.error(`SetDataValue: Type ${r.getTypeName()} is not an array`);
      else {
        if (!(C instanceof Mc)) return void console.error("SetDataValue: Unknown postfix type", C);
        {
          const l = C.value;
          if (r instanceof dr) {
            let d = !1;
            for (const h of r.members) if (h.name === l) {
              s += h.offset, r = h.type, d = !0;
              break;
            }
            if (!d) return void console.error(`SetDataValue: Member ${l} not found`);
          } else if (r instanceof Pi) {
            const d = r.getTypeName();
            let h = 0;
            if (l === "x" || l === "r") h = 0;
            else if (l === "y" || l === "g") h = 1;
            else if (l === "z" || l === "b") h = 2;
            else {
              if (l !== "w" && l !== "a") return void console.error(`SetDataValue: Unknown member ${l}`);
              h = 3;
            }
            if (!(I instanceof tg)) return void console.error("SetDataValue: Invalid value", I);
            const D = I.value;
            return d === "vec2f" ? void (new Float32Array(this.buffer, s, 2)[h] = D) : d === "vec3f" ? void (new Float32Array(this.buffer, s, 3)[h] = D) : d === "vec4f" ? void (new Float32Array(this.buffer, s, 4)[h] = D) : d === "vec2i" ? void (new Int32Array(this.buffer, s, 2)[h] = D) : d === "vec3i" ? void (new Int32Array(this.buffer, s, 3)[h] = D) : d === "vec4i" ? void (new Int32Array(this.buffer, s, 4)[h] = D) : d === "vec2u" ? void (new Uint32Array(this.buffer, s, 2)[h] = D) : d === "vec3u" ? void (new Uint32Array(this.buffer, s, 3)[h] = D) : d === "vec4u" ? void (new Uint32Array(this.buffer, s, 4)[h] = D) : void console.error(`SetDataValue: Type ${d} is not a struct`);
          }
        }
      }
      C = C.postfix;
    }
    this.setData(g, I, r, s, t);
  }
  setData(g, I, C, t, s) {
    const r = C.getTypeName();
    if (r !== "f32" && r !== "f16") if (r !== "i32" && r !== "atomic<i32>" && r !== "x32") if (r !== "u32" && r !== "atomic<u32>") if (r !== "bool") {
      if (r === "vec2f" || r === "vec2h") {
        const l = new Float32Array(this.buffer, t, 2);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1]) : (l[0] = I[0], l[1] = I[1]));
      }
      if (r === "vec3f" || r === "vec3h") {
        const l = new Float32Array(this.buffer, t, 3);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2]));
      }
      if (r === "vec4f" || r === "vec4h") {
        const l = new Float32Array(this.buffer, t, 4);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3]));
      }
      if (r === "vec2i") {
        const l = new Int32Array(this.buffer, t, 2);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1]) : (l[0] = I[0], l[1] = I[1]));
      }
      if (r === "vec3i") {
        const l = new Int32Array(this.buffer, t, 3);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2]));
      }
      if (r === "vec4i") {
        const l = new Int32Array(this.buffer, t, 4);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3]));
      }
      if (r === "vec2u") {
        const l = new Uint32Array(this.buffer, t, 2);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1]) : (l[0] = I[0], l[1] = I[1]));
      }
      if (r === "vec3u") {
        const l = new Uint32Array(this.buffer, t, 3);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2]));
      }
      if (r === "vec4u") {
        const l = new Uint32Array(this.buffer, t, 4);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3]));
      }
      if (r === "vec2b") {
        const l = new Uint32Array(this.buffer, t, 2);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1]) : (l[0] = I[0], l[1] = I[1]));
      }
      if (r === "vec3b") {
        const l = new Uint32Array(this.buffer, t, 3);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2]));
      }
      if (r === "vec4b") {
        const l = new Uint32Array(this.buffer, t, 4);
        return void (I instanceof X ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3]));
      }
      if (r === "mat2x2f" || r === "mat2x2h") {
        const l = new Float32Array(this.buffer, t, 4);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3]));
      }
      if (r === "mat2x3f" || r === "mat2x3h") {
        const l = new Float32Array(this.buffer, t, 6);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5]));
      }
      if (r === "mat2x4f" || r === "mat2x4h") {
        const l = new Float32Array(this.buffer, t, 8);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5], l[6] = I.data[6], l[7] = I.data[7]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5], l[6] = I[6], l[7] = I[7]));
      }
      if (r === "mat3x2f" || r === "mat3x2h") {
        const l = new Float32Array(this.buffer, t, 6);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5]));
      }
      if (r === "mat3x3f" || r === "mat3x3h") {
        const l = new Float32Array(this.buffer, t, 9);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5], l[6] = I.data[6], l[7] = I.data[7], l[8] = I.data[8]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5], l[6] = I[6], l[7] = I[7], l[8] = I[8]));
      }
      if (r === "mat3x4f" || r === "mat3x4h") {
        const l = new Float32Array(this.buffer, t, 12);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5], l[6] = I.data[6], l[7] = I.data[7], l[8] = I.data[8], l[9] = I.data[9], l[10] = I.data[10], l[11] = I.data[11]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5], l[6] = I[6], l[7] = I[7], l[8] = I[8], l[9] = I[9], l[10] = I[10], l[11] = I[11]));
      }
      if (r === "mat4x2f" || r === "mat4x2h") {
        const l = new Float32Array(this.buffer, t, 8);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5], l[6] = I.data[6], l[7] = I.data[7]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5], l[6] = I[6], l[7] = I[7]));
      }
      if (r === "mat4x3f" || r === "mat4x3h") {
        const l = new Float32Array(this.buffer, t, 12);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5], l[6] = I.data[6], l[7] = I.data[7], l[8] = I.data[8], l[9] = I.data[9], l[10] = I.data[10], l[11] = I.data[11]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5], l[6] = I[6], l[7] = I[7], l[8] = I[8], l[9] = I[9], l[10] = I[10], l[11] = I[11]));
      }
      if (r === "mat4x4f" || r === "mat4x4h") {
        const l = new Float32Array(this.buffer, t, 16);
        return void (I instanceof oI ? (l[0] = I.data[0], l[1] = I.data[1], l[2] = I.data[2], l[3] = I.data[3], l[4] = I.data[4], l[5] = I.data[5], l[6] = I.data[6], l[7] = I.data[7], l[8] = I.data[8], l[9] = I.data[9], l[10] = I.data[10], l[11] = I.data[11], l[12] = I.data[12], l[13] = I.data[13], l[14] = I.data[14], l[15] = I.data[15]) : (l[0] = I[0], l[1] = I[1], l[2] = I[2], l[3] = I[3], l[4] = I[4], l[5] = I[5], l[6] = I[6], l[7] = I[7], l[8] = I[8], l[9] = I[9], l[10] = I[10], l[11] = I[11], l[12] = I[12], l[13] = I[13], l[14] = I[14], l[15] = I[15]));
      }
      if (I instanceof ip) {
        if (C === I.typeInfo)
          return void new Uint8Array(this.buffer, t, I.buffer.byteLength).set(new Uint8Array(I.buffer));
        console.error("SetDataValue: Type mismatch", r, I.typeInfo.getTypeName());
      } else console.error(`SetData: Unknown type ${r}`);
    } else I instanceof tg && (new Int32Array(this.buffer, t, 1)[0] = I.value);
    else I instanceof tg && (new Uint32Array(this.buffer, t, 1)[0] = I.value);
    else I instanceof tg && (new Int32Array(this.buffer, t, 1)[0] = I.value);
    else I instanceof tg && (new Float32Array(this.buffer, t, 1)[0] = I.value);
  }
  getSubData(g, I, C) {
    var t, s, r;
    if (I === null) return this;
    let l = this.offset, d = this.typeInfo;
    for (; I; ) {
      if (I instanceof bf) {
        const D = I.index, w = D instanceof Kn ? g.evalExpression(D, C) : D;
        let p = 0;
        if (w instanceof tg ? p = w.value : typeof w == "number" ? p = w : console.error("GetDataValue: Invalid index type", D), d instanceof yr) l += p * d.stride, d = d.format;
        else {
          const b = d.getTypeName();
          b === "mat4x4" || b === "mat4x4f" || b === "mat4x4h" ? (l += 16 * p, d = g.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${d.getTypeName()} is not an array`);
        }
      } else {
        if (!(I instanceof Mc)) return console.error("GetDataValue: Unknown postfix type", I), null;
        {
          const D = I.value;
          if (d instanceof dr) {
            let w = !1;
            for (const p of d.members) if (p.name === D) {
              l += p.offset, d = p.type, w = !0;
              break;
            }
            if (!w) return console.error(`GetDataValue: Member ${D} not found`), null;
          } else if (d instanceof Pi) {
            const w = d.getTypeName();
            if (w === "vec2f" || w === "vec3f" || w === "vec4f" || w === "vec2i" || w === "vec3i" || w === "vec4i" || w === "vec2u" || w === "vec3u" || w === "vec4u" || w === "vec2b" || w === "vec3b" || w === "vec4b" || w === "vec2h" || w === "vec3h" || w === "vec4h" || w === "vec2" || w === "vec3" || w === "vec4") {
              if (D.length > 0 && D.length < 5) {
                let p = "f";
                const b = [];
                for (let S = 0; S < D.length; ++S) {
                  const K = D[S].toLowerCase();
                  let Y = 0;
                  if (K === "x" || K === "r") Y = 0;
                  else if (K === "y" || K === "g") Y = 1;
                  else if (K === "z" || K === "b") Y = 2;
                  else {
                    if (K !== "w" && K !== "a") return console.error(`Unknown member ${D}`), null;
                    Y = 3;
                  }
                  if (D.length === 1) {
                    if (w.endsWith("f")) return this.buffer.byteLength < l + 4 * Y + 4 ? (console.log("Insufficient buffer data"), null) : new tg(new Float32Array(this.buffer, l + 4 * Y, 1), g.getTypeInfo("f32"), this);
                    if (w.endsWith("h")) return new tg(new Float32Array(this.buffer, l + 4 * Y, 1), g.getTypeInfo("f16"), this);
                    if (w.endsWith("i")) return new tg(new Int32Array(this.buffer, l + 4 * Y, 1), g.getTypeInfo("i32"), this);
                    if (w.endsWith("b")) return new tg(new Int32Array(this.buffer, l + 4 * Y, 1), g.getTypeInfo("bool"), this);
                    if (w.endsWith("u")) return new tg(new Uint32Array(this.buffer, l + 4 * Y, 1), g.getTypeInfo("i32"), this);
                  }
                  if (w === "vec2f") b.push(new Float32Array(this.buffer, l, 2)[Y]);
                  else if (w === "vec3f") {
                    if (l + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const T = new Float32Array(this.buffer, l, 3);
                    b.push(T[Y]);
                  } else if (w === "vec4f") b.push(new Float32Array(this.buffer, l, 4)[Y]);
                  else if (w === "vec2i") p = "i", b.push(new Int32Array(this.buffer, l, 2)[Y]);
                  else if (w === "vec3i") p = "i", b.push(new Int32Array(this.buffer, l, 3)[Y]);
                  else if (w === "vec4i") p = "i", b.push(new Int32Array(this.buffer, l, 4)[Y]);
                  else if (w === "vec2u") {
                    p = "u";
                    const T = new Uint32Array(this.buffer, l, 2);
                    b.push(T[Y]);
                  } else w === "vec3u" ? (p = "u", b.push(new Uint32Array(this.buffer, l, 3)[Y])) : w === "vec4u" && (p = "u", b.push(new Uint32Array(this.buffer, l, 4)[Y]));
                }
                return b.length === 2 ? d = g.getTypeInfo(`vec2${p}`) : b.length === 3 ? d = g.getTypeInfo(`vec3${p}`) : b.length === 4 ? d = g.getTypeInfo(`vec4${p}`) : console.error(`GetDataValue: Invalid vector length ${b.length}`), new X(b, d, null);
              }
              return console.error(`GetDataValue: Unknown member ${D}`), null;
            }
            return console.error(`GetDataValue: Type ${w} is not a struct`), null;
          }
        }
      }
      I = I.postfix;
    }
    const h = d.getTypeName();
    return h === "f32" ? new tg(new Float32Array(this.buffer, l, 1), d, this) : h === "i32" ? new tg(new Int32Array(this.buffer, l, 1), d, this) : h === "u32" ? new tg(new Uint32Array(this.buffer, l, 1), d, this) : h === "vec2f" ? new X(new Float32Array(this.buffer, l, 2), d, this) : h === "vec3f" ? new X(new Float32Array(this.buffer, l, 3), d, this) : h === "vec4f" ? new X(new Float32Array(this.buffer, l, 4), d, this) : h === "vec2i" ? new X(new Int32Array(this.buffer, l, 2), d, this) : h === "vec3i" ? new X(new Int32Array(this.buffer, l, 3), d, this) : h === "vec4i" ? new X(new Int32Array(this.buffer, l, 4), d, this) : h === "vec2u" ? new X(new Uint32Array(this.buffer, l, 2), d, this) : h === "vec3u" ? new X(new Uint32Array(this.buffer, l, 3), d, this) : h === "vec4u" ? new X(new Uint32Array(this.buffer, l, 4), d, this) : d instanceof Dc && d.name === "atomic" ? ((t = d.format) === null || t === void 0 ? void 0 : t.name) === "u32" ? new tg(new Uint32Array(this.buffer, l, 1)[0], d.format, this) : ((s = d.format) === null || s === void 0 ? void 0 : s.name) === "i32" ? new tg(new Int32Array(this.buffer, l, 1)[0], d.format, this) : (console.error(`GetDataValue: Invalid atomic format ${(r = d.format) === null || r === void 0 ? void 0 : r.name}`), null) : new ip(this.buffer, d, l, this);
  }
  toString() {
    let g = "";
    if (this.typeInfo instanceof yr) if (this.typeInfo.format.name === "f32") {
      const I = new Float32Array(this.buffer, this.offset);
      g = `[${I[0]}`;
      for (let C = 1; C < I.length; ++C) g += `, ${I[C]}`;
    } else if (this.typeInfo.format.name === "i32") {
      const I = new Int32Array(this.buffer, this.offset);
      g = `[${I[0]}`;
      for (let C = 1; C < I.length; ++C) g += `, ${I[C]}`;
    } else if (this.typeInfo.format.name === "u32") {
      const I = new Uint32Array(this.buffer, this.offset);
      g = `[${I[0]}`;
      for (let C = 1; C < I.length; ++C) g += `, ${I[C]}`;
    } else if (this.typeInfo.format.name === "vec2f") {
      const I = new Float32Array(this.buffer, this.offset);
      g = `[${I[0]}, ${I[1]}]`;
      for (let C = 1; C < I.length / 2; ++C) g += `, [${I[2 * C]}, ${I[2 * C + 1]}]`;
    } else if (this.typeInfo.format.name === "vec3f") {
      const I = new Float32Array(this.buffer, this.offset);
      g = `[${I[0]}, ${I[1]}, ${I[2]}]`;
      for (let C = 4; C < I.length; C += 4) g += `, [${I[C]}, ${I[C + 1]}, ${I[C + 2]}]`;
    } else if (this.typeInfo.format.name === "vec4f") {
      const I = new Float32Array(this.buffer, this.offset);
      g = `[${I[0]}, ${I[1]}, ${I[2]}, ${I[3]}]`;
      for (let C = 4; C < I.length; C += 4) g += `, [${I[C]}, ${I[C + 1]}, ${I[C + 2]}, ${I[C + 3]}]`;
    } else g = "[...]";
    else this.typeInfo instanceof dr ? g += "{...}" : g = "[...]";
    return g;
  }
};
class Yo extends Hi {
  constructor(g, I, C, t) {
    super(I, null), this.data = g, this.descriptor = C, this.view = t;
  }
  clone() {
    return new Yo(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var g, I;
    const C = this.descriptor.size;
    return C instanceof Array && C.length > 0 ? (g = C[0]) !== null && g !== void 0 ? g : 0 : C instanceof Object && (I = C.width) !== null && I !== void 0 ? I : 0;
  }
  get height() {
    var g, I;
    const C = this.descriptor.size;
    return C instanceof Array && C.length > 1 ? (g = C[1]) !== null && g !== void 0 ? g : 0 : C instanceof Object && (I = C.height) !== null && I !== void 0 ? I : 0;
  }
  get depthOrArrayLayers() {
    var g, I;
    const C = this.descriptor.size;
    return C instanceof Array && C.length > 2 ? (g = C[2]) !== null && g !== void 0 ? g : 0 : C instanceof Object && (I = C.depthOrArrayLayers) !== null && I !== void 0 ? I : 0;
  }
  get format() {
    var g;
    return this.descriptor && (g = this.descriptor.format) !== null && g !== void 0 ? g : "rgba8unorm";
  }
  get sampleCount() {
    var g;
    return this.descriptor && (g = this.descriptor.sampleCount) !== null && g !== void 0 ? g : 1;
  }
  get mipLevelCount() {
    var g;
    return this.descriptor && (g = this.descriptor.mipLevelCount) !== null && g !== void 0 ? g : 1;
  }
  get dimension() {
    var g;
    return this.descriptor && (g = this.descriptor.dimension) !== null && g !== void 0 ? g : "2d";
  }
  getMipLevelSize(g) {
    if (g >= this.mipLevelCount) return [0, 0, 0];
    const I = [this.width, this.height, this.depthOrArrayLayers];
    for (let C = 0; C < I.length; ++C) I[C] = Math.max(1, I[C] >> g);
    return I;
  }
  get texelByteSize() {
    const g = this.format, I = fb[g];
    return I ? I.isDepthStencil ? 4 : I.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const g = this.format, I = fb[g];
    return !!I && I.isDepthStencil;
  }
  getGpuSize() {
    const g = this.format, I = fb[g], C = this.width;
    if (!g || C <= 0 || !I) return -1;
    const t = this.height, s = this.depthOrArrayLayers, r = this.dimension;
    return C / I.blockWidth * (r === "1d" ? 1 : t / I.blockHeight) * I.bytesPerBlock * s;
  }
  getPixel(g, I, C = 0, t = 0) {
    const s = this.texelByteSize, r = this.bytesPerRow, l = this.height, d = this.data[t];
    return xV(new Uint8Array(d), g, I, C, t, l, r, s, this.format);
  }
  setPixel(g, I, C, t, s) {
    const r = this.texelByteSize, l = this.bytesPerRow, d = this.height, h = this.data[t];
    (function(D, w, p, b, S, K, Y, T, E, H) {
      const R = b * (Y >>= S) * (K >>= S) + p * Y + w * T;
      switch (E) {
        case "r8unorm":
          return void nA(D, R, "8unorm", 1, H);
        case "r8snorm":
          return void nA(D, R, "8snorm", 1, H);
        case "r8uint":
          return void nA(D, R, "8uint", 1, H);
        case "r8sint":
          return void nA(D, R, "8sint", 1, H);
        case "rg8unorm":
          return void nA(D, R, "8unorm", 2, H);
        case "rg8snorm":
          return void nA(D, R, "8snorm", 2, H);
        case "rg8uint":
          return void nA(D, R, "8uint", 2, H);
        case "rg8sint":
          return void nA(D, R, "8sint", 2, H);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void nA(D, R, "8unorm", 4, H);
        case "rgba8snorm":
          return void nA(D, R, "8snorm", 4, H);
        case "rgba8uint":
          return void nA(D, R, "8uint", 4, H);
        case "rgba8sint":
          return void nA(D, R, "8sint", 4, H);
        case "r16uint":
          return void nA(D, R, "16uint", 1, H);
        case "r16sint":
          return void nA(D, R, "16sint", 1, H);
        case "r16float":
          return void nA(D, R, "16float", 1, H);
        case "rg16uint":
          return void nA(D, R, "16uint", 2, H);
        case "rg16sint":
          return void nA(D, R, "16sint", 2, H);
        case "rg16float":
          return void nA(D, R, "16float", 2, H);
        case "rgba16uint":
          return void nA(D, R, "16uint", 4, H);
        case "rgba16sint":
          return void nA(D, R, "16sint", 4, H);
        case "rgba16float":
          return void nA(D, R, "16float", 4, H);
        case "r32uint":
          return void nA(D, R, "32uint", 1, H);
        case "r32sint":
          return void nA(D, R, "32sint", 1, H);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void nA(D, R, "32float", 1, H);
        case "rg32uint":
          return void nA(D, R, "32uint", 2, H);
        case "rg32sint":
          return void nA(D, R, "32sint", 2, H);
        case "rg32float":
          return void nA(D, R, "32float", 2, H);
        case "rgba32uint":
          return void nA(D, R, "32uint", 4, H);
        case "rgba32sint":
          return void nA(D, R, "32sint", 4, H);
        case "rgba32float":
          return void nA(D, R, "32float", 4, H);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    })(new Uint8Array(h), g, I, C, t, d, l, r, this.format, s);
  }
}
((A) => {
  A[A.token = 0] = "token", A[A.keyword = 1] = "keyword", A[A.reserved = 2] = "reserved";
})(ng || (ng = {}));
class sg {
  constructor(g, I, C) {
    this.name = g, this.type = I, this.rule = C;
  }
  toString() {
    return this.name;
  }
}
class V {
}
fg = V, V.none = new sg("", ng.reserved, ""), V.eof = new sg("EOF", ng.token, ""), V.reserved = { asm: new sg("asm", ng.reserved, "asm"), bf16: new sg("bf16", ng.reserved, "bf16"), do: new sg("do", ng.reserved, "do"), enum: new sg("enum", ng.reserved, "enum"), f16: new sg("f16", ng.reserved, "f16"), f64: new sg("f64", ng.reserved, "f64"), handle: new sg("handle", ng.reserved, "handle"), i8: new sg("i8", ng.reserved, "i8"), i16: new sg("i16", ng.reserved, "i16"), i64: new sg("i64", ng.reserved, "i64"), mat: new sg("mat", ng.reserved, "mat"), premerge: new sg("premerge", ng.reserved, "premerge"), regardless: new sg("regardless", ng.reserved, "regardless"), typedef: new sg("typedef", ng.reserved, "typedef"), u8: new sg("u8", ng.reserved, "u8"), u16: new sg("u16", ng.reserved, "u16"), u64: new sg("u64", ng.reserved, "u64"), unless: new sg("unless", ng.reserved, "unless"), using: new sg("using", ng.reserved, "using"), vec: new sg("vec", ng.reserved, "vec"), void: new sg("void", ng.reserved, "void") }, V.keywords = { array: new sg("array", ng.keyword, "array"), atomic: new sg("atomic", ng.keyword, "atomic"), bool: new sg("bool", ng.keyword, "bool"), f32: new sg("f32", ng.keyword, "f32"), i32: new sg("i32", ng.keyword, "i32"), mat2x2: new sg("mat2x2", ng.keyword, "mat2x2"), mat2x3: new sg("mat2x3", ng.keyword, "mat2x3"), mat2x4: new sg("mat2x4", ng.keyword, "mat2x4"), mat3x2: new sg("mat3x2", ng.keyword, "mat3x2"), mat3x3: new sg("mat3x3", ng.keyword, "mat3x3"), mat3x4: new sg("mat3x4", ng.keyword, "mat3x4"), mat4x2: new sg("mat4x2", ng.keyword, "mat4x2"), mat4x3: new sg("mat4x3", ng.keyword, "mat4x3"), mat4x4: new sg("mat4x4", ng.keyword, "mat4x4"), ptr: new sg("ptr", ng.keyword, "ptr"), sampler: new sg("sampler", ng.keyword, "sampler"), sampler_comparison: new sg("sampler_comparison", ng.keyword, "sampler_comparison"), struct: new sg("struct", ng.keyword, "struct"), texture_1d: new sg("texture_1d", ng.keyword, "texture_1d"), texture_2d: new sg("texture_2d", ng.keyword, "texture_2d"), texture_2d_array: new sg("texture_2d_array", ng.keyword, "texture_2d_array"), texture_3d: new sg("texture_3d", ng.keyword, "texture_3d"), texture_cube: new sg("texture_cube", ng.keyword, "texture_cube"), texture_cube_array: new sg("texture_cube_array", ng.keyword, "texture_cube_array"), texture_multisampled_2d: new sg("texture_multisampled_2d", ng.keyword, "texture_multisampled_2d"), texture_storage_1d: new sg("texture_storage_1d", ng.keyword, "texture_storage_1d"), texture_storage_2d: new sg("texture_storage_2d", ng.keyword, "texture_storage_2d"), texture_storage_2d_array: new sg("texture_storage_2d_array", ng.keyword, "texture_storage_2d_array"), texture_storage_3d: new sg("texture_storage_3d", ng.keyword, "texture_storage_3d"), texture_depth_2d: new sg("texture_depth_2d", ng.keyword, "texture_depth_2d"), texture_depth_2d_array: new sg("texture_depth_2d_array", ng.keyword, "texture_depth_2d_array"), texture_depth_cube: new sg("texture_depth_cube", ng.keyword, "texture_depth_cube"), texture_depth_cube_array: new sg("texture_depth_cube_array", ng.keyword, "texture_depth_cube_array"), texture_depth_multisampled_2d: new sg("texture_depth_multisampled_2d", ng.keyword, "texture_depth_multisampled_2d"), texture_external: new sg("texture_external", ng.keyword, "texture_external"), u32: new sg("u32", ng.keyword, "u32"), vec2: new sg("vec2", ng.keyword, "vec2"), vec3: new sg("vec3", ng.keyword, "vec3"), vec4: new sg("vec4", ng.keyword, "vec4"), bitcast: new sg("bitcast", ng.keyword, "bitcast"), block: new sg("block", ng.keyword, "block"), break: new sg("break", ng.keyword, "break"), case: new sg("case", ng.keyword, "case"), continue: new sg("continue", ng.keyword, "continue"), continuing: new sg("continuing", ng.keyword, "continuing"), default: new sg("default", ng.keyword, "default"), diagnostic: new sg("diagnostic", ng.keyword, "diagnostic"), discard: new sg("discard", ng.keyword, "discard"), else: new sg("else", ng.keyword, "else"), enable: new sg("enable", ng.keyword, "enable"), fallthrough: new sg("fallthrough", ng.keyword, "fallthrough"), false: new sg("false", ng.keyword, "false"), fn: new sg("fn", ng.keyword, "fn"), for: new sg("for", ng.keyword, "for"), function: new sg("function", ng.keyword, "function"), if: new sg("if", ng.keyword, "if"), let: new sg("let", ng.keyword, "let"), const: new sg("const", ng.keyword, "const"), loop: new sg("loop", ng.keyword, "loop"), while: new sg("while", ng.keyword, "while"), private: new sg("private", ng.keyword, "private"), read: new sg("read", ng.keyword, "read"), read_write: new sg("read_write", ng.keyword, "read_write"), return: new sg("return", ng.keyword, "return"), requires: new sg("requires", ng.keyword, "requires"), storage: new sg("storage", ng.keyword, "storage"), switch: new sg("switch", ng.keyword, "switch"), true: new sg("true", ng.keyword, "true"), alias: new sg("alias", ng.keyword, "alias"), type: new sg("type", ng.keyword, "type"), uniform: new sg("uniform", ng.keyword, "uniform"), var: new sg("var", ng.keyword, "var"), override: new sg("override", ng.keyword, "override"), workgroup: new sg("workgroup", ng.keyword, "workgroup"), write: new sg("write", ng.keyword, "write"), r8unorm: new sg("r8unorm", ng.keyword, "r8unorm"), r8snorm: new sg("r8snorm", ng.keyword, "r8snorm"), r8uint: new sg("r8uint", ng.keyword, "r8uint"), r8sint: new sg("r8sint", ng.keyword, "r8sint"), r16uint: new sg("r16uint", ng.keyword, "r16uint"), r16sint: new sg("r16sint", ng.keyword, "r16sint"), r16float: new sg("r16float", ng.keyword, "r16float"), rg8unorm: new sg("rg8unorm", ng.keyword, "rg8unorm"), rg8snorm: new sg("rg8snorm", ng.keyword, "rg8snorm"), rg8uint: new sg("rg8uint", ng.keyword, "rg8uint"), rg8sint: new sg("rg8sint", ng.keyword, "rg8sint"), r32uint: new sg("r32uint", ng.keyword, "r32uint"), r32sint: new sg("r32sint", ng.keyword, "r32sint"), r32float: new sg("r32float", ng.keyword, "r32float"), rg16uint: new sg("rg16uint", ng.keyword, "rg16uint"), rg16sint: new sg("rg16sint", ng.keyword, "rg16sint"), rg16float: new sg("rg16float", ng.keyword, "rg16float"), rgba8unorm: new sg("rgba8unorm", ng.keyword, "rgba8unorm"), rgba8unorm_srgb: new sg("rgba8unorm_srgb", ng.keyword, "rgba8unorm_srgb"), rgba8snorm: new sg("rgba8snorm", ng.keyword, "rgba8snorm"), rgba8uint: new sg("rgba8uint", ng.keyword, "rgba8uint"), rgba8sint: new sg("rgba8sint", ng.keyword, "rgba8sint"), bgra8unorm: new sg("bgra8unorm", ng.keyword, "bgra8unorm"), bgra8unorm_srgb: new sg("bgra8unorm_srgb", ng.keyword, "bgra8unorm_srgb"), rgb10a2unorm: new sg("rgb10a2unorm", ng.keyword, "rgb10a2unorm"), rg11b10float: new sg("rg11b10float", ng.keyword, "rg11b10float"), rg32uint: new sg("rg32uint", ng.keyword, "rg32uint"), rg32sint: new sg("rg32sint", ng.keyword, "rg32sint"), rg32float: new sg("rg32float", ng.keyword, "rg32float"), rgba16uint: new sg("rgba16uint", ng.keyword, "rgba16uint"), rgba16sint: new sg("rgba16sint", ng.keyword, "rgba16sint"), rgba16float: new sg("rgba16float", ng.keyword, "rgba16float"), rgba32uint: new sg("rgba32uint", ng.keyword, "rgba32uint"), rgba32sint: new sg("rgba32sint", ng.keyword, "rgba32sint"), rgba32float: new sg("rgba32float", ng.keyword, "rgba32float"), static_assert: new sg("static_assert", ng.keyword, "static_assert") }, V.tokens = { decimal_float_literal: new sg("decimal_float_literal", ng.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/), hex_float_literal: new sg("hex_float_literal", ng.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/), int_literal: new sg("int_literal", ng.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/), uint_literal: new sg("uint_literal", ng.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/), name: new sg("name", ng.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u), ident: new sg("ident", ng.token, /[_a-zA-Z][0-9a-zA-Z_]*/), and: new sg("and", ng.token, "&"), and_and: new sg("and_and", ng.token, "&&"), arrow: new sg("arrow ", ng.token, "->"), attr: new sg("attr", ng.token, "@"), forward_slash: new sg("forward_slash", ng.token, "/"), bang: new sg("bang", ng.token, "!"), bracket_left: new sg("bracket_left", ng.token, "["), bracket_right: new sg("bracket_right", ng.token, "]"), brace_left: new sg("brace_left", ng.token, "{"), brace_right: new sg("brace_right", ng.token, "}"), colon: new sg("colon", ng.token, ":"), comma: new sg("comma", ng.token, ","), equal: new sg("equal", ng.token, "="), equal_equal: new sg("equal_equal", ng.token, "=="), not_equal: new sg("not_equal", ng.token, "!="), greater_than: new sg("greater_than", ng.token, ">"), greater_than_equal: new sg("greater_than_equal", ng.token, ">="), shift_right: new sg("shift_right", ng.token, ">>"), less_than: new sg("less_than", ng.token, "<"), less_than_equal: new sg("less_than_equal", ng.token, "<="), shift_left: new sg("shift_left", ng.token, "<<"), modulo: new sg("modulo", ng.token, "%"), minus: new sg("minus", ng.token, "-"), minus_minus: new sg("minus_minus", ng.token, "--"), period: new sg("period", ng.token, "."), plus: new sg("plus", ng.token, "+"), plus_plus: new sg("plus_plus", ng.token, "++"), or: new sg("or", ng.token, "|"), or_or: new sg("or_or", ng.token, "||"), paren_left: new sg("paren_left", ng.token, "("), paren_right: new sg("paren_right", ng.token, ")"), semicolon: new sg("semicolon", ng.token, ";"), star: new sg("star", ng.token, "*"), tilde: new sg("tilde", ng.token, "~"), underscore: new sg("underscore", ng.token, "_"), xor: new sg("xor", ng.token, "^"), plus_equal: new sg("plus_equal", ng.token, "+="), minus_equal: new sg("minus_equal", ng.token, "-="), times_equal: new sg("times_equal", ng.token, "*="), division_equal: new sg("division_equal", ng.token, "/="), modulo_equal: new sg("modulo_equal", ng.token, "%="), and_equal: new sg("and_equal", ng.token, "&="), or_equal: new sg("or_equal", ng.token, "|="), xor_equal: new sg("xor_equal", ng.token, "^="), shift_right_equal: new sg("shift_right_equal", ng.token, ">>="), shift_left_equal: new sg("shift_left_equal", ng.token, "<<=") }, V.simpleTokens = { "@": fg.tokens.attr, "{": fg.tokens.brace_left, "}": fg.tokens.brace_right, ":": fg.tokens.colon, ",": fg.tokens.comma, "(": fg.tokens.paren_left, ")": fg.tokens.paren_right, ";": fg.tokens.semicolon }, V.literalTokens = { "&": fg.tokens.and, "&&": fg.tokens.and_and, "->": fg.tokens.arrow, "/": fg.tokens.forward_slash, "!": fg.tokens.bang, "[": fg.tokens.bracket_left, "]": fg.tokens.bracket_right, "=": fg.tokens.equal, "==": fg.tokens.equal_equal, "!=": fg.tokens.not_equal, ">": fg.tokens.greater_than, ">=": fg.tokens.greater_than_equal, ">>": fg.tokens.shift_right, "<": fg.tokens.less_than, "<=": fg.tokens.less_than_equal, "<<": fg.tokens.shift_left, "%": fg.tokens.modulo, "-": fg.tokens.minus, "--": fg.tokens.minus_minus, ".": fg.tokens.period, "+": fg.tokens.plus, "++": fg.tokens.plus_plus, "|": fg.tokens.or, "||": fg.tokens.or_or, "*": fg.tokens.star, "~": fg.tokens.tilde, _: fg.tokens.underscore, "^": fg.tokens.xor, "+=": fg.tokens.plus_equal, "-=": fg.tokens.minus_equal, "*=": fg.tokens.times_equal, "/=": fg.tokens.division_equal, "%=": fg.tokens.modulo_equal, "&=": fg.tokens.and_equal, "|=": fg.tokens.or_equal, "^=": fg.tokens.xor_equal, ">>=": fg.tokens.shift_right_equal, "<<=": fg.tokens.shift_left_equal }, V.regexTokens = { decimal_float_literal: fg.tokens.decimal_float_literal, hex_float_literal: fg.tokens.hex_float_literal, int_literal: fg.tokens.int_literal, uint_literal: fg.tokens.uint_literal, ident: fg.tokens.ident }, V.storage_class = [fg.keywords.function, fg.keywords.private, fg.keywords.workgroup, fg.keywords.uniform, fg.keywords.storage], V.access_mode = [fg.keywords.read, fg.keywords.write, fg.keywords.read_write], V.sampler_type = [fg.keywords.sampler, fg.keywords.sampler_comparison], V.sampled_texture_type = [fg.keywords.texture_1d, fg.keywords.texture_2d, fg.keywords.texture_2d_array, fg.keywords.texture_3d, fg.keywords.texture_cube, fg.keywords.texture_cube_array], V.multisampled_texture_type = [fg.keywords.texture_multisampled_2d], V.storage_texture_type = [fg.keywords.texture_storage_1d, fg.keywords.texture_storage_2d, fg.keywords.texture_storage_2d_array, fg.keywords.texture_storage_3d], V.depth_texture_type = [fg.keywords.texture_depth_2d, fg.keywords.texture_depth_2d_array, fg.keywords.texture_depth_cube, fg.keywords.texture_depth_cube_array, fg.keywords.texture_depth_multisampled_2d], V.texture_external_type = [fg.keywords.texture_external], V.any_texture_type = [...fg.sampled_texture_type, ...fg.multisampled_texture_type, ...fg.storage_texture_type, ...fg.depth_texture_type, ...fg.texture_external_type], V.texel_format = [fg.keywords.r8unorm, fg.keywords.r8snorm, fg.keywords.r8uint, fg.keywords.r8sint, fg.keywords.r16uint, fg.keywords.r16sint, fg.keywords.r16float, fg.keywords.rg8unorm, fg.keywords.rg8snorm, fg.keywords.rg8uint, fg.keywords.rg8sint, fg.keywords.r32uint, fg.keywords.r32sint, fg.keywords.r32float, fg.keywords.rg16uint, fg.keywords.rg16sint, fg.keywords.rg16float, fg.keywords.rgba8unorm, fg.keywords.rgba8unorm_srgb, fg.keywords.rgba8snorm, fg.keywords.rgba8uint, fg.keywords.rgba8sint, fg.keywords.bgra8unorm, fg.keywords.bgra8unorm_srgb, fg.keywords.rgb10a2unorm, fg.keywords.rg11b10float, fg.keywords.rg32uint, fg.keywords.rg32sint, fg.keywords.rg32float, fg.keywords.rgba16uint, fg.keywords.rgba16sint, fg.keywords.rgba16float, fg.keywords.rgba32uint, fg.keywords.rgba32sint, fg.keywords.rgba32float], V.const_literal = [fg.tokens.int_literal, fg.tokens.uint_literal, fg.tokens.decimal_float_literal, fg.tokens.hex_float_literal, fg.keywords.true, fg.keywords.false], V.literal_or_ident = [fg.tokens.ident, fg.tokens.int_literal, fg.tokens.uint_literal, fg.tokens.decimal_float_literal, fg.tokens.hex_float_literal, fg.tokens.name], V.element_count_expression = [fg.tokens.int_literal, fg.tokens.uint_literal, fg.tokens.ident], V.template_types = [fg.keywords.vec2, fg.keywords.vec3, fg.keywords.vec4, fg.keywords.mat2x2, fg.keywords.mat2x3, fg.keywords.mat2x4, fg.keywords.mat3x2, fg.keywords.mat3x3, fg.keywords.mat3x4, fg.keywords.mat4x2, fg.keywords.mat4x3, fg.keywords.mat4x4, fg.keywords.atomic, fg.keywords.bitcast, ...fg.any_texture_type], V.attribute_name = [fg.tokens.ident, fg.keywords.block, fg.keywords.diagnostic], V.assignment_operators = [fg.tokens.equal, fg.tokens.plus_equal, fg.tokens.minus_equal, fg.tokens.times_equal, fg.tokens.division_equal, fg.tokens.modulo_equal, fg.tokens.and_equal, fg.tokens.or_equal, fg.tokens.xor_equal, fg.tokens.shift_right_equal, fg.tokens.shift_left_equal], V.increment_operators = [fg.tokens.plus_plus, fg.tokens.minus_minus];
class vP {
  constructor(g, I, C, t, s) {
    this.type = g, this.lexeme = I, this.line = C, this.start = t, this.end = s;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return V.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == V.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
let JV = class {
  constructor(g) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = g ?? "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new vP(V.eof, "", this._line, this._current, this._current)), this._tokens;
  }
  scanToken() {
    let g = this._advance();
    if (g == `
`) return this._line++, !0;
    if (this._isWhitespace(g)) return !0;
    if (g == "/") {
      if (this._peekAhead() == "/") {
        for (; g != `
`; ) {
          if (this._isAtEnd()) return !0;
          g = this._advance();
        }
        return this._line++, !0;
      }
      if (this._peekAhead() == "*") {
        this._advance();
        let r = 1;
        for (; r > 0; ) {
          if (this._isAtEnd()) return !0;
          if (g = this._advance(), g == `
`) this._line++;
          else if (g == "*") {
            if (this._peekAhead() == "/" && (this._advance(), r--, r == 0)) return !0;
          } else g == "/" && this._peekAhead() == "*" && (this._advance(), r++);
        }
        return !0;
      }
    }
    const I = V.simpleTokens[g];
    if (I) return this._addToken(I), !0;
    let C = V.none;
    const t = this._isAlpha(g), s = g === "_";
    if (this._isAlphaNumeric(g)) {
      let r = this._peekAhead();
      for (; this._isAlphaNumeric(r); ) g += this._advance(), r = this._peekAhead();
    }
    if (t) {
      const r = V.keywords[g];
      if (r) return this._addToken(r), !0;
    }
    if (t || s) return this._addToken(V.tokens.ident), !0;
    for (; ; ) {
      let r = this._findType(g);
      const l = this._peekAhead();
      if (g == "-" && this._tokens.length > 0) {
        if (l == "=") return this._current++, g += l, this._addToken(V.tokens.minus_equal), !0;
        if (l == "-") return this._current++, g += l, this._addToken(V.tokens.minus_minus), !0;
        const d = this._tokens.length - 1;
        if ((V.literal_or_ident.indexOf(this._tokens[d].type) != -1 || this._tokens[d].type == V.tokens.paren_right) && l != ">") return this._addToken(r), !0;
      }
      if (g == ">" && (l == ">" || l == "=")) {
        let d = !1, h = this._tokens.length - 1;
        for (let D = 0; D < 5 && h >= 0 && V.assignment_operators.indexOf(this._tokens[h].type) === -1; ++D, --h) if (this._tokens[h].type === V.tokens.less_than) {
          h > 0 && this._tokens[h - 1].isArrayOrTemplateType() && (d = !0);
          break;
        }
        if (d) return this._addToken(r), !0;
      }
      if (r === V.none) {
        let d = g, h = 0;
        const D = 2;
        for (let w = 0; w < D; ++w) if (d += this._peekAhead(w), r = this._findType(d), r !== V.none) {
          h = w;
          break;
        }
        if (r === V.none) return C !== V.none && (this._current--, this._addToken(C), !0);
        g = d, this._current += h + 1;
      }
      if (C = r, this._isAtEnd()) break;
      g += this._advance();
    }
    return C !== V.none && (this._addToken(C), !0);
  }
  _findType(g) {
    for (const C in V.regexTokens) {
      const t = V.regexTokens[C];
      if (this._match(g, t.rule)) return t;
    }
    return V.literalTokens[g] || V.none;
  }
  _match(g, I) {
    const C = I.exec(g);
    return C && C.index == 0 && C[0] == g;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(g) {
    return !this._isNumeric(g) && !this._isWhitespace(g) && g !== "_" && g !== "." && g !== "(" && g !== ")" && g !== "[" && g !== "]" && g !== "{" && g !== "}" && g !== "," && g !== ";" && g !== ":" && g !== "=" && g !== "!" && g !== "<" && g !== ">" && g !== "+" && g !== "-" && g !== "*" && g !== "/" && g !== "%" && g !== "&" && g !== "|" && g !== "^" && g !== "~" && g !== "@" && g !== "#" && g !== "?" && g !== "'" && g !== "`" && g !== '"' && g !== "\\" && g !== `
` && g !== "\r" && g !== "	" && g !== "\0";
  }
  _isNumeric(g) {
    return g >= "0" && g <= "9";
  }
  _isAlphaNumeric(g) {
    return this._isAlpha(g) || this._isNumeric(g) || g === "_";
  }
  _isWhitespace(g) {
    return g == " " || g == "	" || g == "\r";
  }
  _advance(g = 0) {
    let I = this._source[this._current];
    return g = g || 0, g++, this._current += g, I;
  }
  _peekAhead(g = 0) {
    return g = g || 0, this._current + g >= this._source.length ? "\0" : this._source[this._current + g];
  }
  _addToken(g) {
    const I = this._source.substring(this._start, this._current);
    this._tokens.push(new vP(g, I, this._line, this._start, this._current));
  }
};
function zg(A) {
  return Array.isArray(A) || A?.buffer instanceof ArrayBuffer;
}
const bp = new Float32Array(1), LV = new Uint32Array(bp.buffer), qV = new Uint32Array(bp.buffer), Sp = new Int32Array(1), $V = new Float32Array(Sp.buffer), gx = new Uint32Array(Sp.buffer), Gp = new Uint32Array(1), Ix = new Float32Array(Gp.buffer), Ax = new Int32Array(Gp.buffer);
function HP(A, g, I) {
  if (g === I) return A;
  if (g === "f32") {
    if (I === "i32" || I === "x32") return bp[0] = A, LV[0];
    if (I === "u32") return bp[0] = A, qV[0];
  } else if (g === "i32" || g === "x32") {
    if (I === "f32") return Sp[0] = A, $V[0];
    if (I === "u32") return Sp[0] = A, gx[0];
  } else if (g === "u32") {
    if (I === "f32") return Gp[0] = A, Ix[0];
    if (I === "i32" || I === "x32") return Gp[0] = A, Ax[0];
  }
  return console.error(`Unsupported cast from ${g} to ${I}`), A;
}
class Cx {
  constructor(g) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = g;
  }
}
class HB {
  constructor(g, I) {
    this.align = g, this.size = I;
  }
}
class ps {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new NV(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(g) {
    return g.name == "texture_storage_1d" || g.name == "texture_storage_2d" || g.name == "texture_storage_2d_array" || g.name == "texture_storage_3d";
  }
  updateAST(g) {
    for (const I of g) I instanceof cM && this._functions.set(I.name, new Cx(I));
    for (const I of g) if (I instanceof To) {
      const C = this.getTypeInfo(I, null);
      C instanceof dr && this.structs.push(C);
    }
    for (const I of g) if (I instanceof mG) this.aliases.push(this._getAliasInfo(I));
    else {
      if (I instanceof BG) {
        const C = I, t = this._getAttributeNum(C.attributes, "id", 0), s = C.type != null ? this.getTypeInfo(C.type, C.attributes) : null;
        this.overrides.push(new EV(C.name, s, C.attributes, t));
        continue;
      }
      if (this._isUniformVar(I)) {
        const C = I, t = this._getAttributeNum(C.attributes, "group", 0), s = this._getAttributeNum(C.attributes, "binding", 0), r = this.getTypeInfo(C.type, C.attributes), l = new vB(C.name, r, t, s, C.attributes, cr.Uniform, C.access);
        l.access || (l.access = "read"), this.uniforms.push(l);
        continue;
      }
      if (this._isStorageVar(I)) {
        const C = I, t = this._getAttributeNum(C.attributes, "group", 0), s = this._getAttributeNum(C.attributes, "binding", 0), r = this.getTypeInfo(C.type, C.attributes), l = this._isStorageTexture(r), d = new vB(C.name, r, t, s, C.attributes, l ? cr.StorageTexture : cr.Storage, C.access);
        d.access || (d.access = "read"), this.storage.push(d);
        continue;
      }
      if (this._isTextureVar(I)) {
        const C = I, t = this._getAttributeNum(C.attributes, "group", 0), s = this._getAttributeNum(C.attributes, "binding", 0), r = this.getTypeInfo(C.type, C.attributes), l = this._isStorageTexture(r), d = new vB(C.name, r, t, s, C.attributes, l ? cr.StorageTexture : cr.Texture, C.access);
        d.access || (d.access = "read"), l ? this.storage.push(d) : this.textures.push(d);
        continue;
      }
      if (this._isSamplerVar(I)) {
        const C = I, t = this._getAttributeNum(C.attributes, "group", 0), s = this._getAttributeNum(C.attributes, "binding", 0), r = this.getTypeInfo(C.type, C.attributes), l = new vB(C.name, r, t, s, C.attributes, cr.Sampler, C.access);
        this.samplers.push(l);
        continue;
      }
    }
    for (const I of g) if (I instanceof cM) {
      const C = this._getAttribute(I, "vertex"), t = this._getAttribute(I, "fragment"), s = this._getAttribute(I, "compute"), r = C || t || s, l = new OV(I.name, r?.name, I.attributes);
      l.attributes = I.attributes, l.startLine = I.startLine, l.endLine = I.endLine, this.functions.push(l), this._functions.get(I.name).info = l, r && (this._functions.get(I.name).inUse = !0, l.inUse = !0, l.resources = this._findResources(I, !!r), l.inputs = this._getInputs(I.args), l.outputs = this._getOutputs(I.returnType), this.entry[r.name].push(l)), l.arguments = I.args.map((d) => new RV(d.name, this.getTypeInfo(d.type, d.attributes), d.attributes)), l.returnType = I.returnType ? this.getTypeInfo(I.returnType, I.attributes) : null;
      continue;
    }
    for (const I of this._functions.values()) I.info && (I.info.inUse = I.inUse, this._addCalls(I.node, I.info.calls));
    for (const I of this._functions.values()) I.node.search((C) => {
      var t, s, r;
      if (C instanceof Jj) {
        if (C.value) if (zg(C.value)) for (const l of C.value) for (const d of this.overrides) l === d.name && ((t = I.info) === null || t === void 0 || t.overrides.push(d));
        else for (const l of this.overrides) C.value === l.name && ((s = I.info) === null || s === void 0 || s.overrides.push(l));
      } else if (C instanceof Ft) for (const l of this.overrides) C.name === l.name && ((r = I.info) === null || r === void 0 || r.overrides.push(l));
    });
    for (const I of this.uniforms) this._markStructsInUse(I.type);
    for (const I of this.storage) this._markStructsInUse(I.type);
  }
  getFunctionInfo(g) {
    for (const I of this.functions) if (I.name == g) return I;
    return null;
  }
  getStructInfo(g) {
    for (const I of this.structs) if (I.name == g) return I;
    return null;
  }
  getOverrideInfo(g) {
    for (const I of this.overrides) if (I.name == g) return I;
    return null;
  }
  _markStructsInUse(g) {
    if (g) if (g.isStruct) {
      if (g.inUse = !0, g.members) for (const I of g.members) this._markStructsInUse(I.type);
    } else if (g.isArray) this._markStructsInUse(g.format);
    else if (g.isTemplate) g.format && this._markStructsInUse(g.format);
    else {
      const I = this._getAlias(g.name);
      I && this._markStructsInUse(I);
    }
  }
  _addCalls(g, I) {
    var C;
    for (const t of g.calls) {
      const s = (C = this._functions.get(t.name)) === null || C === void 0 ? void 0 : C.info;
      s && I.add(s);
    }
  }
  findResource(g, I, C) {
    if (C) {
      for (const t of this.entry.compute) if (t.name === C) {
        for (const s of t.resources) if (s.group == g && s.binding == I) return s;
      }
      for (const t of this.entry.vertex) if (t.name === C) {
        for (const s of t.resources) if (s.group == g && s.binding == I) return s;
      }
      for (const t of this.entry.fragment) if (t.name === C) {
        for (const s of t.resources) if (s.group == g && s.binding == I) return s;
      }
    }
    for (const t of this.uniforms) if (t.group == g && t.binding == I) return t;
    for (const t of this.storage) if (t.group == g && t.binding == I) return t;
    for (const t of this.textures) if (t.group == g && t.binding == I) return t;
    for (const t of this.samplers) if (t.group == g && t.binding == I) return t;
    return null;
  }
  _findResource(g) {
    for (const I of this.uniforms) if (I.name == g) return I;
    for (const I of this.storage) if (I.name == g) return I;
    for (const I of this.textures) if (I.name == g) return I;
    for (const I of this.samplers) if (I.name == g) return I;
    return null;
  }
  _markStructsFromAST(g) {
    const I = this.getTypeInfo(g, null);
    this._markStructsInUse(I);
  }
  _findResources(g, I) {
    const C = [], t = this, s = [];
    return g.search((r) => {
      if (r instanceof pp) s.push({});
      else if (r instanceof mp) s.pop();
      else if (r instanceof Po) {
        const l = r;
        I && l.type !== null && this._markStructsFromAST(l.type), s.length > 0 && (s[s.length - 1][l.name] = l);
      } else if (r instanceof Ms) {
        const l = r;
        I && l.type !== null && this._markStructsFromAST(l.type);
      } else if (r instanceof tM) {
        const l = r;
        I && l.type !== null && this._markStructsFromAST(l.type), s.length > 0 && (s[s.length - 1][l.name] = l);
      } else if (r instanceof Ft) {
        const l = r;
        if (s.length > 0 && s[s.length - 1][l.name])
          return;
        const d = t._findResource(l.name);
        d && C.push(d);
      } else if (r instanceof bG) {
        const l = r, d = t._functions.get(l.name);
        d && (I && (d.inUse = !0), g.calls.add(d.node), d.resources === null && (d.resources = t._findResources(d.node, I)), C.push(...d.resources));
      } else if (r instanceof pG) {
        const l = r, d = t._functions.get(l.name);
        d && (I && (d.inUse = !0), g.calls.add(d.node), d.resources === null && (d.resources = t._findResources(d.node, I)), C.push(...d.resources));
      }
    }), [...new Map(C.map((r) => [r.name, r])).values()];
  }
  getBindGroups() {
    const g = [];
    function I(C, t) {
      C >= g.length && (g.length = C + 1), g[C] === void 0 && (g[C] = []), t >= g[C].length && (g[C].length = t + 1);
    }
    for (const C of this.uniforms)
      I(C.group, C.binding), g[C.group][C.binding] = C;
    for (const C of this.storage)
      I(C.group, C.binding), g[C.group][C.binding] = C;
    for (const C of this.textures)
      I(C.group, C.binding), g[C.group][C.binding] = C;
    for (const C of this.samplers)
      I(C.group, C.binding), g[C.group][C.binding] = C;
    return g;
  }
  _getOutputs(g, I = void 0) {
    if (I === void 0 && (I = []), g instanceof To) this._getStructOutputs(g, I);
    else {
      const C = this._getOutputInfo(g);
      C !== null && I.push(C);
    }
    return I;
  }
  _getStructOutputs(g, I) {
    for (const C of g.members) if (C.type instanceof To) this._getStructOutputs(C.type, I);
    else {
      const t = this._getAttribute(C, "location") || this._getAttribute(C, "builtin");
      if (t !== null) {
        const s = this.getTypeInfo(C.type, C.type.attributes), r = this._parseInt(t.value), l = new TP(C.name, s, t.name, r);
        I.push(l);
      }
    }
  }
  _getOutputInfo(g) {
    const I = this._getAttribute(g, "location") || this._getAttribute(g, "builtin");
    if (I !== null) {
      const C = this.getTypeInfo(g, g.attributes), t = this._parseInt(I.value);
      return new TP("", C, I.name, t);
    }
    return null;
  }
  _getInputs(g, I = void 0) {
    I === void 0 && (I = []);
    for (const C of g) if (C.type instanceof To) this._getStructInputs(C.type, I);
    else {
      const t = this._getInputInfo(C);
      t !== null && I.push(t);
    }
    return I;
  }
  _getStructInputs(g, I) {
    for (const C of g.members) if (C.type instanceof To) this._getStructInputs(C.type, I);
    else {
      const t = this._getInputInfo(C);
      t !== null && I.push(t);
    }
  }
  _getInputInfo(g) {
    const I = this._getAttribute(g, "location") || this._getAttribute(g, "builtin");
    if (I !== null) {
      const C = this._getAttribute(g, "interpolation"), t = this.getTypeInfo(g.type, g.attributes), s = this._parseInt(I.value), r = new HV(g.name, t, I.name, s);
      return C !== null && (r.interpolation = this._parseString(C.value)), r;
    }
    return null;
  }
  _parseString(g) {
    return g instanceof Array && (g = g[0]), g;
  }
  _parseInt(g) {
    g instanceof Array && (g = g[0]);
    const I = parseInt(g);
    return isNaN(I) ? g : I;
  }
  _getAlias(g) {
    for (const I of this.aliases) if (I.name == g) return I.type;
    return null;
  }
  _getAliasInfo(g) {
    return new vV(g.name, this.getTypeInfo(g.type, null));
  }
  getTypeInfoByName(g) {
    for (const I of this.structs) if (I.name == g) return I;
    for (const I of this.aliases) if (I.name == g) return I.type;
    return null;
  }
  getTypeInfo(g, I = null) {
    if (this._types.has(g)) return this._types.get(g);
    if (g instanceof ep) {
      const t = g.type ? this.getTypeInfo(g.type, g.attributes) : null, s = new rS(g.name, t, I);
      return this._types.set(g, s), this._updateTypeInfo(s), s;
    }
    if (g instanceof iM) {
      const t = g, s = t.format ? this.getTypeInfo(t.format, t.attributes) : null, r = new yr(t.name, I);
      return r.format = s, r.count = t.count, this._types.set(g, r), this._updateTypeInfo(r), r;
    }
    if (g instanceof To) {
      const t = g, s = new dr(t.name, I);
      s.startLine = t.startLine, s.endLine = t.endLine;
      for (const r of t.members) {
        const l = this.getTypeInfo(r.type, r.attributes);
        s.members.push(new KP(r.name, l, r.attributes));
      }
      return this._types.set(g, s), this._updateTypeInfo(s), s;
    }
    if (g instanceof JD) {
      const t = g, s = t.format instanceof Eg, r = t.format ? s ? this.getTypeInfo(t.format, null) : new Pi(t.format, null) : null, l = new Dc(t.name, r, I, t.access);
      return this._types.set(g, l), this._updateTypeInfo(l), l;
    }
    if (g instanceof lg) {
      const t = g, s = t.format ? this.getTypeInfo(t.format, null) : null, r = new Dc(t.name, s, I, t.access);
      return this._types.set(g, r), this._updateTypeInfo(r), r;
    }
    const C = new Pi(g.name, I);
    return this._types.set(g, C), this._updateTypeInfo(C), C;
  }
  _updateTypeInfo(g) {
    var I, C, t;
    const s = this._getTypeSize(g);
    if (g.size = (I = s?.size) !== null && I !== void 0 ? I : 0, g instanceof yr && g.format) {
      const r = this._getTypeSize(g.format);
      g.stride = Math.max((C = r?.size) !== null && C !== void 0 ? C : 0, (t = r?.align) !== null && t !== void 0 ? t : 0), this._updateTypeInfo(g.format);
    }
    g instanceof rS && this._updateTypeInfo(g.format), g instanceof dr && this._updateStructInfo(g);
  }
  _updateStructInfo(g) {
    var I;
    let C = 0, t = 0, s = 0, r = 0;
    for (let l = 0, d = g.members.length; l < d; ++l) {
      const h = g.members[l], D = this._getTypeSize(h);
      if (!D) continue;
      (I = this._getAlias(h.type.name)) !== null && I !== void 0 || h.type;
      const w = D.align, p = D.size;
      C = this._roundUp(w, C + t), t = p, s = C, r = Math.max(r, w), h.offset = C, h.size = p, this._updateTypeInfo(h.type);
    }
    g.size = this._roundUp(r, s + t), g.align = r;
  }
  _getTypeSize(g) {
    var I, C;
    if (g == null) return null;
    const t = this._getAttributeNum(g.attributes, "size", 0), s = this._getAttributeNum(g.attributes, "align", 0);
    if (g instanceof KP && (g = g.type), g instanceof Pi) {
      const r = this._getAlias(g.name);
      r !== null && (g = r);
    }
    {
      const r = ps._typeInfo[g.name];
      if (r !== void 0) {
        const l = ((I = g.format) === null || I === void 0 ? void 0 : I.name) === "f16" ? 2 : 1;
        return new HB(Math.max(s, r.align / l), Math.max(t, r.size / l));
      }
    }
    {
      const r = ps._typeInfo[g.name.substring(0, g.name.length - 1)];
      if (r) {
        const l = g.name[g.name.length - 1] === "h" ? 2 : 1;
        return new HB(Math.max(s, r.align / l), Math.max(t, r.size / l));
      }
    }
    if (g instanceof yr) {
      let r = g, l = 8, d = 8;
      const h = this._getTypeSize(r.format);
      return h !== null && (d = h.size, l = h.align), d = r.count * this._getAttributeNum((C = g?.attributes) !== null && C !== void 0 ? C : null, "stride", this._roundUp(l, d)), t && (d = t), new HB(Math.max(s, l), Math.max(t, d));
    }
    if (g instanceof dr) {
      let r = 0, l = 0, d = 0, h = 0, D = 0;
      for (const w of g.members) {
        const p = this._getTypeSize(w.type);
        p !== null && (r = Math.max(p.align, r), d = this._roundUp(p.align, d + h), h = p.size, D = d);
      }
      return l = this._roundUp(r, D + h), new HB(Math.max(s, r), Math.max(t, l));
    }
    return null;
  }
  _isUniformVar(g) {
    return g instanceof Po && g.storage == "uniform";
  }
  _isStorageVar(g) {
    return g instanceof Po && g.storage == "storage";
  }
  _isTextureVar(g) {
    return g instanceof Po && g.type !== null && ps._textureTypes.indexOf(g.type.name) != -1;
  }
  _isSamplerVar(g) {
    return g instanceof Po && g.type !== null && ps._samplerTypes.indexOf(g.type.name) != -1;
  }
  _getAttribute(g, I) {
    const C = g;
    if (!C || !C.attributes) return null;
    const t = C.attributes;
    for (let s of t) if (s.name == I) return s;
    return null;
  }
  _getAttributeNum(g, I, C) {
    if (g === null) return C;
    for (let t of g) if (t.name == I) {
      let s = t !== null && t.value !== null ? t.value : C;
      return s instanceof Array && (s = s[0]), typeof s == "number" ? s : typeof s == "string" ? parseInt(s) : C;
    }
    return C;
  }
  _roundUp(g, I) {
    return Math.ceil(I / g) * g;
  }
}
ps._typeInfo = { f16: { align: 2, size: 2 }, i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, atomic: { align: 4, size: 4 }, vec2: { align: 8, size: 8 }, vec3: { align: 16, size: 12 }, vec4: { align: 16, size: 16 }, mat2x2: { align: 8, size: 16 }, mat3x2: { align: 8, size: 24 }, mat4x2: { align: 8, size: 32 }, mat2x3: { align: 16, size: 32 }, mat3x3: { align: 16, size: 48 }, mat4x3: { align: 16, size: 64 }, mat2x4: { align: 16, size: 32 }, mat3x4: { align: 16, size: 48 }, mat4x4: { align: 16, size: 64 } }, ps._textureTypes = V.any_texture_type.map((A) => A.name), ps._samplerTypes = V.sampler_type.map((A) => A.name);
let SG = 0;
class GG {
  constructor(g, I, C) {
    this.id = SG++, this.name = g, this.value = I, this.node = C;
  }
  clone() {
    return new GG(this.name, this.value, this.node);
  }
}
class KG {
  constructor(g) {
    this.id = SG++, this.name = g.name, this.node = g;
  }
  clone() {
    return new KG(this.node);
  }
}
class TG {
  constructor(g) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = SG++, g && (this.parent = g, this.currentFunctionName = g.currentFunctionName);
  }
  getVariable(g) {
    var I;
    return this.variables.has(g) ? (I = this.variables.get(g)) !== null && I !== void 0 ? I : null : this.parent ? this.parent.getVariable(g) : null;
  }
  getFunction(g) {
    var I;
    return this.functions.has(g) ? (I = this.functions.get(g)) !== null && I !== void 0 ? I : null : this.parent ? this.parent.getFunction(g) : null;
  }
  createVariable(g, I, C) {
    this.variables.set(g, new GG(g, I, C ?? null));
  }
  setVariable(g, I, C) {
    const t = this.getVariable(g);
    t !== null ? t.value = I : this.createVariable(g, I, C);
  }
  getVariableValue(g) {
    var I;
    const C = this.getVariable(g);
    return (I = C?.value) !== null && I !== void 0 ? I : null;
  }
  clone() {
    return new TG(this);
  }
}
class ex {
  evalExpression(g, I) {
    return null;
  }
  getTypeInfo(g) {
    return null;
  }
  getVariableName(g, I) {
    return "";
  }
}
class tx {
  constructor(g) {
    this.exec = g;
  }
  getTypeInfo(g) {
    return this.exec.getTypeInfo(g);
  }
  All(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    let t = !0;
    if (C instanceof X) return C.data.forEach((s) => {
      s || (t = !1);
    }), new tg(t ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${g.line}`);
  }
  Any(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) {
      const t = C.data.some((s) => s);
      return new tg(t ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${g.line}`);
  }
  Select(g, I) {
    const C = this.exec.evalExpression(g.args[2], I);
    if (!(C instanceof tg)) throw new Error(`Select() expects a bool condition. Line ${g.line}`);
    return C.value ? this.exec.evalExpression(g.args[1], I) : this.exec.evalExpression(g.args[0], I);
  }
  ArrayLength(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.evalExpression(C, I);
    if (t instanceof VC && t.typeInfo.size === 0) {
      const s = t.typeInfo, r = t.buffer.byteLength / s.stride;
      return new tg(r, this.getTypeInfo("u32"));
    }
    return new tg(t.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.abs(s)), C.typeInfo);
    const t = C;
    return new tg(Math.abs(t.value), t.typeInfo);
  }
  Acos(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.acos(s)), C.typeInfo);
    const t = C;
    return new tg(Math.acos(t.value), C.typeInfo);
  }
  Acosh(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.acosh(s)), C.typeInfo);
    const t = C;
    return new tg(Math.acosh(t.value), C.typeInfo);
  }
  Asin(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.asin(s)), C.typeInfo);
    const t = C;
    return new tg(Math.asin(t.value), C.typeInfo);
  }
  Asinh(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.asinh(s)), C.typeInfo);
    const t = C;
    return new tg(Math.asinh(t.value), C.typeInfo);
  }
  Atan(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.atan(s)), C.typeInfo);
    const t = C;
    return new tg(Math.atan(t.value), C.typeInfo);
  }
  Atanh(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.atanh(s)), C.typeInfo);
    const t = C;
    return new tg(Math.atanh(t.value), C.typeInfo);
  }
  Atan2(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) return new X(C.data.map((l, d) => Math.atan2(l, t.data[d])), C.typeInfo);
    const s = C, r = t;
    return new tg(Math.atan2(s.value, r.value), C.typeInfo);
  }
  Ceil(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.ceil(s)), C.typeInfo);
    const t = C;
    return new tg(Math.ceil(t.value), C.typeInfo);
  }
  _clamp(g, I, C) {
    return Math.min(Math.max(g, I), C);
  }
  Clamp(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (C instanceof X && t instanceof X && s instanceof X) return new X(C.data.map((h, D) => this._clamp(h, t.data[D], s.data[D])), C.typeInfo);
    const r = C, l = t, d = s;
    return new tg(this._clamp(r.value, l.value, d.value), C.typeInfo);
  }
  Cos(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.cos(s)), C.typeInfo);
    const t = C;
    return new tg(Math.cos(t.value), C.typeInfo);
  }
  Cosh(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.cosh(s)), C.typeInfo);
    const t = C;
    return new tg(Math.cos(t.value), C.typeInfo);
  }
  CountLeadingZeros(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.clz32(s)), C.typeInfo);
    const t = C;
    return new tg(Math.clz32(t.value), C.typeInfo);
  }
  _countOneBits(g) {
    let I = 0;
    for (; g !== 0; ) 1 & g && I++, g >>= 1;
    return I;
  }
  CountOneBits(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => this._countOneBits(s)), C.typeInfo);
    const t = C;
    return new tg(this._countOneBits(t.value), C.typeInfo);
  }
  _countTrailingZeros(g) {
    if (g === 0) return 32;
    let I = 0;
    for (; !(1 & g); ) g >>= 1, I++;
    return I;
  }
  CountTrailingZeros(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => this._countTrailingZeros(s)), C.typeInfo);
    const t = C;
    return new tg(this._countTrailingZeros(t.value), C.typeInfo);
  }
  Cross(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) {
      if (C.data.length !== 3 || t.data.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${g.line}`), null;
      const s = C.data, r = t.data;
      return new X([s[1] * r[2] - r[1] * s[2], s[2] * r[0] - r[2] * s[0], s[0] * r[1] - r[0] * s[1]], C.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${g.line}`), null;
  }
  Degrees(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = 180 / Math.PI;
    return C instanceof X ? new X(C.data.map((s) => s * t), C.typeInfo) : new tg(C.value * t, this.getTypeInfo("f32"));
  }
  Determinant(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof oI) {
      const t = C.data, s = C.typeInfo.getTypeName(), r = s.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if (s === "mat2x2" || s === "mat2x2f" || s === "mat2x2h") return new tg(t[0] * t[3] - t[1] * t[2], r);
      if (s === "mat2x3" || s === "mat2x3f" || s === "mat2x3h") return new tg(t[0] * (t[4] * t[8] - t[5] * t[7]) - t[1] * (t[3] * t[8] - t[5] * t[6]) + t[2] * (t[3] * t[7] - t[4] * t[6]), r);
      if (s === "mat2x4" || s === "mat2x4f" || s === "mat2x4h") console.error(`TODO: Determinant for ${s}`);
      else if (s === "mat3x2" || s === "mat3x2f" || s === "mat3x2h") console.error(`TODO: Determinant for ${s}`);
      else {
        if (s === "mat3x3" || s === "mat3x3f" || s === "mat3x3h") return new tg(t[0] * (t[4] * t[8] - t[5] * t[7]) - t[1] * (t[3] * t[8] - t[5] * t[6]) + t[2] * (t[3] * t[7] - t[4] * t[6]), r);
        s === "mat3x4" || s === "mat3x4f" || s === "mat3x4h" || s === "mat4x2" || s === "mat4x2f" || s === "mat4x2h" || s === "mat4x3" || s === "mat4x3f" || s === "mat4x3h" ? console.error(`TODO: Determinant for ${s}`) : s !== "mat4x4" && s !== "mat4x4f" && s !== "mat4x4h" || console.error(`TODO: Determinant for ${s}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${g.line}`), null;
  }
  Distance(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) {
      let l = 0;
      for (let d = 0; d < C.data.length; ++d) l += (C.data[d] - t.data[d]) * (C.data[d] - t.data[d]);
      return new tg(Math.sqrt(l), this.getTypeInfo("f32"));
    }
    const s = C, r = t;
    return new tg(Math.abs(s.value - r.value), C.typeInfo);
  }
  _dot(g, I) {
    let C = 0;
    for (let t = 0; t < g.length; ++t) C += I[t] * g[t];
    return C;
  }
  Dot(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    return C instanceof X && t instanceof X ? new tg(this._dot(C.data, t.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${g.line}`), null);
  }
  Dot4U8Packed(g, I) {
    return console.error(`TODO: dot4U8Packed. Line ${g.line}`), null;
  }
  Dot4I8Packed(g, I) {
    return console.error(`TODO: dot4I8Packed. Line ${g.line}`), null;
  }
  Exp(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.exp(s)), C.typeInfo);
    const t = C;
    return new tg(Math.exp(t.value), C.typeInfo);
  }
  Exp2(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.pow(2, s)), C.typeInfo);
    const t = C;
    return new tg(Math.pow(2, t.value), C.typeInfo);
  }
  ExtractBits(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (t.typeInfo.name !== "u32" && t.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${g.line}`), null;
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${g.line}`), null;
    const r = t.value, l = s.value;
    if (C instanceof X) return new X(C.data.map((h) => h >> r & (1 << l) - 1), C.typeInfo);
    if (C.typeInfo.name !== "i32" && C.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${g.line}`), null;
    const d = C.value;
    return new tg(d >> r & (1 << l) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (C instanceof X && t instanceof X && s instanceof X) {
      const r = this._dot(t.data, s.data);
      return new X(r < 0 ? Array.from(C.data) : C.data.map((l) => -l), C.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${g.line}`), null;
  }
  _firstLeadingBit(g) {
    return g === 0 ? -1 : 31 - Math.clz32(g);
  }
  FirstLeadingBit(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => this._firstLeadingBit(s)), C.typeInfo);
    const t = C;
    return new tg(this._firstLeadingBit(t.value), C.typeInfo);
  }
  _firstTrailingBit(g) {
    return g === 0 ? -1 : Math.log2(g & -g);
  }
  FirstTrailingBit(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => this._firstTrailingBit(s)), C.typeInfo);
    const t = C;
    return new tg(this._firstTrailingBit(t.value), C.typeInfo);
  }
  Floor(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.floor(s)), C.typeInfo);
    const t = C;
    return new tg(Math.floor(t.value), C.typeInfo);
  }
  Fma(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (C instanceof X && t instanceof X && s instanceof X) return C.data.length !== t.data.length || C.data.length !== s.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${g.line}`), null) : new X(C.data.map((h, D) => h * t.data[D] + s.data[D]), C.typeInfo);
    const r = C, l = t, d = s;
    return new tg(r.value * l.value + d.value, r.typeInfo);
  }
  Fract(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => s - Math.floor(s)), C.typeInfo);
    const t = C;
    return new tg(t.value - Math.floor(t.value), C.typeInfo);
  }
  Frexp(g, I) {
    return console.error(`TODO: frexp. Line ${g.line}`), null;
  }
  InsertBits(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I), r = this.exec.evalExpression(g.args[3], I);
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${g.line}`), null;
    const l = s.value, d = (1 << r.value) - 1 << l, h = ~d;
    if (C instanceof X && t instanceof X) return new X(C.data.map((p, b) => p & h | t.data[b] << l & d), C.typeInfo);
    const D = C.value, w = t.value;
    return new tg(D & h | w << l & d, C.typeInfo);
  }
  InverseSqrt(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => 1 / Math.sqrt(s)), C.typeInfo);
    const t = C;
    return new tg(1 / Math.sqrt(t.value), C.typeInfo);
  }
  Ldexp(g, I) {
    return console.error(`TODO: ldexp. Line ${g.line}`), null;
  }
  Length(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) {
      let s = 0;
      return C.data.forEach((r) => {
        s += r * r;
      }), new tg(Math.sqrt(s), this.getTypeInfo("f32"));
    }
    const t = C;
    return new tg(Math.abs(t.value), C.typeInfo);
  }
  Log(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.log(s)), C.typeInfo);
    const t = C;
    return new tg(Math.log(t.value), C.typeInfo);
  }
  Log2(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.log2(s)), C.typeInfo);
    const t = C;
    return new tg(Math.log2(t.value), C.typeInfo);
  }
  Max(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) return new X(C.data.map((l, d) => Math.max(l, t.data[d])), C.typeInfo);
    const s = C, r = t;
    return new tg(Math.max(s.value, r.value), C.typeInfo);
  }
  Min(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) return new X(C.data.map((l, d) => Math.min(l, t.data[d])), C.typeInfo);
    const s = C, r = t;
    return new tg(Math.min(s.value, r.value), C.typeInfo);
  }
  Mix(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (C instanceof X && t instanceof X && s instanceof X) return new X(C.data.map((d, h) => C.data[h] * (1 - s.data[h]) + t.data[h] * s.data[h]), C.typeInfo);
    const r = t, l = s;
    return new tg(C.value * (1 - l.value) + r.value * l.value, C.typeInfo);
  }
  Modf(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) return new X(C.data.map((r, l) => r % t.data[l]), C.typeInfo);
    const s = t;
    return new tg(C.value % s.value, C.typeInfo);
  }
  Normalize(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) {
      const t = this.Length(g, I).value;
      return new X(C.data.map((s) => s / t), C.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${g.line}`), null;
  }
  Pow(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) return new X(C.data.map((l, d) => Math.pow(l, t.data[d])), C.typeInfo);
    const s = C, r = t;
    return new tg(Math.pow(s.value, r.value), C.typeInfo);
  }
  QuantizeToF16(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    return C instanceof X ? new X(C.data.map((t) => t), C.typeInfo) : new tg(C.value, C.typeInfo);
  }
  Radians(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    return C instanceof X ? new X(C.data.map((t) => t * Math.PI / 180), C.typeInfo) : new tg(C.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(g, I) {
    let C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (C instanceof X && t instanceof X) {
      const s = this._dot(C.data, t.data);
      return new X(C.data.map((r, l) => r - 2 * s * t.data[l]), C.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${g.line}`), null;
  }
  Refract(g, I) {
    let C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (C instanceof X && t instanceof X && s instanceof tg) {
      const r = this._dot(t.data, C.data);
      return new X(C.data.map((l, d) => {
        const h = 1 - s.value * s.value * (1 - r * r);
        if (h < 0) return 0;
        const D = Math.sqrt(h);
        return s.value * l - (s.value * r + D) * t.data[d];
      }), C.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${g.line}`), null;
  }
  ReverseBits(g, I) {
    return console.error(`TODO: reverseBits. Line ${g.line}`), null;
  }
  Round(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.round(s)), C.typeInfo);
    const t = C;
    return new tg(Math.round(t.value), C.typeInfo);
  }
  Saturate(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.min(Math.max(s, 0), 1)), C.typeInfo);
    const t = C;
    return new tg(Math.min(Math.max(t.value, 0), 1), C.typeInfo);
  }
  Sign(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.sign(s)), C.typeInfo);
    const t = C;
    return new tg(Math.sign(t.value), C.typeInfo);
  }
  Sin(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.sin(s)), C.typeInfo);
    const t = C;
    return new tg(Math.sin(t.value), C.typeInfo);
  }
  Sinh(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.sinh(s)), C.typeInfo);
    const t = C;
    return new tg(Math.sinh(t.value), C.typeInfo);
  }
  _smoothstep(g, I, C) {
    const t = Math.min(Math.max((C - g) / (I - g), 0), 1);
    return t * t * (3 - 2 * t);
  }
  SmoothStep(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I), s = this.exec.evalExpression(g.args[2], I);
    if (s instanceof X && C instanceof X && t instanceof X) return new X(s.data.map((h, D) => this._smoothstep(C.data[D], t.data[D], h)), s.typeInfo);
    const r = C, l = t, d = s;
    return new tg(this._smoothstep(r.value, l.value, d.value), s.typeInfo);
  }
  Sqrt(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.sqrt(s)), C.typeInfo);
    const t = C;
    return new tg(Math.sqrt(t.value), C.typeInfo);
  }
  Step(g, I) {
    const C = this.exec.evalExpression(g.args[0], I), t = this.exec.evalExpression(g.args[1], I);
    if (t instanceof X && C instanceof X) return new X(t.data.map((r, l) => r < C.data[l] ? 0 : 1), t.typeInfo);
    const s = C;
    return new tg(t.value < s.value ? 0 : 1, s.typeInfo);
  }
  Tan(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.tan(s)), C.typeInfo);
    const t = C;
    return new tg(Math.tan(t.value), C.typeInfo);
  }
  Tanh(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.tanh(s)), C.typeInfo);
    const t = C;
    return new tg(Math.tanh(t.value), C.typeInfo);
  }
  _getTransposeType(g) {
    const I = g.getTypeName();
    return I === "mat2x2f" || I === "mat2x2h" ? g : I === "mat2x3f" ? this.getTypeInfo("mat3x2f") : I === "mat2x3h" ? this.getTypeInfo("mat3x2h") : I === "mat2x4f" ? this.getTypeInfo("mat4x2f") : I === "mat2x4h" ? this.getTypeInfo("mat4x2h") : I === "mat3x2f" ? this.getTypeInfo("mat2x3f") : I === "mat3x2h" ? this.getTypeInfo("mat2x3h") : I === "mat3x3f" || I === "mat3x3h" ? g : I === "mat3x4f" ? this.getTypeInfo("mat4x3f") : I === "mat3x4h" ? this.getTypeInfo("mat4x3h") : I === "mat4x2f" ? this.getTypeInfo("mat2x4f") : I === "mat4x2h" ? this.getTypeInfo("mat2x4h") : I === "mat4x3f" ? this.getTypeInfo("mat3x4f") : I === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (I === "mat4x4f" || I === "mat4x4h" || console.error(`Invalid matrix type ${I}`), g);
  }
  Transpose(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (!(C instanceof oI)) return console.error(`Transpose() expects a matrix argument. Line ${g.line}`), null;
    const t = this._getTransposeType(C.typeInfo);
    if (C.typeInfo.name === "mat2x2" || C.typeInfo.name === "mat2x2f" || C.typeInfo.name === "mat2x2h") {
      const s = C.data;
      return new oI([s[0], s[2], s[1], s[3]], t);
    }
    if (C.typeInfo.name === "mat2x3" || C.typeInfo.name === "mat2x3f" || C.typeInfo.name === "mat2x3h") {
      const s = C.data;
      return new oI([s[0], s[3], s[6], s[1], s[4], s[7]], t);
    }
    if (C.typeInfo.name === "mat2x4" || C.typeInfo.name === "mat2x4f" || C.typeInfo.name === "mat2x4h") {
      const s = C.data;
      return new oI([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13]], t);
    }
    if (C.typeInfo.name === "mat3x2" || C.typeInfo.name === "mat3x2f" || C.typeInfo.name === "mat3x2h") {
      const s = C.data;
      return new oI([s[0], s[3], s[1], s[4], s[2], s[5]], t);
    }
    if (C.typeInfo.name === "mat3x3" || C.typeInfo.name === "mat3x3f" || C.typeInfo.name === "mat3x3h") {
      const s = C.data;
      return new oI([s[0], s[3], s[6], s[1], s[4], s[7], s[2], s[5], s[8]], t);
    }
    if (C.typeInfo.name === "mat3x4" || C.typeInfo.name === "mat3x4f" || C.typeInfo.name === "mat3x4h") {
      const s = C.data;
      return new oI([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14]], t);
    }
    if (C.typeInfo.name === "mat4x2" || C.typeInfo.name === "mat4x2f" || C.typeInfo.name === "mat4x2h") {
      const s = C.data;
      return new oI([s[0], s[4], s[1], s[5], s[2], s[6]], t);
    }
    if (C.typeInfo.name === "mat4x3" || C.typeInfo.name === "mat4x3f" || C.typeInfo.name === "mat4x3h") {
      const s = C.data;
      return new oI([s[0], s[4], s[8], s[1], s[5], s[9], s[2], s[6], s[10]], t);
    }
    if (C.typeInfo.name === "mat4x4" || C.typeInfo.name === "mat4x4f" || C.typeInfo.name === "mat4x4h") {
      const s = C.data;
      return new oI([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14], s[3], s[7], s[11], s[15]], t);
    }
    return console.error(`Invalid matrix type ${C.typeInfo.name}`), null;
  }
  Trunc(g, I) {
    const C = this.exec.evalExpression(g.args[0], I);
    if (C instanceof X) return new X(C.data.map((s) => Math.trunc(s)), C.typeInfo);
    const t = C;
    return new tg(Math.trunc(t.value), C.typeInfo);
  }
  Dpdx(g, I) {
    return console.error(`TODO: dpdx. Line ${g.line}`), null;
  }
  DpdxCoarse(g, I) {
    return console.error(`TODO: dpdxCoarse. Line ${g.line}`), null;
  }
  DpdxFine(g, I) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(g, I) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(g, I) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(g, I) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(g, I) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(g, I) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(g, I) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(g, I) {
    const C = g.args[0], t = g.args.length > 1 ? this.exec.evalExpression(g.args[1], I).value : 0;
    if (C instanceof Ft) {
      const s = C.name, r = I.getVariableValue(s);
      if (r instanceof Yo) {
        if (t < 0 || t >= r.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${g.line}`), null;
        const l = r.getMipLevelSize(t), d = r.dimension;
        return d === "1d" ? new tg(l[0], this.getTypeInfo("u32")) : d === "3d" ? new X(l, this.getTypeInfo("vec3u")) : d === "2d" ? new X(l.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${d} not found. Line ${g.line}`), null);
      }
      return console.error(`Texture ${s} not found. Line ${g.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${g.line}`), null;
  }
  TextureGather(g, I) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(g, I) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(g, I) {
    const C = g.args[0], t = this.exec.evalExpression(g.args[1], I), s = g.args.length > 2 ? this.exec.evalExpression(g.args[2], I).value : 0;
    if (!(t instanceof X) || t.data.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${g.line}`), null;
    if (C instanceof Ft) {
      const r = C.name, l = I.getVariableValue(r);
      if (l instanceof Yo) {
        const d = Math.floor(t.data[0]), h = Math.floor(t.data[1]);
        if (d < 0 || d >= l.width || h < 0 || h >= l.height) return console.error(`Texture ${r} out of bounds. Line ${g.line}`), null;
        const D = l.getPixel(d, h, 0, s);
        return D === null ? (console.error(`Invalid texture format for textureLoad. Line ${g.line}`), null) : new X(D, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${r} not found. Line ${g.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${g.line}`), null;
  }
  TextureNumLayers(g, I) {
    const C = g.args[0];
    if (C instanceof Ft) {
      const t = C.name, s = I.getVariableValue(t);
      return s instanceof Yo ? new tg(s.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${t} not found. Line ${g.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${g.line}`), null;
  }
  TextureNumLevels(g, I) {
    const C = g.args[0];
    if (C instanceof Ft) {
      const t = C.name, s = I.getVariableValue(t);
      return s instanceof Yo ? new tg(s.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${t} not found. Line ${g.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${g.line}`), null;
  }
  TextureNumSamples(g, I) {
    const C = g.args[0];
    if (C instanceof Ft) {
      const t = C.name, s = I.getVariableValue(t);
      return s instanceof Yo ? new tg(s.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${t} not found. Line ${g.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${g.line}`), null;
  }
  TextureSample(g, I) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(g, I) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(g, I) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(g, I) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(g, I) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(g, I) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(g, I) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(g, I) {
    const C = g.args[0], t = this.exec.evalExpression(g.args[1], I), s = g.args.length === 4 ? this.exec.evalExpression(g.args[2], I).value : 0, r = g.args.length === 4 ? this.exec.evalExpression(g.args[3], I).data : this.exec.evalExpression(g.args[2], I).data;
    if (r.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${g.line}`), null;
    if (!(t instanceof X) || t.data.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${g.line}`), null;
    if (C instanceof Ft) {
      const l = C.name, d = I.getVariableValue(l);
      if (d instanceof Yo) {
        const h = d.getMipLevelSize(0), D = Math.floor(t.data[0]), w = Math.floor(t.data[1]);
        return D < 0 || D >= h[0] || w < 0 || w >= h[1] ? (console.error(`Texture ${l} out of bounds. Line ${g.line}`), null) : (d.setPixel(D, w, 0, s, Array.from(r)), null);
      }
      return console.error(`Texture ${l} not found. Line ${g.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${g.line}`), null;
  }
  AtomicLoad(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I);
    return I.getVariable(t).value.getSubData(this.exec, C.postfix, I);
  }
  AtomicStore(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I);
    return d instanceof tg && l instanceof tg && (d.value = l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), null;
  }
  AtomicAdd(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value += l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicSub(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value -= l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicMax(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value = Math.max(d.value, l.value)), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicMin(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value = Math.min(d.value, l.value)), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicAnd(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value = d.value & l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicOr(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value = d.value | l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicXor(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value = d.value ^ l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicExchange(g, I) {
    let C = g.args[0];
    C instanceof dC && (C = C.right);
    const t = this.exec.getVariableName(C, I), s = I.getVariable(t);
    let r = g.args[1];
    const l = this.exec.evalExpression(r, I), d = s.value.getSubData(this.exec, C.postfix, I), h = new tg(d.value, d.typeInfo);
    return d instanceof tg && l instanceof tg && (d.value = l.value), s.value instanceof VC && s.value.setDataValue(this.exec, d, C.postfix, I), h;
  }
  AtomicCompareExchangeWeak(g, I) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(g, I) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(g, I) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(g, I) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(g, I) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(g, I) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(g, I) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(g, I) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(g, I) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(g, I) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(g, I) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(g, I) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(g, I) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(g, I) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(g, I) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(g, I) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(g, I) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(g, I) {
    return null;
  }
  TextureBarrier(g, I) {
    return null;
  }
  WorkgroupBarrier(g, I) {
    return null;
  }
  WorkgroupUniformLoad(g, I) {
    return null;
  }
  SubgroupAdd(g, I) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(g, I) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(g, I) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(g, I) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(g, I) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(g, I) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(g, I) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(g, I) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(g, I) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(g, I) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(g, I) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(g, I) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(g, I) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(g, I) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(g, I) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(g, I) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(g, I) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(g, I) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(g, I) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(g, I) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(g, I) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(g, I) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(g, I) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(g, I) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(g, I) {
    return console.error("TODO: quadSwapY"), null;
  }
}
const hb = { vec2: 2, vec2f: 2, vec2i: 2, vec2u: 2, vec2b: 2, vec2h: 2, vec3: 3, vec3f: 3, vec3i: 3, vec3u: 3, vec3b: 3, vec3h: 3, vec4: 4, vec4f: 4, vec4i: 4, vec4u: 4, vec4b: 4, vec4h: 4 }, Fe = { mat2x2: [2, 2, 4], mat2x2f: [2, 2, 4], mat2x2h: [2, 2, 4], mat2x3: [2, 3, 6], mat2x3f: [2, 3, 6], mat2x3h: [2, 3, 6], mat2x4: [2, 4, 8], mat2x4f: [2, 4, 8], mat2x4h: [2, 4, 8], mat3x2: [3, 2, 6], mat3x2f: [3, 2, 6], mat3x2h: [3, 2, 6], mat3x3: [3, 3, 9], mat3x3f: [3, 3, 9], mat3x3h: [3, 3, 9], mat3x4: [3, 4, 12], mat3x4f: [3, 4, 12], mat3x4h: [3, 4, 12], mat4x2: [4, 2, 8], mat4x2f: [4, 2, 8], mat4x2h: [4, 2, 8], mat4x3: [4, 3, 12], mat4x3f: [4, 3, 12], mat4x3h: [4, 3, 12], mat4x4: [4, 4, 16], mat4x4f: [4, 4, 16], mat4x4h: [4, 4, 16] };
class Se extends ex {
  constructor(g, I) {
    var C;
    super(), this.ast = g ?? [], this.reflection = new ps(), this.reflection.updateAST(this.ast), this.context = (C = I?.clone()) !== null && C !== void 0 ? C : new TG(), this.builtins = new tx(this), this.typeInfo = { bool: this.getTypeInfo(Eg.bool), i32: this.getTypeInfo(Eg.i32), u32: this.getTypeInfo(Eg.u32), f32: this.getTypeInfo(Eg.f32), f16: this.getTypeInfo(Eg.f16), vec2f: this.getTypeInfo(lg.vec2f), vec2u: this.getTypeInfo(lg.vec2u), vec2i: this.getTypeInfo(lg.vec2i), vec2h: this.getTypeInfo(lg.vec2h), vec3f: this.getTypeInfo(lg.vec3f), vec3u: this.getTypeInfo(lg.vec3u), vec3i: this.getTypeInfo(lg.vec3i), vec3h: this.getTypeInfo(lg.vec3h), vec4f: this.getTypeInfo(lg.vec4f), vec4u: this.getTypeInfo(lg.vec4u), vec4i: this.getTypeInfo(lg.vec4i), vec4h: this.getTypeInfo(lg.vec4h), mat2x2f: this.getTypeInfo(lg.mat2x2f), mat2x3f: this.getTypeInfo(lg.mat2x3f), mat2x4f: this.getTypeInfo(lg.mat2x4f), mat3x2f: this.getTypeInfo(lg.mat3x2f), mat3x3f: this.getTypeInfo(lg.mat3x3f), mat3x4f: this.getTypeInfo(lg.mat3x4f), mat4x2f: this.getTypeInfo(lg.mat4x2f), mat4x3f: this.getTypeInfo(lg.mat4x3f), mat4x4f: this.getTypeInfo(lg.mat4x4f) };
  }
  getVariableValue(g) {
    var I, C;
    const t = (C = (I = this.context.getVariable(g)) === null || I === void 0 ? void 0 : I.value) !== null && C !== void 0 ? C : null;
    if (t === null) return null;
    if (t instanceof tg) return t.value;
    if (t instanceof X || t instanceof oI) return Array.from(t.data);
    if (t instanceof VC && t.typeInfo instanceof yr) {
      if (t.typeInfo.format.name === "u32") return Array.from(new Uint32Array(t.buffer, t.offset, t.typeInfo.count));
      if (t.typeInfo.format.name === "i32") return Array.from(new Int32Array(t.buffer, t.offset, t.typeInfo.count));
      if (t.typeInfo.format.name === "f32") return Array.from(new Float32Array(t.buffer, t.offset, t.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${t.typeInfo.name}`), null;
  }
  execute(g) {
    (g = g ?? {}).constants && this._setOverrides(g.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(g, I, C, t) {
    const s = this.context.clone();
    (t = t ?? {}).constants && this._setOverrides(t.constants, s), this._execStatements(this.ast, s);
    const r = s.getFunction(g);
    if (!r) return void console.error(`Function ${g} not found`);
    if (typeof I == "number") I = [I, 1, 1];
    else {
      if (I.length === 0) return void console.error("Invalid dispatch count");
      I.length === 1 ? I = [I[0], 1, 1] : I.length === 2 ? I = [I[0], I[1], 1] : I.length > 3 && (I = [I[0], I[1], I[2]]);
    }
    const l = I[0], d = I[1], h = I[2], D = this.getTypeInfo("vec3u");
    s.setVariable("@num_workgroups", new X(I, D));
    const w = this.reflection.getFunctionInfo(g);
    w === null && console.error(`Function ${g} not found in reflection data`);
    for (const p in C) for (const b in C[p]) {
      const S = C[p][b];
      s.variables.forEach((K) => {
        var Y;
        const T = K.node;
        if (T?.attributes) {
          let E = null, H = null;
          for (const R of T.attributes) R.name === "binding" ? E = R.value : R.name === "group" && (H = R.value);
          if (b == E && p == H) {
            let R = !1;
            for (const x of w.resources) if (x.name === K.name && x.group === parseInt(p) && x.binding === parseInt(b)) {
              R = !0;
              break;
            }
            if (R) if (S.texture !== void 0 && S.descriptor !== void 0) {
              const x = new Yo(S.texture, this.getTypeInfo(T.type), S.descriptor, (Y = S.texture.view) !== null && Y !== void 0 ? Y : null);
              K.value = x;
            } else S.uniform !== void 0 ? K.value = new VC(S.uniform, this.getTypeInfo(T.type)) : K.value = new VC(S, this.getTypeInfo(T.type));
          }
        }
      });
    }
    for (let p = 0; p < h; ++p) for (let b = 0; b < d; ++b) for (let S = 0; S < l; ++S) s.setVariable("@workgroup_id", new X([S, b, p], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(r, [S, b, p], s);
  }
  execStatement(g, I) {
    if (g instanceof kj) return this.evalExpression(g.value, I);
    if (g instanceof Vj) {
      if (g.condition) {
        const C = this.evalExpression(g.condition, I);
        if (!(C instanceof tg)) throw new Error("Invalid break-if condition");
        if (!C.value) return null;
      }
      return Se._breakObj;
    }
    if (g instanceof xj) return Se._continueObj;
    if (g instanceof tM) this._let(g, I);
    else if (g instanceof Po) this._var(g, I);
    else if (g instanceof Cp) this._const(g, I);
    else if (g instanceof cM) this._function(g, I);
    else {
      if (g instanceof Nj) return this._if(g, I);
      if (g instanceof Oj) return this._switch(g, I);
      if (g instanceof vj) return this._for(g, I);
      if (g instanceof jj) return this._while(g, I);
      if (g instanceof Rj) return this._loop(g, I);
      if (g instanceof lS) {
        const C = I.clone();
        return C.currentFunctionName = I.currentFunctionName, this._execStatements(g.body, C);
      }
      if (g instanceof Ej) this._assign(g, I);
      else if (g instanceof Hj) this._increment(g, I);
      else {
        if (g instanceof To) return null;
        if (g instanceof BG) {
          const C = g.name;
          I.getVariable(C) === null && I.setVariable(C, new tg(0, this.getTypeInfo("u32")));
        } else if (g instanceof pG) this._call(g, I);
        else {
          if (g instanceof Wj || g instanceof mG) return null;
          console.error("Invalid statement type.", g, `Line ${g.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(g, I) {
    return g instanceof pn ? this._evalBinaryOp(g, I) : g instanceof TC ? this._evalLiteral(g, I) : g instanceof Ft ? this._evalVariable(g, I) : g instanceof bG ? this._evalCall(g, I) : g instanceof Ms ? this._evalCreate(g, I) : g instanceof _j ? this._evalConst(g, I) : g instanceof Uj ? this._evalBitcast(g, I) : g instanceof dC ? this._evalUnaryOp(g, I) : (console.error("Invalid expression type", g, `Line ${g.line}`), null);
  }
  getTypeInfo(g) {
    var I;
    if (g instanceof Eg) {
      const t = this.reflection.getTypeInfo(g);
      if (t !== null) return t;
    }
    let C = (I = this.typeInfo[g]) !== null && I !== void 0 ? I : null;
    return C !== null || (C = this.reflection.getTypeInfoByName(g)), C;
  }
  _setOverrides(g, I) {
    for (const C in g) {
      const t = g[C], s = this.reflection.getOverrideInfo(C);
      s !== null ? (s.type === null && (s.type = this.getTypeInfo("u32")), s.type.name === "u32" || s.type.name === "i32" || s.type.name === "f32" || s.type.name === "f16" ? I.setVariable(C, new tg(t, s.type)) : s.type.name === "bool" ? I.setVariable(C, new tg(t ? 1 : 0, s.type)) : s.type.name === "vec2" || s.type.name === "vec3" || s.type.name === "vec4" || s.type.name === "vec2f" || s.type.name === "vec3f" || s.type.name === "vec4f" || s.type.name === "vec2i" || s.type.name === "vec3i" || s.type.name === "vec4i" || s.type.name === "vec2u" || s.type.name === "vec3u" || s.type.name === "vec4u" || s.type.name === "vec2h" || s.type.name === "vec3h" || s.type.name === "vec4h" ? I.setVariable(C, new X(t, s.type)) : console.error(`Invalid constant type for ${C}`)) : console.error(`Override ${C} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(g, I, C) {
    const t = [1, 1, 1];
    for (const D of g.node.attributes) if (D.name === "workgroup_size") {
      if (D.value.length > 0) {
        const w = C.getVariableValue(D.value[0]);
        t[0] = w instanceof tg ? w.value : parseInt(D.value[0]);
      }
      if (D.value.length > 1) {
        const w = C.getVariableValue(D.value[1]);
        t[1] = w instanceof tg ? w.value : parseInt(D.value[1]);
      }
      if (D.value.length > 2) {
        const w = C.getVariableValue(D.value[2]);
        t[2] = w instanceof tg ? w.value : parseInt(D.value[2]);
      }
    }
    const s = this.getTypeInfo("vec3u"), r = this.getTypeInfo("u32");
    C.setVariable("@workgroup_size", new X(t, s));
    const l = t[0], d = t[1], h = t[2];
    for (let D = 0, w = 0; D < h; ++D) for (let p = 0; p < d; ++p) for (let b = 0; b < l; ++b, ++w) {
      const S = [b, p, D], K = [b + I[0] * t[0], p + I[1] * t[1], D + I[2] * t[2]];
      C.setVariable("@local_invocation_id", new X(S, s)), C.setVariable("@global_invocation_id", new X(K, s)), C.setVariable("@local_invocation_index", new tg(w, r)), this._dispatchExec(g, C);
    }
  }
  _dispatchExec(g, I) {
    for (const C of g.node.args) for (const t of C.attributes) if (t.name === "builtin") {
      const s = `@${t.value}`, r = I.getVariable(s);
      r !== void 0 && I.variables.set(C.name, r);
    }
    this._execStatements(g.node.body, I);
  }
  getVariableName(g, I) {
    for (; g instanceof dC; ) g = g.right;
    return g instanceof Ft ? g.name : (console.error("Unknown variable type", g, "Line", g.line), null);
  }
  _execStatements(g, I) {
    for (const C of g) {
      if (C instanceof Array) {
        const s = I.clone(), r = this._execStatements(C, s);
        if (r) return r;
        continue;
      }
      const t = this.execStatement(C, I);
      if (t) return t;
    }
    return null;
  }
  _call(g, I) {
    const C = I.clone();
    C.currentFunctionName = g.name;
    const t = I.getFunction(g.name);
    if (t) {
      for (let s = 0; s < t.node.args.length; ++s) {
        const r = t.node.args[s], l = this.evalExpression(g.args[s], C);
        C.setVariable(r.name, l, r);
      }
      this._execStatements(t.node.body, C);
    } else g.isBuiltin ? this._callBuiltinFunction(g, C) : this.getTypeInfo(g.name) && this._evalCreate(g, I);
  }
  _increment(g, I) {
    const C = this.getVariableName(g.variable, I), t = I.getVariable(C);
    t ? g.operator === "++" ? t.value instanceof tg ? t.value.value++ : console.error(`Variable ${C} is not a scalar. Line ${g.line}`) : g.operator === "--" ? t.value instanceof tg ? t.value.value-- : console.error(`Variable ${C} is not a scalar. Line ${g.line}`) : console.error(`Unknown increment operator ${g.operator}. Line ${g.line}`) : console.error(`Variable ${C} not found. Line ${g.line}`);
  }
  _getVariableData(g, I) {
    if (g instanceof Ft) {
      const C = this.getVariableName(g, I), t = I.getVariable(C);
      return t === null ? (console.error(`Variable ${C} not found. Line ${g.line}`), null) : t.value.getSubData(this, g.postfix, I);
    }
    if (g instanceof dC) {
      if (g.operator === "*") {
        const C = this._getVariableData(g.right, I);
        return C instanceof gf ? C.reference.getSubData(this, g.postfix, I) : (console.error(`Variable ${g.right} is not a pointer. Line ${g.line}`), null);
      }
      if (g.operator === "&") {
        const C = this._getVariableData(g.right, I);
        return new gf(C);
      }
    }
    return null;
  }
  _assign(g, I) {
    let C = null, t = "<var>", s = null;
    if (g.variable instanceof dC) {
      const d = this._getVariableData(g.variable, I), h = this.evalExpression(g.value, I), D = g.operator;
      if (D === "=") {
        if (d instanceof tg || d instanceof X || d instanceof oI) {
          if (h instanceof tg || h instanceof X || h instanceof oI && d.data.length === h.data.length) return void d.data.set(h.data);
          console.error(`Invalid assignment. Line ${g.line}`);
        } else if (d instanceof VC && h instanceof VC && d.buffer.byteLength - d.offset >= h.buffer.byteLength - h.offset) return void (d.buffer.byteLength % 4 == 0 ? new Uint32Array(d.buffer, d.offset, d.typeInfo.size / 4).set(new Uint32Array(h.buffer, h.offset, h.typeInfo.size / 4)) : new Uint8Array(d.buffer, d.offset, d.typeInfo.size).set(new Uint8Array(h.buffer, h.offset, h.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${g.line}`), null;
      }
      if (D === "+=") return d instanceof tg || d instanceof X || d instanceof oI ? h instanceof tg || h instanceof X || h instanceof oI ? void d.data.set(h.data.map((w, p) => d.data[p] + w)) : void console.error(`Invalid assignment . Line ${g.line}`) : void console.error(`Invalid assignment. Line ${g.line}`);
      if (D === "-=") return (d instanceof tg || d instanceof X || d instanceof oI) && (h instanceof tg || h instanceof X || h instanceof oI) ? void d.data.set(h.data.map((w, p) => d.data[p] - w)) : void console.error(`Invalid assignment. Line ${g.line}`);
    }
    if (g.variable instanceof dC) {
      if (g.variable.operator === "*") {
        t = this.getVariableName(g.variable.right, I);
        const d = I.getVariable(t);
        if (!(d && d.value instanceof gf)) return void console.error(`Variable ${t} is not a pointer. Line ${g.line}`);
        C = d.value.reference;
        let h = g.variable.postfix;
        if (!h) {
          let D = g.variable.right;
          for (; D instanceof dC; ) {
            if (D.postfix) {
              h = D.postfix;
              break;
            }
            D = D.right;
          }
        }
        h && (C = C.getSubData(this, h, I));
      }
    } else {
      s = g.variable.postfix, t = this.getVariableName(g.variable, I);
      const d = I.getVariable(t);
      if (d === null) return void console.error(`Variable ${t} not found. Line ${g.line}`);
      C = d.value;
    }
    if (C instanceof gf && (C = C.reference), C === null) return void console.error(`Variable ${t} not found. Line ${g.line}`);
    const r = this.evalExpression(g.value, I), l = g.operator;
    if (l !== "=") {
      const d = C.getSubData(this, s, I);
      if (d instanceof X && r instanceof tg) {
        const h = d.data, D = r.value;
        if (l === "+=") for (let w = 0; w < h.length; ++w) h[w] += D;
        else if (l === "-=") for (let w = 0; w < h.length; ++w) h[w] -= D;
        else if (l === "*=") for (let w = 0; w < h.length; ++w) h[w] *= D;
        else if (l === "/=") for (let w = 0; w < h.length; ++w) h[w] /= D;
        else if (l === "%=") for (let w = 0; w < h.length; ++w) h[w] %= D;
        else if (l === "&=") for (let w = 0; w < h.length; ++w) h[w] &= D;
        else if (l === "|=") for (let w = 0; w < h.length; ++w) h[w] |= D;
        else if (l === "^=") for (let w = 0; w < h.length; ++w) h[w] ^= D;
        else if (l === "<<=") for (let w = 0; w < h.length; ++w) h[w] <<= D;
        else if (l === ">>=") for (let w = 0; w < h.length; ++w) h[w] >>= D;
        else console.error(`Invalid operator ${l}. Line ${g.line}`);
      } else if (d instanceof X && r instanceof X) {
        const h = d.data, D = r.data;
        if (h.length !== D.length) return void console.error(`Vector length mismatch. Line ${g.line}`);
        if (l === "+=") for (let w = 0; w < h.length; ++w) h[w] += D[w];
        else if (l === "-=") for (let w = 0; w < h.length; ++w) h[w] -= D[w];
        else if (l === "*=") for (let w = 0; w < h.length; ++w) h[w] *= D[w];
        else if (l === "/=") for (let w = 0; w < h.length; ++w) h[w] /= D[w];
        else if (l === "%=") for (let w = 0; w < h.length; ++w) h[w] %= D[w];
        else if (l === "&=") for (let w = 0; w < h.length; ++w) h[w] &= D[w];
        else if (l === "|=") for (let w = 0; w < h.length; ++w) h[w] |= D[w];
        else if (l === "^=") for (let w = 0; w < h.length; ++w) h[w] ^= D[w];
        else if (l === "<<=") for (let w = 0; w < h.length; ++w) h[w] <<= D[w];
        else if (l === ">>=") for (let w = 0; w < h.length; ++w) h[w] >>= D[w];
        else console.error(`Invalid operator ${l}. Line ${g.line}`);
      } else {
        if (!(d instanceof tg && r instanceof tg)) return void console.error(`Invalid type for ${g.operator} operator. Line ${g.line}`);
        l === "+=" ? d.value += r.value : l === "-=" ? d.value -= r.value : l === "*=" ? d.value *= r.value : l === "/=" ? d.value /= r.value : l === "%=" ? d.value %= r.value : l === "&=" ? d.value &= r.value : l === "|=" ? d.value |= r.value : l === "^=" ? d.value ^= r.value : l === "<<=" ? d.value <<= r.value : l === ">>=" ? d.value >>= r.value : console.error(`Invalid operator ${l}. Line ${g.line}`);
      }
      return void (C instanceof VC && C.setDataValue(this, d, s, I));
    }
    if (C instanceof VC) C.setDataValue(this, r, s, I);
    else if (s) {
      if (!(C instanceof X || C instanceof oI)) return void console.error(`Variable ${t} is not a vector or matrix. Line ${g.line}`);
      if (s instanceof bf) {
        const d = this.evalExpression(s.index, I).value;
        if (C instanceof X) {
          if (!(r instanceof tg)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
          C.data[d] = r.value;
        } else {
          if (!(C instanceof oI)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
          {
            const h = this.evalExpression(s.index, I).value;
            if (h < 0) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
            if (!(r instanceof X)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
            {
              const D = C.typeInfo.getTypeName();
              if (D === "mat2x2" || D === "mat2x2f" || D === "mat2x2h") {
                if (!(h < 2 && r.data.length === 2)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[2 * h] = r.data[0], C.data[2 * h + 1] = r.data[1];
              } else if (D === "mat2x3" || D === "mat2x3f" || D === "mat2x3h") {
                if (!(h < 2 && r.data.length === 3)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[3 * h] = r.data[0], C.data[3 * h + 1] = r.data[1], C.data[3 * h + 2] = r.data[2];
              } else if (D === "mat2x4" || D === "mat2x4f" || D === "mat2x4h") {
                if (!(h < 2 && r.data.length === 4)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[4 * h] = r.data[0], C.data[4 * h + 1] = r.data[1], C.data[4 * h + 2] = r.data[2], C.data[4 * h + 3] = r.data[3];
              } else if (D === "mat3x2" || D === "mat3x2f" || D === "mat3x2h") {
                if (!(h < 3 && r.data.length === 2)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[2 * h] = r.data[0], C.data[2 * h + 1] = r.data[1];
              } else if (D === "mat3x3" || D === "mat3x3f" || D === "mat3x3h") {
                if (!(h < 3 && r.data.length === 3)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[3 * h] = r.data[0], C.data[3 * h + 1] = r.data[1], C.data[3 * h + 2] = r.data[2];
              } else if (D === "mat3x4" || D === "mat3x4f" || D === "mat3x4h") {
                if (!(h < 3 && r.data.length === 4)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[4 * h] = r.data[0], C.data[4 * h + 1] = r.data[1], C.data[4 * h + 2] = r.data[2], C.data[4 * h + 3] = r.data[3];
              } else if (D === "mat4x2" || D === "mat4x2f" || D === "mat4x2h") {
                if (!(h < 4 && r.data.length === 2)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[2 * h] = r.data[0], C.data[2 * h + 1] = r.data[1];
              } else if (D === "mat4x3" || D === "mat4x3f" || D === "mat4x3h") {
                if (!(h < 4 && r.data.length === 3)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[3 * h] = r.data[0], C.data[3 * h + 1] = r.data[1], C.data[3 * h + 2] = r.data[2];
              } else {
                if (D !== "mat4x4" && D !== "mat4x4f" && D !== "mat4x4h") return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                if (!(h < 4 && r.data.length === 4)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
                C.data[4 * h] = r.data[0], C.data[4 * h + 1] = r.data[1], C.data[4 * h + 2] = r.data[2], C.data[4 * h + 3] = r.data[3];
              }
            }
          }
        }
      } else if (s instanceof Mc) {
        const d = s.value;
        if (!(C instanceof X)) return void console.error(`Invalid assignment to ${d}. Variable ${t} is not a vector. Line ${g.line}`);
        if (r instanceof tg) {
          if (d.length > 1) return void console.error(`Invalid assignment to ${d} for variable ${t}. Line ${g.line}`);
          if (d === "x") C.data[0] = r.value;
          else if (d === "y") {
            if (C.data.length < 2) return void console.error(`Invalid assignment to ${d} for variable ${t}. Line ${g.line}`);
            C.data[1] = r.value;
          } else if (d === "z") {
            if (C.data.length < 3) return void console.error(`Invalid assignment to ${d} for variable ${t}. Line ${g.line}`);
            C.data[2] = r.value;
          } else if (d === "w") {
            if (C.data.length < 4) return void console.error(`Invalid assignment to ${d} for variable ${t}. Line ${g.line}`);
            C.data[3] = r.value;
          }
        } else {
          if (!(r instanceof X)) return void console.error(`Invalid assignment to ${t}. Line ${g.line}`);
          if (d.length !== r.data.length) return void console.error(`Invalid assignment to ${d} for variable ${t}. Line ${g.line}`);
          for (let h = 0; h < d.length; ++h) {
            const D = d[h];
            if (D === "x" || D === "r") C.data[0] = r.data[h];
            else if (D === "y" || D === "g") {
              if (r.data.length < 2) return void console.error(`Invalid assignment to ${D} for variable ${t}. Line ${g.line}`);
              C.data[1] = r.data[h];
            } else if (D === "z" || D === "b") {
              if (r.data.length < 3) return void console.error(`Invalid assignment to ${D} for variable ${t}. Line ${g.line}`);
              C.data[2] = r.data[h];
            } else {
              if (D !== "w" && D !== "a") return void console.error(`Invalid assignment to ${D} for variable ${t}. Line ${g.line}`);
              if (r.data.length < 4) return void console.error(`Invalid assignment to ${D} for variable ${t}. Line ${g.line}`);
              C.data[3] = r.data[h];
            }
          }
        }
      }
    } else C instanceof tg && r instanceof tg ? C.value = r.value : C instanceof X && r instanceof X || C instanceof oI && r instanceof oI ? C.data.set(r.data) : console.error(`Invalid assignment to ${t}. Line ${g.line}`);
  }
  _function(g, I) {
    const C = new KG(g);
    I.functions.set(g.name, C);
  }
  _const(g, I) {
    let C = null;
    g.value !== null && (C = this.evalExpression(g.value, I)), I.createVariable(g.name, C, g);
  }
  _let(g, I) {
    let C = null;
    if (g.value !== null) {
      if (C = this.evalExpression(g.value, I), C === null) return void console.error(`Invalid value for variable ${g.name}. Line ${g.line}`);
      g.value instanceof dC || (C = C.clone());
    } else {
      const t = g.type.name;
      if (t === "f32" || t === "i32" || t === "u32" || t === "bool" || t === "f16" || t === "vec2" || t === "vec3" || t === "vec4" || t === "vec2f" || t === "vec3f" || t === "vec4f" || t === "vec2i" || t === "vec3i" || t === "vec4i" || t === "vec2u" || t === "vec3u" || t === "vec4u" || t === "vec2h" || t === "vec3h" || t === "vec4h" || t === "vec2b" || t === "vec3b" || t === "vec4b" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4" || t === "mat2x2f" || t === "mat2x3f" || t === "mat2x4f" || t === "mat3x2f" || t === "mat3x3f" || t === "mat3x4f" || t === "mat4x2f" || t === "mat4x3f" || t === "mat4x4f" || t === "mat2x2h" || t === "mat2x3h" || t === "mat2x4h" || t === "mat3x2h" || t === "mat3x3h" || t === "mat3x4h" || t === "mat4x2h" || t === "mat4x3h" || t === "mat4x4h" || t === "array") {
        const s = new Ms(g.type, []);
        C = this._evalCreate(s, I);
      }
    }
    I.createVariable(g.name, C, g);
  }
  _var(g, I) {
    let C = null;
    if (g.value !== null) {
      if (C = this.evalExpression(g.value, I), C === null) return void console.error(`Invalid value for variable ${g.name}. Line ${g.line}`);
      g.value instanceof dC || (C = C.clone());
    } else {
      if (g.type === null) return void console.error(`Variable ${g.name} has no type. Line ${g.line}`);
      const t = g.type.name;
      if (t === "f32" || t === "i32" || t === "u32" || t === "bool" || t === "f16" || t === "vec2" || t === "vec3" || t === "vec4" || t === "vec2f" || t === "vec3f" || t === "vec4f" || t === "vec2i" || t === "vec3i" || t === "vec4i" || t === "vec2u" || t === "vec3u" || t === "vec4u" || t === "vec2h" || t === "vec3h" || t === "vec4h" || t === "vec2b" || t === "vec3b" || t === "vec4b" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4" || t === "mat2x2f" || t === "mat2x3f" || t === "mat2x4f" || t === "mat3x2f" || t === "mat3x3f" || t === "mat3x4f" || t === "mat4x2f" || t === "mat4x3f" || t === "mat4x4f" || t === "mat2x2h" || t === "mat2x3h" || t === "mat2x4h" || t === "mat3x2h" || t === "mat3x3h" || t === "mat3x4h" || t === "mat4x2h" || t === "mat4x3h" || t === "mat4x4h" || g.type instanceof iM || g.type instanceof To || g.type instanceof lg) {
        const s = new Ms(g.type, []);
        C = this._evalCreate(s, I);
      }
    }
    I.createVariable(g.name, C, g);
  }
  _switch(g, I) {
    I = I.clone();
    const C = this.evalExpression(g.condition, I);
    if (!(C instanceof tg)) return console.error(`Invalid if condition. Line ${g.line}`), null;
    let t = null;
    for (const s of g.cases) if (s instanceof Qj) for (const r of s.selectors) {
      if (r instanceof tp) {
        t = s;
        continue;
      }
      const l = this.evalExpression(r, I);
      if (!(l instanceof tg)) return console.error(`Invalid case selector. Line ${g.line}`), null;
      if (l.value === C.value) return this._execStatements(s.body, I);
    }
    else s instanceof zj && (t = s);
    return t ? this._execStatements(t.body, I) : null;
  }
  _if(g, I) {
    I = I.clone();
    const C = this.evalExpression(g.condition, I);
    if (!(C instanceof tg)) return console.error(`Invalid if condition. Line ${g.line}`), null;
    if (C.value) return this._execStatements(g.body, I);
    for (const t of g.elseif) {
      const s = this.evalExpression(t.condition, I);
      if (!(s instanceof tg)) return console.error(`Invalid if condition. Line ${g.line}`), null;
      if (s.value) return this._execStatements(t.body, I);
    }
    return g.else ? this._execStatements(g.else, I) : null;
  }
  _getScalarValue(g) {
    return g instanceof tg ? g.value : (console.error("Expected scalar value.", g), 0);
  }
  _for(g, I) {
    for (I = I.clone(), this.execStatement(g.init, I); this._getScalarValue(this.evalExpression(g.condition, I)); ) {
      const C = this._execStatements(g.body, I);
      if (C === Se._breakObj) break;
      if (C !== null && C !== Se._continueObj) return C;
      this.execStatement(g.increment, I);
    }
    return null;
  }
  _loop(g, I) {
    for (I = I.clone(); ; ) {
      const C = this._execStatements(g.body, I);
      if (C === Se._breakObj) break;
      if (C === Se._continueObj) {
        if (g.continuing && this._execStatements(g.continuing.body, I) === Se._breakObj)
          break;
      } else if (C !== null) return C;
    }
    return null;
  }
  _while(g, I) {
    for (I = I.clone(); this._getScalarValue(this.evalExpression(g.condition, I)); ) {
      const C = this._execStatements(g.body, I);
      if (C === Se._breakObj) break;
      if (C !== Se._continueObj && C !== null) return C;
    }
    return null;
  }
  _evalBitcast(g, I) {
    const C = this.evalExpression(g.value, I), t = g.type;
    if (C instanceof tg) {
      const s = HP(C.value, C.typeInfo.name, t.name);
      return new tg(s, this.getTypeInfo(t));
    }
    if (C instanceof X) {
      const s = C.typeInfo.getTypeName();
      let r = "";
      if (s.endsWith("f")) r = "f32";
      else if (s.endsWith("i")) r = "i32";
      else if (s.endsWith("u")) r = "u32";
      else if (s.endsWith("b")) r = "bool";
      else {
        if (!s.endsWith("h")) return console.error(`Unknown vector type ${s}. Line ${g.line}`), null;
        r = "f16";
      }
      const l = t.getTypeName();
      let d = "";
      if (l.endsWith("f")) d = "f32";
      else if (l.endsWith("i")) d = "i32";
      else if (l.endsWith("u")) d = "u32";
      else if (l.endsWith("b")) d = "bool";
      else {
        if (!l.endsWith("h")) return console.error(`Unknown vector type ${d}. Line ${g.line}`), null;
        d = "f16";
      }
      const h = (function(D, w, p) {
        if (w === p) return D;
        const b = new Array(D.length);
        for (let S = 0; S < D.length; S++) b[S] = HP(D[S], w, p);
        return b;
      })(Array.from(C.data), r, d);
      return new X(h, this.getTypeInfo(t));
    }
    return console.error(`TODO: bitcast for ${C.typeInfo.name}. Line ${g.line}`), null;
  }
  _evalConst(g, I) {
    return I.getVariableValue(g.name).clone().getSubData(this, g.postfix, I);
  }
  _evalCreate(g, I) {
    var C;
    if (g instanceof Ms) {
      if (g.type === null) return cS.void;
      switch (g.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(g, I);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(g, I);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(g, I);
      }
    }
    const t = g instanceof Ms ? g.type.name : g.name, s = g instanceof Ms ? this.getTypeInfo(g.type) : this.getTypeInfo(g.name);
    if (s === null) return console.error(`Unknown type ${t}. Line ${g.line}`), null;
    if (s.size === 0) return null;
    const r = new VC(new ArrayBuffer(s.size), s, 0);
    if (s instanceof dr) {
      if (g.args) for (let l = 0; l < g.args.length; ++l) {
        const d = s.members[l], h = g.args[l], D = this.evalExpression(h, I);
        r.setData(this, D, d.type, d.offset, I);
      }
    } else if (s instanceof yr) {
      let l = 0;
      if (g.args) for (let d = 0; d < g.args.length; ++d) {
        const h = g.args[d], D = this.evalExpression(h, I);
        s.format === null && (((C = D.typeInfo) === null || C === void 0 ? void 0 : C.name) === "x32" ? s.format = this.getTypeInfo("i32") : s.format = D.typeInfo), r.setData(this, D, s.format, l, I), l += s.stride;
      }
    } else console.error(`Unknown type "${t}". Line ${g.line}`);
    return g instanceof Ms ? r.getSubData(this, g.postfix, I) : r;
  }
  _evalLiteral(g, I) {
    const C = this.getTypeInfo(g.type), t = C.name;
    return t === "x32" || t === "u32" || t === "f32" || t === "f16" || t === "i32" || t === "bool" ? new tg(g.scalarValue, C) : t === "vec2" || t === "vec3" || t === "vec4" || t === "vec2f" || t === "vec3f" || t === "vec4f" || t === "vec2h" || t === "vec3h" || t === "vec4h" || t === "vec2i" || t === "vec3i" || t === "vec4i" || t === "vec2u" || t === "vec3u" || t === "vec4u" ? this._callConstructorVec(g, I) : t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4" || t === "mat2x2f" || t === "mat2x3f" || t === "mat2x4f" || t === "mat3x2f" || t === "mat3x3f" || t === "mat3x4f" || t === "mat4x2f" || t === "mat4x3f" || t === "mat4x4f" || t === "mat2x2h" || t === "mat2x3h" || t === "mat2x4h" || t === "mat3x2h" || t === "mat3x3h" || t === "mat3x4h" || t === "mat4x2h" || t === "mat4x3h" || t === "mat4x4h" ? this._callConstructorMatrix(g, I) : g.value;
  }
  _evalVariable(g, I) {
    const C = I.getVariableValue(g.name);
    return C === null ? C : C.getSubData(this, g.postfix, I);
  }
  _maxFormatTypeInfo(g) {
    let I = g[0];
    if (I.name === "f32") return I;
    for (let C = 1; C < g.length; ++C) {
      const t = Se._priority.get(I.name);
      Se._priority.get(g[C].name) < t && (I = g[C]);
    }
    return I.name === "x32" ? this.getTypeInfo("i32") : I;
  }
  _evalUnaryOp(g, I) {
    const C = this.evalExpression(g.right, I);
    if (g.operator === "&") return new gf(C);
    if (g.operator === "*") return C instanceof gf ? C.reference.getSubData(this, g.postfix, I) : (console.error(`Invalid dereference. Line ${g.line}`), null);
    const t = C instanceof tg ? C.value : C instanceof X ? Array.from(C.data) : null;
    switch (g.operator) {
      case "+": {
        if (zg(t)) {
          const l = t.map((d, h) => +d);
          return new X(l, C.typeInfo);
        }
        const s = t, r = this._maxFormatTypeInfo([C.typeInfo, C.typeInfo]);
        return new tg(+s, r);
      }
      case "-": {
        if (zg(t)) {
          const l = t.map((d, h) => -d);
          return new X(l, C.typeInfo);
        }
        const s = t, r = this._maxFormatTypeInfo([C.typeInfo, C.typeInfo]);
        return new tg(-s, r);
      }
      case "!": {
        if (zg(t)) {
          const l = t.map((d, h) => d ? 0 : 1);
          return new X(l, C.typeInfo);
        }
        const s = t, r = this._maxFormatTypeInfo([C.typeInfo, C.typeInfo]);
        return new tg(s ? 0 : 1, r);
      }
      case "~": {
        if (zg(t)) {
          const l = t.map((d, h) => ~d);
          return new X(l, C.typeInfo);
        }
        const s = t, r = this._maxFormatTypeInfo([C.typeInfo, C.typeInfo]);
        return new tg(~s, r);
      }
    }
    return console.error(`Invalid unary operator ${g.operator}. Line ${g.line}`), null;
  }
  _evalBinaryOp(g, I) {
    const C = this.evalExpression(g.left, I), t = this.evalExpression(g.right, I), s = C instanceof tg ? C.value : C instanceof X || C instanceof oI ? Array.from(C.data) : null, r = t instanceof tg ? t.value : t instanceof X || t instanceof oI ? Array.from(t.data) : null;
    switch (g.operator) {
      case "+": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b + w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p + D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D + p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l + d, h);
      }
      case "-": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b - w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p - D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D - p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l - d, h);
      }
      case "*": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (C instanceof oI && t instanceof oI) {
            const p = (function(Y, T, E, H) {
              if (Fe[T.name] === void 0 || Fe[H.name] === void 0) return null;
              const R = Fe[T.name][0], x = Fe[T.name][1], U = Fe[H.name][0];
              if (R !== Fe[H.name][1]) return null;
              const J = new Array(U * x);
              for (let L = 0; L < x; L++) for (let eg = 0; eg < U; eg++) {
                let Mg = 0;
                for (let ig = 0; ig < R; ig++) Mg += Y[ig * x + L] * E[eg * R + ig];
                J[L * U + eg] = Mg;
              }
              return J;
            })(D, C.typeInfo, w, t.typeInfo);
            if (p === null) return console.error(`Matrix multiplication failed. Line ${g.line}.`), null;
            const b = Fe[t.typeInfo.name][0], S = Fe[C.typeInfo.name][1], K = this.getTypeInfo(`mat${b}x${S}f`);
            return new oI(p, K);
          }
          if (C instanceof oI && t instanceof X) {
            const p = (function(b, S, K, Y) {
              if (Fe[S.name] === void 0 || hb[Y.name] === void 0) return null;
              const T = Fe[S.name][0], E = Fe[S.name][1];
              if (T !== K.length) return null;
              const H = new Array(E);
              for (let R = 0; R < E; R++) {
                let x = 0;
                for (let U = 0; U < T; U++) x += b[U * E + R] * K[U];
                H[R] = x;
              }
              return H;
            })(D, C.typeInfo, w, t.typeInfo);
            return p === null ? (console.error(`Matrix vector multiplication failed. Line ${g.line}.`), null) : new X(p, t.typeInfo);
          }
          if (C instanceof X && t instanceof oI) {
            const p = (function(b, S, K, Y) {
              if (hb[S.name] === void 0 || Fe[Y.name] === void 0) return null;
              const T = Fe[Y.name][0], E = Fe[Y.name][1];
              if (E !== b.length) return null;
              const H = [];
              for (let R = 0; R < T; R++) {
                let x = 0;
                for (let U = 0; U < E; U++) x += b[U] * K[U * T + R];
                H[R] = x;
              }
              return H;
            })(D, C.typeInfo, w, t.typeInfo);
            return p === null ? (console.error(`Matrix vector multiplication failed. Line ${g.line}.`), null) : new X(p, C.typeInfo);
          }
          {
            if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
            const p = D.map((b, S) => b * w[S]);
            return new X(p, C.typeInfo);
          }
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p * D);
          return C instanceof oI ? new oI(w, C.typeInfo) : new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D * p);
          return t instanceof oI ? new oI(w, t.typeInfo) : new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l * d, h);
      }
      case "%": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b % w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p % D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D % p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l % d, h);
      }
      case "/": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b / w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p / D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D / p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l / d, h);
      }
      case "&": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b & w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p & D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D & p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l & d, h);
      }
      case "|": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b | w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p | D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D | p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l | d, h);
      }
      case "^": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b ^ w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p ^ D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D ^ p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l ^ d, h);
      }
      case "<<": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b << w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p << D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D << p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l << d, h);
      }
      case ">>": {
        if (zg(s) && zg(r)) {
          const D = s, w = r;
          if (D.length !== w.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const p = D.map((b, S) => b >> w[S]);
          return new X(p, C.typeInfo);
        }
        if (zg(s)) {
          const D = r, w = s.map((p, b) => p >> D);
          return new X(w, C.typeInfo);
        }
        if (zg(r)) {
          const D = s, w = r.map((p, b) => D >> p);
          return new X(w, t.typeInfo);
        }
        const l = s, d = r, h = this._maxFormatTypeInfo([C.typeInfo, t.typeInfo]);
        return new tg(l >> d, h);
      }
      case ">":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D > d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h > l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l > h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s > r ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D < d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h < l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l < h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s < r ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D === d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h == l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l == h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s === r ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D !== d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h !== l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l !== h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s !== r ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D >= d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h >= l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l >= h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s >= r ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D <= d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h <= l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l <= h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s <= r ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D && d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h && l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l && h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s && r ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (zg(s) && zg(r)) {
          const l = s, d = r;
          if (l.length !== d.length) return console.error(`Vector length mismatch. Line ${g.line}.`), null;
          const h = l.map((D, w) => D || d[w] ? 1 : 0);
          return new X(h, C.typeInfo);
        }
        if (zg(s)) {
          const l = r, d = s.map((h, D) => h || l ? 1 : 0);
          return new X(d, C.typeInfo);
        }
        if (zg(r)) {
          const l = s, d = r.map((h, D) => l || h ? 1 : 0);
          return new X(d, t.typeInfo);
        }
        return new tg(s || r ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${g.operator}. Line ${g.line}`), null;
  }
  _evalCall(g, I) {
    if (g.cachedReturnValue !== null) return g.cachedReturnValue;
    const C = I.clone();
    C.currentFunctionName = g.name;
    const t = I.getFunction(g.name);
    if (!t)
      return g.isBuiltin ? this._callBuiltinFunction(g, C) : this.getTypeInfo(g.name) ? this._evalCreate(g, I) : (console.error(`Unknown function "${g.name}". Line ${g.line}`), null);
    for (let s = 0; s < t.node.args.length; ++s) {
      const r = t.node.args[s], l = this.evalExpression(g.args[s], C);
      C.createVariable(r.name, l, r);
    }
    return this._execStatements(t.node.body, C);
  }
  _callBuiltinFunction(g, I) {
    switch (g.name) {
      case "all":
        return this.builtins.All(g, I);
      case "any":
        return this.builtins.Any(g, I);
      case "select":
        return this.builtins.Select(g, I);
      case "arrayLength":
        return this.builtins.ArrayLength(g, I);
      case "abs":
        return this.builtins.Abs(g, I);
      case "acos":
        return this.builtins.Acos(g, I);
      case "acosh":
        return this.builtins.Acosh(g, I);
      case "asin":
        return this.builtins.Asin(g, I);
      case "asinh":
        return this.builtins.Asinh(g, I);
      case "atan":
        return this.builtins.Atan(g, I);
      case "atanh":
        return this.builtins.Atanh(g, I);
      case "atan2":
        return this.builtins.Atan2(g, I);
      case "ceil":
        return this.builtins.Ceil(g, I);
      case "clamp":
        return this.builtins.Clamp(g, I);
      case "cos":
        return this.builtins.Cos(g, I);
      case "cosh":
        return this.builtins.Cosh(g, I);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(g, I);
      case "countOneBits":
        return this.builtins.CountOneBits(g, I);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(g, I);
      case "cross":
        return this.builtins.Cross(g, I);
      case "degrees":
        return this.builtins.Degrees(g, I);
      case "determinant":
        return this.builtins.Determinant(g, I);
      case "distance":
        return this.builtins.Distance(g, I);
      case "dot":
        return this.builtins.Dot(g, I);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(g, I);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(g, I);
      case "exp":
        return this.builtins.Exp(g, I);
      case "exp2":
        return this.builtins.Exp2(g, I);
      case "extractBits":
        return this.builtins.ExtractBits(g, I);
      case "faceForward":
        return this.builtins.FaceForward(g, I);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(g, I);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(g, I);
      case "floor":
        return this.builtins.Floor(g, I);
      case "fma":
        return this.builtins.Fma(g, I);
      case "fract":
        return this.builtins.Fract(g, I);
      case "frexp":
        return this.builtins.Frexp(g, I);
      case "insertBits":
        return this.builtins.InsertBits(g, I);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(g, I);
      case "ldexp":
        return this.builtins.Ldexp(g, I);
      case "length":
        return this.builtins.Length(g, I);
      case "log":
        return this.builtins.Log(g, I);
      case "log2":
        return this.builtins.Log2(g, I);
      case "max":
        return this.builtins.Max(g, I);
      case "min":
        return this.builtins.Min(g, I);
      case "mix":
        return this.builtins.Mix(g, I);
      case "modf":
        return this.builtins.Modf(g, I);
      case "normalize":
        return this.builtins.Normalize(g, I);
      case "pow":
        return this.builtins.Pow(g, I);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(g, I);
      case "radians":
        return this.builtins.Radians(g, I);
      case "reflect":
        return this.builtins.Reflect(g, I);
      case "refract":
        return this.builtins.Refract(g, I);
      case "reverseBits":
        return this.builtins.ReverseBits(g, I);
      case "round":
        return this.builtins.Round(g, I);
      case "saturate":
        return this.builtins.Saturate(g, I);
      case "sign":
        return this.builtins.Sign(g, I);
      case "sin":
        return this.builtins.Sin(g, I);
      case "sinh":
        return this.builtins.Sinh(g, I);
      case "smoothstep":
        return this.builtins.SmoothStep(g, I);
      case "sqrt":
        return this.builtins.Sqrt(g, I);
      case "step":
        return this.builtins.Step(g, I);
      case "tan":
        return this.builtins.Tan(g, I);
      case "tanh":
        return this.builtins.Tanh(g, I);
      case "transpose":
        return this.builtins.Transpose(g, I);
      case "trunc":
        return this.builtins.Trunc(g, I);
      case "dpdx":
        return this.builtins.Dpdx(g, I);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(g, I);
      case "dpdxFine":
        return this.builtins.DpdxFine(g, I);
      case "dpdy":
        return this.builtins.Dpdy(g, I);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(g, I);
      case "dpdyFine":
        return this.builtins.DpdyFine(g, I);
      case "fwidth":
        return this.builtins.Fwidth(g, I);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(g, I);
      case "fwidthFine":
        return this.builtins.FwidthFine(g, I);
      case "textureDimensions":
        return this.builtins.TextureDimensions(g, I);
      case "textureGather":
        return this.builtins.TextureGather(g, I);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(g, I);
      case "textureLoad":
        return this.builtins.TextureLoad(g, I);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(g, I);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(g, I);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(g, I);
      case "textureSample":
        return this.builtins.TextureSample(g, I);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(g, I);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(g, I);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(g, I);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(g, I);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(g, I);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(g, I);
      case "textureStore":
        return this.builtins.TextureStore(g, I);
      case "atomicLoad":
        return this.builtins.AtomicLoad(g, I);
      case "atomicStore":
        return this.builtins.AtomicStore(g, I);
      case "atomicAdd":
        return this.builtins.AtomicAdd(g, I);
      case "atomicSub":
        return this.builtins.AtomicSub(g, I);
      case "atomicMax":
        return this.builtins.AtomicMax(g, I);
      case "atomicMin":
        return this.builtins.AtomicMin(g, I);
      case "atomicAnd":
        return this.builtins.AtomicAnd(g, I);
      case "atomicOr":
        return this.builtins.AtomicOr(g, I);
      case "atomicXor":
        return this.builtins.AtomicXor(g, I);
      case "atomicExchange":
        return this.builtins.AtomicExchange(g, I);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(g, I);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(g, I);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(g, I);
      case "pack4xI8":
        return this.builtins.Pack4xI8(g, I);
      case "pack4xU8":
        return this.builtins.Pack4xU8(g, I);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(g, I);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(g, I);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(g, I);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(g, I);
      case "pack2x16float":
        return this.builtins.Pack2x16float(g, I);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(g, I);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(g, I);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(g, I);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(g, I);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(g, I);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(g, I);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(g, I);
      case "storageBarrier":
        return this.builtins.StorageBarrier(g, I);
      case "textureBarrier":
        return this.builtins.TextureBarrier(g, I);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(g, I);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(g, I);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(g, I);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(g, I);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(g, I);
      case "subgroupAll":
        return this.builtins.SubgroupAll(g, I);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(g, I);
      case "subgroupAny":
        return this.builtins.SubgroupAny(g, I);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(g, I);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(g, I);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(g, I);
      case "subgroupElect":
        return this.builtins.SubgroupElect(g, I);
      case "subgroupMax":
        return this.builtins.SubgroupMax(g, I);
      case "subgroupMin":
        return this.builtins.SubgroupMin(g, I);
      case "subgroupMul":
        return this.builtins.SubgroupMul(g, I);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(g, I);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(g, I);
      case "subgroupOr":
        return this.builtins.SubgroupOr(g, I);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(g, I);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(g, I);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(g, I);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(g, I);
      case "subgroupXor":
        return this.builtins.SubgroupXor(g, I);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(g, I);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(g, I);
      case "quadSwapX":
        return this.builtins.QuadSwapX(g, I);
      case "quadSwapY":
        return this.builtins.QuadSwapY(g, I);
    }
    const C = I.getFunction(g.name);
    if (C) {
      const t = I.clone();
      for (let s = 0; s < C.node.args.length; ++s) {
        const r = C.node.args[s], l = this.evalExpression(g.args[s], t);
        t.setVariable(r.name, l, r);
      }
      return this._execStatements(C.node.body, t);
    }
    return null;
  }
  _callConstructorValue(g, I) {
    if (!g.args || g.args.length === 0) return new tg(0, this.getTypeInfo(g.type));
    const C = this.evalExpression(g.args[0], I);
    return C.typeInfo = this.getTypeInfo(g.type), C.getSubData(this, g.postfix, I).clone();
  }
  _callConstructorVec(g, I) {
    const C = this.getTypeInfo(g.type), t = g.type.getTypeName(), s = hb[t];
    if (s === void 0) return console.error(`Invalid vec constructor ${t}. Line ${g.line}`), null;
    const r = [];
    if (g instanceof TC) if (g.isVector) {
      const l = g.vectorValue;
      for (const d of l) r.push(d);
    } else r.push(g.scalarValue);
    else if (g.args) for (const l of g.args) {
      const d = this.evalExpression(l, I);
      if (d instanceof X) {
        const h = d.data;
        for (let D = 0; D < h.length; ++D) {
          let w = h[D];
          r.push(w);
        }
      } else if (d instanceof tg) {
        let h = d.value;
        r.push(h);
      }
    }
    if (g.type instanceof lg && g.type.format === null && (g.type.format = lg.f32), r.length === 0) {
      const l = new Array(s).fill(0);
      return new X(l, C).getSubData(this, g.postfix, I);
    }
    if (r.length === 1) for (; r.length < s; ) r.push(r[0]);
    return r.length < s ? (console.error(`Invalid vec constructor. Line ${g.line}`), null) : new X(r.length > s ? r.slice(0, s) : r, C).getSubData(this, g.postfix, I);
  }
  _callConstructorMatrix(g, I) {
    const C = this.getTypeInfo(g.type), t = g.type.getTypeName(), s = Fe[t];
    if (s === void 0) return console.error(`Invalid matrix constructor ${t}. Line ${g.line}`), null;
    const r = [];
    if (g instanceof TC) if (g.isVector) {
      const l = g.vectorValue;
      for (const d of l) r.push(d);
    } else r.push(g.scalarValue);
    else if (g.args) for (const l of g.args) {
      const d = this.evalExpression(l, I);
      d instanceof X ? r.push(...d.data) : d instanceof tg ? r.push(d.value) : d instanceof oI && r.push(...d.data);
    }
    if (C instanceof Dc && C.format === null && (C.format = this.getTypeInfo("f32")), r.length === 0) {
      const l = new Array(s[2]).fill(0);
      return new oI(l, C).getSubData(this, g.postfix, I);
    }
    return r.length !== s[2] ? (console.error(`Invalid matrix constructor. Line ${g.line}`), null) : new oI(r, C).getSubData(this, g.postfix, I);
  }
}
Se._breakObj = new Hi(new Pi("BREAK", null), null), Se._continueObj = new Hi(new Pi("CONTINUE", null), null), Se._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class ix {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class nx {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new ix(), this._exec = new Se(), this._forwardTypeCount = 0;
  }
  parse(g) {
    this._initialize(g), this._deferArrayCountEval.length = 0;
    const I = [];
    for (; !this._isAtEnd(); ) {
      const C = this._global_decl_or_directive();
      if (!C) break;
      I.push(C);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const C of this._deferArrayCountEval) {
        const t = C.arrayType, s = C.countNode;
        if (s instanceof Ft) {
          const r = s.name, l = this._context.constants.get(r);
          if (l) try {
            const d = l.constEvaluate(this._exec);
            t.count = d;
          } catch {
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    if (this._forwardTypeCount > 0) for (const C of I) C.search((t) => {
      t instanceof jP || t instanceof ep ? t.type = this._forwardType(t.type) : t instanceof iM ? t.format = this._forwardType(t.format) : t instanceof Po || t instanceof tM || t instanceof Cp ? t.type = this._forwardType(t.type) : t instanceof cM ? t.returnType = this._forwardType(t.returnType) : t instanceof ZP && (t.type = this._forwardType(t.type));
    });
    return I;
  }
  _forwardType(g) {
    if (g instanceof PP) {
      const I = this._getType(g.name);
      if (I) return I;
    } else g instanceof ep ? g.type = this._forwardType(g.type) : g instanceof iM && (g.format = this._forwardType(g.format));
    return g;
  }
  _initialize(g) {
    if (g) if (typeof g == "string") {
      const I = new JV(g);
      this._tokens = I.scanTokens();
    } else this._tokens = g;
    else this._tokens = [];
    this._current = 0;
  }
  _updateNode(g, I) {
    return g.line = I ?? this._currentLine, g;
  }
  _error(g, I) {
    return { token: g, message: I, toString: () => `${I}` };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == V.eof;
  }
  _match(g) {
    if (g instanceof sg) return !!this._check(g) && (this._advance(), !0);
    for (let I = 0, C = g.length; I < C; ++I) {
      const t = g[I];
      if (this._check(t)) return this._advance(), !0;
    }
    return !1;
  }
  _consume(g, I) {
    if (this._check(g)) return this._advance();
    throw this._error(this._peek(), `${I}. Line:${this._currentLine}`);
  }
  _check(g) {
    if (this._isAtEnd()) return !1;
    const I = this._peek();
    if (g instanceof Array) {
      const C = I.type;
      let t = !1;
      for (const s of g) {
        if (C === s) return !0;
        s === V.tokens.name && (t = !0);
      }
      if (t) {
        const s = V.tokens.name.rule.exec(I.lexeme);
        if (s && s.index == 0 && s[0] == I.lexeme) return !0;
      }
      return !1;
    }
    if (I.type === g) return !0;
    if (g === V.tokens.name) {
      const C = V.tokens.name.rule.exec(I.lexeme);
      return C && C.index == 0 && C[0] == I.lexeme;
    }
    return !1;
  }
  _advance() {
    var g, I;
    return this._currentLine = (I = (g = this._peek()) === null || g === void 0 ? void 0 : g.line) !== null && I !== void 0 ? I : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(V.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._match(V.keywords.alias)) {
      const I = this._type_alias();
      return this._consume(V.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([I]), I;
    }
    if (this._match(V.keywords.diagnostic)) {
      const I = this._diagnostic();
      return this._consume(V.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([I]), I;
    }
    if (this._match(V.keywords.requires)) {
      const I = this._requires_directive();
      return this._consume(V.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([I]), I;
    }
    if (this._match(V.keywords.enable)) {
      const I = this._enable_directive();
      return this._consume(V.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([I]), I;
    }
    const g = this._attribute();
    if (this._check(V.keywords.var)) {
      const I = this._global_variable_decl();
      return I != null && (I.attributes = g), this._consume(V.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([I]), I;
    }
    if (this._check(V.keywords.override)) {
      const I = this._override_variable_decl();
      return I != null && (I.attributes = g), this._consume(V.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([I]), I;
    }
    if (this._check(V.keywords.let)) {
      const I = this._global_let_decl();
      return I != null && (I.attributes = g), this._consume(V.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([I]), I;
    }
    if (this._check(V.keywords.const)) {
      const I = this._global_const_decl();
      return I != null && (I.attributes = g), this._consume(V.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([I]), I;
    }
    if (this._check(V.keywords.struct)) {
      const I = this._struct_decl();
      return I != null && (I.attributes = g), this._exec.reflection.updateAST([I]), I;
    }
    if (this._check(V.keywords.fn)) {
      const I = this._function_decl();
      return I != null && (I.attributes = g), this._exec.reflection.updateAST([I]), I;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(V.keywords.fn)) return null;
    const g = this._currentLine, I = this._consume(V.tokens.ident, "Expected function name.").toString();
    this._consume(V.tokens.paren_left, "Expected '(' for function arguments.");
    const C = [];
    if (!this._check(V.tokens.paren_right)) do {
      if (this._check(V.tokens.paren_right)) break;
      const l = this._attribute(), d = this._consume(V.tokens.name, "Expected argument name.").toString();
      this._consume(V.tokens.colon, "Expected ':' for argument type.");
      const h = this._attribute(), D = this._type_decl();
      D != null && (D.attributes = h, C.push(this._updateNode(new ZP(d, D, l))));
    } while (this._match(V.tokens.comma));
    this._consume(V.tokens.paren_right, "Expected ')' after function arguments.");
    let t = null;
    if (this._match(V.tokens.arrow)) {
      const l = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = l);
    }
    const s = this._compound_statement(), r = this._currentLine;
    return this._updateNode(new cM(I, C, t, s, g, r), g);
  }
  _compound_statement() {
    const g = [];
    for (this._consume(V.tokens.brace_left, "Expected '{' for block."); !this._check(V.tokens.brace_right); ) {
      const I = this._statement();
      I !== null && g.push(I);
    }
    return this._consume(V.tokens.brace_right, "Expected '}' for block."), g;
  }
  _statement() {
    for (; this._match(V.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._check(V.tokens.attr) && this._attribute(), this._check(V.keywords.if)) return this._if_statement();
    if (this._check(V.keywords.switch)) return this._switch_statement();
    if (this._check(V.keywords.loop)) return this._loop_statement();
    if (this._check(V.keywords.for)) return this._for_statement();
    if (this._check(V.keywords.while)) return this._while_statement();
    if (this._check(V.keywords.continuing)) return this._continuing_statement();
    if (this._check(V.keywords.static_assert)) return this._static_assert_statement();
    if (this._check(V.tokens.brace_left)) return this._compound_statement();
    let g = null;
    if (this._check(V.keywords.return)) g = this._return_statement();
    else if (this._check([V.keywords.var, V.keywords.let, V.keywords.const])) g = this._variable_statement();
    else if (this._match(V.keywords.discard)) g = this._updateNode(new XV());
    else if (this._match(V.keywords.break)) {
      const I = this._updateNode(new Vj());
      if (this._currentLoop.length > 0) {
        const C = this._currentLoop[this._currentLoop.length - 1];
        I.loopId = C.id;
      }
      g = I, this._check(V.keywords.if) && (this._advance(), I.condition = this._optional_paren_expression());
    } else if (this._match(V.keywords.continue)) {
      const I = this._updateNode(new xj());
      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${I.line}`);
      {
        const C = this._currentLoop[this._currentLoop.length - 1];
        I.loopId = C.id;
      }
      g = I;
    } else g = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return g != null && this._consume(V.tokens.semicolon, "Expected ';' after statement."), g;
  }
  _static_assert_statement() {
    if (!this._match(V.keywords.static_assert)) return null;
    const g = this._currentLine, I = this._optional_paren_expression();
    return this._updateNode(new _V(I), g);
  }
  _while_statement() {
    if (!this._match(V.keywords.while)) return null;
    const g = this._updateNode(new jj(null, null));
    return this._currentLoop.push(g), g.condition = this._optional_paren_expression(), this._check(V.tokens.attr) && this._attribute(), g.body = this._compound_statement(), this._currentLoop.pop(), g;
  }
  _continuing_statement() {
    const g = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
    if (!this._match(V.keywords.continuing)) return null;
    const I = this._currentLine, C = this._compound_statement();
    return this._updateNode(new lS(C, g), I);
  }
  _for_statement() {
    if (!this._match(V.keywords.for)) return null;
    this._consume(V.tokens.paren_left, "Expected '('.");
    const g = this._updateNode(new vj(null, null, null, null));
    return this._currentLoop.push(g), g.init = this._check(V.tokens.semicolon) ? null : this._for_init(), this._consume(V.tokens.semicolon, "Expected ';'."), g.condition = this._check(V.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(V.tokens.semicolon, "Expected ';'."), g.increment = this._check(V.tokens.paren_right) ? null : this._for_increment(), this._consume(V.tokens.paren_right, "Expected ')'."), this._check(V.tokens.attr) && this._attribute(), g.body = this._compound_statement(), this._currentLoop.pop(), g;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(V.keywords.var)) {
      const g = this._variable_decl();
      if (g === null) throw this._error(this._peek(), "Variable declaration expected.");
      let I = null;
      return this._match(V.tokens.equal) && (I = this._short_circuit_or_expression()), this._updateNode(new Po(g.name, g.type, g.storage, g.access, I), g.line);
    }
    if (this._match(V.keywords.let)) {
      const g = this._currentLine, I = this._consume(V.tokens.name, "Expected name for let.").toString();
      let C = null;
      if (this._match(V.tokens.colon)) {
        const s = this._attribute();
        C = this._type_decl(), C != null && (C.attributes = s);
      }
      this._consume(V.tokens.equal, "Expected '=' for let.");
      const t = this._short_circuit_or_expression();
      return this._updateNode(new tM(I, C, null, null, t), g);
    }
    if (this._match(V.keywords.const)) {
      const g = this._currentLine, I = this._consume(V.tokens.name, "Expected name for const.").toString();
      let C = null;
      if (this._match(V.tokens.colon)) {
        const s = this._attribute();
        C = this._type_decl(), C != null && (C.attributes = s);
      }
      this._consume(V.tokens.equal, "Expected '=' for const.");
      const t = this._short_circuit_or_expression();
      return C === null && t instanceof TC && (C = t.type), this._updateNode(new Cp(I, C, null, null, t), g);
    }
    return null;
  }
  _increment_decrement_statement() {
    const g = this._current, I = this._unary_expression();
    if (I == null) return null;
    if (!this._check(V.increment_operators)) return this._current = g, null;
    const C = this._consume(V.increment_operators, "Expected increment operator");
    return this._updateNode(new Hj(C.type === V.tokens.plus_plus ? lf.increment : lf.decrement, I));
  }
  _assignment_statement() {
    let g = null;
    const I = this._currentLine;
    if (this._check(V.tokens.brace_right)) return null;
    let C = this._match(V.tokens.underscore);
    if (C || (g = this._unary_expression()), !C && g == null) return null;
    const t = this._consume(V.assignment_operators, "Expected assignment operator."), s = this._short_circuit_or_expression();
    return this._updateNode(new Ej(zD.parse(t.lexeme), g, s), I);
  }
  _func_call_statement() {
    if (!this._check(V.tokens.ident)) return null;
    const g = this._currentLine, I = this._current, C = this._consume(V.tokens.ident, "Expected function name."), t = this._argument_expression_list();
    return t === null ? (this._current = I, null) : this._updateNode(new pG(C.lexeme, t), g);
  }
  _loop_statement() {
    if (!this._match(V.keywords.loop)) return null;
    this._check(V.tokens.attr) && this._attribute(), this._consume(V.tokens.brace_left, "Expected '{' for loop.");
    const g = this._updateNode(new Rj([], null));
    this._currentLoop.push(g);
    let I = this._statement();
    for (; I !== null; ) {
      if (Array.isArray(I)) for (let C of I) g.body.push(C);
      else g.body.push(I);
      if (I instanceof lS) {
        g.continuing = I;
        break;
      }
      I = this._statement();
    }
    return this._currentLoop.pop(), this._consume(V.tokens.brace_right, "Expected '}' for loop."), g;
  }
  _switch_statement() {
    if (!this._match(V.keywords.switch)) return null;
    const g = this._updateNode(new Oj(null, []));
    if (this._currentLoop.push(g), g.condition = this._optional_paren_expression(), this._check(V.tokens.attr) && this._attribute(), this._consume(V.tokens.brace_left, "Expected '{' for switch."), g.cases = this._switch_body(), g.cases == null || g.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(V.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), g;
  }
  _switch_body() {
    const g = [];
    let I = !1;
    for (; this._check([V.keywords.default, V.keywords.case]); ) {
      if (this._match(V.keywords.case)) {
        const C = this._case_selectors();
        for (const s of C) if (s instanceof tp) {
          if (I) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          I = !0;
          break;
        }
        this._match(V.tokens.colon), this._check(V.tokens.attr) && this._attribute(), this._consume(V.tokens.brace_left, "Exected '{' for switch case.");
        const t = this._case_body();
        this._consume(V.tokens.brace_right, "Exected '}' for switch case."), g.push(this._updateNode(new Qj(C, t)));
      }
      if (this._match(V.keywords.default)) {
        if (I) throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(V.tokens.colon), this._check(V.tokens.attr) && this._attribute(), this._consume(V.tokens.brace_left, "Exected '{' for switch default.");
        const C = this._case_body();
        this._consume(V.tokens.brace_right, "Exected '}' for switch default."), g.push(this._updateNode(new zj(C)));
      }
    }
    return g;
  }
  _case_selectors() {
    const g = [];
    for (this._match(V.keywords.default) ? g.push(this._updateNode(new tp())) : g.push(this._shift_expression()); this._match(V.tokens.comma); ) this._match(V.keywords.default) ? g.push(this._updateNode(new tp())) : g.push(this._shift_expression());
    return g;
  }
  _case_body() {
    if (this._match(V.keywords.fallthrough)) return this._consume(V.tokens.semicolon, "Expected ';'"), [];
    let g = this._statement();
    if (g == null) return [];
    g instanceof Array || (g = [g]);
    const I = this._case_body();
    return I.length == 0 ? g : [...g, I[0]];
  }
  _if_statement() {
    if (!this._match(V.keywords.if)) return null;
    const g = this._currentLine, I = this._optional_paren_expression();
    this._check(V.tokens.attr) && this._attribute();
    const C = this._compound_statement();
    let t = [];
    this._match_elseif() && (this._check(V.tokens.attr) && this._attribute(), t = this._elseif_statement(t));
    let s = null;
    return this._match(V.keywords.else) && (this._check(V.tokens.attr) && this._attribute(), s = this._compound_statement()), this._updateNode(new Nj(I, C, t, s), g);
  }
  _match_elseif() {
    return this._tokens[this._current].type === V.keywords.else && this._tokens[this._current + 1].type === V.keywords.if && (this._advance(), this._advance(), !0);
  }
  _elseif_statement(g = []) {
    const I = this._optional_paren_expression(), C = this._compound_statement();
    return g.push(this._updateNode(new QV(I, C))), this._match_elseif() && (this._check(V.tokens.attr) && this._attribute(), this._elseif_statement(g)), g;
  }
  _return_statement() {
    if (!this._match(V.keywords.return)) return null;
    const g = this._short_circuit_or_expression();
    return this._updateNode(new kj(g));
  }
  _short_circuit_or_expression() {
    let g = this._short_circuit_and_expr();
    for (; this._match(V.tokens.or_or); ) g = this._updateNode(new pn(this._previous().toString(), g, this._short_circuit_and_expr()));
    return g;
  }
  _short_circuit_and_expr() {
    let g = this._inclusive_or_expression();
    for (; this._match(V.tokens.and_and); ) g = this._updateNode(new pn(this._previous().toString(), g, this._inclusive_or_expression()));
    return g;
  }
  _inclusive_or_expression() {
    let g = this._exclusive_or_expression();
    for (; this._match(V.tokens.or); ) g = this._updateNode(new pn(this._previous().toString(), g, this._exclusive_or_expression()));
    return g;
  }
  _exclusive_or_expression() {
    let g = this._and_expression();
    for (; this._match(V.tokens.xor); ) g = this._updateNode(new pn(this._previous().toString(), g, this._and_expression()));
    return g;
  }
  _and_expression() {
    let g = this._equality_expression();
    for (; this._match(V.tokens.and); ) g = this._updateNode(new pn(this._previous().toString(), g, this._equality_expression()));
    return g;
  }
  _equality_expression() {
    const g = this._relational_expression();
    return this._match([V.tokens.equal_equal, V.tokens.not_equal]) ? this._updateNode(new pn(this._previous().toString(), g, this._relational_expression())) : g;
  }
  _relational_expression() {
    let g = this._shift_expression();
    for (; this._match([V.tokens.less_than, V.tokens.greater_than, V.tokens.less_than_equal, V.tokens.greater_than_equal]); ) g = this._updateNode(new pn(this._previous().toString(), g, this._shift_expression()));
    return g;
  }
  _shift_expression() {
    let g = this._additive_expression();
    for (; this._match([V.tokens.shift_left, V.tokens.shift_right]); ) g = this._updateNode(new pn(this._previous().toString(), g, this._additive_expression()));
    return g;
  }
  _additive_expression() {
    let g = this._multiplicative_expression();
    for (; this._match([V.tokens.plus, V.tokens.minus]); ) g = this._updateNode(new pn(this._previous().toString(), g, this._multiplicative_expression()));
    return g;
  }
  _multiplicative_expression() {
    let g = this._unary_expression();
    for (; this._match([V.tokens.star, V.tokens.forward_slash, V.tokens.modulo]); ) g = this._updateNode(new pn(this._previous().toString(), g, this._unary_expression()));
    return g;
  }
  _unary_expression() {
    return this._match([V.tokens.minus, V.tokens.bang, V.tokens.tilde, V.tokens.star, V.tokens.and]) ? this._updateNode(new dC(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const g = this._primary_expression(), I = this._postfix_expression();
    return I && (g.postfix = I), g;
  }
  _postfix_expression() {
    if (this._match(V.tokens.bracket_left)) {
      const g = this._short_circuit_or_expression();
      this._consume(V.tokens.bracket_right, "Expected ']'.");
      const I = this._updateNode(new bf(g)), C = this._postfix_expression();
      return C && (I.postfix = C), I;
    }
    if (this._match(V.tokens.period)) {
      const g = this._consume(V.tokens.name, "Expected member name."), I = this._postfix_expression(), C = this._updateNode(new Mc(g.lexeme));
      return I && (C.postfix = I), C;
    }
    return null;
  }
  _getStruct(g) {
    return this._context.aliases.has(g) ? this._context.aliases.get(g).type : this._context.structs.has(g) ? this._context.structs.get(g) : null;
  }
  _getType(g) {
    const I = this._getStruct(g);
    if (I !== null) return I;
    switch (g) {
      case "void":
        return Eg.void;
      case "bool":
        return Eg.bool;
      case "i32":
        return Eg.i32;
      case "u32":
        return Eg.u32;
      case "f32":
        return Eg.f32;
      case "f16":
        return Eg.f16;
      case "vec2f":
        return lg.vec2f;
      case "vec3f":
        return lg.vec3f;
      case "vec4f":
        return lg.vec4f;
      case "vec2i":
        return lg.vec2i;
      case "vec3i":
        return lg.vec3i;
      case "vec4i":
        return lg.vec4i;
      case "vec2u":
        return lg.vec2u;
      case "vec3u":
        return lg.vec3u;
      case "vec4u":
        return lg.vec4u;
      case "vec2h":
        return lg.vec2h;
      case "vec3h":
        return lg.vec3h;
      case "vec4h":
        return lg.vec4h;
      case "mat2x2f":
        return lg.mat2x2f;
      case "mat2x3f":
        return lg.mat2x3f;
      case "mat2x4f":
        return lg.mat2x4f;
      case "mat3x2f":
        return lg.mat3x2f;
      case "mat3x3f":
        return lg.mat3x3f;
      case "mat3x4f":
        return lg.mat3x4f;
      case "mat4x2f":
        return lg.mat4x2f;
      case "mat4x3f":
        return lg.mat4x3f;
      case "mat4x4f":
        return lg.mat4x4f;
      case "mat2x2h":
        return lg.mat2x2h;
      case "mat2x3h":
        return lg.mat2x3h;
      case "mat2x4h":
        return lg.mat2x4h;
      case "mat3x2h":
        return lg.mat3x2h;
      case "mat3x3h":
        return lg.mat3x3h;
      case "mat3x4h":
        return lg.mat3x4h;
      case "mat4x2h":
        return lg.mat4x2h;
      case "mat4x3h":
        return lg.mat4x3h;
      case "mat4x4h":
        return lg.mat4x4h;
      case "mat2x2i":
        return lg.mat2x2i;
      case "mat2x3i":
        return lg.mat2x3i;
      case "mat2x4i":
        return lg.mat2x4i;
      case "mat3x2i":
        return lg.mat3x2i;
      case "mat3x3i":
        return lg.mat3x3i;
      case "mat3x4i":
        return lg.mat3x4i;
      case "mat4x2i":
        return lg.mat4x2i;
      case "mat4x3i":
        return lg.mat4x3i;
      case "mat4x4i":
        return lg.mat4x4i;
      case "mat2x2u":
        return lg.mat2x2u;
      case "mat2x3u":
        return lg.mat2x3u;
      case "mat2x4u":
        return lg.mat2x4u;
      case "mat3x2u":
        return lg.mat3x2u;
      case "mat3x3u":
        return lg.mat3x3u;
      case "mat3x4u":
        return lg.mat3x4u;
      case "mat4x2u":
        return lg.mat4x2u;
      case "mat4x3u":
        return lg.mat4x3u;
      case "mat4x4u":
        return lg.mat4x4u;
    }
    return null;
  }
  _validateTypeRange(g, I) {
    if (I.name === "i32") {
      if (g < -2147483648 || g > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${g}. Line: ${this._currentLine}.`);
    } else if (I.name === "u32" && (g < 0 || g > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${g}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(V.tokens.ident)) {
      const C = this._previous().toString();
      if (this._check(V.tokens.paren_left)) {
        const t = this._argument_expression_list(), s = this._getType(C);
        return s !== null ? this._updateNode(new Ms(s, t)) : this._updateNode(new bG(C, t));
      }
      if (this._context.constants.has(C)) {
        const t = this._context.constants.get(C);
        return this._updateNode(new _j(C, t.value));
      }
      return this._updateNode(new Ft(C));
    }
    if (this._match(V.tokens.int_literal)) {
      const C = this._previous().toString();
      let t = C.endsWith("i") || C.endsWith("i") ? Eg.i32 : C.endsWith("u") || C.endsWith("U") ? Eg.u32 : Eg.x32;
      const s = parseInt(C);
      return this._validateTypeRange(s, t), this._updateNode(new TC(new tg(s, this._exec.getTypeInfo(t)), t));
    }
    if (this._match(V.tokens.uint_literal)) {
      const C = parseInt(this._previous().toString());
      return this._validateTypeRange(C, Eg.u32), this._updateNode(new TC(new tg(C, this._exec.getTypeInfo(Eg.u32)), Eg.u32));
    }
    if (this._match([V.tokens.decimal_float_literal, V.tokens.hex_float_literal])) {
      let C = this._previous().toString(), t = C.endsWith("h");
      t && (C = C.substring(0, C.length - 1));
      const s = parseFloat(C);
      this._validateTypeRange(s, t ? Eg.f16 : Eg.f32);
      const r = t ? Eg.f16 : Eg.f32;
      return this._updateNode(new TC(new tg(s, this._exec.getTypeInfo(r)), r));
    }
    if (this._match([V.keywords.true, V.keywords.false])) {
      let C = this._previous().toString() === V.keywords.true.rule;
      return this._updateNode(new TC(new tg(C ? 1 : 0, this._exec.getTypeInfo(Eg.bool)), Eg.bool));
    }
    if (this._check(V.tokens.paren_left)) return this._paren_expression();
    if (this._match(V.keywords.bitcast)) {
      this._consume(V.tokens.less_than, "Expected '<'.");
      const C = this._type_decl();
      this._consume(V.tokens.greater_than, "Expected '>'.");
      const t = this._paren_expression();
      return this._updateNode(new Uj(C, t));
    }
    const g = this._type_decl(), I = this._argument_expression_list();
    return this._updateNode(new Ms(g, I));
  }
  _argument_expression_list() {
    if (!this._match(V.tokens.paren_left)) return null;
    const g = [];
    do {
      if (this._check(V.tokens.paren_right)) break;
      const I = this._short_circuit_or_expression();
      g.push(I);
    } while (this._match(V.tokens.comma));
    return this._consume(V.tokens.paren_right, "Expected ')' for agument list"), g;
  }
  _optional_paren_expression() {
    this._match(V.tokens.paren_left);
    const g = this._short_circuit_or_expression();
    return this._match(V.tokens.paren_right), g;
  }
  _paren_expression() {
    this._consume(V.tokens.paren_left, "Expected '('.");
    const g = this._short_circuit_or_expression();
    return this._consume(V.tokens.paren_right, "Expected ')'."), g;
  }
  _struct_decl() {
    if (!this._match(V.keywords.struct)) return null;
    const g = this._currentLine, I = this._consume(V.tokens.ident, "Expected name for struct.").toString();
    this._consume(V.tokens.brace_left, "Expected '{' for struct body.");
    const C = [];
    for (; !this._check(V.tokens.brace_right); ) {
      const r = this._attribute(), l = this._consume(V.tokens.name, "Expected variable name.").toString();
      this._consume(V.tokens.colon, "Expected ':' for struct member type.");
      const d = this._attribute(), h = this._type_decl();
      h != null && (h.attributes = d), this._check(V.tokens.brace_right) ? this._match(V.tokens.comma) : this._consume(V.tokens.comma, "Expected ',' for struct member."), C.push(this._updateNode(new jP(l, h, r)));
    }
    this._consume(V.tokens.brace_right, "Expected '}' after struct body.");
    const t = this._currentLine, s = this._updateNode(new To(I, C, g, t), g);
    return this._context.structs.set(I, s), s;
  }
  _global_variable_decl() {
    const g = this._variable_decl();
    if (!g) return null;
    if (this._match(V.tokens.equal)) {
      const I = this._const_expression();
      g.value = I;
    }
    if (g.type !== null && g.value instanceof TC) {
      if (g.value.type.name !== "x32" && g.type.getTypeName() !== g.value.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${g.value.type.name} to ${g.type.name}. Line:${this._currentLine}`);
      g.value.isScalar && this._validateTypeRange(g.value.scalarValue, g.type), g.value.type = g.type;
    } else g.type === null && g.value instanceof TC && (g.type = g.value.type.name === "x32" ? Eg.i32 : g.value.type, g.value.isScalar && this._validateTypeRange(g.value.scalarValue, g.type));
    return g;
  }
  _override_variable_decl() {
    const g = this._override_decl();
    return g && this._match(V.tokens.equal) && (g.value = this._const_expression()), g;
  }
  _global_const_decl() {
    var g;
    if (!this._match(V.keywords.const)) return null;
    const I = this._consume(V.tokens.name, "Expected variable name"), C = this._currentLine;
    let t = null;
    if (this._match(V.tokens.colon)) {
      const d = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = d);
    }
    let s = null;
    this._consume(V.tokens.equal, "const declarations require an assignment");
    const r = this._short_circuit_or_expression();
    try {
      let d = [Eg.f32], h = r.constEvaluate(this._exec, d);
      h instanceof tg && this._validateTypeRange(h.value, d[0]), d[0] instanceof lg && d[0].format === null && h.typeInfo instanceof Dc && h.typeInfo.format !== null && (h.typeInfo.format.name === "f16" ? d[0].format = Eg.f16 : h.typeInfo.format.name === "f32" ? d[0].format = Eg.f32 : h.typeInfo.format.name === "i32" ? d[0].format = Eg.i32 : h.typeInfo.format.name === "u32" ? d[0].format = Eg.u32 : h.typeInfo.format.name === "bool" ? d[0].format = Eg.bool : console.error(`TODO: impelement template format type ${h.typeInfo.format.name}`)), s = this._updateNode(new TC(h, d[0])), this._exec.context.setVariable(I.toString(), h);
    } catch {
      s = r;
    }
    if (t !== null && s instanceof TC) {
      if (s.type.name !== "x32" && t.getTypeName() !== s.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${s.type.name} to ${t.name}. Line:${this._currentLine}`);
      s.type = t, s.isScalar && this._validateTypeRange(s.scalarValue, s.type);
    } else t === null && s instanceof TC && (t = (g = s?.type) !== null && g !== void 0 ? g : Eg.f32, t === Eg.x32 && (t = Eg.i32));
    const l = this._updateNode(new Cp(I.toString(), t, "", "", s), C);
    return this._context.constants.set(l.name, l), l;
  }
  _global_let_decl() {
    if (!this._match(V.keywords.let)) return null;
    const g = this._currentLine, I = this._consume(V.tokens.name, "Expected variable name");
    let C = null;
    if (this._match(V.tokens.colon)) {
      const s = this._attribute();
      C = this._type_decl(), C != null && (C.attributes = s);
    }
    let t = null;
    if (this._match(V.tokens.equal) && (t = this._const_expression()), C !== null && t instanceof TC) {
      if (t.type.name !== "x32" && C.getTypeName() !== t.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${t.type.name} to ${C.name}. Line:${this._currentLine}`);
      t.type = C;
    } else C === null && t instanceof TC && (C = t.type.name === "x32" ? Eg.i32 : t.type);
    return t instanceof TC && t.isScalar && this._validateTypeRange(t.scalarValue, C), this._updateNode(new tM(I.toString(), C, "", "", t), g);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(V.keywords.var)) return null;
    const g = this._currentLine;
    let I = "", C = "";
    this._match(V.tokens.less_than) && (I = this._consume(V.storage_class, "Expected storage_class.").toString(), this._match(V.tokens.comma) && (C = this._consume(V.access_mode, "Expected access_mode.").toString()), this._consume(V.tokens.greater_than, "Expected '>'."));
    const t = this._consume(V.tokens.name, "Expected variable name");
    let s = null;
    if (this._match(V.tokens.colon)) {
      const r = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = r);
    }
    return this._updateNode(new Po(t.toString(), s, I, C, null), g);
  }
  _override_decl() {
    if (!this._match(V.keywords.override)) return null;
    const g = this._consume(V.tokens.name, "Expected variable name");
    let I = null;
    if (this._match(V.tokens.colon)) {
      const C = this._attribute();
      I = this._type_decl(), I != null && (I.attributes = C);
    }
    return this._updateNode(new BG(g.toString(), I, null));
  }
  _diagnostic() {
    this._consume(V.tokens.paren_left, "Expected '('");
    const g = this._consume(V.tokens.ident, "Expected severity control name.");
    this._consume(V.tokens.comma, "Expected ','");
    let I = this._consume(V.tokens.ident, "Expected diagnostic rule name.").toString();
    return this._match(V.tokens.period) && (I += `.${this._consume(V.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(V.tokens.paren_right, "Expected ')'"), this._updateNode(new Wj(g.toString(), I));
  }
  _enable_directive() {
    const g = this._consume(V.tokens.ident, "identity expected.");
    return this._updateNode(new UV(g.toString()));
  }
  _requires_directive() {
    const g = [this._consume(V.tokens.ident, "identity expected.").toString()];
    for (; this._match(V.tokens.comma); ) {
      const I = this._consume(V.tokens.ident, "identity expected.");
      g.push(I.toString());
    }
    return this._updateNode(new FV(g));
  }
  _type_alias() {
    const g = this._consume(V.tokens.ident, "identity expected.");
    this._consume(V.tokens.equal, "Expected '=' for type alias.");
    let I = this._type_decl();
    if (I === null) throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(I.name) && (I = this._context.aliases.get(I.name).type);
    const C = this._updateNode(new mG(g.toString(), I));
    return this._context.aliases.set(C.name, C), C;
  }
  _type_decl() {
    if (this._check([V.tokens.ident, ...V.texel_format, V.keywords.bool, V.keywords.f32, V.keywords.i32, V.keywords.u32])) {
      const C = this._advance().toString();
      if (this._context.structs.has(C)) return this._context.structs.get(C);
      if (this._context.aliases.has(C)) return this._context.aliases.get(C).type;
      if (!this._getType(C)) {
        const t = this._updateNode(new PP(C));
        return this._forwardTypeCount++, t;
      }
      return this._updateNode(new Eg(C));
    }
    let g = this._texture_sampler_types();
    if (g) return g;
    if (this._check(V.template_types)) {
      let C = this._advance().toString(), t = null, s = null;
      return this._match(V.tokens.less_than) && (t = this._type_decl(), s = null, this._match(V.tokens.comma) && (s = this._consume(V.access_mode, "Expected access_mode for pointer").toString()), this._consume(V.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new lg(C, t, s));
    }
    if (this._match(V.keywords.ptr)) {
      let C = this._previous().toString();
      this._consume(V.tokens.less_than, "Expected '<' for pointer.");
      const t = this._consume(V.storage_class, "Expected storage_class for pointer");
      this._consume(V.tokens.comma, "Expected ',' for pointer.");
      const s = this._type_decl();
      let r = null;
      return this._match(V.tokens.comma) && (r = this._consume(V.access_mode, "Expected access_mode for pointer").toString()), this._consume(V.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new ep(C, t.toString(), s, r));
    }
    const I = this._attribute();
    if (this._match(V.keywords.array)) {
      let C = null, t = -1;
      const s = this._previous();
      let r = null;
      if (this._match(V.tokens.less_than)) {
        C = this._type_decl(), this._context.aliases.has(C.name) && (C = this._context.aliases.get(C.name).type);
        let d = "";
        if (this._match(V.tokens.comma)) {
          r = this._shift_expression();
          try {
            d = r.constEvaluate(this._exec).toString(), r = null;
          } catch {
            d = "1";
          }
        }
        this._consume(V.tokens.greater_than, "Expected '>' for array."), t = d ? parseInt(d) : 0;
      }
      const l = this._updateNode(new iM(s.toString(), I, C, t));
      return r && this._deferArrayCountEval.push({ arrayType: l, countNode: r }), l;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(V.sampler_type)) return this._updateNode(new JD(this._previous().toString(), null, null));
    if (this._match(V.depth_texture_type)) return this._updateNode(new JD(this._previous().toString(), null, null));
    if (this._match(V.sampled_texture_type) || this._match(V.multisampled_texture_type)) {
      const g = this._previous();
      this._consume(V.tokens.less_than, "Expected '<' for sampler type.");
      const I = this._type_decl();
      return this._consume(V.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new JD(g.toString(), I, null));
    }
    if (this._match(V.storage_texture_type)) {
      const g = this._previous();
      this._consume(V.tokens.less_than, "Expected '<' for sampler type.");
      const I = this._consume(V.texel_format, "Invalid texel format.").toString();
      this._consume(V.tokens.comma, "Expected ',' after texel format.");
      const C = this._consume(V.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(V.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new JD(g.toString(), I, C));
    }
    return null;
  }
  _attribute() {
    let g = [];
    for (; this._match(V.tokens.attr); ) {
      const I = this._consume(V.attribute_name, "Expected attribute name"), C = this._updateNode(new Jj(I.toString(), null));
      if (this._match(V.tokens.paren_left)) {
        if (C.value = this._consume(V.literal_or_ident, "Expected attribute value").toString(), this._check(V.tokens.comma)) {
          this._advance();
          do {
            const t = this._consume(V.literal_or_ident, "Expected attribute value").toString();
            C.value instanceof Array || (C.value = [C.value]), C.value.push(t);
          } while (this._match(V.tokens.comma));
        }
        this._consume(V.tokens.paren_right, "Expected ')'");
      }
      g.push(C);
    }
    return g.length == 0 ? null : g;
  }
}
class sx extends ps {
  constructor(g) {
    super(), g && this.update(g);
  }
  update(g) {
    const I = new nx().parse(g);
    this.updateAST(I);
  }
}
function ox(A) {
  const g = { attributes: [], bindings: [] };
  let I;
  try {
    I = ax(A);
  } catch (s) {
    return xg.error(s.message)(), g;
  }
  for (const s of I.uniforms) {
    const r = [];
    for (const l of s.type?.members || [])
      r.push({
        name: l.name,
        type: EP(l.type)
      });
    g.bindings.push({
      type: "uniform",
      name: s.name,
      group: s.group,
      location: s.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members: r
    });
  }
  for (const s of I.textures)
    g.bindings.push({
      type: "texture",
      name: s.name,
      group: s.group,
      location: s.binding
    });
  for (const s of I.samplers)
    g.bindings.push({
      type: "sampler",
      name: s.name,
      group: s.group,
      location: s.binding
    });
  const C = I.entry.vertex[0], t = C?.inputs.length || 0;
  for (let s = 0; s < t; s++) {
    const r = C.inputs[s];
    if (r.locationType === "location") {
      const l = EP(r.type);
      g.attributes.push({
        name: r.name,
        location: Number(r.location),
        type: l
      });
    }
  }
  return g;
}
function EP(A) {
  return A.format ? `${A.name}<${A.format.name}>` : A.name;
}
function ax(A) {
  try {
    return new sx(A);
  } catch (g) {
    if (g instanceof Error)
      throw g;
    let I = "WGSL parse error";
    throw typeof g == "object" && g?.message && (I += `: ${g.message} `), typeof g == "object" && g?.token && (I += g.token.line || ""), new Error(I, { cause: g });
  }
}
const rx = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || { config: { ...rx } };
const Zi = globalThis.mathgl.config;
function lx(A, { precision: g = Zi.precision } = {}) {
  return A = cx(A), `${parseFloat(A.toPrecision(g))}`;
}
function Sf(A) {
  return Array.isArray(A) || ArrayBuffer.isView(A) && !(A instanceof DataView);
}
function xC(A, g, I) {
  return dx(A, (C) => Math.max(g, Math.min(I, C)));
}
function Kp(A, g, I) {
  return Sf(A) ? A.map((C, t) => Kp(C, g[t], I)) : I * g + (1 - I) * A;
}
function uM(A, g, I) {
  const C = Zi.EPSILON;
  try {
    if (A === g)
      return !0;
    if (Sf(A) && Sf(g)) {
      if (A.length !== g.length)
        return !1;
      for (let t = 0; t < A.length; ++t)
        if (!uM(A[t], g[t]))
          return !1;
      return !0;
    }
    return A && A.equals ? A.equals(g) : g && g.equals ? g.equals(A) : typeof A == "number" && typeof g == "number" ? Math.abs(A - g) <= Zi.EPSILON * Math.max(1, Math.abs(A), Math.abs(g)) : !1;
  } finally {
    Zi.EPSILON = C;
  }
}
function cx(A) {
  return Math.round(A / Zi.EPSILON) * Zi.EPSILON;
}
function ux(A) {
  return A.clone ? A.clone() : new Array(A.length);
}
function dx(A, g, I) {
  if (Sf(A)) {
    const C = A;
    I = I || ux(C);
    for (let t = 0; t < I.length && t < C.length; ++t) {
      const s = typeof A == "number" ? A : A[t];
      I[t] = g(s, t, I);
    }
    return I;
  }
  return g(A);
}
class Lj extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(g, I = 0) {
    for (let C = 0; C < this.ELEMENTS; ++C)
      this[C] = g[C + I];
    return this.check();
  }
  toArray(g = [], I = 0) {
    for (let C = 0; C < this.ELEMENTS; ++C)
      g[I + C] = this[C];
    return g;
  }
  toObject(g) {
    return g;
  }
  from(g) {
    return Array.isArray(g) ? this.copy(g) : (
      // @ts-ignore
      this.fromObject(g)
    );
  }
  to(g) {
    return g === this ? this : Sf(g) ? this.toArray(g) : this.toObject(g);
  }
  toTarget(g) {
    return g ? this.to(g) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(Zi);
  }
  /** Formats string according to options */
  formatString(g) {
    let I = "";
    for (let C = 0; C < this.ELEMENTS; ++C)
      I += (C > 0 ? ", " : "") + lx(this[C], g);
    return `${g.printTypes ? this.constructor.name : ""}[${I}]`;
  }
  equals(g) {
    if (!g || this.length !== g.length)
      return !1;
    for (let I = 0; I < this.ELEMENTS; ++I)
      if (!uM(this[I], g[I]))
        return !1;
    return !0;
  }
  exactEquals(g) {
    if (!g || this.length !== g.length)
      return !1;
    for (let I = 0; I < this.ELEMENTS; ++I)
      if (this[I] !== g[I])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let g = 0; g < this.ELEMENTS; ++g)
      this[g] = -this[g];
    return this.check();
  }
  lerp(g, I, C) {
    if (C === void 0)
      return this.lerp(this, g, I);
    for (let t = 0; t < this.ELEMENTS; ++t) {
      const s = g[t], r = typeof I == "number" ? I : I[t];
      this[t] = s + C * (r - s);
    }
    return this.check();
  }
  /** Minimal */
  min(g) {
    for (let I = 0; I < this.ELEMENTS; ++I)
      this[I] = Math.min(g[I], this[I]);
    return this.check();
  }
  /** Maximal */
  max(g) {
    for (let I = 0; I < this.ELEMENTS; ++I)
      this[I] = Math.max(g[I], this[I]);
    return this.check();
  }
  clamp(g, I) {
    for (let C = 0; C < this.ELEMENTS; ++C)
      this[C] = Math.min(Math.max(this[C], g[C]), I[C]);
    return this.check();
  }
  add(...g) {
    for (const I of g)
      for (let C = 0; C < this.ELEMENTS; ++C)
        this[C] += I[C];
    return this.check();
  }
  subtract(...g) {
    for (const I of g)
      for (let C = 0; C < this.ELEMENTS; ++C)
        this[C] -= I[C];
    return this.check();
  }
  scale(g) {
    if (typeof g == "number")
      for (let I = 0; I < this.ELEMENTS; ++I)
        this[I] *= g;
    else
      for (let I = 0; I < this.ELEMENTS && I < g.length; ++I)
        this[I] *= g[I];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(g) {
    for (let I = 0; I < this.ELEMENTS; ++I)
      this[I] *= g;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (Zi.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let g = this.length === this.ELEMENTS;
    for (let I = 0; I < this.ELEMENTS; ++I)
      g = g && Number.isFinite(this[I]);
    return g;
  }
  // three.js compatibility
  /** @deprecated */
  sub(g) {
    return this.subtract(g);
  }
  /** @deprecated */
  setScalar(g) {
    for (let I = 0; I < this.ELEMENTS; ++I)
      this[I] = g;
    return this.check();
  }
  /** @deprecated */
  addScalar(g) {
    for (let I = 0; I < this.ELEMENTS; ++I)
      this[I] += g;
    return this.check();
  }
  /** @deprecated */
  subScalar(g) {
    return this.addScalar(-g);
  }
  /** @deprecated */
  multiplyScalar(g) {
    for (let I = 0; I < this.ELEMENTS; ++I)
      this[I] *= g;
    return this.check();
  }
  /** @deprecated */
  divideScalar(g) {
    return this.multiplyByScalar(1 / g);
  }
  /** @deprecated */
  clampScalar(g, I) {
    for (let C = 0; C < this.ELEMENTS; ++C)
      this[C] = Math.min(Math.max(this[C], g), I);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function fx(A, g) {
  if (A.length !== g)
    return !1;
  for (let I = 0; I < A.length; ++I)
    if (!Number.isFinite(A[I]))
      return !1;
  return !0;
}
function Ut(A) {
  if (!Number.isFinite(A))
    throw new Error(`Invalid number ${JSON.stringify(A)}`);
  return A;
}
function yb(A, g, I = "") {
  if (Zi.debug && !fx(A, g))
    throw new Error(`math.gl: ${I} some fields set to invalid numbers'`);
  return A;
}
function RP(A, g) {
  if (!A)
    throw new Error(`math.gl assertion ${g}`);
}
class hx extends Lj {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(g) {
    this[0] = Ut(g);
  }
  get y() {
    return this[1];
  }
  set y(g) {
    this[1] = Ut(g);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let g = 0;
    for (let I = 0; I < this.ELEMENTS; ++I)
      g += this[I] * this[I];
    return g;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(g) {
    return Math.sqrt(this.distanceSquared(g));
  }
  distanceSquared(g) {
    let I = 0;
    for (let C = 0; C < this.ELEMENTS; ++C) {
      const t = this[C] - g[C];
      I += t * t;
    }
    return Ut(I);
  }
  dot(g) {
    let I = 0;
    for (let C = 0; C < this.ELEMENTS; ++C)
      I += this[C] * g[C];
    return Ut(I);
  }
  // MODIFIERS
  normalize() {
    const g = this.magnitude();
    if (g !== 0)
      for (let I = 0; I < this.ELEMENTS; ++I)
        this[I] /= g;
    return this.check();
  }
  multiply(...g) {
    for (const I of g)
      for (let C = 0; C < this.ELEMENTS; ++C)
        this[C] *= I[C];
    return this.check();
  }
  divide(...g) {
    for (const I of g)
      for (let C = 0; C < this.ELEMENTS; ++C)
        this[C] /= I[C];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(g) {
    return this.distance(g);
  }
  distanceToSquared(g) {
    return this.distanceSquared(g);
  }
  getComponent(g) {
    return RP(g >= 0 && g < this.ELEMENTS, "index is out of range"), Ut(this[g]);
  }
  setComponent(g, I) {
    return RP(g >= 0 && g < this.ELEMENTS, "index is out of range"), this[g] = I, this.check();
  }
  addVectors(g, I) {
    return this.copy(g).add(I);
  }
  subVectors(g, I) {
    return this.copy(g).subtract(I);
  }
  multiplyVectors(g, I) {
    return this.copy(g).multiply(I);
  }
  addScaledVector(g, I) {
    return this.add(new this.constructor(g).multiplyScalar(I));
  }
}
const np = 1e-6;
let Gf = typeof Float32Array < "u" ? Float32Array : Array;
function yx() {
  const A = new Gf(2);
  return Gf != Float32Array && (A[0] = 0, A[1] = 0), A;
}
function Tp(A, g, I) {
  return A[0] = g[0] + I[0], A[1] = g[1] + I[1], A;
}
function qj(A, g) {
  return A[0] = -g[0], A[1] = -g[1], A;
}
function $j(A, g, I, C) {
  const t = g[0], s = g[1];
  return A[0] = t + C * (I[0] - t), A[1] = s + C * (I[1] - s), A;
}
function Dx(A, g, I) {
  const C = g[0], t = g[1];
  return A[0] = I[0] * C + I[4] * t + I[12], A[1] = I[1] * C + I[5] * t + I[13], A;
}
(function() {
  const A = yx();
  return function(g, I, C, t, s, r) {
    let l, d;
    for (I || (I = 2), C || (C = 0), t ? d = Math.min(t * I + C, g.length) : d = g.length, l = C; l < d; l += I)
      A[0] = g[l], A[1] = g[l + 1], s(A, A, r), g[l] = A[0], g[l + 1] = A[1];
    return g;
  };
})();
function Mx(A, g, I) {
  const C = g[0], t = g[1], s = I[3] * C + I[7] * t || 1;
  return A[0] = (I[0] * C + I[4] * t) / s, A[1] = (I[1] * C + I[5] * t) / s, A;
}
function gv(A, g, I) {
  const C = g[0], t = g[1], s = g[2], r = I[3] * C + I[7] * t + I[11] * s || 1;
  return A[0] = (I[0] * C + I[4] * t + I[8] * s) / r, A[1] = (I[1] * C + I[5] * t + I[9] * s) / r, A[2] = (I[2] * C + I[6] * t + I[10] * s) / r, A;
}
function wx(A, g, I) {
  const C = g[0], t = g[1];
  return A[0] = I[0] * C + I[2] * t, A[1] = I[1] * C + I[3] * t, A[2] = g[2], A;
}
function Bx() {
  const A = new Gf(3);
  return Gf != Float32Array && (A[0] = 0, A[1] = 0, A[2] = 0), A;
}
function px(A, g, I) {
  return A[0] = g[0] - I[0], A[1] = g[1] - I[1], A[2] = g[2] - I[2], A;
}
function mx(A, g) {
  return A[0] = -g[0], A[1] = -g[1], A[2] = -g[2], A;
}
function bx(A, g) {
  return A[0] * g[0] + A[1] * g[1] + A[2] * g[2];
}
function Sx(A, g, I) {
  const C = g[0], t = g[1], s = g[2], r = I[0], l = I[1], d = I[2];
  return A[0] = t * d - s * l, A[1] = s * r - C * d, A[2] = C * l - t * r, A;
}
function Iv(A, g, I) {
  const C = g[0], t = g[1], s = g[2];
  let r = I[3] * C + I[7] * t + I[11] * s + I[15];
  return r = r || 1, A[0] = (I[0] * C + I[4] * t + I[8] * s + I[12]) / r, A[1] = (I[1] * C + I[5] * t + I[9] * s + I[13]) / r, A[2] = (I[2] * C + I[6] * t + I[10] * s + I[14]) / r, A;
}
function Gx(A, g, I) {
  const C = g[0], t = g[1], s = g[2];
  return A[0] = C * I[0] + t * I[3] + s * I[6], A[1] = C * I[1] + t * I[4] + s * I[7], A[2] = C * I[2] + t * I[5] + s * I[8], A;
}
function Kx(A, g, I) {
  const C = I[0], t = I[1], s = I[2], r = I[3], l = g[0], d = g[1], h = g[2];
  let D = t * h - s * d, w = s * l - C * h, p = C * d - t * l, b = t * p - s * w, S = s * D - C * p, K = C * w - t * D;
  const Y = r * 2;
  return D *= Y, w *= Y, p *= Y, b *= 2, S *= 2, K *= 2, A[0] = l + D + b, A[1] = d + w + S, A[2] = h + p + K, A;
}
function Tx(A, g, I, C) {
  const t = [], s = [];
  return t[0] = g[0] - I[0], t[1] = g[1] - I[1], t[2] = g[2] - I[2], s[0] = t[0], s[1] = t[1] * Math.cos(C) - t[2] * Math.sin(C), s[2] = t[1] * Math.sin(C) + t[2] * Math.cos(C), A[0] = s[0] + I[0], A[1] = s[1] + I[1], A[2] = s[2] + I[2], A;
}
function Yx(A, g, I, C) {
  const t = [], s = [];
  return t[0] = g[0] - I[0], t[1] = g[1] - I[1], t[2] = g[2] - I[2], s[0] = t[2] * Math.sin(C) + t[0] * Math.cos(C), s[1] = t[1], s[2] = t[2] * Math.cos(C) - t[0] * Math.sin(C), A[0] = s[0] + I[0], A[1] = s[1] + I[1], A[2] = s[2] + I[2], A;
}
function Px(A, g, I, C) {
  const t = [], s = [];
  return t[0] = g[0] - I[0], t[1] = g[1] - I[1], t[2] = g[2] - I[2], s[0] = t[0] * Math.cos(C) - t[1] * Math.sin(C), s[1] = t[0] * Math.sin(C) + t[1] * Math.cos(C), s[2] = t[2], A[0] = s[0] + I[0], A[1] = s[1] + I[1], A[2] = s[2] + I[2], A;
}
function Zx(A, g) {
  const I = A[0], C = A[1], t = A[2], s = g[0], r = g[1], l = g[2], d = Math.sqrt((I * I + C * C + t * t) * (s * s + r * r + l * l)), h = d && bx(A, g) / d;
  return Math.acos(Math.min(Math.max(h, -1), 1));
}
const jx = px;
(function() {
  const A = Bx();
  return function(g, I, C, t, s, r) {
    let l, d;
    for (I || (I = 3), C || (C = 0), t ? d = Math.min(t * I + C, g.length) : d = g.length, l = C; l < d; l += I)
      A[0] = g[l], A[1] = g[l + 1], A[2] = g[l + 2], s(A, A, r), g[l] = A[0], g[l + 1] = A[1], g[l + 2] = A[2];
    return g;
  };
})();
const Db = [0, 0, 0];
let EB;
class Ss extends hx {
  static get ZERO() {
    return EB || (EB = new Ss(0, 0, 0), Object.freeze(EB)), EB;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(g = 0, I = 0, C = 0) {
    super(-0, -0, -0), arguments.length === 1 && Sf(g) ? this.copy(g) : (Zi.debug && (Ut(g), Ut(I), Ut(C)), this[0] = g, this[1] = I, this[2] = C);
  }
  set(g, I, C) {
    return this[0] = g, this[1] = I, this[2] = C, this.check();
  }
  copy(g) {
    return this[0] = g[0], this[1] = g[1], this[2] = g[2], this.check();
  }
  fromObject(g) {
    return Zi.debug && (Ut(g.x), Ut(g.y), Ut(g.z)), this[0] = g.x, this[1] = g.y, this[2] = g.z, this.check();
  }
  toObject(g) {
    return g.x = this[0], g.y = this[1], g.z = this[2], g;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(g) {
    this[2] = Ut(g);
  }
  // ACCESSORS
  angle(g) {
    return Zx(this, g);
  }
  // MODIFIERS
  cross(g) {
    return Sx(this, this, g), this.check();
  }
  rotateX({ radians: g, origin: I = Db }) {
    return Tx(this, this, I, g), this.check();
  }
  rotateY({ radians: g, origin: I = Db }) {
    return Yx(this, this, I, g), this.check();
  }
  rotateZ({ radians: g, origin: I = Db }) {
    return Px(this, this, I, g), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(g) {
    return this.transformAsPoint(g);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(g) {
    return Iv(this, this, g), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(g) {
    return gv(this, this, g), this.check();
  }
  transformByMatrix3(g) {
    return Gx(this, this, g), this.check();
  }
  transformByMatrix2(g) {
    return wx(this, this, g), this.check();
  }
  transformByQuaternion(g) {
    return Kx(this, this, g), this.check();
  }
}
class vx extends Lj {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let g = "[";
    if (Zi.printRowMajor) {
      g += "row-major:";
      for (let I = 0; I < this.RANK; ++I)
        for (let C = 0; C < this.RANK; ++C)
          g += ` ${this[C * this.RANK + I]}`;
    } else {
      g += "column-major:";
      for (let I = 0; I < this.ELEMENTS; ++I)
        g += ` ${this[I]}`;
    }
    return g += "]", g;
  }
  getElementIndex(g, I) {
    return I * this.RANK + g;
  }
  // By default assumes row major indices
  getElement(g, I) {
    return this[I * this.RANK + g];
  }
  // By default assumes row major indices
  setElement(g, I, C) {
    return this[I * this.RANK + g] = Ut(C), this;
  }
  getColumn(g, I = new Array(this.RANK).fill(-0)) {
    const C = g * this.RANK;
    for (let t = 0; t < this.RANK; ++t)
      I[t] = this[C + t];
    return I;
  }
  setColumn(g, I) {
    const C = g * this.RANK;
    for (let t = 0; t < this.RANK; ++t)
      this[C + t] = I[t];
    return this;
  }
}
function Hx(A) {
  return A[0] = 1, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = 1, A[6] = 0, A[7] = 0, A[8] = 0, A[9] = 0, A[10] = 1, A[11] = 0, A[12] = 0, A[13] = 0, A[14] = 0, A[15] = 1, A;
}
function Ex(A, g) {
  if (A === g) {
    const I = g[1], C = g[2], t = g[3], s = g[6], r = g[7], l = g[11];
    A[1] = g[4], A[2] = g[8], A[3] = g[12], A[4] = I, A[6] = g[9], A[7] = g[13], A[8] = C, A[9] = s, A[11] = g[14], A[12] = t, A[13] = r, A[14] = l;
  } else
    A[0] = g[0], A[1] = g[4], A[2] = g[8], A[3] = g[12], A[4] = g[1], A[5] = g[5], A[6] = g[9], A[7] = g[13], A[8] = g[2], A[9] = g[6], A[10] = g[10], A[11] = g[14], A[12] = g[3], A[13] = g[7], A[14] = g[11], A[15] = g[15];
  return A;
}
function uS(A, g) {
  const I = g[0], C = g[1], t = g[2], s = g[3], r = g[4], l = g[5], d = g[6], h = g[7], D = g[8], w = g[9], p = g[10], b = g[11], S = g[12], K = g[13], Y = g[14], T = g[15], E = I * l - C * r, H = I * d - t * r, R = I * h - s * r, x = C * d - t * l, U = C * h - s * l, J = t * h - s * d, L = D * K - w * S, eg = D * Y - p * S, Mg = D * T - b * S, ig = w * Y - p * K, Zg = w * T - b * K, Kg = p * T - b * Y;
  let mg = E * Kg - H * Zg + R * ig + x * Mg - U * eg + J * L;
  return mg ? (mg = 1 / mg, A[0] = (l * Kg - d * Zg + h * ig) * mg, A[1] = (t * Zg - C * Kg - s * ig) * mg, A[2] = (K * J - Y * U + T * x) * mg, A[3] = (p * U - w * J - b * x) * mg, A[4] = (d * Mg - r * Kg - h * eg) * mg, A[5] = (I * Kg - t * Mg + s * eg) * mg, A[6] = (Y * R - S * J - T * H) * mg, A[7] = (D * J - p * R + b * H) * mg, A[8] = (r * Zg - l * Mg + h * L) * mg, A[9] = (C * Mg - I * Zg - s * L) * mg, A[10] = (S * U - K * R + T * E) * mg, A[11] = (w * R - D * U - b * E) * mg, A[12] = (l * eg - r * ig - d * L) * mg, A[13] = (I * ig - C * eg + t * L) * mg, A[14] = (K * H - S * x - Y * E) * mg, A[15] = (D * x - w * H + p * E) * mg, A) : null;
}
function Rx(A) {
  const g = A[0], I = A[1], C = A[2], t = A[3], s = A[4], r = A[5], l = A[6], d = A[7], h = A[8], D = A[9], w = A[10], p = A[11], b = A[12], S = A[13], K = A[14], Y = A[15], T = g * r - I * s, E = g * l - C * s, H = I * l - C * r, R = h * S - D * b, x = h * K - w * b, U = D * K - w * S, J = g * U - I * x + C * R, L = s * U - r * x + l * R, eg = h * H - D * E + w * T, Mg = b * H - S * E + K * T;
  return d * J - t * L + Y * eg - p * Mg;
}
function dc(A, g, I) {
  const C = g[0], t = g[1], s = g[2], r = g[3], l = g[4], d = g[5], h = g[6], D = g[7], w = g[8], p = g[9], b = g[10], S = g[11], K = g[12], Y = g[13], T = g[14], E = g[15];
  let H = I[0], R = I[1], x = I[2], U = I[3];
  return A[0] = H * C + R * l + x * w + U * K, A[1] = H * t + R * d + x * p + U * Y, A[2] = H * s + R * h + x * b + U * T, A[3] = H * r + R * D + x * S + U * E, H = I[4], R = I[5], x = I[6], U = I[7], A[4] = H * C + R * l + x * w + U * K, A[5] = H * t + R * d + x * p + U * Y, A[6] = H * s + R * h + x * b + U * T, A[7] = H * r + R * D + x * S + U * E, H = I[8], R = I[9], x = I[10], U = I[11], A[8] = H * C + R * l + x * w + U * K, A[9] = H * t + R * d + x * p + U * Y, A[10] = H * s + R * h + x * b + U * T, A[11] = H * r + R * D + x * S + U * E, H = I[12], R = I[13], x = I[14], U = I[15], A[12] = H * C + R * l + x * w + U * K, A[13] = H * t + R * d + x * p + U * Y, A[14] = H * s + R * h + x * b + U * T, A[15] = H * r + R * D + x * S + U * E, A;
}
function Yp(A, g, I) {
  const C = I[0], t = I[1], s = I[2];
  let r, l, d, h, D, w, p, b, S, K, Y, T;
  return g === A ? (A[12] = g[0] * C + g[4] * t + g[8] * s + g[12], A[13] = g[1] * C + g[5] * t + g[9] * s + g[13], A[14] = g[2] * C + g[6] * t + g[10] * s + g[14], A[15] = g[3] * C + g[7] * t + g[11] * s + g[15]) : (r = g[0], l = g[1], d = g[2], h = g[3], D = g[4], w = g[5], p = g[6], b = g[7], S = g[8], K = g[9], Y = g[10], T = g[11], A[0] = r, A[1] = l, A[2] = d, A[3] = h, A[4] = D, A[5] = w, A[6] = p, A[7] = b, A[8] = S, A[9] = K, A[10] = Y, A[11] = T, A[12] = r * C + D * t + S * s + g[12], A[13] = l * C + w * t + K * s + g[13], A[14] = d * C + p * t + Y * s + g[14], A[15] = h * C + b * t + T * s + g[15]), A;
}
function YG(A, g, I) {
  const C = I[0], t = I[1], s = I[2];
  return A[0] = g[0] * C, A[1] = g[1] * C, A[2] = g[2] * C, A[3] = g[3] * C, A[4] = g[4] * t, A[5] = g[5] * t, A[6] = g[6] * t, A[7] = g[7] * t, A[8] = g[8] * s, A[9] = g[9] * s, A[10] = g[10] * s, A[11] = g[11] * s, A[12] = g[12], A[13] = g[13], A[14] = g[14], A[15] = g[15], A;
}
function Ox(A, g, I, C) {
  let t = C[0], s = C[1], r = C[2], l = Math.sqrt(t * t + s * s + r * r), d, h, D, w, p, b, S, K, Y, T, E, H, R, x, U, J, L, eg, Mg, ig, Zg, Kg, mg, Ng;
  return l < np ? null : (l = 1 / l, t *= l, s *= l, r *= l, h = Math.sin(I), d = Math.cos(I), D = 1 - d, w = g[0], p = g[1], b = g[2], S = g[3], K = g[4], Y = g[5], T = g[6], E = g[7], H = g[8], R = g[9], x = g[10], U = g[11], J = t * t * D + d, L = s * t * D + r * h, eg = r * t * D - s * h, Mg = t * s * D - r * h, ig = s * s * D + d, Zg = r * s * D + t * h, Kg = t * r * D + s * h, mg = s * r * D - t * h, Ng = r * r * D + d, A[0] = w * J + K * L + H * eg, A[1] = p * J + Y * L + R * eg, A[2] = b * J + T * L + x * eg, A[3] = S * J + E * L + U * eg, A[4] = w * Mg + K * ig + H * Zg, A[5] = p * Mg + Y * ig + R * Zg, A[6] = b * Mg + T * ig + x * Zg, A[7] = S * Mg + E * ig + U * Zg, A[8] = w * Kg + K * mg + H * Ng, A[9] = p * Kg + Y * mg + R * Ng, A[10] = b * Kg + T * mg + x * Ng, A[11] = S * Kg + E * mg + U * Ng, g !== A && (A[12] = g[12], A[13] = g[13], A[14] = g[14], A[15] = g[15]), A);
}
function Av(A, g, I) {
  const C = Math.sin(I), t = Math.cos(I), s = g[4], r = g[5], l = g[6], d = g[7], h = g[8], D = g[9], w = g[10], p = g[11];
  return g !== A && (A[0] = g[0], A[1] = g[1], A[2] = g[2], A[3] = g[3], A[12] = g[12], A[13] = g[13], A[14] = g[14], A[15] = g[15]), A[4] = s * t + h * C, A[5] = r * t + D * C, A[6] = l * t + w * C, A[7] = d * t + p * C, A[8] = h * t - s * C, A[9] = D * t - r * C, A[10] = w * t - l * C, A[11] = p * t - d * C, A;
}
function Nx(A, g, I) {
  const C = Math.sin(I), t = Math.cos(I), s = g[0], r = g[1], l = g[2], d = g[3], h = g[8], D = g[9], w = g[10], p = g[11];
  return g !== A && (A[4] = g[4], A[5] = g[5], A[6] = g[6], A[7] = g[7], A[12] = g[12], A[13] = g[13], A[14] = g[14], A[15] = g[15]), A[0] = s * t - h * C, A[1] = r * t - D * C, A[2] = l * t - w * C, A[3] = d * t - p * C, A[8] = s * C + h * t, A[9] = r * C + D * t, A[10] = l * C + w * t, A[11] = d * C + p * t, A;
}
function Cv(A, g, I) {
  const C = Math.sin(I), t = Math.cos(I), s = g[0], r = g[1], l = g[2], d = g[3], h = g[4], D = g[5], w = g[6], p = g[7];
  return g !== A && (A[8] = g[8], A[9] = g[9], A[10] = g[10], A[11] = g[11], A[12] = g[12], A[13] = g[13], A[14] = g[14], A[15] = g[15]), A[0] = s * t + h * C, A[1] = r * t + D * C, A[2] = l * t + w * C, A[3] = d * t + p * C, A[4] = h * t - s * C, A[5] = D * t - r * C, A[6] = w * t - l * C, A[7] = p * t - d * C, A;
}
function kx(A, g) {
  const I = g[0], C = g[1], t = g[2], s = g[3], r = I + I, l = C + C, d = t + t, h = I * r, D = C * r, w = C * l, p = t * r, b = t * l, S = t * d, K = s * r, Y = s * l, T = s * d;
  return A[0] = 1 - w - S, A[1] = D + T, A[2] = p - Y, A[3] = 0, A[4] = D - T, A[5] = 1 - h - S, A[6] = b + K, A[7] = 0, A[8] = p + Y, A[9] = b - K, A[10] = 1 - h - w, A[11] = 0, A[12] = 0, A[13] = 0, A[14] = 0, A[15] = 1, A;
}
function Wx(A, g, I, C, t, s, r) {
  const l = 1 / (I - g), d = 1 / (t - C), h = 1 / (s - r);
  return A[0] = s * 2 * l, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = s * 2 * d, A[6] = 0, A[7] = 0, A[8] = (I + g) * l, A[9] = (t + C) * d, A[10] = (r + s) * h, A[11] = -1, A[12] = 0, A[13] = 0, A[14] = r * s * 2 * h, A[15] = 0, A;
}
function Vx(A, g, I, C, t) {
  const s = 1 / Math.tan(g / 2);
  if (A[0] = s / I, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = s, A[6] = 0, A[7] = 0, A[8] = 0, A[9] = 0, A[11] = -1, A[12] = 0, A[13] = 0, A[15] = 0, t != null && t !== 1 / 0) {
    const r = 1 / (C - t);
    A[10] = (t + C) * r, A[14] = 2 * t * C * r;
  } else
    A[10] = -1, A[14] = -2 * C;
  return A;
}
const xx = Vx;
function _x(A, g, I, C, t, s, r) {
  const l = 1 / (g - I), d = 1 / (C - t), h = 1 / (s - r);
  return A[0] = -2 * l, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = -2 * d, A[6] = 0, A[7] = 0, A[8] = 0, A[9] = 0, A[10] = 2 * h, A[11] = 0, A[12] = (g + I) * l, A[13] = (t + C) * d, A[14] = (r + s) * h, A[15] = 1, A;
}
const Ux = _x;
function Fx(A, g, I, C) {
  let t, s, r, l, d, h, D, w, p, b;
  const S = g[0], K = g[1], Y = g[2], T = C[0], E = C[1], H = C[2], R = I[0], x = I[1], U = I[2];
  return Math.abs(S - R) < np && Math.abs(K - x) < np && Math.abs(Y - U) < np ? Hx(A) : (w = S - R, p = K - x, b = Y - U, t = 1 / Math.sqrt(w * w + p * p + b * b), w *= t, p *= t, b *= t, s = E * b - H * p, r = H * w - T * b, l = T * p - E * w, t = Math.sqrt(s * s + r * r + l * l), t ? (t = 1 / t, s *= t, r *= t, l *= t) : (s = 0, r = 0, l = 0), d = p * l - b * r, h = b * s - w * l, D = w * r - p * s, t = Math.sqrt(d * d + h * h + D * D), t ? (t = 1 / t, d *= t, h *= t, D *= t) : (d = 0, h = 0, D = 0), A[0] = s, A[1] = d, A[2] = w, A[3] = 0, A[4] = r, A[5] = h, A[6] = p, A[7] = 0, A[8] = l, A[9] = D, A[10] = b, A[11] = 0, A[12] = -(s * S + r * K + l * Y), A[13] = -(d * S + h * K + D * Y), A[14] = -(w * S + p * K + b * Y), A[15] = 1, A);
}
function Xx() {
  const A = new Gf(4);
  return Gf != Float32Array && (A[0] = 0, A[1] = 0, A[2] = 0, A[3] = 0), A;
}
function Qx(A, g, I) {
  return A[0] = g[0] * I, A[1] = g[1] * I, A[2] = g[2] * I, A[3] = g[3] * I, A;
}
function SM(A, g, I) {
  const C = g[0], t = g[1], s = g[2], r = g[3];
  return A[0] = I[0] * C + I[4] * t + I[8] * s + I[12] * r, A[1] = I[1] * C + I[5] * t + I[9] * s + I[13] * r, A[2] = I[2] * C + I[6] * t + I[10] * s + I[14] * r, A[3] = I[3] * C + I[7] * t + I[11] * s + I[15] * r, A;
}
(function() {
  const A = Xx();
  return function(g, I, C, t, s, r) {
    let l, d;
    for (I || (I = 4), C || (C = 0), t ? d = Math.min(t * I + C, g.length) : d = g.length, l = C; l < d; l += I)
      A[0] = g[l], A[1] = g[l + 1], A[2] = g[l + 2], A[3] = g[l + 3], s(A, A, r), g[l] = A[0], g[l + 1] = A[1], g[l + 2] = A[2], g[l + 3] = A[3];
    return g;
  };
})();
var dS;
(function(A) {
  A[A.COL0ROW0 = 0] = "COL0ROW0", A[A.COL0ROW1 = 1] = "COL0ROW1", A[A.COL0ROW2 = 2] = "COL0ROW2", A[A.COL0ROW3 = 3] = "COL0ROW3", A[A.COL1ROW0 = 4] = "COL1ROW0", A[A.COL1ROW1 = 5] = "COL1ROW1", A[A.COL1ROW2 = 6] = "COL1ROW2", A[A.COL1ROW3 = 7] = "COL1ROW3", A[A.COL2ROW0 = 8] = "COL2ROW0", A[A.COL2ROW1 = 9] = "COL2ROW1", A[A.COL2ROW2 = 10] = "COL2ROW2", A[A.COL2ROW3 = 11] = "COL2ROW3", A[A.COL3ROW0 = 12] = "COL3ROW0", A[A.COL3ROW1 = 13] = "COL3ROW1", A[A.COL3ROW2 = 14] = "COL3ROW2", A[A.COL3ROW3 = 15] = "COL3ROW3";
})(dS || (dS = {}));
const zx = 45 * Math.PI / 180, Jx = 1, Mb = 0.1, wb = 500, Lx = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Jt extends vx {
  static get IDENTITY() {
    return $x();
  }
  static get ZERO() {
    return qx();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return dS;
  }
  constructor(g) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(g) ? this.copy(g) : this.identity();
  }
  copy(g) {
    return this[0] = g[0], this[1] = g[1], this[2] = g[2], this[3] = g[3], this[4] = g[4], this[5] = g[5], this[6] = g[6], this[7] = g[7], this[8] = g[8], this[9] = g[9], this[10] = g[10], this[11] = g[11], this[12] = g[12], this[13] = g[13], this[14] = g[14], this[15] = g[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(g, I, C, t, s, r, l, d, h, D, w, p, b, S, K, Y) {
    return this[0] = g, this[1] = I, this[2] = C, this[3] = t, this[4] = s, this[5] = r, this[6] = l, this[7] = d, this[8] = h, this[9] = D, this[10] = w, this[11] = p, this[12] = b, this[13] = S, this[14] = K, this[15] = Y, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(g, I, C, t, s, r, l, d, h, D, w, p, b, S, K, Y) {
    return this[0] = g, this[1] = s, this[2] = h, this[3] = b, this[4] = I, this[5] = r, this[6] = D, this[7] = S, this[8] = C, this[9] = l, this[10] = w, this[11] = K, this[12] = t, this[13] = d, this[14] = p, this[15] = Y, this.check();
  }
  toRowMajor(g) {
    return g[0] = this[0], g[1] = this[4], g[2] = this[8], g[3] = this[12], g[4] = this[1], g[5] = this[5], g[6] = this[9], g[7] = this[13], g[8] = this[2], g[9] = this[6], g[10] = this[10], g[11] = this[14], g[12] = this[3], g[13] = this[7], g[14] = this[11], g[15] = this[15], g;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(Lx);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(g) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(g) {
    return kx(this, g), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(g) {
    const { left: I, right: C, bottom: t, top: s, near: r = Mb, far: l = wb } = g;
    return l === 1 / 0 ? g_(this, I, C, t, s, r) : Wx(this, I, C, t, s, r, l), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(g) {
    const { eye: I, center: C = [0, 0, 0], up: t = [0, 1, 0] } = g;
    return Fx(this, I, C, t), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(g) {
    const { left: I, right: C, bottom: t, top: s, near: r = Mb, far: l = wb } = g;
    return Ux(this, I, C, t, s, r, l), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(g) {
    const { fovy: I = zx, aspect: C = Jx, focalDistance: t = 1, near: s = Mb, far: r = wb } = g;
    OP(I);
    const l = I / 2, d = t * Math.tan(l), h = d * C;
    return this.ortho({
      left: -h,
      right: h,
      bottom: -d,
      top: d,
      near: s,
      far: r
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(g) {
    const { fovy: I = 45 * Math.PI / 180, aspect: C = 1, near: t = 0.1, far: s = 500 } = g;
    return OP(I), xx(this, I, C, t, s), this.check();
  }
  // Accessors
  determinant() {
    return Rx(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(g = [-0, -0, -0]) {
    return g[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), g[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), g[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), g;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(g = [-0, -0, -0]) {
    return g[0] = this[12], g[1] = this[13], g[2] = this[14], g;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(g, I) {
    g = g || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], I = I || [-0, -0, -0];
    const C = this.getScale(I), t = 1 / C[0], s = 1 / C[1], r = 1 / C[2];
    return g[0] = this[0] * t, g[1] = this[1] * s, g[2] = this[2] * r, g[3] = 0, g[4] = this[4] * t, g[5] = this[5] * s, g[6] = this[6] * r, g[7] = 0, g[8] = this[8] * t, g[9] = this[9] * s, g[10] = this[10] * r, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(g, I) {
    g = g || [-0, -0, -0, -0, -0, -0, -0, -0, -0], I = I || [-0, -0, -0];
    const C = this.getScale(I), t = 1 / C[0], s = 1 / C[1], r = 1 / C[2];
    return g[0] = this[0] * t, g[1] = this[1] * s, g[2] = this[2] * r, g[3] = this[4] * t, g[4] = this[5] * s, g[5] = this[6] * r, g[6] = this[8] * t, g[7] = this[9] * s, g[8] = this[10] * r, g;
  }
  // Modifiers
  transpose() {
    return Ex(this, this), this.check();
  }
  invert() {
    return uS(this, this), this.check();
  }
  // Operations
  multiplyLeft(g) {
    return dc(this, g, this), this.check();
  }
  multiplyRight(g) {
    return dc(this, this, g), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(g) {
    return Av(this, this, g), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(g) {
    return Nx(this, this, g), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(g) {
    return Cv(this, this, g), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(g) {
    return this.rotateX(g[0]).rotateY(g[1]).rotateZ(g[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(g, I) {
    return Ox(this, this, g, I), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(g) {
    return YG(this, this, Array.isArray(g) ? g : [g, g, g]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(g) {
    return Yp(this, this, g), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(g, I) {
    return g.length === 4 ? (I = SM(I || [-0, -0, -0, -0], g, this), yb(I, 4), I) : this.transformAsPoint(g, I);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(g, I) {
    const { length: C } = g;
    let t;
    switch (C) {
      case 2:
        t = Dx(I || [-0, -0], g, this);
        break;
      case 3:
        t = Iv(I || [-0, -0, -0], g, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return yb(t, g.length), t;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(g, I) {
    let C;
    switch (g.length) {
      case 2:
        C = Mx(I || [-0, -0], g, this);
        break;
      case 3:
        C = gv(I || [-0, -0, -0], g, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return yb(C, g.length), C;
  }
  /** @deprecated */
  transformPoint(g, I) {
    return this.transformAsPoint(g, I);
  }
  /** @deprecated */
  transformVector(g, I) {
    return this.transformAsPoint(g, I);
  }
  /** @deprecated */
  transformDirection(g, I) {
    return this.transformAsVector(g, I);
  }
  // three.js math API compatibility
  makeRotationX(g) {
    return this.identity().rotateX(g);
  }
  makeTranslation(g, I, C) {
    return this.identity().translate([g, I, C]);
  }
}
let RB, OB;
function qx() {
  return RB || (RB = new Jt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(RB)), RB;
}
function $x() {
  return OB || (OB = new Jt(), Object.freeze(OB)), OB;
}
function OP(A) {
  if (A > Math.PI * 2)
    throw Error("expected radians");
}
function g_(A, g, I, C, t, s) {
  const r = 2 * s / (I - g), l = 2 * s / (t - C), d = (I + g) / (I - g), h = (t + C) / (t - C), D = -1, w = -1, p = -2 * s;
  return A[0] = r, A[1] = 0, A[2] = 0, A[3] = 0, A[4] = 0, A[5] = l, A[6] = 0, A[7] = 0, A[8] = d, A[9] = h, A[10] = D, A[11] = w, A[12] = 0, A[13] = 0, A[14] = p, A[15] = 0, A;
}
function ev(A, g = [], I = 0) {
  const C = Math.fround(A), t = A - C;
  return g[I] = C, g[I + 1] = t, g;
}
function I_(A) {
  return A - Math.fround(A);
}
function A_(A) {
  const g = new Float32Array(32);
  for (let I = 0; I < 4; ++I)
    for (let C = 0; C < 4; ++C) {
      const t = I * 4 + C;
      ev(A[C * 4 + I], g, t * 2);
    }
  return g;
}
const C_ = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
), e_ = {
  name: "fp32",
  vs: C_
}, t_ = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
), i_ = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
}, n_ = {
  name: "fp64arithmetic",
  vs: t_,
  defaultUniforms: i_,
  uniformTypes: { ONE: "f32" },
  // Additional Functions
  fp64ify: ev,
  fp64LowPart: I_,
  fp64ifyMatrix4: A_
}, s_ = [0, 1, 1, 1], o_ = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
), a_ = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
), NP = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: s_
  },
  vs: o_,
  fs: a_,
  getUniforms: r_
};
function r_(A = {}, g) {
  const I = {};
  if (A.highlightedObjectColor !== void 0) if (A.highlightedObjectColor === null)
    I.isHighlightActive = !1;
  else {
    I.isHighlightActive = !0;
    const C = A.highlightedObjectColor.slice(0, 3);
    I.highlightedObjectColor = C;
  }
  if (A.highlightColor) {
    const C = Array.from(A.highlightColor, (t) => t / 255);
    Number.isFinite(C[3]) || (C[3] = 1), I.highlightColor = C;
  }
  return A.isActive !== void 0 && (I.isActive = !!A.isActive, I.isAttribute = !!A.isAttribute), A.useFloatColors !== void 0 && (I.useFloatColors = !!A.useFloatColors), I;
}
const kP = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
), l_ = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
), tv = 3, c_ = 255;
var dM;
(function(A) {
  A[A.POINT = 0] = "POINT", A[A.DIRECTIONAL = 1] = "DIRECTIONAL";
})(dM || (dM = {}));
const sp = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    MAX_LIGHTS: tv
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientLightColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: dM.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientLightColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: l_,
  vs: kP,
  fs: kP,
  getUniforms: u_
};
function u_(A, g = {}) {
  if (A = A && { ...A }, !A)
    return { ...sp.defaultUniforms };
  A.lights && (A = { ...A, ...f_(A.lights), lights: void 0 });
  const { ambientLight: I, pointLights: C, directionalLights: t } = A || {};
  if (!(I || C && C.length > 0 || t && t.length > 0))
    return { ...sp.defaultUniforms, enabled: 0 };
  const r = {
    ...sp.defaultUniforms,
    ...g,
    ...d_({ ambientLight: I, pointLights: C, directionalLights: t })
  };
  return A.enabled !== void 0 && (r.enabled = A.enabled ? 1 : 0), r;
}
function d_({ ambientLight: A, pointLights: g = [], directionalLights: I = [] }) {
  const C = {};
  C.ambientLightColor = Bb(A);
  let t = 0;
  for (const s of g) {
    C.lightType = dM.POINT;
    const r = t;
    C[`lightColor${r}`] = Bb(s), C[`lightPosition${r}`] = s.position, C[`lightAttenuation${r}`] = s.attenuation || [1, 0, 0], t++;
  }
  for (const s of I) {
    C.lightType = dM.DIRECTIONAL;
    const r = t;
    C[`lightColor${r}`] = Bb(s), C[`lightDirection${r}`] = s.direction, t++;
  }
  return t > tv && xg.warn("MAX_LIGHTS exceeded")(), C.directionalLightCount = I.length, C.pointLightCount = g.length, C;
}
function f_(A) {
  const g = { pointLights: [], directionalLights: [] };
  for (const I of A || [])
    switch (I.type) {
      case "ambient":
        g.ambientLight = I;
        break;
      case "directional":
        g.directionalLights?.push(I);
        break;
      case "point":
        g.pointLights?.push(I);
        break;
    }
  return g;
}
function Bb(A = {}) {
  const { color: g = [0, 0, 0], intensity: I = 1 } = A;
  return g.map((C) => C * I / c_);
}
const h_ = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
), y_ = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
), D_ = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
), iv = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: y_.replace("phongMaterial", "gouraudMaterial"),
  fs: h_.replace("phongMaterial", "gouraudMaterial"),
  source: D_.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: 1
  },
  dependencies: [sp],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(A) {
    const g = { ...A };
    return g.specularColor && (g.specularColor = g.specularColor.map((I) => I / 255)), { ...iv.defaultUniforms, ...g };
  }
}, WP = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, M_ = {
  name: "layer",
  vs: WP,
  fs: WP,
  getUniforms: (A) => ({
    // apply gamma to opacity to make it visually "linear"
    // TODO - v10: use raw opacity?
    opacity: Math.pow(A.opacity, 1 / 2.2)
  }),
  uniformTypes: {
    opacity: "f32"
  }
}, w_ = (
  /* wgsl */
  `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), nv = "#define SMOOTH_EDGE_RADIUS 0.5", B_ = (
  /* glsl */
  `${nv}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
), p_ = (
  /* glsl */
  `${nv}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), sv = {
  name: "geometry",
  source: w_,
  vs: B_,
  fs: p_
}, m_ = 25;
var fC;
(function(A) {
  A[A.Start = 1] = "Start", A[A.Move = 2] = "Move", A[A.End = 4] = "End", A[A.Cancel = 8] = "Cancel";
})(fC || (fC = {}));
var YC;
(function(A) {
  A[A.None = 0] = "None", A[A.Left = 1] = "Left", A[A.Right = 2] = "Right", A[A.Up = 4] = "Up", A[A.Down = 8] = "Down", A[A.Horizontal = 3] = "Horizontal", A[A.Vertical = 12] = "Vertical", A[A.All = 15] = "All";
})(YC || (YC = {}));
var SI;
(function(A) {
  A[A.Possible = 1] = "Possible", A[A.Began = 2] = "Began", A[A.Changed = 4] = "Changed", A[A.Ended = 8] = "Ended", A[A.Recognized = 8] = "Recognized", A[A.Cancelled = 16] = "Cancelled", A[A.Failed = 32] = "Failed";
})(SI || (SI = {}));
const b_ = "compute", S_ = "auto", fS = "manipulation", op = "none", hS = "pan-x", yS = "pan-y";
function G_(A) {
  if (A.includes(op))
    return op;
  const g = A.includes(hS), I = A.includes(yS);
  return g && I ? op : g || I ? g ? hS : yS : A.includes(fS) ? fS : S_;
}
class K_ {
  constructor(g, I) {
    this.actions = "", this.manager = g, this.set(I);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(g) {
    g === b_ && (g = this.compute()), this.manager.element && (this.manager.element.style.touchAction = g, this.actions = g);
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let g = [];
    for (const I of this.manager.recognizers)
      I.options.enable && (g = g.concat(I.getTouchAction()));
    return G_(g.join(" "));
  }
}
function Pp(A) {
  return A.trim().split(/\s+/g);
}
function pb(A, g, I) {
  if (A)
    for (const C of Pp(g))
      A.addEventListener(C, I, !1);
}
function mb(A, g, I) {
  if (A)
    for (const C of Pp(g))
      A.removeEventListener(C, I, !1);
}
function VP(A) {
  return (A.ownerDocument || A).defaultView;
}
function T_(A, g) {
  let I = A;
  for (; I; ) {
    if (I === g)
      return !0;
    I = I.parentNode;
  }
  return !1;
}
function ov(A) {
  const g = A.length;
  if (g === 1)
    return {
      x: Math.round(A[0].clientX),
      y: Math.round(A[0].clientY)
    };
  let I = 0, C = 0, t = 0;
  for (; t < g; )
    I += A[t].clientX, C += A[t].clientY, t++;
  return {
    x: Math.round(I / g),
    y: Math.round(C / g)
  };
}
function xP(A) {
  const g = [];
  let I = 0;
  for (; I < A.pointers.length; )
    g[I] = {
      clientX: Math.round(A.pointers[I].clientX),
      clientY: Math.round(A.pointers[I].clientY)
    }, I++;
  return {
    timeStamp: Date.now(),
    pointers: g,
    center: ov(g),
    deltaX: A.deltaX,
    deltaY: A.deltaY
  };
}
function av(A, g) {
  const I = g.x - A.x, C = g.y - A.y;
  return Math.sqrt(I * I + C * C);
}
function _P(A, g) {
  const I = g.clientX - A.clientX, C = g.clientY - A.clientY;
  return Math.sqrt(I * I + C * C);
}
function Y_(A, g) {
  const I = g.x - A.x, C = g.y - A.y;
  return Math.atan2(C, I) * 180 / Math.PI;
}
function UP(A, g) {
  const I = g.clientX - A.clientX, C = g.clientY - A.clientY;
  return Math.atan2(C, I) * 180 / Math.PI;
}
function rv(A, g) {
  return A === g ? YC.None : Math.abs(A) >= Math.abs(g) ? A < 0 ? YC.Left : YC.Right : g < 0 ? YC.Up : YC.Down;
}
function P_(A, g) {
  const I = g.center;
  let C = A.offsetDelta, t = A.prevDelta;
  const s = A.prevInput;
  return (g.eventType === fC.Start || s?.eventType === fC.End) && (t = A.prevDelta = {
    x: s?.deltaX || 0,
    y: s?.deltaY || 0
  }, C = A.offsetDelta = {
    x: I.x,
    y: I.y
  }), {
    deltaX: t.x + (I.x - C.x),
    deltaY: t.y + (I.y - C.y)
  };
}
function lv(A, g, I) {
  return {
    x: g / A || 0,
    y: I / A || 0
  };
}
function Z_(A, g) {
  return _P(g[0], g[1]) / _P(A[0], A[1]);
}
function j_(A, g) {
  return UP(g[1], g[0]) - UP(A[1], A[0]);
}
function v_(A, g) {
  const I = A.lastInterval || g, C = g.timeStamp - I.timeStamp;
  let t, s, r, l;
  if (g.eventType !== fC.Cancel && (C > m_ || I.velocity === void 0)) {
    const d = g.deltaX - I.deltaX, h = g.deltaY - I.deltaY, D = lv(C, d, h);
    s = D.x, r = D.y, t = Math.abs(D.x) > Math.abs(D.y) ? D.x : D.y, l = rv(d, h), A.lastInterval = g;
  } else
    t = I.velocity, s = I.velocityX, r = I.velocityY, l = I.direction;
  g.velocity = t, g.velocityX = s, g.velocityY = r, g.direction = l;
}
function H_(A, g) {
  const { session: I } = A, { pointers: C } = g, { length: t } = C;
  I.firstInput || (I.firstInput = xP(g)), t > 1 && !I.firstMultiple ? I.firstMultiple = xP(g) : t === 1 && (I.firstMultiple = !1);
  const { firstInput: s, firstMultiple: r } = I, l = r ? r.center : s.center, d = g.center = ov(C);
  g.timeStamp = Date.now(), g.deltaTime = g.timeStamp - s.timeStamp, g.angle = Y_(l, d), g.distance = av(l, d);
  const { deltaX: h, deltaY: D } = P_(I, g);
  g.deltaX = h, g.deltaY = D, g.offsetDirection = rv(g.deltaX, g.deltaY);
  const w = lv(g.deltaTime, g.deltaX, g.deltaY);
  g.overallVelocityX = w.x, g.overallVelocityY = w.y, g.overallVelocity = Math.abs(w.x) > Math.abs(w.y) ? w.x : w.y, g.scale = r ? Z_(r.pointers, C) : 1, g.rotation = r ? j_(r.pointers, C) : 0, g.maxPointers = I.prevInput ? g.pointers.length > I.prevInput.maxPointers ? g.pointers.length : I.prevInput.maxPointers : g.pointers.length;
  let p = A.element;
  return T_(g.srcEvent.target, p) && (p = g.srcEvent.target), g.target = p, v_(I, g), g;
}
function E_(A, g, I) {
  const C = I.pointers.length, t = I.changedPointers.length, s = g & fC.Start && C - t === 0, r = g & (fC.End | fC.Cancel) && C - t === 0;
  I.isFirst = !!s, I.isFinal = !!r, s && (A.session = {}), I.eventType = g;
  const l = H_(A, I);
  A.emit("hammer.input", l), A.recognize(l), A.session.prevInput = l;
}
let R_ = class {
  constructor(g) {
    this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (I) => {
      this.manager.options.enable && this.handler(I);
    }, this.manager = g, this.element = g.element, this.target = g.options.inputTarget || g.element;
  }
  callback(g, I) {
    E_(this.manager, g, I);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    pb(this.element, this.evEl, this.domHandler), pb(this.target, this.evTarget, this.domHandler), pb(VP(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    mb(this.element, this.evEl, this.domHandler), mb(this.target, this.evTarget, this.domHandler), mb(VP(this.element), this.evWin, this.domHandler);
  }
};
const O_ = {
  pointerdown: fC.Start,
  pointermove: fC.Move,
  pointerup: fC.End,
  pointercancel: fC.Cancel,
  pointerout: fC.Cancel
}, N_ = "pointerdown", k_ = "pointermove pointerup pointercancel";
class W_ extends R_ {
  constructor(g) {
    super(g), this.evEl = N_, this.evWin = k_, this.store = this.manager.session.pointerEvents = [], this.init();
  }
  /**
   * handle mouse events
   */
  handler(g) {
    const { store: I } = this;
    let C = !1;
    const t = O_[g.type], s = g.pointerType, r = s === "touch";
    let l = I.findIndex((d) => d.pointerId === g.pointerId);
    t & fC.Start && (g.buttons || r) ? l < 0 && (I.push(g), l = I.length - 1) : t & (fC.End | fC.Cancel) && (C = !0), !(l < 0) && (I[l] = g, this.callback(t, {
      pointers: I,
      changedPointers: [g],
      eventType: t,
      pointerType: s,
      srcEvent: g
    }), C && I.splice(l, 1));
  }
}
const V_ = ["", "webkit", "Moz", "MS", "ms", "o"];
function x_(A, g) {
  const I = g[0].toUpperCase() + g.slice(1);
  for (const C of V_) {
    const t = C ? C + I : g;
    if (t in A)
      return t;
  }
}
const __ = 1, FP = 2, XP = {
  touchAction: "compute",
  enable: !0,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
class U_ {
  constructor(g, I) {
    this.options = {
      ...XP,
      ...I,
      cssProps: { ...XP.cssProps, ...I.cssProps },
      inputTarget: I.inputTarget || g
    }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = g, this.input = new W_(this), this.touchAction = new K_(this, this.options.touchAction), this.toggleCssProps(!0);
  }
  /**
   * set options
   */
  set(g) {
    return Object.assign(this.options, g), g.touchAction && this.touchAction.update(), g.inputTarget && (this.input.destroy(), this.input.target = g.inputTarget, this.input.init()), this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(g) {
    this.session.stopped = g ? FP : __;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(g) {
    const { session: I } = this;
    if (I.stopped)
      return;
    this.session.prevented && g.srcEvent.preventDefault();
    let C;
    const { recognizers: t } = this;
    let { curRecognizer: s } = I;
    (!s || s && s.state & SI.Recognized) && (s = I.curRecognizer = null);
    let r = 0;
    for (; r < t.length; )
      C = t[r], I.stopped !== FP && // 1
      (!s || C === s || // 2
      C.canRecognizeWith(s)) ? C.recognize(g) : C.reset(), !s && C.state & (SI.Began | SI.Changed | SI.Ended) && (s = I.curRecognizer = C), r++;
  }
  /**
   * get a recognizer by its event name.
   */
  get(g) {
    const { recognizers: I } = this;
    for (let C = 0; C < I.length; C++)
      if (I[C].options.event === g)
        return I[C];
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(g) {
    if (Array.isArray(g)) {
      for (const C of g)
        this.add(C);
      return this;
    }
    const I = this.get(g.options.event);
    return I && this.remove(I), this.recognizers.push(g), g.manager = this, this.touchAction.update(), g;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(g) {
    if (Array.isArray(g)) {
      for (const C of g)
        this.remove(C);
      return this;
    }
    const I = typeof g == "string" ? this.get(g) : g;
    if (I) {
      const { recognizers: C } = this, t = C.indexOf(I);
      t !== -1 && (C.splice(t, 1), this.touchAction.update());
    }
    return this;
  }
  /**
   * bind event
   */
  on(g, I) {
    if (!g || !I)
      return;
    const { handlers: C } = this;
    for (const t of Pp(g))
      C[t] = C[t] || [], C[t].push(I);
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(g, I) {
    if (!g)
      return;
    const { handlers: C } = this;
    for (const t of Pp(g))
      I ? C[t] && C[t].splice(C[t].indexOf(I), 1) : delete C[t];
  }
  /**
   * emit event to the listeners
   */
  emit(g, I) {
    const C = this.handlers[g] && this.handlers[g].slice();
    if (!C || !C.length)
      return;
    const t = I;
    t.type = g, t.preventDefault = function() {
      I.srcEvent.preventDefault();
    };
    let s = 0;
    for (; s < C.length; )
      C[s](t), s++;
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(!1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(g) {
    const { element: I } = this;
    if (I) {
      for (const [C, t] of Object.entries(this.options.cssProps)) {
        const s = x_(I.style, C);
        g ? (this.oldCssProps[s] = I.style[s], I.style[s] = t) : I.style[s] = this.oldCssProps[s] || "";
      }
      g || (this.oldCssProps = {});
    }
  }
}
let F_ = 1;
function X_() {
  return F_++;
}
function QP(A) {
  return A & SI.Cancelled ? "cancel" : A & SI.Ended ? "end" : A & SI.Changed ? "move" : A & SI.Began ? "start" : "";
}
class cv {
  constructor(g) {
    this.options = g, this.id = X_(), this.state = SI.Possible, this.simultaneous = {}, this.requireFail = [];
  }
  /**
   * set options
   */
  set(g) {
    return Object.assign(this.options, g), this.manager.touchAction.update(), this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(g) {
    if (Array.isArray(g)) {
      for (const t of g)
        this.recognizeWith(t);
      return this;
    }
    let I;
    if (typeof g == "string") {
      if (I = this.manager.get(g), !I)
        throw new Error(`Cannot find recognizer ${g}`);
    } else
      I = g;
    const { simultaneous: C } = this;
    return C[I.id] || (C[I.id] = I, I.recognizeWith(this)), this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(g) {
    if (Array.isArray(g)) {
      for (const C of g)
        this.dropRecognizeWith(C);
      return this;
    }
    let I;
    return typeof g == "string" ? I = this.manager.get(g) : I = g, I && delete this.simultaneous[I.id], this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(g) {
    if (Array.isArray(g)) {
      for (const t of g)
        this.requireFailure(t);
      return this;
    }
    let I;
    if (typeof g == "string") {
      if (I = this.manager.get(g), !I)
        throw new Error(`Cannot find recognizer ${g}`);
    } else
      I = g;
    const { requireFail: C } = this;
    return C.indexOf(I) === -1 && (C.push(I), I.requireFailure(this)), this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(g) {
    if (Array.isArray(g)) {
      for (const C of g)
        this.dropRequireFailure(C);
      return this;
    }
    let I;
    if (typeof g == "string" ? I = this.manager.get(g) : I = g, I) {
      const C = this.requireFail.indexOf(I);
      C > -1 && this.requireFail.splice(C, 1);
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return !!this.requireFail.find((g) => g.options.enable);
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(g) {
    return !!this.simultaneous[g.id];
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(g) {
    if (!g)
      return;
    const { state: I } = this;
    I < SI.Ended && this.manager.emit(this.options.event + QP(I), g), this.manager.emit(this.options.event, g), g.additionalEvent && this.manager.emit(g.additionalEvent, g), I >= SI.Ended && this.manager.emit(this.options.event + QP(I), g);
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(g) {
    this.canEmit() ? this.emit(g) : this.state = SI.Failed;
  }
  /**
   * can we emit?
   */
  canEmit() {
    let g = 0;
    for (; g < this.requireFail.length; ) {
      if (!(this.requireFail[g].state & (SI.Failed | SI.Possible)))
        return !1;
      g++;
    }
    return !0;
  }
  /**
   * update the recognizer
   */
  recognize(g) {
    const I = { ...g };
    if (!this.options.enable) {
      this.reset(), this.state = SI.Failed;
      return;
    }
    this.state & (SI.Recognized | SI.Cancelled | SI.Failed) && (this.state = SI.Possible), this.state = this.process(I), this.state & (SI.Began | SI.Changed | SI.Ended | SI.Cancelled) && this.tryEmit(I);
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
}
class uv extends cv {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(g) {
    const I = this.options.pointers;
    return I === 0 || g.pointers.length === I;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(g) {
    const { state: I } = this, { eventType: C } = g, t = I & (SI.Began | SI.Changed), s = this.attrTest(g);
    return t && (C & fC.Cancel || !s) ? I | SI.Cancelled : t || s ? C & fC.End ? I | SI.Ended : I & SI.Began ? I | SI.Changed : SI.Began : SI.Failed;
  }
}
class zP extends cv {
  constructor(g = {}) {
    super({
      enable: !0,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...g
    }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
  }
  getTouchAction() {
    return [fS];
  }
  process(g) {
    const { options: I } = this, C = g.pointers.length === I.pointers, t = g.distance < I.threshold, s = g.deltaTime < I.time;
    if (this.reset(), g.eventType & fC.Start && this.count === 0)
      return this.failTimeout();
    if (t && s && C) {
      if (g.eventType !== fC.End)
        return this.failTimeout();
      const r = this.pTime ? g.timeStamp - this.pTime < I.interval : !0, l = !this.pCenter || av(this.pCenter, g.center) < I.posThreshold;
      if (this.pTime = g.timeStamp, this.pCenter = g.center, !l || !r ? this.count = 1 : this.count += 1, this._input = g, this.count % I.taps === 0)
        return this.hasRequireFailures() ? (this._timer = setTimeout(() => {
          this.state = SI.Recognized, this.tryEmit(this._input);
        }, I.interval), SI.Began) : SI.Recognized;
    }
    return SI.Failed;
  }
  failTimeout() {
    return this._timer = setTimeout(() => {
      this.state = SI.Failed;
    }, this.options.interval), SI.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(g) {
    this.state === SI.Recognized && (g.tapCount = this.count, this.manager.emit(this.options.event, g));
  }
}
const Q_ = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
class JP extends uv {
  constructor(g = {}) {
    super({
      enable: !0,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: YC.All,
      ...g
    }), this.pX = null, this.pY = null;
  }
  getTouchAction() {
    const { options: { direction: g } } = this, I = [];
    return g & YC.Horizontal && I.push(yS), g & YC.Vertical && I.push(hS), I;
  }
  getEventNames() {
    return Q_.map((g) => this.options.event + g);
  }
  directionTest(g) {
    const { options: I } = this;
    let C = !0, { distance: t } = g, { direction: s } = g;
    const r = g.deltaX, l = g.deltaY;
    return s & I.direction || (I.direction & YC.Horizontal ? (s = r === 0 ? YC.None : r < 0 ? YC.Left : YC.Right, C = r !== this.pX, t = Math.abs(g.deltaX)) : (s = l === 0 ? YC.None : l < 0 ? YC.Up : YC.Down, C = l !== this.pY, t = Math.abs(g.deltaY))), g.direction = s, C && t > I.threshold && !!(s & I.direction);
  }
  attrTest(g) {
    return super.attrTest(g) && (!!(this.state & SI.Began) || !(this.state & SI.Began) && this.directionTest(g));
  }
  emit(g) {
    this.pX = g.deltaX, this.pY = g.deltaY;
    const I = YC[g.direction].toLowerCase();
    I && (g.additionalEvent = this.options.event + I), super.emit(g);
  }
}
const z_ = ["", "start", "move", "end", "cancel", "in", "out"];
class J_ extends uv {
  constructor(g = {}) {
    super({
      enable: !0,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...g
    });
  }
  getTouchAction() {
    return [op];
  }
  getEventNames() {
    return z_.map((g) => this.options.event + g);
  }
  attrTest(g) {
    return super.attrTest(g) && (Math.abs(g.scale - 1) > this.options.threshold || !!(this.state & SI.Began));
  }
  emit(g) {
    if (g.scale !== 1) {
      const I = g.scale < 1 ? "in" : "out";
      g.additionalEvent = this.options.event + I;
    }
    super.emit(g);
  }
}
let g0 = class {
  constructor(g, I, C) {
    this.element = g, this.callback = I, this.options = C;
  }
};
const L_ = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", q_ = L_.indexOf("firefox") !== -1, LP = 4.000244140625, $_ = 40, g9 = 0.25;
class I9 extends g0 {
  constructor(g, I, C) {
    super(g, I, { enable: !0, ...C }), this.handleEvent = (t) => {
      if (!this.options.enable)
        return;
      let s = t.deltaY;
      globalThis.WheelEvent && (q_ && t.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (s /= globalThis.devicePixelRatio), t.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (s *= $_)), s !== 0 && s % LP === 0 && (s = Math.floor(s / LP)), t.shiftKey && s && (s = s * g9), this.callback({
        type: "wheel",
        center: {
          x: t.clientX,
          y: t.clientY
        },
        delta: -s,
        srcEvent: t,
        pointerType: "mouse",
        target: t.target
      });
    }, g.addEventListener("wheel", this.handleEvent, { passive: !1 });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(g, I) {
    g === "wheel" && (this.options.enable = I);
  }
}
const qP = [
  "mousedown",
  "mousemove",
  "mouseup",
  "mouseover",
  "mouseout",
  "mouseleave"
];
class A9 extends g0 {
  constructor(g, I, C) {
    super(g, I, { enable: !0, ...C }), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const { enable: t } = this.options;
    this.enableMoveEvent = t, this.enableLeaveEvent = t, this.enableEnterEvent = t, this.enableOutEvent = t, this.enableOverEvent = t, qP.forEach((s) => g.addEventListener(s, this.handleEvent));
  }
  destroy() {
    qP.forEach((g) => this.element.removeEventListener(g, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(g, I) {
    switch (g) {
      case "pointermove":
        this.enableMoveEvent = I;
        break;
      case "pointerover":
        this.enableOverEvent = I;
        break;
      case "pointerout":
        this.enableOutEvent = I;
        break;
      case "pointerenter":
        this.enableEnterEvent = I;
        break;
      case "pointerleave":
        this.enableLeaveEvent = I;
        break;
    }
  }
  handleOverEvent(g) {
    this.enableOverEvent && g.type === "mouseover" && this._emit("pointerover", g);
  }
  handleOutEvent(g) {
    this.enableOutEvent && g.type === "mouseout" && this._emit("pointerout", g);
  }
  handleEnterEvent(g) {
    this.enableEnterEvent && g.type === "mouseenter" && this._emit("pointerenter", g);
  }
  handleLeaveEvent(g) {
    this.enableLeaveEvent && g.type === "mouseleave" && this._emit("pointerleave", g);
  }
  handleMoveEvent(g) {
    if (this.enableMoveEvent)
      switch (g.type) {
        case "mousedown":
          g.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          g.buttons === 0 && (this.pressed = !1), this.pressed || this._emit("pointermove", g);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(g, I) {
    this.callback({
      type: g,
      center: {
        x: I.clientX,
        y: I.clientY
      },
      srcEvent: I,
      pointerType: "mouse",
      target: I.target
    });
  }
}
const $P = ["keydown", "keyup"];
class C9 extends g0 {
  constructor(g, I, C) {
    super(g, I, { enable: !0, tabIndex: 0, ...C }), this.handleEvent = (t) => {
      const s = t.target || t.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && t.type === "keydown" && this.callback({
        type: "keydown",
        srcEvent: t,
        key: t.key,
        target: t.target
      }), this.enableUpEvent && t.type === "keyup" && this.callback({
        type: "keyup",
        srcEvent: t,
        key: t.key,
        target: t.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, g.tabIndex = this.options.tabIndex, g.style.outline = "none", $P.forEach((t) => g.addEventListener(t, this.handleEvent));
  }
  destroy() {
    $P.forEach((g) => this.element.removeEventListener(g, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(g, I) {
    g === "keydown" && (this.enableDownEvent = I), g === "keyup" && (this.enableUpEvent = I);
  }
}
class e9 extends g0 {
  constructor(g, I, C) {
    super(g, I, C), this.handleEvent = (t) => {
      this.options.enable && this.callback({
        type: "contextmenu",
        center: {
          x: t.clientX,
          y: t.clientY
        },
        srcEvent: t,
        pointerType: "mouse",
        target: t.target
      });
    }, g.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(g, I) {
    g === "contextmenu" && (this.options.enable = I);
  }
}
const g1 = 1, DS = 2, I1 = 4, t9 = {
  pointerdown: g1,
  pointermove: DS,
  pointerup: I1,
  mousedown: g1,
  mousemove: DS,
  mouseup: I1
}, i9 = 0, n9 = 1, s9 = 2, o9 = 1, a9 = 2, r9 = 4;
function l9(A) {
  const g = t9[A.srcEvent.type];
  if (!g)
    return null;
  const { buttons: I, button: C } = A.srcEvent;
  let t = !1, s = !1, r = !1;
  return g === DS ? (t = !!(I & o9), s = !!(I & r9), r = !!(I & a9)) : (t = C === i9, s = C === n9, r = C === s9), { leftButton: t, middleButton: s, rightButton: r };
}
function c9(A, g) {
  const I = A.center;
  if (!I)
    return null;
  const C = g.getBoundingClientRect(), t = C.width / g.offsetWidth || 1, s = C.height / g.offsetHeight || 1, r = {
    x: (I.x - C.left - g.clientLeft) / t,
    y: (I.y - C.top - g.clientTop) / s
  };
  return { center: I, offsetCenter: r };
}
const u9 = {
  srcElement: "root",
  priority: 0
};
class d9 {
  constructor(g, I) {
    this.handleEvent = (C) => {
      if (this.isEmpty())
        return;
      const t = this._normalizeEvent(C);
      let s = C.srcEvent.target;
      for (; s && s !== t.rootElement; ) {
        if (this._emit(t, s), t.handled)
          return;
        s = s.parentNode;
      }
      this._emit(t, "root");
    }, this.eventManager = g, this.recognizerName = I, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(g, I, C, t = !1, s = !1) {
    const { handlers: r, handlersByElement: l } = this, d = { ...u9, ...C };
    let h = l.get(d.srcElement);
    h || (h = [], l.set(d.srcElement, h));
    const D = {
      type: g,
      handler: I,
      srcElement: d.srcElement,
      priority: d.priority
    };
    t && (D.once = !0), s && (D.passive = !0), r.push(D), this._active = this._active || !D.passive;
    let w = h.length - 1;
    for (; w >= 0 && !(h[w].priority >= D.priority); )
      w--;
    h.splice(w + 1, 0, D);
  }
  remove(g, I) {
    const { handlers: C, handlersByElement: t } = this;
    for (let s = C.length - 1; s >= 0; s--) {
      const r = C[s];
      if (r.type === g && r.handler === I) {
        C.splice(s, 1);
        const l = t.get(r.srcElement);
        l.splice(l.indexOf(r), 1), l.length === 0 && t.delete(r.srcElement);
      }
    }
    this._active = C.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(g, I) {
    const C = this.handlersByElement.get(I);
    if (C) {
      let t = !1;
      const s = () => {
        g.handled = !0;
      }, r = () => {
        g.handled = !0, t = !0;
      }, l = [];
      for (let d = 0; d < C.length; d++) {
        const { type: h, handler: D, once: w } = C[d];
        if (D({
          ...g,
          type: h,
          stopPropagation: s,
          stopImmediatePropagation: r
        }), w && l.push(C[d]), t)
          break;
      }
      for (let d = 0; d < l.length; d++) {
        const { type: h, handler: D } = l[d];
        this.remove(h, D);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(g) {
    const I = this.eventManager.getElement();
    return {
      ...g,
      ...l9(g),
      ...c9(g, I),
      preventDefault: () => {
        g.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: I
    };
  }
}
function f9(A) {
  if ("recognizer" in A)
    return A;
  let g;
  const I = Array.isArray(A) ? [...A] : [A];
  if (typeof I[0] == "function") {
    const C = I.shift(), t = I.shift() || {};
    g = new C(t);
  } else
    g = I.shift();
  return {
    recognizer: g,
    recognizeWith: typeof I[0] == "string" ? [I[0]] : I[0],
    requireFailure: typeof I[1] == "string" ? [I[1]] : I[1]
  };
}
class h9 {
  constructor(g = null, I = {}) {
    if (this._onBasicInput = (C) => {
      this.manager.emit(C.srcEvent.type, C);
    }, this._onOtherEvent = (C) => {
      this.manager.emit(C.type, C);
    }, this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...I
    }, this.events = /* @__PURE__ */ new Map(), this.element = g, !!g) {
      this.manager = new U_(g, this.options);
      for (const C of this.options.recognizers) {
        const { recognizer: t, recognizeWith: s, requireFailure: r } = f9(C);
        this.manager.add(t), s && t.recognizeWith(s), r && t.requireFailure(r);
      }
      this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new I9(g, this._onOtherEvent, {
        enable: !1
      }), this.moveInput = new A9(g, this._onOtherEvent, {
        enable: !1
      }), this.keyInput = new C9(g, this._onOtherEvent, {
        enable: !1,
        tabIndex: I.tabIndex
      }), this.contextmenuInput = new e9(g, this._onOtherEvent, {
        enable: !1
      }), this.on(this.options.events);
    }
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
  }
  /** Register an event handler function to be called on `event` */
  on(g, I, C) {
    this._addEventHandler(g, I, C, !1);
  }
  once(g, I, C) {
    this._addEventHandler(g, I, C, !0);
  }
  watch(g, I, C) {
    this._addEventHandler(g, I, C, !1, !0);
  }
  off(g, I) {
    this._removeEventHandler(g, I);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(g, I) {
    const { manager: C } = this;
    if (!C)
      return;
    const t = C.get(g);
    t && (t.set({ enable: I }), C.touchAction.update()), this.wheelInput?.enableEventType(g, I), this.moveInput?.enableEventType(g, I), this.keyInput?.enableEventType(g, I), this.contextmenuInput?.enableEventType(g, I);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(g, I, C, t, s) {
    if (typeof g != "string") {
      C = I;
      for (const [h, D] of Object.entries(g))
        this._addEventHandler(h, D, C, t, s);
      return;
    }
    const { manager: r, events: l } = this;
    if (!r)
      return;
    let d = l.get(g);
    if (!d) {
      const h = this._getRecognizerName(g) || g;
      d = new d9(this, h), l.set(g, d), r && r.on(g, d.handleEvent);
    }
    d.add(g, I, C, t, s), d.isEmpty() || this._toggleRecognizer(d.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(g, I) {
    if (typeof g != "string") {
      for (const [s, r] of Object.entries(g))
        this._removeEventHandler(s, r);
      return;
    }
    const { events: C } = this, t = C.get(g);
    if (t && (t.remove(g, I), t.isEmpty())) {
      const { recognizerName: s } = t;
      let r = !1;
      for (const l of C.values())
        if (l.recognizerName === s && !l.isEmpty()) {
          r = !0;
          break;
        }
      r || this._toggleRecognizer(s, !1);
    }
  }
  _getRecognizerName(g) {
    return this.manager.recognizers.find((I) => I.getEventNames().includes(g))?.options.event;
  }
}
const gA = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(gA, "IDENTITY", {
  get: () => (uA.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const Yi = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, wc = {
  common: 0,
  meters: 1,
  pixels: 2
}, MS = {
  click: "onClick",
  dblclick: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
}, A1 = {
  multipan: [JP, { threshold: 10, direction: YC.Vertical, pointers: 2 }],
  pinch: [J_, {}, null, ["multipan"]],
  pan: [JP, { threshold: 1 }, ["pinch"], ["multipan"]],
  dblclick: [zP, { event: "dblclick", taps: 2 }],
  click: [zP, { event: "click" }, null, ["dblclick"]]
};
function y9(A, g) {
  if (A === g)
    return !0;
  if (Array.isArray(A)) {
    const I = A.length;
    if (!g || g.length !== I)
      return !1;
    for (let C = 0; C < I; C++)
      if (A[C] !== g[C])
        return !1;
    return !0;
  }
  return !1;
}
function GM(A) {
  let g = {}, I;
  return (C) => {
    for (const t in C)
      if (!y9(C[t], g[t])) {
        I = A(C), g = C;
        break;
      }
    return I;
  };
}
const C1 = [0, 0, 0, 0], D9 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], dv = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], M9 = [0, 0, 0], fv = [0, 0, 0], w9 = GM(m9);
function hv(A, g, I = fv) {
  I.length < 3 && (I = [I[0], I[1], 0]);
  let C = I, t, s = !0;
  switch (g === gA.LNGLAT_OFFSETS || g === gA.METER_OFFSETS ? t = I : t = A.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(A.longitude), Math.fround(A.latitude), 0]
  ) : null, A.projectionMode) {
    case Yi.WEB_MERCATOR:
      (g === gA.LNGLAT || g === gA.CARTESIAN) && (t = [0, 0, 0], s = !1);
      break;
    case Yi.WEB_MERCATOR_AUTO_OFFSET:
      g === gA.LNGLAT ? C = t : g === gA.CARTESIAN && (C = [
        Math.fround(A.center[0]),
        Math.fround(A.center[1]),
        0
      ], t = A.unprojectPosition(C), C[0] -= I[0], C[1] -= I[1], C[2] -= I[2]);
      break;
    case Yi.IDENTITY:
      C = A.position.map(Math.fround), C[2] = C[2] || 0;
      break;
    case Yi.GLOBE:
      s = !1, t = null;
      break;
    default:
      s = !1;
  }
  return { geospatialOrigin: t, shaderCoordinateOrigin: C, offsetMode: s };
}
function B9(A, g, I) {
  const { viewMatrixUncentered: C, projectionMatrix: t } = A;
  let { viewMatrix: s, viewProjectionMatrix: r } = A, l = C1, d = C1, h = A.cameraPosition;
  const { geospatialOrigin: D, shaderCoordinateOrigin: w, offsetMode: p } = hv(A, g, I);
  return p && (d = A.projectPosition(D || w), h = [
    h[0] - d[0],
    h[1] - d[1],
    h[2] - d[2]
  ], d[3] = 1, l = SM([], d, r), s = C || s, r = dc([], t, s), r = dc([], r, D9)), {
    viewMatrix: s,
    viewProjectionMatrix: r,
    projectionCenter: l,
    originCommon: d,
    cameraPosCommon: h,
    shaderCoordinateOrigin: w,
    geospatialOrigin: D
  };
}
function p9({
  viewport: A,
  devicePixelRatio: g = 1,
  modelMatrix: I = null,
  // Match Layer.defaultProps
  coordinateSystem: C = gA.DEFAULT,
  coordinateOrigin: t = fv,
  autoWrapLongitude: s = !1
}) {
  C === gA.DEFAULT && (C = A.isGeospatial ? gA.LNGLAT : gA.CARTESIAN);
  const r = w9({
    viewport: A,
    devicePixelRatio: g,
    coordinateSystem: C,
    coordinateOrigin: t
  });
  return r.wrapLongitude = s, r.modelMatrix = I || dv, r;
}
function m9({ viewport: A, devicePixelRatio: g, coordinateSystem: I, coordinateOrigin: C }) {
  const { projectionCenter: t, viewProjectionMatrix: s, originCommon: r, cameraPosCommon: l, shaderCoordinateOrigin: d, geospatialOrigin: h } = B9(A, I, C), D = A.getDistanceScales(), w = [
    A.width * g,
    A.height * g
  ], p = SM([], [0, 0, -A.focalDistance, 1], A.projectionMatrix)[3] || 1, b = {
    // Projection mode values
    coordinateSystem: I,
    projectionMode: A.projectionMode,
    coordinateOrigin: d,
    commonOrigin: r.slice(0, 3),
    center: t,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: !!A._pseudoMeters,
    // Screen size
    viewportSize: w,
    devicePixelRatio: g,
    focalDistance: p,
    commonUnitsPerMeter: D.unitsPerMeter,
    commonUnitsPerWorldUnit: D.unitsPerMeter,
    commonUnitsPerWorldUnit2: M9,
    scale: A.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: !1,
    viewProjectionMatrix: s,
    modelMatrix: dv,
    // This is for lighting calculations
    cameraPosition: l
  };
  if (h) {
    const S = A.getDistanceScales(h);
    switch (I) {
      case gA.METER_OFFSETS:
        b.commonUnitsPerWorldUnit = S.unitsPerMeter, b.commonUnitsPerWorldUnit2 = S.unitsPerMeter2;
        break;
      case gA.LNGLAT:
      case gA.LNGLAT_OFFSETS:
        A._pseudoMeters || (b.commonUnitsPerMeter = S.unitsPerMeter), b.commonUnitsPerWorldUnit = S.unitsPerDegree, b.commonUnitsPerWorldUnit2 = S.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case gA.CARTESIAN:
        b.commonUnitsPerWorldUnit = [1, 1, S.unitsPerMeter[2]], b.commonUnitsPerWorldUnit2 = [0, 0, S.unitsPerMeter2[2]];
        break;
    }
  }
  return b;
}
const b9 = Object.keys(gA).map((A) => `const COORDINATE_SYSTEM_${A}: i32 = ${gA[A]};`).join(""), S9 = Object.keys(Yi).map((A) => `const PROJECTION_MODE_${A}: i32 = ${Yi[A]};`).join(""), G9 = Object.keys(wc).map((A) => `const UNIT_${A.toUpperCase()}: i32 = ${wc[A]};`).join(""), K9 = (
  /* wgsl */
  `${b9}
${S9}
${G9}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
), T9 = (
  /* wgsl */
  `${K9}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the zaxis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
), Y9 = Object.keys(gA).map((A) => `const int COORDINATE_SYSTEM_${A} = ${gA[A]};`).join(""), P9 = Object.keys(Yi).map((A) => `const int PROJECTION_MODE_${A} = ${Yi[A]};`).join(""), Z9 = Object.keys(wc).map((A) => `const int UNIT_${A.toUpperCase()} = ${wc[A]};`).join(""), j9 = (
  /* glsl */
  `${Y9}
${P9}
${Z9}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`
), v9 = {};
function H9(A = v9) {
  return "viewport" in A ? p9(A) : {};
}
const PG = {
  name: "project",
  dependencies: [e_, sv],
  source: T9,
  vs: j9,
  getUniforms: H9,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
}, E9 = (
  /* wgsl */
  `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
), R9 = (
  /* glsl */
  `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
), yv = {
  name: "project32",
  dependencies: [PG],
  source: E9,
  vs: R9
};
function O9() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Mf(A, g) {
  const I = SM([], g, A);
  return Qx(I, I, 1 / I[3]), I;
}
function e1(A, g) {
  const I = A % g;
  return I < 0 ? g + I : I;
}
function wS(A, g, I) {
  return A < g ? g : A > I ? I : A;
}
function N9(A) {
  return Math.log(A) * Math.LOG2E;
}
const ZG = Math.log2 || N9;
function Zo(A, g) {
  if (!A)
    throw new Error(g || "@math.gl/web-mercator: assertion failed.");
}
const mn = Math.PI, Dv = mn / 4, ji = mn / 180, BS = 180 / mn, Kf = 512, Zp = 4003e4, NB = 85.051129, k9 = 1.5;
function W9(A) {
  return ZG(A);
}
function jp(A) {
  const [g, I] = A;
  Zo(Number.isFinite(g)), Zo(Number.isFinite(I) && I >= -90 && I <= 90, "invalid latitude");
  const C = g * ji, t = I * ji, s = Kf * (C + mn) / (2 * mn), r = Kf * (mn + Math.log(Math.tan(Dv + t * 0.5))) / (2 * mn);
  return [s, r];
}
function Tf(A) {
  const [g, I] = A, C = g / Kf * (2 * mn) - mn, t = 2 * (Math.atan(Math.exp(I / Kf * (2 * mn) - mn)) - Dv);
  return [C * BS, t * BS];
}
function V9(A) {
  const { latitude: g } = A;
  Zo(Number.isFinite(g));
  const I = Math.cos(g * ji);
  return W9(Zp * I) - 9;
}
function bb(A) {
  const g = Math.cos(A * ji);
  return Kf / Zp / g;
}
function pS(A) {
  const { latitude: g, longitude: I, highPrecision: C = !1 } = A;
  Zo(Number.isFinite(g) && Number.isFinite(I));
  const t = Kf, s = Math.cos(g * ji), r = t / 360, l = r / s, d = t / Zp / s, h = {
    unitsPerMeter: [d, d, d],
    metersPerUnit: [1 / d, 1 / d, 1 / d],
    unitsPerDegree: [r, l, d],
    degreesPerUnit: [1 / r, 1 / l, 1 / d]
  };
  if (C) {
    const D = ji * Math.tan(g * ji) / s, w = r * D / 2, p = t / Zp * D, b = p / l * d;
    h.unitsPerDegree2 = [0, w, p], h.unitsPerMeter2 = [b, 0, b];
  }
  return h;
}
function Mv(A, g) {
  const [I, C, t] = A, [s, r, l] = g, { unitsPerMeter: d, unitsPerMeter2: h } = pS({
    longitude: I,
    latitude: C,
    highPrecision: !0
  }), D = jp(A);
  D[0] += s * (d[0] + h[0] * r), D[1] += r * (d[1] + h[1] * r);
  const w = Tf(D), p = (t || 0) + (l || 0);
  return Number.isFinite(t) || Number.isFinite(l) ? [w[0], w[1], p] : w;
}
function x9(A) {
  const {
    // Viewport props
    height: g,
    pitch: I,
    bearing: C,
    altitude: t,
    // Pre-calculated parameters
    scale: s,
    center: r
  } = A, l = O9();
  Yp(l, l, [0, 0, -t]), Av(l, l, -I * ji), Cv(l, l, C * ji);
  const d = s / g;
  return YG(l, l, [d, d, d]), r && Yp(l, l, mx([], r)), l;
}
function _9(A) {
  const { width: g, height: I, altitude: C, pitch: t = 0, offset: s, center: r, scale: l, nearZMultiplier: d = 1, farZMultiplier: h = 1 } = A;
  let { fovy: D = vp(k9) } = A;
  C !== void 0 && (D = vp(C));
  const w = D * ji, p = t * ji, b = jG(D);
  let S = b;
  r && (S += r[2] * l / Math.cos(p) / I);
  const K = w * (0.5 + (s ? s[1] : 0) / I), Y = Math.sin(K) * S / Math.sin(wS(Math.PI / 2 - p - K, 0.01, Math.PI - 0.01)), T = Math.sin(p) * Y + S, E = S * 10, H = Math.min(T * h, E);
  return {
    fov: w,
    aspect: g / I,
    focalDistance: b,
    near: d,
    far: H
  };
}
function vp(A) {
  return 2 * Math.atan(0.5 / A) * BS;
}
function jG(A) {
  return 0.5 / Math.tan(0.5 * A * ji);
}
function wv(A, g) {
  const [I, C, t = 0] = A;
  return Zo(Number.isFinite(I) && Number.isFinite(C) && Number.isFinite(t)), Mf(g, [I, C, t, 1]);
}
function KM(A, g, I = 0) {
  const [C, t, s] = A;
  if (Zo(Number.isFinite(C) && Number.isFinite(t), "invalid pixel coordinate"), Number.isFinite(s))
    return Mf(g, [C, t, s, 1]);
  const r = Mf(g, [C, t, 0, 1]), l = Mf(g, [C, t, 1, 1]), d = r[2], h = l[2], D = d === h ? 0 : ((I || 0) - d) / (h - d);
  return $j([], r, l, D);
}
function U9(A) {
  const {
    width: g,
    height: I,
    bounds: C,
    minExtent: t = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: s = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: r = [0, 0]
  } = A, [[l, d], [h, D]] = C, w = F9(A.padding), p = jp([l, wS(D, -NB, NB)]), b = jp([h, wS(d, -NB, NB)]), S = [
    Math.max(Math.abs(b[0] - p[0]), t),
    Math.max(Math.abs(b[1] - p[1]), t)
  ], K = [
    g - w.left - w.right - Math.abs(r[0]) * 2,
    I - w.top - w.bottom - Math.abs(r[1]) * 2
  ];
  Zo(K[0] > 0 && K[1] > 0);
  const Y = K[0] / S[0], T = K[1] / S[1], E = (w.right - w.left) / 2 / Y, H = (w.top - w.bottom) / 2 / T, R = [(b[0] + p[0]) / 2 + E, (b[1] + p[1]) / 2 + H], x = Tf(R), U = Math.min(s, ZG(Math.abs(Math.min(Y, T))));
  return Zo(Number.isFinite(U)), {
    longitude: x[0],
    latitude: x[1],
    zoom: U
  };
}
function F9(A = 0) {
  return typeof A == "number" ? {
    top: A,
    bottom: A,
    left: A,
    right: A
  } : (Zo(Number.isFinite(A.top) && Number.isFinite(A.bottom) && Number.isFinite(A.left) && Number.isFinite(A.right)), A);
}
const t1 = Math.PI / 180;
function X9(A, g = 0) {
  const { width: I, height: C, unproject: t } = A, s = { targetZ: g }, r = t([0, C], s), l = t([I, C], s);
  let d, h;
  const D = A.fovy ? 0.5 * A.fovy * t1 : Math.atan(0.5 / A.altitude), w = (90 - A.pitch) * t1;
  return D > w - 0.01 ? (d = i1(A, 0, g), h = i1(A, I, g)) : (d = t([0, 0], s), h = t([I, 0], s)), [r, l, h, d];
}
function i1(A, g, I) {
  const { pixelUnprojectionMatrix: C } = A, t = Mf(C, [g, 0, 1, 1]), s = Mf(C, [g, A.height, 1, 1]), l = (I * A.distanceScales.unitsPerMeter[2] - t[2]) / (s[2] - t[2]), d = $j([], t, s, l), h = Tf(d);
  return h.push(I), h;
}
const n1 = 512;
function Q9(A) {
  const { width: g, height: I, pitch: C = 0 } = A;
  let { longitude: t, latitude: s, zoom: r, bearing: l = 0 } = A;
  (t < -180 || t > 180) && (t = e1(t + 180, 360) - 180), (l < -180 || l > 180) && (l = e1(l + 180, 360) - 180);
  const d = ZG(I / n1);
  if (r <= d)
    r = d, s = 0;
  else {
    const h = I / 2 / Math.pow(2, r), D = Tf([0, h])[1];
    if (s < D)
      s = D;
    else {
      const w = Tf([0, n1 - h])[1];
      s > w && (s = w);
    }
  }
  return { width: g, height: I, longitude: t, latitude: s, zoom: r, pitch: C, bearing: l };
}
const Bv = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
), z9 = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
), J9 = `
${Bv}
${z9}
`, L9 = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
), q9 = `
${Bv}
${L9}
`, $9 = GM(eU), gU = GM(tU), IU = [0, 0, 0, 1], AU = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function CU(A, g) {
  const [I, C, t] = A, s = KM([I, C, t], g);
  return Number.isFinite(t) ? s : [s[0], s[1], 0];
}
function eU({ viewport: A, center: g }) {
  return new Jt(A.viewProjectionMatrix).invert().transform(g);
}
function tU({ viewport: A, shadowMatrices: g }) {
  const I = [], C = A.pixelUnprojectionMatrix, t = A.isGeospatial ? void 0 : 1, s = [
    [0, 0, t],
    // top left ground
    [A.width, 0, t],
    // top right ground
    [0, A.height, t],
    // bottom left ground
    [A.width, A.height, t],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [A.width, 0, -1],
    // top right near
    [0, A.height, -1],
    // bottom left near
    [A.width, A.height, -1]
    // bottom right near
  ].map((r) => (
    // @ts-expect-error z may be undefined
    CU(r, C)
  ));
  for (const r of g) {
    const l = r.clone().translate(new Ss(A.center).negate()), d = s.map((D) => l.transform(D)), h = new Jt().ortho({
      left: Math.min(...d.map((D) => D[0])),
      right: Math.max(...d.map((D) => D[0])),
      bottom: Math.min(...d.map((D) => D[1])),
      top: Math.max(...d.map((D) => D[1])),
      near: Math.min(...d.map((D) => -D[2])),
      far: Math.max(...d.map((D) => -D[2]))
    });
    I.push(h.multiplyRight(r));
  }
  return I;
}
function iU(A) {
  const { shadowEnabled: g = !0, project: I } = A;
  if (!g || !I || !A.shadowMatrices || !A.shadowMatrices.length)
    return {
      drawShadowMap: !1,
      useShadowMap: !1,
      shadow_uShadowMap0: A.dummyShadowMap,
      shadow_uShadowMap1: A.dummyShadowMap
    };
  const C = PG.getUniforms(I), t = $9({
    viewport: I.viewport,
    center: C.center
  }), s = [], r = gU({
    shadowMatrices: A.shadowMatrices,
    viewport: I.viewport
  }).slice();
  for (let d = 0; d < A.shadowMatrices.length; d++) {
    const h = r[d], D = h.clone().translate(new Ss(I.viewport.center).negate());
    C.coordinateSystem === gA.LNGLAT && C.projectionMode === Yi.WEB_MERCATOR ? (r[d] = D, s[d] = t) : (r[d] = h.clone().multiplyRight(AU), s[d] = D.transform(t));
  }
  const l = {
    drawShadowMap: !!A.drawToShadowMap,
    useShadowMap: A.shadowMaps ? A.shadowMaps.length > 0 : !1,
    color: A.shadowColor || IU,
    lightId: A.shadowLightId || 0,
    lightCount: A.shadowMatrices.length,
    shadow_uShadowMap0: A.dummyShadowMap,
    shadow_uShadowMap1: A.dummyShadowMap
  };
  for (let d = 0; d < r.length; d++)
    l[`viewProjectionMatrix${d}`] = r[d], l[`projectCenter${d}`] = s[d];
  for (let d = 0; d < 2; d++)
    l[`shadow_uShadowMap${d}`] = A.shadowMaps && A.shadowMaps[d] || A.dummyShadowMap;
  return l;
}
const s1 = {
  name: "shadow",
  dependencies: [PG],
  vs: J9,
  fs: q9,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: iU,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
}, pv = {
  ...NP,
  defaultUniforms: { ...NP.defaultUniforms, useFloatColors: !1 },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, nU = [sv], sU = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
], oU = [
  // Not yet supported
];
function aU(A) {
  const g = lc.getDefaultShaderAssembler();
  for (const C of nU)
    g.addDefaultModule(C);
  const I = A === "glsl" ? sU : oU;
  for (const C of I)
    g.addShaderHook(C);
  return g;
}
const rU = [255, 255, 255], lU = 1;
let cU = 0;
class uU {
  constructor(g = {}) {
    this.type = "ambient";
    const { color: I = rU } = g, { intensity: C = lU } = g;
    this.id = g.id || `ambient-${cU++}`, this.color = I, this.intensity = C;
  }
}
const dU = [255, 255, 255], fU = 1, hU = [0, 0, -1];
let yU = 0;
class o1 {
  constructor(g = {}) {
    this.type = "directional";
    const { color: I = dU } = g, { intensity: C = fU } = g, { direction: t = hU } = g, { _shadow: s = !1 } = g;
    this.id = g.id || `directional-${yU++}`, this.color = I, this.intensity = C, this.type = "directional", this.direction = new Ss(t).normalize().toArray(), this.shadow = s;
  }
  getProjectedLight(g) {
    return this;
  }
}
class DU {
  /** Create a new Pass instance */
  constructor(g, I = { id: "pass" }) {
    const { id: C } = I;
    this.id = C, this.device = g, this.props = { ...I };
  }
  setProps(g) {
    Object.assign(this.props, g);
  }
  render(g) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class vG extends DU {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(g) {
    const [I, C] = this.device.canvasContext.getDrawingBufferSize(), t = g.clearCanvas ?? !0, s = g.clearColor ?? (t ? [0, 0, 0, 0] : !1), r = t ? 1 : !1, l = t ? 0 : !1, d = g.colorMask ?? 15, h = { viewport: [0, 0, I, C] };
    g.colorMask && (h.colorMask = d), g.scissorRect && (h.scissorRect = g.scissorRect);
    const D = this.device.beginRenderPass({
      framebuffer: g.target,
      parameters: h,
      clearColor: s,
      clearDepth: r,
      clearStencil: l
    });
    try {
      return this._drawLayers(D, g);
    } finally {
      D.end(), this.device.submit();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(g, I) {
    const { target: C, shaderModuleProps: t, viewports: s, views: r, onViewportActive: l, clearStack: d = !0 } = I;
    I.pass = I.pass || "unknown", d && (this._lastRenderIndex = -1);
    const h = [];
    for (const D of s) {
      const w = r && r[D.id];
      l?.(D);
      const p = this._getDrawLayerParams(D, I), b = D.subViewports || [D];
      for (const S of b) {
        const K = this._drawLayersInViewport(g, {
          target: C,
          shaderModuleProps: t,
          viewport: S,
          view: w,
          pass: I.pass,
          layers: I.layers
        }, p);
        h.push(K);
      }
    }
    return h;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(g, { layers: I, pass: C, isPicking: t = !1, layerFilter: s, cullRect: r, effects: l, shaderModuleProps: d }, h = !1) {
    const D = [], w = mv(this._lastRenderIndex + 1), p = {
      layer: I[0],
      viewport: g,
      isPicking: t,
      renderPass: C,
      cullRect: r
    }, b = {};
    for (let S = 0; S < I.length; S++) {
      const K = I[S], Y = this._shouldDrawLayer(K, p, s, b), T = { shouldDrawLayer: Y };
      Y && !h && (T.shouldDrawLayer = !0, T.layerRenderIndex = w(K, Y), T.shaderModuleProps = this._getShaderModuleProps(K, l, C, d), T.layerParameters = {
        ...K.context.deck?.props.parameters,
        ...this.getLayerParameters(K, S, g)
      }), D[S] = T;
    }
    return D;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(g, { layers: I, shaderModuleProps: C, pass: t, target: s, viewport: r, view: l }, d) {
    const h = MU(this.device, {
      shaderModuleProps: C,
      target: s,
      viewport: r
    });
    if (l && l.props.clear) {
      const w = l.props.clear === !0 ? { color: !0, depth: !0 } : l.props.clear;
      this.device.beginRenderPass({
        framebuffer: s,
        parameters: {
          viewport: h,
          scissorRect: h
        },
        clearColor: w.color ? [0, 0, 0, 0] : !1,
        clearDepth: w.depth ? 1 : !1
      }).end();
    }
    const D = {
      totalCount: I.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    g.setParameters({ viewport: h });
    for (let w = 0; w < I.length; w++) {
      const p = I[w], b = d[w], { shouldDrawLayer: S } = b;
      if (S && p.props.pickable && D.pickableCount++, p.isComposite && D.compositeCount++, p.isDrawable && b.shouldDrawLayer) {
        const { layerRenderIndex: K, shaderModuleProps: Y, layerParameters: T } = b;
        D.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, K), Y.project && (Y.project.viewport = r), p.context.renderPass = g;
        try {
          p._drawLayer({
            renderPass: g,
            shaderModuleProps: Y,
            uniforms: { layerIndex: K },
            parameters: T
          });
        } catch (E) {
          p.raiseError(E, `drawing ${p} to ${t}`);
        }
      }
    }
    return D;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(g) {
    return !0;
  }
  getShaderModuleProps(g, I, C) {
    return null;
  }
  getLayerParameters(g, I, C) {
    return g.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(g, I, C, t) {
    if (!(g.props.visible && this.shouldDrawLayer(g)))
      return !1;
    I.layer = g;
    let r = g.parent;
    for (; r; ) {
      if (!r.props.visible || !r.filterSubLayer(I))
        return !1;
      I.layer = r, r = r.parent;
    }
    if (C) {
      const l = I.layer.id;
      if (l in t || (t[l] = C(I)), !t[l])
        return !1;
    }
    return g.activateViewport(I.viewport), !0;
  }
  _getShaderModuleProps(g, I, C, t) {
    const s = this.device.canvasContext.cssToDeviceRatio(), r = g.internalState?.propsInTransition || g.props, l = {
      layer: r,
      picking: {
        isActive: !1
      },
      project: {
        viewport: g.context.viewport,
        devicePixelRatio: s,
        modelMatrix: r.modelMatrix,
        coordinateSystem: r.coordinateSystem,
        coordinateOrigin: r.coordinateOrigin,
        autoWrapLongitude: g.wrapLongitude
      }
    };
    if (I)
      for (const d of I)
        a1(l, d.getShaderModuleProps?.(g, l));
    return a1(l, this.getShaderModuleProps(g, I, l), t);
  }
}
function mv(A = 0, g = {}) {
  const I = {}, C = (t, s) => {
    const r = t.props._offset, l = t.id, d = t.parent && t.parent.id;
    let h;
    if (d && !(d in g) && C(t.parent, !1), d in I) {
      const D = I[d] = I[d] || mv(g[d], g);
      h = D(t, s), I[l] = D;
    } else Number.isFinite(r) ? (h = r + (g[d] || 0), I[l] = null) : h = A;
    return s && h >= A && (A = h + 1), g[l] = h, h;
  };
  return C;
}
function MU(A, { shaderModuleProps: g, target: I, viewport: C }) {
  const t = g?.project?.devicePixelRatio ?? // @ts-expect-error TODO - assuming WebGL context
  A.canvasContext.cssToDeviceRatio(), [, s] = A.canvasContext.getDrawingBufferSize(), r = I ? I.height : s, l = C;
  return [
    l.x * t,
    r - (l.y + l.height) * t,
    l.width * t,
    l.height * t
  ];
}
function a1(A, ...g) {
  for (const I of g)
    if (I)
      for (const C in I)
        A[C] ? Object.assign(A[C], I[C]) : A[C] = I[C];
  return A;
}
class wU extends vG {
  constructor(g, I) {
    super(g, I);
    const C = g.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      mipmaps: !0
    }), t = g.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: !1
    });
    this.fbo = g.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [C],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: t
    });
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null);
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(g) {
    const I = this.fbo, C = this.device.canvasContext.cssToDeviceRatio(), t = g.viewports[0], s = t.width * C, r = t.height * C, l = [1, 1, 1, 1];
    (s !== I.width || r !== I.height) && I.resize({ width: s, height: r }), super.render({ ...g, clearColor: l, target: I, pass: "shadow" });
  }
  getLayerParameters(g, I, C) {
    return {
      ...g.props.parameters,
      blend: !1,
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(g) {
    return g.props.shadowEnabled !== !1;
  }
  getShaderModuleProps(g, I, C) {
    return {
      shadow: {
        project: C.project,
        drawToShadowMap: !0
      }
    };
  }
}
const BU = {
  color: [255, 255, 255],
  intensity: 1
}, r1 = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
], pU = [0, 0, 0, 200 / 255];
class bv {
  constructor(g = {}) {
    this.id = "lighting-effect", this.shadowColor = pU, this.shadow = !1, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(g);
  }
  setup(g) {
    this.context = g;
    const { device: I, deck: C } = g;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(I), C._addDefaultShaderModule(s1), this.dummyShadowMap = I.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(g) {
    this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
    for (const I in g) {
      const C = g[I];
      switch (C.type) {
        case "ambient":
          this.ambientLight = C;
          break;
        case "directional":
          this.directionalLights.push(C);
          break;
        case "point":
          this.pointLights.push(C);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((I) => I.shadow), this.context && this.setup(this.context), this.props = g;
  }
  preRender({ layers: g, layerFilter: I, viewports: C, onViewportActive: t, views: s }) {
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let r = 0; r < this.shadowPasses.length; r++)
        this.shadowPasses[r].render({
          layers: g,
          layerFilter: I,
          viewports: C,
          onViewportActive: t,
          views: s,
          shaderModuleProps: {
            shadow: {
              shadowLightId: r,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
    }
  }
  getShaderModuleProps(g, I) {
    const C = this.shadow ? {
      project: I.project,
      shadowMaps: this.shadowPasses.map((r) => r.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {}, t = {
      enabled: !0,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((r) => r.getProjectedLight({ layer: g })),
      pointLights: this.pointLights.map((r) => r.getProjectedLight({ layer: g }))
    }, s = g.props.material;
    return {
      shadow: C,
      lighting: t,
      phongMaterial: s,
      gouraudMaterial: s
    };
  }
  cleanup(g) {
    for (const I of this.shadowPasses)
      I.delete();
    this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, g.deck._removeDefaultShaderModule(s1));
  }
  _calculateMatrices() {
    const g = [];
    for (const I of this.directionalLights) {
      const C = new Jt().lookAt({
        eye: new Ss(I.direction).negate()
      });
      g.push(C);
    }
    return g;
  }
  _createShadowPasses(g) {
    for (let I = 0; I < this.directionalLights.length; I++) {
      const C = new wU(g);
      this.shadowPasses[I] = C;
    }
  }
  _applyDefaultLights() {
    const { ambientLight: g, pointLights: I, directionalLights: C } = this;
    !g && I.length === 0 && C.length === 0 && (this.ambientLight = new uU(BU), this.directionalLights.push(new o1(r1[0]), new o1(r1[1])));
  }
}
class mU {
  constructor(g = {}) {
    this._pool = [], this.opts = { overAlloc: 2, poolSize: 100 }, this.setOptions(g);
  }
  setOptions(g) {
    Object.assign(this.opts, g);
  }
  allocate(g, I, { size: C = 1, type: t, padding: s = 0, copy: r = !1, initialize: l = !1, maxCount: d }) {
    const h = t || g && g.constructor || Float32Array, D = I * C + s;
    if (ArrayBuffer.isView(g)) {
      if (D <= g.length)
        return g;
      if (D * g.BYTES_PER_ELEMENT <= g.buffer.byteLength)
        return new h(g.buffer, 0, D);
    }
    let w = 1 / 0;
    d && (w = d * C + s);
    const p = this._allocate(h, D, l, w);
    return g && r ? p.set(g) : l || p.fill(0, 0, 4), this._release(g), p;
  }
  release(g) {
    this._release(g);
  }
  _allocate(g, I, C, t) {
    let s = Math.max(Math.ceil(I * this.opts.overAlloc), 1);
    s > t && (s = t);
    const r = this._pool, l = g.BYTES_PER_ELEMENT * s, d = r.findIndex((h) => h.byteLength >= l);
    if (d >= 0) {
      const h = new g(r.splice(d, 1)[0], 0, s);
      return C && h.fill(0), h;
    }
    return new g(s);
  }
  _release(g) {
    if (!ArrayBuffer.isView(g))
      return;
    const I = this._pool, { buffer: C } = g, { byteLength: t } = C, s = I.findIndex((r) => r.byteLength >= t);
    s < 0 ? I.push(C) : (s > 0 || I.length < this.opts.poolSize) && I.splice(s, 0, C), I.length > this.opts.poolSize && I.shift();
  }
}
const fM = new mU();
function qD() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function bU(A, g) {
  const I = A % g;
  return I < 0 ? g + I : I;
}
function SU(A) {
  return [A[12], A[13], A[14]];
}
function GU(A) {
  return {
    left: If(A[3] + A[0], A[7] + A[4], A[11] + A[8], A[15] + A[12]),
    right: If(A[3] - A[0], A[7] - A[4], A[11] - A[8], A[15] - A[12]),
    bottom: If(A[3] + A[1], A[7] + A[5], A[11] + A[9], A[15] + A[13]),
    top: If(A[3] - A[1], A[7] - A[5], A[11] - A[9], A[15] - A[13]),
    near: If(A[3] + A[2], A[7] + A[6], A[11] + A[10], A[15] + A[14]),
    far: If(A[3] - A[2], A[7] - A[6], A[11] - A[10], A[15] - A[14])
  };
}
const l1 = new Ss();
function If(A, g, I, C) {
  l1.set(A, g, I);
  const t = l1.len();
  return { distance: C / t, normal: new Ss(-A / t, -g / t, -I / t) };
}
function KU(A) {
  return A - Math.fround(A);
}
let WD;
function Sb(A, g) {
  const { size: I = 1, startIndex: C = 0 } = g, t = g.endIndex !== void 0 ? g.endIndex : A.length, s = (t - C) / I;
  WD = fM.allocate(WD, s, {
    type: Float32Array,
    size: I * 2
  });
  let r = C, l = 0;
  for (; r < t; ) {
    for (let d = 0; d < I; d++) {
      const h = A[r++];
      WD[l + d] = h, WD[l + d + I] = KU(h);
    }
    l += I * 2;
  }
  return WD.subarray(0, s * I * 2);
}
function TU(A) {
  let g = null, I = !1;
  for (const C of A)
    C && (g ? (I || (g = [
      [g[0][0], g[0][1]],
      [g[1][0], g[1][1]]
    ], I = !0), g[0][0] = Math.min(g[0][0], C[0][0]), g[0][1] = Math.min(g[0][1], C[0][1]), g[1][0] = Math.max(g[1][0], C[1][0]), g[1][1] = Math.max(g[1][1], C[1][1])) : g = C);
  return g;
}
const YU = Math.PI / 180, PU = qD(), c1 = [0, 0, 0], ZU = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function jU({ width: A, height: g, orthographic: I, fovyRadians: C, focalDistance: t, padding: s, near: r, far: l }) {
  const d = A / g, h = I ? new Jt().orthographic({ fovy: C, aspect: d, focalDistance: t, near: r, far: l }) : new Jt().perspective({ fovy: C, aspect: d, near: r, far: l });
  if (s) {
    const { left: D = 0, right: w = 0, top: p = 0, bottom: b = 0 } = s, S = xC((D + A - w) / 2, 0, A) - A / 2, K = xC((p + g - b) / 2, 0, g) - g / 2;
    h[8] -= S * 2 / A, h[9] += K * 2 / g;
  }
  return h;
}
class vc {
  // eslint-disable-next-line complexity
  constructor(g = {}) {
    this._frustumPlanes = {}, this.id = g.id || this.constructor.displayName || "viewport", this.x = g.x || 0, this.y = g.y || 0, this.width = g.width || 1, this.height = g.height || 1, this.zoom = g.zoom || 0, this.padding = g.padding, this.distanceScales = g.distanceScales || ZU, this.focalDistance = g.focalDistance || 1, this.position = g.position || c1, this.modelMatrix = g.modelMatrix || null;
    const { longitude: I, latitude: C } = g;
    this.isGeospatial = Number.isFinite(C) && Number.isFinite(I), this._initProps(g), this._initMatrices(g), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? Yi.WEB_MERCATOR : Yi.WEB_MERCATOR_AUTO_OFFSET : Yi.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(g) {
    return g instanceof vc ? this === g ? !0 : g.width === this.width && g.height === this.height && g.scale === this.scale && uM(g.projectionMatrix, this.projectionMatrix) && uM(g.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(g, { topLeft: I = !0 } = {}) {
    const C = this.projectPosition(g), t = wv(C, this.pixelProjectionMatrix), [s, r] = t, l = I ? r : this.height - r;
    return g.length === 2 ? [s, l] : [s, l, t[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(g, { topLeft: I = !0, targetZ: C } = {}) {
    const [t, s, r] = g, l = I ? s : this.height - s, d = C && C * this.distanceScales.unitsPerMeter[2], h = KM([t, l, r], this.pixelUnprojectionMatrix, d), [D, w, p] = this.unprojectPosition(h);
    return Number.isFinite(r) ? [D, w, p] : Number.isFinite(C) ? [D, w, C] : [D, w];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(g) {
    const [I, C] = this.projectFlat(g), t = (g[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [I, C, t];
  }
  unprojectPosition(g) {
    const [I, C] = this.unprojectFlat(g), t = (g[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [I, C, t];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(g) {
    if (this.isGeospatial) {
      const I = jp(g);
      return I[1] = xC(I[1], -318, 830), I;
    }
    return g;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(g) {
    return this.isGeospatial ? Tf(g) : g;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(g = {}) {
    const I = { targetZ: g.z || 0 }, C = this.unproject([0, 0], I), t = this.unproject([this.width, 0], I), s = this.unproject([0, this.height], I), r = this.unproject([this.width, this.height], I);
    return [
      Math.min(C[0], t[0], s[0], r[0]),
      Math.min(C[1], t[1], s[1], r[1]),
      Math.max(C[0], t[0], s[0], r[0]),
      Math.max(C[1], t[1], s[1], r[1])
    ];
  }
  getDistanceScales(g) {
    return g && this.isGeospatial ? pS({
      longitude: g[0],
      latitude: g[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel({ x: g, y: I, width: C = 1, height: t = 1 }) {
    return g < this.x + this.width && this.x < g + C && I < this.y + this.height && this.y < I + t;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, GU(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(g, I) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(g) {
    const I = g.longitude, C = g.latitude;
    this.isGeospatial && (Number.isFinite(g.zoom) || (this.zoom = V9({ latitude: C }) + Math.log2(this.focalDistance)), this.distanceScales = g.distanceScales || pS({ latitude: C, longitude: I }));
    const t = Math.pow(2, this.zoom);
    this.scale = t;
    const { position: s, modelMatrix: r } = g;
    let l = c1;
    if (s && (l = r ? new Jt(r).transformAsVector(s, []) : s), this.isGeospatial) {
      const d = this.projectPosition([I, C, 0]);
      this.center = new Ss(l).scale(this.distanceScales.unitsPerMeter).add(d);
    } else
      this.center = this.projectPosition(l);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(g) {
    const {
      // View matrix
      viewMatrix: I = PU,
      // Projection matrix
      projectionMatrix: C = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: t = !1,
      fovyRadians: s,
      fovy: r = 75,
      near: l = 0.1,
      // Distance of near clipping plane
      far: d = 1e3,
      // Distance of far clipping plane
      padding: h = null,
      // Center offset in pixels
      focalDistance: D = 1
    } = g;
    this.viewMatrixUncentered = I, this.viewMatrix = new Jt().multiplyRight(I).translate(new Ss(this.center).negate()), this.projectionMatrix = C || jU({
      width: this.width,
      height: this.height,
      orthographic: t,
      fovyRadians: s || r * YU,
      focalDistance: D,
      padding: h,
      near: l,
      far: d
    });
    const w = qD();
    dc(w, w, this.projectionMatrix), dc(w, w, this.viewMatrix), this.viewProjectionMatrix = w, this.viewMatrixInverse = uS([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = SU(this.viewMatrixInverse);
    const p = qD(), b = qD();
    YG(p, p, [this.width / 2, -this.height / 2, 1]), Yp(p, p, [1, -1, 0]), dc(b, p, this.viewProjectionMatrix), this.pixelProjectionMatrix = b, this.pixelUnprojectionMatrix = uS(qD(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || uA.warn("Pixel project matrix not invertible")();
  }
}
vc.displayName = "Viewport";
class Yf extends vc {
  /* eslint-disable complexity, max-statements */
  constructor(g = {}) {
    const {
      latitude: I = 0,
      longitude: C = 0,
      zoom: t = 0,
      pitch: s = 0,
      bearing: r = 0,
      nearZMultiplier: l = 0.1,
      farZMultiplier: d = 1.01,
      nearZ: h,
      farZ: D,
      orthographic: w = !1,
      projectionMatrix: p,
      repeat: b = !1,
      worldOffset: S = 0,
      position: K,
      padding: Y,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: T = !1
    } = g;
    let { width: E, height: H, altitude: R = 1.5 } = g;
    const x = Math.pow(2, t);
    E = E || 1, H = H || 1;
    let U, J = null;
    if (p)
      R = p[5] / 2, U = vp(R);
    else {
      g.fovy ? (U = g.fovy, R = jG(U)) : U = vp(R);
      let eg;
      if (Y) {
        const { top: Mg = 0, bottom: ig = 0 } = Y;
        eg = [0, xC((Mg + H - ig) / 2, 0, H) - H / 2];
      }
      J = _9({
        width: E,
        height: H,
        scale: x,
        center: K && [0, 0, K[2] * bb(I)],
        offset: eg,
        pitch: s,
        fovy: U,
        nearZMultiplier: l,
        farZMultiplier: d
      }), Number.isFinite(h) && (J.near = h), Number.isFinite(D) && (J.far = D);
    }
    let L = x9({
      height: H,
      pitch: s,
      bearing: r,
      scale: x,
      altitude: R
    });
    S && (L = new Jt().translate([512 * S, 0, 0]).multiplyLeft(L)), super({
      ...g,
      // x, y,
      width: E,
      height: H,
      // view matrix
      viewMatrix: L,
      longitude: C,
      latitude: I,
      zoom: t,
      // projection matrix parameters
      ...J,
      fovy: U,
      focalDistance: R
    }), this.latitude = I, this.longitude = C, this.zoom = t, this.pitch = s, this.bearing = r, this.altitude = R, this.fovy = U, this.orthographic = w, this._subViewports = b ? [] : null, this._pseudoMeters = T, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const g = this.getBounds(), I = Math.floor((g[0] + 180) / 360), C = Math.ceil((g[2] - 180) / 360);
      for (let t = I; t <= C; t++) {
        const s = t ? new Yf({
          ...this,
          worldOffset: t
        }) : this;
        this._subViewports.push(s);
      }
    }
    return this._subViewports;
  }
  projectPosition(g) {
    if (this._pseudoMeters)
      return super.projectPosition(g);
    const [I, C] = this.projectFlat(g), t = (g[2] || 0) * bb(g[1]);
    return [I, C, t];
  }
  unprojectPosition(g) {
    if (this._pseudoMeters)
      return super.unprojectPosition(g);
    const [I, C] = this.unprojectFlat(g), t = (g[2] || 0) / bb(C);
    return [I, C, t];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(g, I) {
    return Mv(g, I);
  }
  panByPosition(g, I) {
    const C = KM(I, this.pixelUnprojectionMatrix), t = this.projectFlat(g), s = Tp([], t, qj([], C)), r = Tp([], this.center, s), [l, d] = this.unprojectFlat(r);
    return { longitude: l, latitude: d };
  }
  getBounds(g = {}) {
    const I = X9(this, g.z || 0);
    return [
      Math.min(I[0][0], I[1][0], I[2][0], I[3][0]),
      Math.min(I[0][1], I[1][1], I[2][1], I[3][1]),
      Math.max(I[0][0], I[1][0], I[2][0], I[3][0]),
      Math.max(I[0][1], I[1][1], I[2][1], I[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(g, I = {}) {
    const { width: C, height: t } = this, { longitude: s, latitude: r, zoom: l } = U9({ width: C, height: t, bounds: g, ...I });
    return new Yf({ width: C, height: t, longitude: s, latitude: r, zoom: l });
  }
}
Yf.displayName = "WebMercatorViewport";
const u1 = [0, 0, 0];
function Gb(A, g, I = !1) {
  const C = g.projectPosition(A);
  if (I && g instanceof Yf) {
    const [t, s, r = 0] = A, l = g.getDistanceScales([t, s]);
    C[2] = r * l.unitsPerMeter[2];
  }
  return C;
}
function vU(A) {
  const { viewport: g, modelMatrix: I, coordinateOrigin: C } = A;
  let { coordinateSystem: t, fromCoordinateSystem: s, fromCoordinateOrigin: r } = A;
  return t === gA.DEFAULT && (t = g.isGeospatial ? gA.LNGLAT : gA.CARTESIAN), s === void 0 && (s = t), r === void 0 && (r = C), {
    viewport: g,
    coordinateSystem: t,
    coordinateOrigin: C,
    modelMatrix: I,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: r
  };
}
function Sv(A, { viewport: g, modelMatrix: I, coordinateSystem: C, coordinateOrigin: t, offsetMode: s }) {
  let [r, l, d = 0] = A;
  switch (I && ([r, l, d] = SM([], [r, l, d, 1], I)), C) {
    case gA.LNGLAT:
      return Gb([r, l, d], g, s);
    case gA.LNGLAT_OFFSETS:
      return Gb([r + t[0], l + t[1], d + (t[2] || 0)], g, s);
    case gA.METER_OFFSETS:
      return Gb(Mv(t, [r, l, d]), g, s);
    case gA.CARTESIAN:
    default:
      return g.isGeospatial ? [r + t[0], l + t[1], d + t[2]] : g.projectPosition([r, l, d]);
  }
}
function HU(A, g) {
  const { viewport: I, coordinateSystem: C, coordinateOrigin: t, modelMatrix: s, fromCoordinateSystem: r, fromCoordinateOrigin: l } = vU(g), { autoOffset: d = !0 } = g, { geospatialOrigin: h = u1, shaderCoordinateOrigin: D = u1, offsetMode: w = !1 } = d ? hv(I, C, t) : {}, p = Sv(A, {
    viewport: I,
    modelMatrix: s,
    coordinateSystem: r,
    coordinateOrigin: l,
    offsetMode: w
  });
  if (w) {
    const b = I.projectPosition(h || D);
    jx(p, p, b);
  }
  return p;
}
let EU = 1, RU = 1;
class Gv {
  time = 0;
  channels = /* @__PURE__ */ new Map();
  animations = /* @__PURE__ */ new Map();
  playing = !1;
  lastEngineTime = -1;
  constructor() {
  }
  addChannel(g) {
    const { delay: I = 0, duration: C = Number.POSITIVE_INFINITY, rate: t = 1, repeat: s = 1 } = g, r = EU++, l = {
      time: 0,
      delay: I,
      duration: C,
      rate: t,
      repeat: s
    };
    return this._setChannelTime(l, this.time), this.channels.set(r, l), r;
  }
  removeChannel(g) {
    this.channels.delete(g);
    for (const [I, C] of this.animations)
      C.channel === g && this.detachAnimation(I);
  }
  isFinished(g) {
    const I = this.channels.get(g);
    return I === void 0 ? !1 : this.time >= I.delay + I.duration * I.repeat;
  }
  getTime(g) {
    if (g === void 0)
      return this.time;
    const I = this.channels.get(g);
    return I === void 0 ? -1 : I.time;
  }
  setTime(g) {
    this.time = Math.max(0, g);
    const I = this.channels.values();
    for (const t of I)
      this._setChannelTime(t, this.time);
    const C = this.animations.values();
    for (const t of C) {
      const { animation: s, channel: r } = t;
      s.setTime(this.getTime(r));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(g, I) {
    const C = RU++;
    return this.animations.set(C, {
      animation: g,
      channel: I
    }), g.setTime(this.getTime(I)), C;
  }
  detachAnimation(g) {
    this.animations.delete(g);
  }
  update(g) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = g), this.setTime(this.time + (g - this.lastEngineTime)), this.lastEngineTime = g);
  }
  _setChannelTime(g, I) {
    const C = I - g.delay, t = g.duration * g.repeat;
    C >= t ? g.time = g.duration * g.rate : (g.time = Math.max(0, C) % g.duration, g.time *= g.rate);
  }
}
function OU(A) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(A) : setTimeout(A, 1e3 / 60);
}
function NU(A) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(A) : clearTimeout(A);
}
let kU = 0;
const WU = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (A) => console.error(A),
  // eslint-disable-line no-console
  stats: CS.stats.get(`animation-loop-${kU++}`),
  // view parameters
  useDevicePixels: !0,
  autoResizeViewport: !1,
  autoResizeDrawingBuffer: !1
};
class VU {
  device = null;
  canvas = null;
  props;
  animationProps = null;
  timeline = null;
  stats;
  cpuTime;
  gpuTime;
  frameRate;
  display;
  needsRedraw = "initialized";
  _initialized = !1;
  _running = !1;
  _animationFrameId = null;
  _nextFramePromise = null;
  _resolveNextFrame = null;
  _cpuStartTime = 0;
  _error = null;
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(g) {
    if (this.props = { ...WU, ...g }, g = this.props, !g.device)
      throw new Error("No device provided");
    const { useDevicePixels: I = !0 } = this.props;
    this.stats = g.stats || new Qp({ id: "animation-loop-stats" }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: g.autoResizeViewport,
      autoResizeDrawingBuffer: g.autoResizeDrawingBuffer,
      useDevicePixels: I
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  setError(g) {
    if (this.props.onError(g), this._error = Error(), this.device?.canvasContext?.canvas instanceof HTMLCanvasElement) {
      const C = document.createElement("h1");
      C.innerHTML = g.message, C.style.position = "absolute", C.style.top = "20%", C.style.left = "10px", C.style.color = "black", C.style.backgroundColor = "red", document.body.appendChild(C);
    }
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(g) {
    return this.needsRedraw = this.needsRedraw || g, this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(g) {
    return "autoResizeViewport" in g && (this.props.autoResizeViewport = g.autoResizeViewport || !1), "autoResizeDrawingBuffer" in g && (this.props.autoResizeDrawingBuffer = g.autoResizeDrawingBuffer || !1), "useDevicePixels" in g && (this.props.useDevicePixels = g.useDevicePixels || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let g;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (g !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (g) {
      const I = g instanceof Error ? g : new Error("Unknown error");
      throw this.props.onError(I), I;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    return this.device?.isLost || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(g) {
    return this.timeline = g, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((g) => {
      this._resolveNextFrame = g;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  _setDisplay(g) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), g && (g.animationLoop = this), this.display = g;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = OU(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (NU(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(g) {
    if (this.display) {
      this.display._renderFrame(g);
      return;
    }
    this.props.onRender(this._getAnimationProps()), this.device?.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    const g = this.device?.canvasContext?.canvas;
    if (!this.device || !g)
      throw new Error("loop");
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: g,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const { width: g, height: I, aspect: C } = this._getSizeAndAspect();
    (g !== this.animationProps.width || I !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), C !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = g, this.animationProps.height = I, this.animationProps.aspect = C, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = this.device.canvasContext?.canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const g = document.createElement("div");
      document.body.appendChild(g), g.style.position = "relative";
      const I = document.createElement("div");
      I.style.position = "absolute", I.style.left = "10px", I.style.bottom = "10px", I.style.width = "300px", I.style.background = "white", this.canvas instanceof HTMLCanvasElement && g.appendChild(this.canvas), g.appendChild(I);
      const C = this.props.onAddHTML(I);
      C && (I.innerHTML = C);
    }
  }
  _getSizeAndAspect() {
    if (!this.device)
      return { width: 1, height: 1, aspect: 1 };
    const [g, I] = this.device?.canvasContext?.getPixelSize() || [1, 1];
    let C = 1;
    const t = this.device?.canvasContext?.canvas;
    return t && t.clientHeight ? C = t.clientWidth / t.clientHeight : g > 0 && I > 0 && (C = g / I), { width: g, height: I, aspect: C };
  }
  /** Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    this.props.autoResizeDrawingBuffer && this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(g) {
    g instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [g.offsetX, g.offsetY]);
  }
  _onMouseleave(g) {
    this._getAnimationProps()._mousePosition = null;
  }
}
const Kb = {};
function I0(A = "id") {
  Kb[A] = Kb[A] || 1;
  const g = Kb[A]++;
  return `${A}-${g}`;
}
class d1 {
  id;
  userData = {};
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  bufferLayout = [];
  vertexCount;
  indices;
  attributes;
  constructor(g) {
    if (this.id = g.id || I0("geometry"), this.topology = g.topology, this.indices = g.indices || null, this.attributes = g.attributes, this.vertexCount = g.vertexCount, this.bufferLayout = g.bufferLayout || [], this.indices && !(this.indices.usage & GA.INDEX))
      throw new Error("Index buffer must have INDEX usage");
  }
  destroy() {
    this.indices?.destroy();
    for (const g of Object.values(this.attributes))
      g.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(g) {
    return g.byteLength / 12;
  }
}
function xU(A, g) {
  if (g instanceof d1)
    return g;
  const I = _U(A, g), { attributes: C, bufferLayout: t } = UU(A, g);
  return new d1({
    topology: g.topology || "triangle-list",
    bufferLayout: t,
    vertexCount: g.vertexCount,
    indices: I,
    attributes: C
  });
}
function _U(A, g) {
  if (!g.indices)
    return;
  const I = g.indices.value;
  return A.createBuffer({ usage: GA.INDEX, data: I });
}
function UU(A, g) {
  const I = [], C = {};
  for (const [s, r] of Object.entries(g.attributes)) {
    let l = s;
    switch (s) {
      case "POSITION":
        l = "positions";
        break;
      case "NORMAL":
        l = "normals";
        break;
      case "TEXCOORD_0":
        l = "texCoords";
        break;
      case "COLOR_0":
        l = "colors";
        break;
    }
    if (r) {
      C[l] = A.createBuffer({
        data: r.value,
        id: `${s}-buffer`
      });
      const { value: d, size: h, normalized: D } = r;
      I.push({ name: l, format: k4(d, h, D) });
    }
  }
  const t = g._calculateVertexCount(g.attributes, g.indices);
  return { attributes: C, bufferLayout: I, vertexCount: t };
}
class HG {
  static defaultProps = { ...mf.defaultProps };
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(g) {
    return g._lumaData.defaultPipelineFactory = g._lumaData.defaultPipelineFactory || new HG(g), g._lumaData.defaultPipelineFactory;
  }
  device;
  destroyPolicy;
  _hashCounter = 0;
  _hashes = {};
  _renderPipelineCache = {};
  _computePipelineCache = {};
  constructor(g) {
    this.device = g, this.destroyPolicy = g.props._factoryDestroyPolicy;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(g) {
    const I = { ...mf.defaultProps, ...g }, C = this._hashRenderPipeline(I);
    if (!this._renderPipelineCache[C]) {
      const t = this.device.createRenderPipeline({
        ...I,
        id: I.id ? `${I.id}-cached` : void 0
      });
      t.hash = C, this._renderPipelineCache[C] = { pipeline: t, useCount: 0 };
    }
    return this._renderPipelineCache[C].useCount++, this._renderPipelineCache[C].pipeline;
  }
  createComputePipeline(g) {
    const I = { ...dp.defaultProps, ...g }, C = this._hashComputePipeline(I);
    if (!this._computePipelineCache[C]) {
      const t = this.device.createComputePipeline({
        ...I,
        id: I.id ? `${I.id}-cached` : void 0
      });
      t.hash = C, this._computePipelineCache[C] = { pipeline: t, useCount: 0 };
    }
    return this._computePipelineCache[C].useCount++, this._computePipelineCache[C].pipeline;
  }
  release(g) {
    const I = g.hash, C = g instanceof dp ? this._computePipelineCache : this._renderPipelineCache;
    C[I].useCount--, C[I].useCount === 0 && this.destroyPolicy === "unused" && (C[I].pipeline.destroy(), delete C[I]);
  }
  // PRIVATE
  _hashComputePipeline(g) {
    return `${this._getHash(g.shader.source)}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(g) {
    const I = g.vs ? this._getHash(g.vs.source) : 0, C = g.fs ? this._getHash(g.fs.source) : 0, t = "-", s = this._getHash(JSON.stringify(g.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${I}/${C}V${t}BL${s}`;
      default:
        const r = this._getHash(JSON.stringify(g.parameters));
        return `${I}/${C}V${t}T${g.topology}P${r}BL${s}`;
    }
  }
  _getHash(g) {
    return this._hashes[g] === void 0 && (this._hashes[g] = this._hashCounter++), this._hashes[g];
  }
}
class EG {
  static defaultProps = { ...Lp.defaultProps };
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(g) {
    return g._lumaData.defaultShaderFactory ||= new EG(g), g._lumaData.defaultShaderFactory;
  }
  device;
  destroyPolicy;
  _cache = {};
  /** @internal */
  constructor(g) {
    this.device = g, this.destroyPolicy = g.props._factoryDestroyPolicy;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(g) {
    const I = this._hashShader(g);
    let C = this._cache[I];
    if (!C) {
      const t = this.device.createShader({
        ...g,
        id: g.id ? `${g.id}-cached` : void 0
      });
      this._cache[I] = C = { shader: t, useCount: 0 };
    }
    return C.useCount++, C.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(g) {
    const I = this._hashShader(g), C = this._cache[I];
    C && (C.useCount--, C.useCount === 0 && this.destroyPolicy === "unused" && (delete this._cache[I], C.shader.destroy()));
  }
  // PRIVATE
  _hashShader(g) {
    return `${g.stage}:${g.source}`;
  }
}
function FU(A, g) {
  const I = {}, C = "Values";
  if (A.attributes.length === 0 && !A.varyings?.length)
    return { "No attributes or varyings": { [C]: "N/A" } };
  for (const t of A.attributes)
    if (t) {
      const s = `${t.location} ${t.name}: ${t.type}`;
      I[`in ${s}`] = { [C]: t.stepMode || "vertex" };
    }
  for (const t of A.varyings || []) {
    const s = `${t.location} ${t.name}`;
    I[`out ${s}`] = { [C]: JSON.stringify(t) };
  }
  return I;
}
let WC = null, Tb = null;
function XU(A, { id: g, minimap: I, opaque: C, top: t = "0", left: s = "0", rgbaScale: r = 1 }) {
  WC || (WC = document.createElement("canvas"), WC.id = g, WC.title = g, WC.style.zIndex = "100", WC.style.position = "absolute", WC.style.top = t, WC.style.left = s, WC.style.border = "blue 5px solid", WC.style.transform = "scaleY(-1)", document.body.appendChild(WC), Tb = WC.getContext("2d")), (WC.width !== A.width || WC.height !== A.height) && (WC.width = A.width / 2, WC.height = A.height / 2, WC.style.width = "400px", WC.style.height = "400px");
  const l = A.device.readPixelsToArrayWebGL(A), d = Tb?.createImageData(A.width, A.height);
  if (d) {
    for (let D = 0; D < l.length; D += 4)
      d.data[0 + D + 0] = l[D + 0] * r, d.data[0 + D + 1] = l[D + 1] * r, d.data[0 + D + 2] = l[D + 2] * r, d.data[0 + D + 3] = C ? 255 : l[D + 3] * r;
    Tb?.putImageData(d, 0, 0);
  }
}
function mS(A, g, I) {
  if (A === g)
    return !0;
  if (!I || !A || !g)
    return !1;
  if (Array.isArray(A)) {
    if (!Array.isArray(g) || A.length !== g.length)
      return !1;
    for (let C = 0; C < A.length; C++)
      if (!mS(A[C], g[C], I - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(g))
    return !1;
  if (typeof A == "object" && typeof g == "object") {
    const C = Object.keys(A), t = Object.keys(g);
    if (C.length !== t.length)
      return !1;
    for (const s of C)
      if (!g.hasOwnProperty(s) || !mS(A[s], g[s], I - 1))
        return !1;
    return !0;
  }
  return !1;
}
function QU(A) {
  return ArrayBuffer.isView(A) && !(A instanceof DataView);
}
function zU(A) {
  return Array.isArray(A) ? A.length === 0 || typeof A[0] == "number" : !1;
}
function Kv(A) {
  return QU(A) || zU(A);
}
function JU(A) {
  return Kv(A) || typeof A == "number" || typeof A == "boolean";
}
function Tv(A) {
  const g = { bindings: {}, uniforms: {} };
  return Object.keys(A).forEach((I) => {
    const C = A[I];
    JU(C) ? g.uniforms[I] = C : g.bindings[I] = C;
  }), g;
}
class LU {
  options = {
    disableWarnings: !1
  };
  /**
   * The map of modules
   * @todo should should this include the resolved dependencies?
   */
  // @ts-ignore Fix typings
  modules;
  /** Stores the uniform values for each module */
  moduleUniforms;
  /** Stores the uniform bindings for each module  */
  moduleBindings;
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(g, I) {
    Object.assign(this.options, I);
    const C = MG(Object.values(g).filter((t) => t.dependencies));
    for (const t of C)
      g[t.name] = t;
    xg.log(1, "Creating ShaderInputs with modules", Object.keys(g))(), this.modules = g, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [t, s] of Object.entries(g))
      this._addModule(s), s.name && t !== s.name && !this.options.disableWarnings && xg.warn(`Module name: ${t} vs ${s.name}`)();
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(g) {
    for (const I of Object.keys(g)) {
      const C = I, t = g[C] || {}, s = this.modules[C];
      if (!s) {
        this.options.disableWarnings || xg.warn(`Module ${I} not found`)();
        continue;
      }
      const r = this.moduleUniforms[C], l = this.moduleBindings[C], d = s.getUniforms?.(t, r) || t, { uniforms: h, bindings: D } = Tv(d);
      this.moduleUniforms[C] = { ...r, ...h }, this.moduleBindings[C] = { ...l, ...D };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const g = {};
    for (const I of Object.values(this.moduleBindings))
      Object.assign(g, I);
    return g;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    const g = {};
    for (const [I, C] of Object.entries(this.moduleUniforms))
      for (const [t, s] of Object.entries(C))
        g[`${I}.${t}`] = {
          type: this.modules[I].uniformTypes?.[t],
          value: String(s)
        };
    return g;
  }
  _addModule(g) {
    const I = g.name;
    this.moduleUniforms[I] = g.defaultUniforms || {}, this.moduleBindings[I] = {};
  }
}
let qU = "";
async function $U(A, g) {
  const I = new Image();
  return I.crossOrigin = "anonymous", I.src = A.startsWith("http") ? A : qU + A, await I.decode(), g ? await createImageBitmap(I, g) : await createImageBitmap(I);
}
class Yb {
  device;
  id;
  // TODO - should we type these as possibly `null`? It will make usage harder?
  // @ts-expect-error
  texture;
  // @ts-expect-error
  sampler;
  // @ts-expect-error
  view;
  ready;
  isReady = !1;
  destroyed = !1;
  resolveReady = () => {
  };
  rejectReady = () => {
  };
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  constructor(g, I) {
    this.device = g, this.id = I.id || I0("async-texture"), typeof I?.data == "string" && I.dimension === "2d" && (I = { ...I, data: $U(I.data) }), this.ready = new Promise((C, t) => {
      this.resolveReady = () => {
        this.isReady = !0, C();
      }, this.rejectReady = t;
    }), this.initAsync(I);
  }
  async initAsync(g) {
    const I = g.data;
    let C;
    try {
      C = await Yv(I);
    } catch (s) {
      this.rejectReady(s);
    }
    if (this.destroyed)
      return;
    const t = { ...g, data: C };
    this.texture = this.device.createTexture(t), this.sampler = this.texture.sampler, this.view = this.texture.view, this.isReady = !0, this.resolveReady();
  }
  destroy() {
    this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = !0;
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(g) {
    if (!this.isReady)
      throw new Error("Cannot resize texture before it is ready");
    if (g.width === this.texture.width && g.height === this.texture.height)
      return !1;
    if (this.texture) {
      const I = this.texture;
      this.texture = I.clone(g), I.destroy();
    }
    return !0;
  }
}
async function Yv(A) {
  if (A = await A, Array.isArray(A))
    return await Promise.all(A.map(Yv));
  if (A && typeof A == "object" && A.constructor === Object) {
    const g = A, I = await Promise.all(Object.values(g)), C = Object.keys(g), t = {};
    for (let s = 0; s < C.length; s++)
      t[C[s]] = I[s];
    return t;
  }
  return A;
}
const sc = 2, g3 = 1e4;
class Bc {
  static defaultProps = {
    ...mf.defaultProps,
    source: void 0,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: lc.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  };
  device;
  id;
  // @ts-expect-error assigned in function called from constructor
  source;
  // @ts-expect-error assigned in function called from constructor
  vs;
  // @ts-expect-error assigned in function called from constructor
  fs;
  pipelineFactory;
  shaderFactory;
  userData = {};
  // Fixed properties (change can trigger pipeline rebuild)
  /** The render pipeline GPU parameters, depth testing etc */
  parameters;
  /** The primitive topology */
  topology;
  /** Buffer layout */
  bufferLayout;
  // Dynamic properties
  /** Use instanced rendering */
  isInstanced = void 0;
  /** instance count. `undefined` means not instanced */
  instanceCount = 0;
  /** Vertex count */
  vertexCount;
  /** Index buffer */
  indexBuffer = null;
  /** Buffer-valued attributes */
  bufferAttributes = {};
  /** Constant-valued attributes */
  constantAttributes = {};
  /** Bindings (textures, samplers, uniform buffers) */
  bindings = {};
  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
  uniforms = {};
  /**
   * VertexArray
   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
   * @todo - allow application to define multiple vertex arrays?
   * */
  vertexArray;
  /** TransformFeedback, WebGL 2 only. */
  transformFeedback = null;
  /** The underlying GPU "program". @note May be recreated if parameters change */
  pipeline;
  /** ShaderInputs instance */
  // @ts-expect-error Assigned in function called by constructor
  shaderInputs;
  // @ts-expect-error Assigned in function called by constructor
  _uniformStore;
  _attributeInfos = {};
  _gpuGeometry = null;
  _getModuleUniforms;
  props;
  _pipelineNeedsUpdate = "newly created";
  _needsRedraw = "initializing";
  _destroyed = !1;
  /** "Time" of last draw. Monotonically increasing timestamp */
  _lastDrawTimestamp = -1;
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  constructor(g, I) {
    this.props = { ...Bc.defaultProps, ...I }, I = this.props, this.id = I.id || I0("model"), this.device = g, Object.assign(this.userData, I.userData);
    const C = Object.fromEntries(this.props.modules?.map((d) => [d.name, d]) || []), t = I.shaderInputs || new LU(C, { disableWarnings: this.props.disableWarnings });
    this.setShaderInputs(t);
    const s = A3(g), r = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || []
    );
    if (this.device.type === "webgpu" && this.props.source) {
      const { source: d, getUniforms: h } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo: s,
        ...this.props,
        modules: r
      });
      this.source = d, this._getModuleUniforms = h, this.props.shaderLayout ||= ox(this.source);
    } else {
      const { vs: d, fs: h, getUniforms: D } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo: s,
        ...this.props,
        modules: r
      });
      this.vs = d, this.fs = h, this._getModuleUniforms = D;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, I.geometry && this.setGeometry(I.geometry), this.pipelineFactory = I.pipelineFactory || HG.getDefaultPipelineFactory(this.device), this.shaderFactory = I.shaderFactory || EG.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = g.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in I && (this.isInstanced = I.isInstanced), I.instanceCount && this.setInstanceCount(I.instanceCount), I.vertexCount && this.setVertexCount(I.vertexCount), I.indexBuffer && this.setIndexBuffer(I.indexBuffer), I.attributes && this.setAttributes(I.attributes), I.constantAttributes && this.setConstantAttributes(I.constantAttributes), I.bindings && this.setBindings(I.bindings), I.uniforms && this.setUniformsWebGL(I.uniforms), I.moduleSettings && this.updateModuleSettingsWebGL(I.moduleSettings), I.transformFeedback && (this.transformFeedback = I.transformFeedback), Object.seal(this);
  }
  destroy() {
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const g = this._needsRedraw;
    return this._needsRedraw = !1, g;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(g) {
    this._needsRedraw ||= g;
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(g) {
    const I = this._areBindingsLoading();
    if (I)
      return xg.info(sc, `>>> DRAWING ABORTED ${this.id}: ${I} not loaded`)(), !1;
    try {
      g.pushDebugGroup(`${this}.predraw(${g})`), this.predraw();
    } finally {
      g.popDebugGroup();
    }
    let C;
    try {
      g.pushDebugGroup(`${this}.draw(${g})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
      const t = this._getBindings();
      this.pipeline.setBindings(t, {
        disableWarnings: this.props.disableWarnings
      }), bS(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
      const { indexBuffer: s } = this.vertexArray, r = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      C = this.pipeline.draw({
        renderPass: g,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: r,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      g.popDebugGroup(), this._logDrawCallEnd();
    }
    return this._logFramebuffer(g), C ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", C;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(g) {
    this._gpuGeometry?.destroy();
    const I = g && xU(this.device, g);
    if (I) {
      this.setTopology(I.topology || "triangle-list");
      const C = new tb(this.bufferLayout);
      this.bufferLayout = C.mergeBufferLayouts(I.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(I);
    }
    this._gpuGeometry = I;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(g) {
    g !== this.topology && (this.topology = g, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(g) {
    const I = new tb(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? I.mergeBufferLayouts(g, this._gpuGeometry.bufferLayout) : g, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(g) {
    mS(g, this.parameters, 2) || (this.parameters = g, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(g) {
    this.instanceCount = g, this.isInstanced === void 0 && g > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(g) {
    this.vertexCount = g, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(g) {
    this.shaderInputs = g, this._uniformStore = new N4(this.shaderInputs.modules);
    for (const [I, C] of Object.entries(this.shaderInputs.modules))
      if (I3(C)) {
        const t = this._uniformStore.getManagedUniformBuffer(this.device, I);
        this.bindings[`${I}Uniforms`] = t;
      }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(g) {
    Object.assign(this.bindings, g), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(g) {
    this.transformFeedback = g, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(g) {
    this.vertexArray.setIndexBuffer(g), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(g, I) {
    const C = I?.disableWarnings ?? this.props.disableWarnings;
    g.indices && xg.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(), this.bufferLayout = W4(this.pipeline.shaderLayout, this.bufferLayout);
    const t = new tb(this.bufferLayout);
    for (const [s, r] of Object.entries(g)) {
      const l = t.getBufferLayout(s);
      if (!l) {
        C || xg.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const d = t.getAttributeNamesForBuffer(l);
      let h = !1;
      for (const D of d) {
        const w = this._attributeInfos[D];
        if (w) {
          const p = this.device.type === "webgpu" ? t.getBufferIndex(w.bufferName) : w.location;
          this.vertexArray.setBuffer(p, r), h = !0;
        }
      }
      !h && !C && xg.warn(`Model(${this.id}): Ignoring buffer "${r.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(g, I) {
    for (const [C, t] of Object.entries(g)) {
      const s = this._attributeInfos[C];
      s ? this.vertexArray.setConstantWebGL(s.location, t) : (I?.disableWarnings ?? this.props.disableWarnings) || xg.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${C}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(g) {
    this.setUniformsWebGL(g);
  }
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniformsWebGL(g) {
    bS(g) || (this.pipeline.setUniformsWebGL(g), Object.assign(this.uniforms, g)), this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettingsWebGL(g) {
    const { bindings: I, uniforms: C } = Tv(this._getModuleUniforms(g));
    Object.assign(this.bindings, I), Object.assign(this.uniforms, C), this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const g of Object.values(this.bindings))
      if (g instanceof Yb && !g.isReady)
        return g.id;
    return !1;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const g = {};
    for (const [I, C] of Object.entries(this.bindings))
      C instanceof Yb ? C.isReady && (g[I] = C.texture) : g[I] = C;
    return g;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let g = 0;
    for (const I of Object.values(this.bindings))
      I instanceof Jp ? g = Math.max(g, I.texture.updateTimestamp) : I instanceof GA || I instanceof cA ? g = Math.max(g, I.updateTimestamp) : I instanceof Yb ? g = I.texture ? Math.max(g, I.texture.updateTimestamp) : (
        // The texture will become available in the future
        1 / 0
      ) : I instanceof lM || (g = Math.max(g, I.buffer.updateTimestamp));
    return g;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(g) {
    const I = { ...g.attributes };
    for (const [C] of Object.entries(I))
      !this.pipeline.shaderLayout.attributes.find((t) => t.name === C) && C !== "positions" && delete I[C];
    this.vertexCount = g.vertexCount, this.setIndexBuffer(g.indices || null), this.setAttributes(g.attributes, { disableWarnings: !0 }), this.setAttributes(I, { disableWarnings: this.props.disableWarnings }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(g) {
    this._pipelineNeedsUpdate ||= g, this.setNeedsRedraw(g);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let g = null, I = null;
      this.pipeline && (xg.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), g = this.pipeline.vs, I = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const C = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let t = null;
      this.source ? t = C : this.fs && (t = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debugShaders: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: C,
        fs: t
      }), this._attributeInfos = qZ(this.pipeline.shaderLayout, this.bufferLayout), g && this.shaderFactory.release(g), I && this.shaderFactory.release(I);
    }
    return this.pipeline;
  }
  /** Throttle draw call logging */
  _lastLogTime = 0;
  _logOpen = !1;
  _logDrawCallStart() {
    const g = xg.level > 3 ? 0 : g3;
    xg.level < 2 || Date.now() - this._lastLogTime < g || (this._lastLogTime = Date.now(), this._logOpen = !0, xg.group(sc, `>>> DRAWING MODEL ${this.id}`, { collapsed: xg.level <= 2 })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const g = FU(this.pipeline.shaderLayout, this.id);
      xg.table(sc, g)();
      const I = this.shaderInputs.getDebugTable();
      for (const [t, s] of Object.entries(this.uniforms))
        I[t] = { value: s };
      xg.table(sc, I)();
      const C = this._getAttributeDebugTable();
      xg.table(sc, this._attributeInfos)(), xg.table(sc, C)(), xg.groupEnd(sc)(), this._logOpen = !1;
    }
  }
  _drawCount = 0;
  _logFramebuffer(g) {
    const I = this.device.props.debugFramebuffers;
    if (this._drawCount++, !I)
      return;
    const C = g.props.framebuffer;
    C && XU(C, { id: C.id, minimap: !0 });
  }
  _getAttributeDebugTable() {
    const g = {};
    for (const [I, C] of Object.entries(this._attributeInfos)) {
      const t = this.vertexArray.attributes[C.location];
      g[C.location] = {
        name: I,
        type: C.shaderType,
        values: t ? this._getBufferOrConstantValues(t, C.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer: I } = this.vertexArray, C = I.indexType === "uint32" ? new Uint32Array(I.debugData) : new Uint16Array(I.debugData);
      g.indices = {
        name: "indices",
        type: I.indexType,
        values: C.toString()
      };
    }
    return g;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(g, I) {
    const C = Ij(I);
    return (g instanceof GA ? new C(g.debugData) : g).toString();
  }
}
function I3(A) {
  return !!(A.uniformTypes && !bS(A.uniformTypes));
}
function A3(A) {
  return {
    type: A.type,
    shaderLanguage: A.info.shadingLanguage,
    shaderLanguageVersion: A.info.shadingLanguageVersion,
    gpu: A.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: A.features
  };
}
function bS(A) {
  for (const g in A)
    return !1;
  return !0;
}
class Pf {
  device;
  model;
  transformFeedback;
  static defaultProps = {
    ...Bc.defaultProps,
    outputs: void 0,
    feedbackBuffers: void 0
  };
  static isSupported(g) {
    return g?.info?.type === "webgl";
  }
  constructor(g, I = Pf.defaultProps) {
    if (!Pf.isSupported(g))
      throw new Error("BufferTransform not yet implemented on WebGPU");
    this.device = g, this.model = new Bc(this.device, {
      id: I.id || "buffer-transform-model",
      fs: I.fs || PV(),
      topology: I.topology || "point-list",
      varyings: I.outputs || I.varyings,
      ...I
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: I.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(g) {
    g?.inputBuffers && this.model.setAttributes(g.inputBuffers), g?.outputBuffers && this.transformFeedback.setBuffers(g.outputBuffers);
    const I = this.device.beginRenderPass(g);
    this.model.draw(I), I.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(g) {
    return this.transformFeedback.getBuffer(g);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(g) {
    const I = this.getBuffer(g);
    if (!I)
      throw new Error("BufferTransform#getBuffer");
    if (I instanceof GA)
      return I.readAsync();
    const { buffer: C, byteOffset: t = 0, byteLength: s = C.byteLength } = I;
    return C.readAsync(t, s);
  }
}
class Pv {
  id;
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  vertexCount;
  indices;
  attributes;
  userData = {};
  constructor(g) {
    const { attributes: I = {}, indices: C = null, vertexCount: t = null } = g;
    this.id = g.id || I0("geometry"), this.topology = g.topology, C && (this.indices = ArrayBuffer.isView(C) ? { value: C, size: 1 } : C), this.attributes = {};
    for (const [s, r] of Object.entries(I)) {
      const l = ArrayBuffer.isView(r) ? { value: r } : r;
      if (!ArrayBuffer.isView(l.value))
        throw new Error(`${this._print(s)}: must be typed array or object with value as typed array`);
      if ((s === "POSITION" || s === "positions") && !l.size && (l.size = 3), s === "indices") {
        if (this.indices)
          throw new Error("Multiple indices detected");
        this.indices = l;
      } else
        this.attributes[s] = l;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = t || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(g) {
    return `Geometry ${this.id} attribute ${g}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(g, I) {
    return this;
  }
  _calculateVertexCount(g, I) {
    if (I)
      return I.value.length;
    let C = 1 / 0;
    for (const t of Object.values(g)) {
      const { value: s, size: r, constant: l } = t;
      !l && s && r !== void 0 && r >= 1 && (C = Math.min(C, s.length / r));
    }
    return C;
  }
}
const C3 = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class Zv extends vG {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(g) {
    return "pickingFBO" in g ? this._drawPickingBuffer(g) : super.render(g);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers: g, layerFilter: I, views: C, viewports: t, onViewportActive: s, pickingFBO: r, deviceRect: { x: l, y: d, width: h, height: D }, cullRect: w, effects: p, pass: b = "picking", pickZ: S, shaderModuleProps: K }) {
    this.pickZ = S;
    const Y = this._resetColorEncoder(S), T = [l, d, h, D], E = super.render({
      target: r,
      layers: g,
      layerFilter: I,
      views: C,
      viewports: t,
      onViewportActive: s,
      cullRect: w,
      effects: p?.filter((R) => R.useInPicking),
      pass: b,
      isPicking: !0,
      shaderModuleProps: K,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: T
    });
    return this._colorEncoderState = null, { decodePickingColor: Y && t3.bind(null, Y), stats: E };
  }
  shouldDrawLayer(g) {
    const { pickable: I, operation: C } = g.props;
    return I && C.includes("draw") || C.includes("terrain") || C.includes("mask");
  }
  getShaderModuleProps(g, I, C) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: { enabled: !1 }
    };
  }
  getLayerParameters(g, I, C) {
    const t = {
      ...g.props.parameters
    }, { pickable: s, operation: r } = g.props;
    return !this._colorEncoderState || r.includes("terrain") ? t.blend = !1 : s && r.includes("draw") && (Object.assign(t, C3), t.blend = !0, t.blendColor = e3(this._colorEncoderState, g, C)), t;
  }
  _resetColorEncoder(g) {
    return this._colorEncoderState = g ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function e3(A, g, I) {
  const { byLayer: C, byAlpha: t } = A;
  let s, r = C.get(g);
  return r ? (r.viewports.push(I), s = r.a) : (s = C.size + 1, s <= 255 ? (r = { a: s, layer: g, viewports: [I] }, C.set(g, r), t[s] = r) : (uA.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255];
}
function t3(A, g) {
  const I = A.byAlpha[g[3]];
  return I && {
    pickedLayer: I.layer,
    pickedViewports: I.viewports,
    pickedObjectIndex: I.layer.decodePickingColor(g)
  };
}
const sf = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, Hp = Symbol.for("component"), fc = Symbol.for("propTypes"), Pb = Symbol.for("deprecatedProps"), wf = Symbol.for("asyncPropDefaults"), pc = Symbol.for("asyncPropOriginal"), fr = Symbol.for("asyncPropResolved");
function jv(A, g = () => !0) {
  return Array.isArray(A) ? vv(A, g, []) : g(A) ? [A] : [];
}
function vv(A, g, I) {
  let C = -1;
  for (; ++C < A.length; ) {
    const t = A[C];
    Array.isArray(t) ? vv(t, g, I) : g(t) && I.push(t);
  }
  return I;
}
function i3({ target: A, source: g, start: I = 0, count: C = 1 }) {
  const t = g.length, s = C * t;
  let r = 0;
  for (let l = I; r < t; r++)
    A[l++] = g[r];
  for (; r < s; )
    r < s - r ? (A.copyWithin(I + r, I, I + r), r *= 2) : (A.copyWithin(I + r, I, I + s - r), r = s);
  return A;
}
class n3 {
  constructor(g, I, C) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = g, this.context = C, this.setData(I);
  }
  // consumer: {onChange: Function}
  subscribe(g) {
    this._subscribers.add(g);
  }
  unsubscribe(g) {
    this._subscribers.delete(g);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(g, I) {
    if (g === this._data && !I)
      return;
    this._data = g;
    const C = ++this._loadCount;
    let t = g;
    typeof g == "string" && (t = iS(g)), t instanceof Promise ? (this.isLoaded = !1, this._loader = t.then((s) => {
      this._loadCount === C && (this.isLoaded = !0, this._error = void 0, this._content = s);
    }).catch((s) => {
      this._loadCount === C && (this.isLoaded = !0, this._error = s || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = g);
    for (const s of this._subscribers)
      s.onChange(this.getData());
  }
}
class s3 {
  constructor(g) {
    this.protocol = g.protocol || "resource://", this._context = {
      device: g.device,
      // @ts-expect-error
      gl: g.device?.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(g) {
    return g.startsWith(this.protocol) ? !0 : g in this._resources;
  }
  add({ resourceId: g, data: I, forceUpdate: C = !1, persistent: t = !0 }) {
    let s = this._resources[g];
    s ? s.setData(I, C) : (s = new n3(g, I, this._context), this._resources[g] = s), s.persistent = t;
  }
  remove(g) {
    const I = this._resources[g];
    I && (I.delete(), delete this._resources[g]);
  }
  unsubscribe({ consumerId: g }) {
    const I = this._consumers[g];
    if (I) {
      for (const C in I) {
        const t = I[C], s = this._resources[t.resourceId];
        s && s.unsubscribe(t);
      }
      delete this._consumers[g], this.prune();
    }
  }
  subscribe({ resourceId: g, onChange: I, consumerId: C, requestId: t = "default" }) {
    const { _resources: s, protocol: r } = this;
    g.startsWith(r) && (g = g.replace(r, ""), s[g] || this.add({ resourceId: g, data: null, persistent: !1 }));
    const l = s[g];
    if (this._track(C, t, l, I), l)
      return l.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const g in this._resources)
      this._resources[g].delete();
  }
  _track(g, I, C, t) {
    const s = this._consumers, r = s[g] = s[g] || {};
    let l = r[I];
    const d = l && l.resourceId && this._resources[l.resourceId];
    d && (d.unsubscribe(l), this.prune()), C && (l ? (l.onChange = t, l.resourceId = C.id) : l = {
      onChange: t,
      resourceId: C.id
    }, r[I] = l, C.subscribe(l));
  }
  _prune() {
    this._pruneRequest = null;
    for (const g of Object.keys(this._resources)) {
      const I = this._resources[g];
      !I.persistent && !I.inUse() && (I.delete(), delete this._resources[g]);
    }
  }
}
const o3 = "layerManager.setLayers", a3 = "layerManager.activateViewport";
class r3 {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(g, I) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (l) => {
      Xe(a3, this, l), l && (this.context.viewport = l);
    };
    const { deck: C, stats: t, viewport: s, timeline: r } = I || {};
    this.layers = [], this.resourceManager = new s3({ device: g, protocol: "deck://" }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: g,
      // @ts-expect-error
      gl: g?.gl,
      deck: C,
      shaderAssembler: aU(g?.info?.shadingLanguage || "glsl"),
      defaultShaderModules: [M_],
      renderPass: void 0,
      stats: t || new Qp({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: s || new vc({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: r || new Gv(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const g of this.layers)
      this._finalizeLayer(g);
  }
  /** Check if a redraw is needed */
  needsRedraw(g = { clearRedrawFlags: !1 }) {
    let I = this._needsRedraw;
    g.clearRedrawFlags && (this._needsRedraw = !1);
    for (const C of this.layers) {
      const t = C.getNeedsRedraw(g);
      I = I || t;
    }
    return I;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(g) {
    this._needsRedraw = this._needsRedraw || g;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(g) {
    this._needsUpdate = this._needsUpdate || g;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds: g } = {}) {
    return g ? this.layers.filter((I) => g.find((C) => I.id.indexOf(C) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(g) {
    "debug" in g && (this._debug = g.debug), "userData" in g && (this.context.userData = g.userData), "layers" in g && (this._nextLayers = g.layers), "onError" in g && (this.context.onError = g.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(g, I) {
    Xe(o3, this, I, g), this._lastRenderedLayers = g;
    const C = jv(g, Boolean);
    for (const t of C)
      t.context = this.context;
    this._updateLayers(this.layers, C);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const g = this.needsUpdate();
    g && (this.setNeedsRedraw(`updating layers: ${g}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, g)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(g) {
    const { defaultShaderModules: I } = this.context;
    I.find((C) => C.name === g.name) || (I.push(g), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(g) {
    const { defaultShaderModules: I } = this.context, C = I.findIndex((t) => t.name === g.name);
    C >= 0 && (I.splice(C, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(g, I, C) {
    C.raiseError(I, `${g} of ${C}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(g, I) {
    const C = {};
    for (const r of g)
      C[r.id] ? uA.warn(`Multiple old layers with same id ${r.id}`)() : C[r.id] = r;
    if (this._defaultShaderModulesChanged) {
      for (const r of g)
        r.setNeedsUpdate(), r.setChangeFlags({ extensionsChanged: !0 });
      this._defaultShaderModulesChanged = !1;
    }
    const t = [];
    this._updateSublayersRecursively(I, C, t), this._finalizeOldLayers(C);
    let s = !1;
    for (const r of t)
      if (r.hasUniformTransition()) {
        s = `Uniform transition in ${r}`;
        break;
      }
    this._needsUpdate = s, this.layers = t;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(g, I, C) {
    for (const t of g) {
      t.context = this.context;
      const s = I[t.id];
      s === null && uA.warn(`Multiple new layers with same id ${t.id}`)(), I[t.id] = null;
      let r = null;
      try {
        this._debug && s !== t && t.validateProps(), s ? (this._transferLayerState(s, t), this._updateLayer(t)) : this._initializeLayer(t), C.push(t), r = t.isComposite ? t.getSubLayers() : null;
      } catch (l) {
        this._handleError("matching", l, t);
      }
      r && this._updateSublayersRecursively(r, I, C);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(g) {
    for (const I in g) {
      const C = g[I];
      C && this._finalizeLayer(C);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(g) {
    try {
      g._initialize(), g.lifecycle = sf.INITIALIZED;
    } catch (I) {
      this._handleError("initialization", I, g);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(g, I) {
    I._transferState(g), I.lifecycle = sf.MATCHED, I !== g && (g.lifecycle = sf.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(g) {
    try {
      g._update();
    } catch (I) {
      this._handleError("update", I, g);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(g) {
    this._needsRedraw = this._needsRedraw || `finalized ${g}`, g.lifecycle = sf.AWAITING_FINALIZATION;
    try {
      g._finalize(), g.lifecycle = sf.FINALIZED;
    } catch (I) {
      this._handleError("finalization", I, g);
    }
  }
}
function Qt(A, g, I) {
  if (A === g)
    return !0;
  if (!I || !A || !g)
    return !1;
  if (Array.isArray(A)) {
    if (!Array.isArray(g) || A.length !== g.length)
      return !1;
    for (let C = 0; C < A.length; C++)
      if (!Qt(A[C], g[C], I - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(g))
    return !1;
  if (typeof A == "object" && typeof g == "object") {
    const C = Object.keys(A), t = Object.keys(g);
    if (C.length !== t.length)
      return !1;
    for (const s of C)
      if (!g.hasOwnProperty(s) || !Qt(A[s], g[s], I - 1))
        return !1;
    return !0;
  }
  return !1;
}
class l3 {
  constructor(g) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = g.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = g.eventManager, this._eventCallbacks = {
      onViewStateChange: g.onViewStateChange,
      onInteractionStateChange: g.onInteractionStateChange
    }, Object.seal(this), this.setProps(g);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const g in this.controllers) {
      const I = this.controllers[g];
      I && I.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(g = { clearRedrawFlags: !1 }) {
    const I = this._needsRedraw;
    return g.clearRedrawFlags && (this._needsRedraw = !1), I;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(g) {
    this._needsUpdate = this._needsUpdate || g, this._needsRedraw = this._needsRedraw || g;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const g in this.controllers) {
      const I = this.controllers[g];
      I && I.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(g) {
    return g ? this._viewports.filter((I) => I.containsPixel(g)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const g = {};
    return this.views.forEach((I) => {
      g[I.id] = I;
    }), g;
  }
  /** Resolves a viewId string to a View */
  getView(g) {
    return this.views.find((I) => I.id === g);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(g) {
    const I = typeof g == "string" ? this.getView(g) : g, C = I && this.viewState[I.getViewStateId()] || this.viewState;
    return I ? I.filterViewState(C) : C;
  }
  getViewport(g) {
    return this._viewportMap[g];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(g, I) {
    const C = this.getViewports(), t = { x: g[0], y: g[1] };
    for (let s = C.length - 1; s >= 0; --s) {
      const r = C[s];
      if (r.containsPixel(t)) {
        const l = g.slice();
        return l[0] -= r.x, l[1] -= r.y, r.unproject(l, I);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(g) {
    g.views && this._setViews(g.views), g.viewState && this._setViewState(g.viewState), ("width" in g || "height" in g) && this._setSize(g.width, g.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(g, I) {
    (g !== this.width || I !== this.height) && (this.width = g, this.height = I, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(g) {
    g = jv(g, Boolean), this._diffViews(g, this.views) && this.setNeedsUpdate("views changed"), this.views = g;
  }
  _setViewState(g) {
    g ? (!Qt(g, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = g) : uA.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(g, I) {
    const C = I.type;
    return new C({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (s) => this.getView(g.id)?.makeViewport({
        viewState: s,
        width: this.width,
        height: this.height
      })
    });
  }
  _updateController(g, I, C, t) {
    const s = g.controller;
    if (s && C) {
      const r = {
        ...I,
        ...s,
        id: g.id,
        x: C.x,
        y: C.y,
        width: C.width,
        height: C.height
      };
      return (!t || t.constructor !== s.type) && (t = this._createController(g, r)), t && t.setProps(r), t;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views: g } = this, I = this.controllers;
    this._viewports = [], this.controllers = {};
    let C = !1;
    for (let t = g.length; t--; ) {
      const s = g[t], r = this.getViewState(s), l = s.makeViewport({ viewState: r, width: this.width, height: this.height });
      let d = I[s.id];
      const h = !!s.controller;
      h && !d && (C = !0), (C || !h) && d && (d.finalize(), d = null), this.controllers[s.id] = this._updateController(s, r, l, d), l && this._viewports.unshift(l);
    }
    for (const t in I) {
      const s = I[t];
      s && !this.controllers[t] && s.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((g) => {
      g.id && (this._viewportMap[g.id] = this._viewportMap[g.id] || g);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(g, I) {
    return g.length !== I.length ? !0 : g.some((C, t) => !g[t].equals(I[t]));
  }
}
const c3 = /([0-9]+\.?[0-9]*)(%|px)/;
function nr(A) {
  switch (typeof A) {
    case "number":
      return {
        position: A,
        relative: !1
      };
    case "string":
      const g = c3.exec(A);
      if (g && g.length >= 3) {
        const I = g[2] === "%", C = parseFloat(g[1]);
        return {
          position: I ? C / 100 : C,
          relative: I
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${A}`);
  }
}
function sr(A, g) {
  return A.relative ? Math.round(A.position * g) : A.position;
}
class Mr {
  constructor(g) {
    const { id: I, x: C = 0, y: t = 0, width: s = "100%", height: r = "100%", padding: l = null } = g;
    this.id = I || this.constructor.displayName || "view", this.props = { ...g, id: this.id }, this._x = nr(C), this._y = nr(t), this._width = nr(s), this._height = nr(r), this._padding = l && {
      left: nr(l.left || 0),
      right: nr(l.right || 0),
      top: nr(l.top || 0),
      bottom: nr(l.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(g) {
    return this === g ? !0 : this.constructor === g.constructor && Qt(this.props, g.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width: g, height: I, viewState: C }) {
    C = this.filterViewState(C);
    const t = this.getDimensions({ width: g, height: I });
    if (!t.height || !t.width)
      return null;
    const s = this.getViewportType(C);
    return new s({ ...C, ...this.props, ...t });
  }
  getViewStateId() {
    const { viewState: g } = this.props;
    return typeof g == "string" ? g : g?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(g) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const I = { ...g };
      for (const C in this.props.viewState)
        C !== "id" && (I[C] = this.props.viewState[C]);
      return I;
    }
    return g;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width: g, height: I }) {
    const C = {
      x: sr(this._x, g),
      y: sr(this._y, I),
      width: sr(this._width, g),
      height: sr(this._height, I)
    };
    return this._padding && (C.padding = {
      left: sr(this._padding.left, g),
      top: sr(this._padding.top, I),
      right: sr(this._padding.right, g),
      bottom: sr(this._padding.bottom, I)
    }), C;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const g = this.props.controller;
    return g ? g === !0 ? { type: this.ControllerType } : typeof g == "function" ? { type: g } : { type: this.ControllerType, ...g } : null;
  }
}
class A0 {
  /**
   * @params timeline {Timeline}
   */
  constructor(g) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = g;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(g) {
    this.cancel(), this.settings = g, this._inProgress = !0, this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const { _timeline: g, settings: I } = this;
      this._handle = g.addChannel({
        delay: g.getTime(),
        duration: I.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const f1 = () => {
}, SS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, u3 = (A) => A, d3 = SS.BREAK;
class f3 {
  constructor(g) {
    this._onTransitionUpdate = (I) => {
      const { time: C, settings: { interpolator: t, startProps: s, endProps: r, duration: l, easing: d } } = I, h = d(C / l), D = t.interpolateProps(s, r, h);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...D
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = g.getControllerState, this.propsInTransition = null, this.transition = new A0(g.timeline), this.onViewStateChange = g.onViewStateChange || f1, this.onStateChange = g.onStateChange || f1;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(g) {
    let I = !1;
    const C = this.props;
    if (this.props = g, !C || this._shouldIgnoreViewportChange(C, g))
      return !1;
    if (this._isTransitionEnabled(g)) {
      let t = C;
      if (this.transition.inProgress) {
        const { interruption: s, endProps: r } = this.transition.settings;
        t = {
          ...C,
          ...s === SS.SNAP_TO_END ? r : this.propsInTransition || C
        };
      }
      this._triggerTransition(t, g), I = !0;
    } else
      this.transition.cancel();
    return I;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(g) {
    const { transitionDuration: I, transitionInterpolator: C } = g;
    return (I > 0 || I === "auto") && !!C;
  }
  _isUpdateDueToCurrentTransition(g) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(g, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(g, I) {
    return this.transition.inProgress ? this.transition.settings.interruption === SS.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(I) : this._isTransitionEnabled(I) ? I.transitionInterpolator.arePropsEqual(g, I) : !0;
  }
  _triggerTransition(g, I) {
    const C = this.getControllerState(g), t = this.getControllerState(I).shortestPathFrom(C), s = I.transitionInterpolator, r = s.getDuration ? s.getDuration(g, I) : I.transitionDuration;
    if (r === 0)
      return;
    const l = s.initializeProps(g, t);
    this.propsInTransition = {};
    const d = {
      duration: r,
      easing: I.transitionEasing || u3,
      interpolator: s,
      interruption: I.transitionInterruption || d3,
      startProps: l.start,
      endProps: l.end,
      onStart: I.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(I.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(I.onTransitionEnd)
    };
    this.transition.start(d), this.onStateChange({ inTransition: !0 }), this.updateTransition();
  }
  _onTransitionEnd(g) {
    return (I) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), g?.(I);
    };
  }
}
function Ge(A, g) {
  if (!A)
    throw new Error(g || "deck.gl: assertion failed.");
}
class h3 {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(g) {
    const { compare: I, extract: C, required: t } = g;
    this._propsToCompare = I, this._propsToExtract = C || I, this._requiredProps = t;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(g, I) {
    for (const C of this._propsToCompare)
      if (!(C in g) || !(C in I) || !uM(g[C], I[C]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(g, I) {
    const C = {}, t = {};
    for (const s of this._propsToExtract)
      (s in g || s in I) && (C[s] = g[s], t[s] = I[s]);
    return this._checkRequiredProps(C), this._checkRequiredProps(t), { start: C, end: t };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(g, I) {
    return I.transitionDuration;
  }
  _checkRequiredProps(g) {
    this._requiredProps && this._requiredProps.forEach((I) => {
      const C = g[I];
      Ge(Number.isFinite(C) || Array.isArray(C), `${I} is required for transition`);
    });
  }
}
const y3 = ["longitude", "latitude", "zoom", "bearing", "pitch"], D3 = ["longitude", "latitude", "zoom"];
class C0 extends h3 {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(g = {}) {
    const I = Array.isArray(g) ? g : g.transitionProps, C = Array.isArray(g) ? {} : g;
    C.transitionProps = Array.isArray(I) ? {
      compare: I,
      required: I
    } : I || {
      compare: y3,
      required: D3
    }, super(C.transitionProps), this.opts = C;
  }
  initializeProps(g, I) {
    const C = super.initializeProps(g, I), { makeViewport: t, around: s } = this.opts;
    if (t && s) {
      const r = t(g), l = t(I), d = r.unproject(s);
      C.start.around = s, Object.assign(C.end, {
        around: l.project(d),
        aroundPosition: d,
        width: I.width,
        height: I.height
      });
    }
    return C;
  }
  interpolateProps(g, I, C) {
    const t = {};
    for (const s of this._propsToExtract)
      t[s] = Kp(g[s] || 0, I[s] || 0, C);
    if (I.aroundPosition && this.opts.makeViewport) {
      const s = this.opts.makeViewport({ ...I, ...t });
      Object.assign(t, s.panByPosition(
        I.aroundPosition,
        // anchor point in current screen coordinates
        Kp(g.around, I.around, C)
      ));
    }
    return t;
  }
}
const or = {
  transitionDuration: 0
}, M3 = 300, kB = (A) => 1 - (1 - A) * (1 - A), Af = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
}, oc = {};
class RG {
  constructor(g) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new f3({
      ...g,
      getControllerState: (I) => new this.ControllerState(I),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = g.eventManager, this.onViewStateChange = g.onViewStateChange || (() => {
    }), this.onStateChange = g.onStateChange || (() => {
    }), this.makeViewport = g.makeViewport;
  }
  set events(g) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(g, !0), this._customEvents = g, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const g in this._events)
      this._events[g] && this.eventManager?.off(g, this.handleEvent);
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(g) {
    this._controllerState = void 0;
    const I = this._eventStartBlocked;
    switch (g.type) {
      case "panstart":
        return I ? !1 : this._onPanStart(g);
      case "panmove":
        return this._onPan(g);
      case "panend":
        return this._onPanEnd(g);
      case "pinchstart":
        return I ? !1 : this._onPinchStart(g);
      case "pinchmove":
        return this._onPinch(g);
      case "pinchend":
        return this._onPinchEnd(g);
      case "multipanstart":
        return I ? !1 : this._onMultiPanStart(g);
      case "multipanmove":
        return this._onMultiPan(g);
      case "multipanend":
        return this._onMultiPanEnd(g);
      case "dblclick":
        return this._onDoubleClick(g);
      case "wheel":
        return this._onWheel(g);
      case "keydown":
        return this._onKeyDown(g);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(g) {
    const { x: I, y: C } = this.props, { offsetCenter: t } = g;
    return [t.x - I, t.y - C];
  }
  isPointInBounds(g, I) {
    const { width: C, height: t } = this.props;
    if (I && I.handled)
      return !1;
    const s = g[0] >= 0 && g[0] <= C && g[1] >= 0 && g[1] <= t;
    return s && I && I.stopPropagation(), s;
  }
  isFunctionKeyPressed(g) {
    const { srcEvent: I } = g;
    return !!(I.metaKey || I.altKey || I.ctrlKey || I.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(g) {
    const I = setTimeout(() => {
      this._eventStartBlocked === I && (this._eventStartBlocked = null);
    }, g);
    this._eventStartBlocked = I;
  }
  /**
   * Extract interactivity options
   */
  setProps(g) {
    g.dragMode && (this.dragMode = g.dragMode), this.props = g, "transitionInterpolator" in g || (g.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(g);
    const { inertia: I } = g;
    this.inertia = Number.isFinite(I) ? I : I === !0 ? M3 : 0;
    const { scrollZoom: C = !0, dragPan: t = !0, dragRotate: s = !0, doubleClickZoom: r = !0, touchZoom: l = !0, touchRotate: d = !1, keyboard: h = !0 } = g, D = !!this.onViewStateChange;
    this.toggleEvents(Af.WHEEL, D && C), this.toggleEvents(Af.PAN, D), this.toggleEvents(Af.PINCH, D && (l || d)), this.toggleEvents(Af.MULTI_PAN, D && d), this.toggleEvents(Af.DOUBLE_CLICK, D && r), this.toggleEvents(Af.KEYBOARD, D && h), this.scrollZoom = C, this.dragPan = t, this.dragRotate = s, this.doubleClickZoom = r, this.touchZoom = l, this.touchRotate = d, this.keyboard = h;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(g, I) {
    this.eventManager && g.forEach((C) => {
      this._events[C] !== I && (this._events[C] = I, I ? this.eventManager.on(C, this.handleEvent) : this.eventManager.off(C, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(g, I = null, C = {}) {
    const t = { ...g.getViewportProps(), ...I }, s = this.controllerState !== g;
    if (this.state = g.getState(), this._setInteractionState(C), s) {
      const r = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({ viewState: t, interactionState: this._interactionState, oldViewState: r, viewId: this.props.id });
    }
  }
  _onTransition(g) {
    this.onViewStateChange({ ...g, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(g) {
    Object.assign(this._interactionState, g), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(g) {
    const I = this.getCenter(g);
    if (!this.isPointInBounds(I, g))
      return !1;
    let C = this.isFunctionKeyPressed(g) || g.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (C = !C);
    const t = this.controllerState[C ? "panStart" : "rotateStart"]({
      pos: I
    });
    return this._panMove = C, this.updateViewport(t, or, { isDragging: !0 }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(g) {
    return this.isDragging() ? this._panMove ? this._onPanMove(g) : this._onPanRotate(g) : !1;
  }
  _onPanEnd(g) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(g) : this._onPanRotateEnd(g) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(g) {
    if (!this.dragPan)
      return !1;
    const I = this.getCenter(g), C = this.controllerState.pan({ pos: I });
    return this.updateViewport(C, or, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(g) {
    const { inertia: I } = this;
    if (this.dragPan && I && g.velocity) {
      const C = this.getCenter(g), t = [
        C[0] + g.velocityX * I / 2,
        C[1] + g.velocityY * I / 2
      ], s = this.controllerState.pan({ pos: t }).panEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: I,
        transitionEasing: kB
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const C = this.controllerState.panEnd();
      this.updateViewport(C, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(g) {
    if (!this.dragRotate)
      return !1;
    const I = this.getCenter(g), C = this.controllerState.rotate({ pos: I });
    return this.updateViewport(C, or, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(g) {
    const { inertia: I } = this;
    if (this.dragRotate && I && g.velocity) {
      const C = this.getCenter(g), t = [
        C[0] + g.velocityX * I / 2,
        C[1] + g.velocityY * I / 2
      ], s = this.controllerState.rotate({ pos: t }).rotateEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: I,
        transitionEasing: kB
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const C = this.controllerState.rotateEnd();
      this.updateViewport(C, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(g) {
    if (!this.scrollZoom)
      return !1;
    const I = this.getCenter(g);
    if (!this.isPointInBounds(I, g))
      return !1;
    g.srcEvent.preventDefault();
    const { speed: C = 0.01, smooth: t = !1 } = this.scrollZoom === !0 ? {} : this.scrollZoom, { delta: s } = g;
    let r = 2 / (1 + Math.exp(-Math.abs(s * C)));
    s < 0 && r !== 0 && (r = 1 / r);
    const l = this.controllerState.zoom({ pos: I, scale: r });
    return this.updateViewport(l, { ...this._getTransitionProps({ around: I }), transitionDuration: t ? 250 : 1 }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onMultiPanStart(g) {
    const I = this.getCenter(g);
    if (!this.isPointInBounds(I, g))
      return !1;
    const C = this.controllerState.rotateStart({ pos: I });
    return this.updateViewport(C, or, { isDragging: !0 }), !0;
  }
  _onMultiPan(g) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const I = this.getCenter(g);
    I[0] -= g.deltaX;
    const C = this.controllerState.rotate({ pos: I });
    return this.updateViewport(C, or, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onMultiPanEnd(g) {
    if (!this.isDragging())
      return !1;
    const { inertia: I } = this;
    if (this.touchRotate && I && g.velocityY) {
      const C = this.getCenter(g), t = [C[0], C[1] += g.velocityY * I / 2], s = this.controllerState.rotate({ pos: t });
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: I,
        transitionEasing: kB
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(I);
    } else {
      const C = this.controllerState.rotateEnd();
      this.updateViewport(C, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(g) {
    const I = this.getCenter(g);
    if (!this.isPointInBounds(I, g))
      return !1;
    const C = this.controllerState.zoomStart({ pos: I }).rotateStart({ pos: I });
    return oc._startPinchRotation = g.rotation, oc._lastPinchEvent = g, this.updateViewport(C, or, { isDragging: !0 }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(g) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let I = this.controllerState;
    if (this.touchZoom) {
      const { scale: C } = g, t = this.getCenter(g);
      I = I.zoom({ pos: t, scale: C });
    }
    if (this.touchRotate) {
      const { rotation: C } = g;
      I = I.rotate({
        deltaAngleX: oc._startPinchRotation - C
      });
    }
    return this.updateViewport(I, or, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), oc._lastPinchEvent = g, !0;
  }
  _onPinchEnd(g) {
    if (!this.isDragging())
      return !1;
    const { inertia: I } = this, { _lastPinchEvent: C } = oc;
    if (this.touchZoom && I && C && g.scale !== C.scale) {
      const t = this.getCenter(g);
      let s = this.controllerState.rotateEnd();
      const r = Math.log2(g.scale), l = (r - Math.log2(C.scale)) / (g.deltaTime - C.deltaTime), d = Math.pow(2, r + l * I / 2);
      s = s.zoom({ pos: t, scale: d }).zoomEnd(), this.updateViewport(s, {
        ...this._getTransitionProps({ around: t }),
        transitionDuration: I,
        transitionEasing: kB
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(I);
    } else {
      const t = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(t, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return oc._startPinchRotation = null, oc._lastPinchEvent = null, !0;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(g) {
    if (!this.doubleClickZoom)
      return !1;
    const I = this.getCenter(g);
    if (!this.isPointInBounds(I, g))
      return !1;
    const C = this.isFunctionKeyPressed(g), t = this.controllerState.zoom({ pos: I, scale: C ? 0.5 : 2 });
    return this.updateViewport(t, this._getTransitionProps({ around: I }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(g) {
    if (!this.keyboard)
      return !1;
    const I = this.isFunctionKeyPressed(g), { zoomSpeed: C, moveSpeed: t, rotateSpeedX: s, rotateSpeedY: r } = this.keyboard === !0 ? {} : this.keyboard, { controllerState: l } = this;
    let d;
    const h = {};
    switch (g.srcEvent.code) {
      case "Minus":
        d = I ? l.zoomOut(C).zoomOut(C) : l.zoomOut(C), h.isZooming = !0;
        break;
      case "Equal":
        d = I ? l.zoomIn(C).zoomIn(C) : l.zoomIn(C), h.isZooming = !0;
        break;
      case "ArrowLeft":
        I ? (d = l.rotateLeft(s), h.isRotating = !0) : (d = l.moveLeft(t), h.isPanning = !0);
        break;
      case "ArrowRight":
        I ? (d = l.rotateRight(s), h.isRotating = !0) : (d = l.moveRight(t), h.isPanning = !0);
        break;
      case "ArrowUp":
        I ? (d = l.rotateUp(r), h.isRotating = !0) : (d = l.moveUp(t), h.isPanning = !0);
        break;
      case "ArrowDown":
        I ? (d = l.rotateDown(r), h.isRotating = !0) : (d = l.moveDown(t), h.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(d, this._getTransitionProps(), h), !0;
  }
  _getTransitionProps(g) {
    const { transition: I } = this;
    return !I || !I.transitionInterpolator ? or : g ? {
      ...I,
      transitionInterpolator: new C0({
        ...g,
        ...I.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : I;
  }
}
class Hv {
  constructor(g, I) {
    this._viewportProps = this.applyConstraints(g), this._state = I;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const h1 = 5, w3 = 1.2;
class B3 extends Hv {
  constructor(g) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: I,
      /** The height of the viewport */
      height: C,
      /** The latitude at the center of the viewport */
      latitude: t,
      /** The longitude at the center of the viewport */
      longitude: s,
      /** The tile zoom level of the map. */
      zoom: r,
      /** The bearing of the viewport in degrees */
      bearing: l = 0,
      /** The pitch of the viewport in degrees */
      pitch: d = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: h = 1.5,
      /** Viewport position */
      position: D = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: w = 20,
      minZoom: p = 0,
      maxPitch: b = 60,
      minPitch: S = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: K,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: Y,
      /* Pointer position when rotation started */
      startRotatePos: T,
      /** Bearing when current perspective rotate operation started */
      startBearing: E,
      /** Pitch when current perspective rotate operation started */
      startPitch: H,
      /** Zoom when current zoom operation started */
      startZoom: R,
      /** Normalize viewport props to fit map height into viewport */
      normalize: x = !0
    } = g;
    Ge(Number.isFinite(s)), Ge(Number.isFinite(t)), Ge(Number.isFinite(r)), super({
      width: I,
      height: C,
      latitude: t,
      longitude: s,
      zoom: r,
      bearing: l,
      pitch: d,
      altitude: h,
      maxZoom: w,
      minZoom: p,
      maxPitch: b,
      minPitch: S,
      normalize: x,
      position: D
    }, {
      startPanLngLat: K,
      startZoomLngLat: Y,
      startRotatePos: T,
      startBearing: E,
      startPitch: H,
      startZoom: R
    }), this.makeViewport = g.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos: g }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(g)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos: g, startPos: I }) {
    const C = this.getState().startPanLngLat || this._unproject(I);
    if (!C)
      return this;
    const s = this.makeViewport(this.getViewportProps()).panByPosition(C, g);
    return this._getUpdatedState(s);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos: g }) {
    return this._getUpdatedState({
      startRotatePos: g,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos: g, deltaAngleX: I = 0, deltaAngleY: C = 0 }) {
    const { startRotatePos: t, startBearing: s, startPitch: r } = this.getState();
    if (!t || s === void 0 || r === void 0)
      return this;
    let l;
    return g ? l = this._getNewRotation(g, t, r, s) : l = {
      bearing: s + I,
      pitch: r + C
    }, this._getUpdatedState(l);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos: g }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(g),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos: g, startPos: I, scale: C }) {
    let { startZoom: t, startZoomLngLat: s } = this.getState();
    if (s || (t = this.getViewportProps().zoom, s = this._unproject(I) || this._unproject(g)), !s)
      return this;
    const { maxZoom: r, minZoom: l } = this.getViewportProps();
    let d = t + Math.log2(C);
    d = xC(d, l, r);
    const h = this.makeViewport({ ...this.getViewportProps(), zoom: d });
    return this._getUpdatedState({
      zoom: d,
      ...h.panByPosition(s, g)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(g = 2) {
    return this._zoomFromCenter(g);
  }
  zoomOut(g = 2) {
    return this._zoomFromCenter(1 / g);
  }
  moveLeft(g = 100) {
    return this._panFromCenter([g, 0]);
  }
  moveRight(g = 100) {
    return this._panFromCenter([-g, 0]);
  }
  moveUp(g = 100) {
    return this._panFromCenter([0, g]);
  }
  moveDown(g = 100) {
    return this._panFromCenter([0, -g]);
  }
  rotateLeft(g = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - g
    });
  }
  rotateRight(g = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + g
    });
  }
  rotateUp(g = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + g
    });
  }
  rotateDown(g = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - g
    });
  }
  shortestPathFrom(g) {
    const I = g.getViewportProps(), C = { ...this.getViewportProps() }, { bearing: t, longitude: s } = C;
    return Math.abs(t - I.bearing) > 180 && (C.bearing = t < 0 ? t + 360 : t - 360), Math.abs(s - I.longitude) > 180 && (C.longitude = s < 0 ? s + 360 : s - 360), C;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(g) {
    const { maxZoom: I, minZoom: C, zoom: t } = g;
    g.zoom = xC(t, C, I);
    const { maxPitch: s, minPitch: r, pitch: l } = g;
    g.pitch = xC(l, r, s);
    const { normalize: d = !0 } = g;
    return d && Object.assign(g, Q9(g)), g;
  }
  /* Private methods */
  _zoomFromCenter(g) {
    const { width: I, height: C } = this.getViewportProps();
    return this.zoom({
      pos: [I / 2, C / 2],
      scale: g
    });
  }
  _panFromCenter(g) {
    const { width: I, height: C } = this.getViewportProps();
    return this.pan({
      startPos: [I / 2, C / 2],
      pos: [I / 2 + g[0], C / 2 + g[1]]
    });
  }
  _getUpdatedState(g) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...g
    });
  }
  _unproject(g) {
    const I = this.makeViewport(this.getViewportProps());
    return g && I.unproject(g);
  }
  _getNewRotation(g, I, C, t) {
    const s = g[0] - I[0], r = g[1] - I[1], l = g[1], d = I[1], { width: h, height: D } = this.getViewportProps(), w = s / h;
    let p = 0;
    r > 0 ? Math.abs(D - d) > h1 && (p = r / (d - D) * w3) : r < 0 && d > h1 && (p = 1 - l / d), p = xC(p, -1, 1);
    const { minPitch: b, maxPitch: S } = this.getViewportProps(), K = t + 180 * w;
    let Y = C;
    return p > 0 ? Y = C + p * (S - C) : p < 0 && (Y = C - p * (b - C)), {
      pitch: Y,
      bearing: K
    };
  }
}
class p3 extends RG {
  constructor() {
    super(...arguments), this.ControllerState = B3, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new C0({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(g) {
    g.position = g.position || [0, 0, 0];
    const I = this.props;
    super.setProps(g), (!I || I.height !== g.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...g,
      ...this.state
    }));
  }
}
class Ev extends Mr {
  constructor(g = {}) {
    super(g);
  }
  getViewportType() {
    return Yf;
  }
  get ControllerType() {
    return p3;
  }
}
Ev.displayName = "MapView";
const m3 = new bv();
function b3(A, g) {
  const I = A.order ?? 1 / 0, C = g.order ?? 1 / 0;
  return I - C;
}
class S3 {
  constructor(g) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = g, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(g) {
    const I = this._defaultEffects;
    if (!I.find((C) => C.id === g.id)) {
      const C = I.findIndex((t) => b3(t, g) > 0);
      C < 0 ? I.push(g) : I.splice(C, 0, g), g.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(g) {
    "effects" in g && (Qt(g.effects, this.effects, 1) || this._setEffects(g.effects));
  }
  needsRedraw(g = { clearRedrawFlags: !1 }) {
    const I = this._needsRedraw;
    return g.clearRedrawFlags && (this._needsRedraw = !1), I;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(g) {
    const I = {};
    for (const t of this.effects)
      I[t.id] = t;
    const C = [];
    for (const t of g) {
      const s = I[t.id];
      let r = t;
      s && s !== t ? s.setProps ? (s.setProps(t.props), r = s) : s.cleanup(this._context) : s || t.setup(this._context), C.push(r), delete I[t.id];
    }
    for (const t in I)
      I[t].cleanup(this._context);
    this.effects = C, this._resolvedEffects = C.concat(this._defaultEffects), g.some((t) => t instanceof bv) || this._resolvedEffects.push(m3), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const g of this._resolvedEffects)
      g.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class G3 extends vG {
  shouldDrawLayer(g) {
    const { operation: I } = g.props;
    return I.includes("draw") || I.includes("terrain");
  }
}
const K3 = "deckRenderer.renderLayers";
class T3 {
  constructor(g) {
    this.device = g, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new G3(g), this.pickLayersPass = new Zv(g), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(g) {
    this.layerFilter !== g.layerFilter && (this.layerFilter = g.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== g.drawPickingColors && (this.drawPickingColors = g.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(g) {
    if (!g.viewports.length)
      return;
    const I = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, C = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...g
    };
    C.effects && this._preRender(C.effects, C);
    const t = this.lastPostProcessEffect ? this.renderBuffers[0] : C.target;
    this.lastPostProcessEffect && (C.clearColor = [0, 0, 0, 0], C.clearCanvas = !0);
    const s = I.render({ ...C, target: t });
    C.effects && this._postRender(C.effects, C), this.renderCount++, Xe(K3, this, s, g);
  }
  needsRedraw(g = { clearRedrawFlags: !1 }) {
    const I = this._needsRedraw;
    return g.clearRedrawFlags && (this._needsRedraw = !1), I;
  }
  finalize() {
    const { renderBuffers: g } = this;
    for (const I of g)
      I.delete();
    g.length = 0;
  }
  _preRender(g, I) {
    this.lastPostProcessEffect = null, I.preRenderStats = I.preRenderStats || {};
    for (const C of g)
      I.preRenderStats[C.id] = C.preRender(I), C.postRender && (this.lastPostProcessEffect = C.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const { renderBuffers: g } = this, I = this.device.canvasContext.getDrawingBufferSize();
    g.length === 0 && [0, 1].map((C) => {
      const t = this.device.createTexture({
        sampler: { minFilter: "linear", magFilter: "linear" }
      });
      g.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${C}`,
        colorAttachments: [t]
      }));
    });
    for (const C of g)
      C.resize(I);
  }
  _postRender(g, I) {
    const { renderBuffers: C } = this, t = {
      ...I,
      inputBuffer: C[0],
      swapBuffer: C[1]
    };
    for (const s of g)
      if (s.postRender) {
        t.target = s.id === this.lastPostProcessEffect ? I.target : void 0;
        const r = s.postRender(t);
        t.inputBuffer = r, t.swapBuffer = r === C[0] ? C[1] : C[0];
      }
  }
}
const Y3 = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function P3({ pickedColors: A, decodePickingColor: g, deviceX: I, deviceY: C, deviceRadius: t, deviceRect: s }) {
  const { x: r, y: l, width: d, height: h } = s;
  let D = t * t, w = -1, p = 0;
  for (let b = 0; b < h; b++) {
    const S = b + l - C, K = S * S;
    if (K > D)
      p += 4 * d;
    else
      for (let Y = 0; Y < d; Y++) {
        if (A[p + 3] - 1 >= 0) {
          const E = Y + r - I, H = E * E + K;
          H <= D && (D = H, w = p);
        }
        p += 4;
      }
  }
  if (w >= 0) {
    const b = A.slice(w, w + 4), S = g(b);
    if (S) {
      const K = Math.floor(w / 4 / d), Y = w / 4 - K * d;
      return {
        ...S,
        pickedColor: b,
        pickedX: r + Y,
        pickedY: l + K
      };
    }
    uA.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return Y3;
}
function Z3({ pickedColors: A, decodePickingColor: g }) {
  const I = /* @__PURE__ */ new Map();
  if (A) {
    for (let C = 0; C < A.length; C += 4)
      if (A[C + 3] - 1 >= 0) {
        const s = A.slice(C, C + 4), r = s.join(",");
        if (!I.has(r)) {
          const l = g(s);
          l ? I.set(r, {
            ...l,
            color: s
          }) : uA.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(I.values());
}
function Rv({ pickInfo: A, viewports: g, pixelRatio: I, x: C, y: t, z: s }) {
  let r = g[0];
  g.length > 1 && (r = v3(A?.pickedViewports || g, { x: C, y: t }));
  let l;
  if (r) {
    const d = [C - r.x, t - r.y];
    s !== void 0 && (d[2] = s), l = r.unproject(d);
  }
  return {
    color: null,
    layer: null,
    viewport: r,
    index: -1,
    picked: !1,
    x: C,
    y: t,
    pixel: [C, t],
    coordinate: l,
    devicePixel: A && "pickedX" in A ? [A.pickedX, A.pickedY] : void 0,
    pixelRatio: I
  };
}
function j3(A) {
  const { pickInfo: g, lastPickedInfo: I, mode: C, layers: t } = A, { pickedColor: s, pickedLayer: r, pickedObjectIndex: l } = g, d = r ? [r] : [];
  if (C === "hover") {
    const w = I.index, p = I.layerId, b = r ? r.props.id : null;
    if (b !== p || l !== w) {
      if (b !== p) {
        const S = t.find((K) => K.props.id === p);
        S && d.unshift(S);
      }
      I.layerId = b, I.index = l, I.info = null;
    }
  }
  const h = Rv(A), D = /* @__PURE__ */ new Map();
  return D.set(null, h), d.forEach((w) => {
    let p = { ...h };
    w === r && (p.color = s, p.index = l, p.picked = !0), p = Ov({ layer: w, info: p, mode: C });
    const b = p.layer;
    w === r && C === "hover" && (I.info = p), D.set(b.id, p), C === "hover" && b.updateAutoHighlight(p);
  }), D;
}
function Ov({ layer: A, info: g, mode: I }) {
  for (; A && g; ) {
    const C = g.layer || null;
    g.sourceLayer = C, g.layer = A, g = A.getPickingInfo({ info: g, mode: I, sourceLayer: C }), A = A.parent;
  }
  return g;
}
function v3(A, g) {
  for (let I = A.length - 1; I >= 0; I--) {
    const C = A[I];
    if (C.containsPixel(g))
      return C;
  }
  return A[0];
}
class H3 {
  constructor(g) {
    this._pickable = !0, this.device = g, this.pickLayersPass = new Zv(g), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(g) {
    "layerFilter" in g && (this.layerFilter = g.layerFilter), "_pickable" in g && (this._pickable = g._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /** Pick the closest info at given coordinate */
  pickObject(g) {
    return this._pickClosestObject(g);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(g) {
    return this._pickVisibleObjects(g);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: g, y: I, layers: C, viewports: t }, s = this.lastPickedInfo.info) {
    const r = s && s.layer && s.layer.id, l = s && s.viewport && s.viewport.id, d = r ? C.find((p) => p.id === r) : null, h = l && t.find((p) => p.id === l) || t[0], D = h && h.unproject([g - h.x, I - h.y]);
    return { ...s, ...{
      x: g,
      y: I,
      viewport: h,
      coordinate: D,
      layer: d
    } };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const I = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = I;
    }
    const { canvas: g } = this.device.getDefaultCanvasContext();
    this.pickingFBO?.resize({ width: g.width, height: g.height }), this.depthFBO?.resize({ width: g.width, height: g.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(g) {
    if (this._pickable === !1)
      return null;
    const I = g.filter((C) => this.pickLayersPass.shouldDrawLayer(C) && !C.isComposite);
    return I.length ? I : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers: g, views: I, viewports: C, x: t, y: s, radius: r = 0, depth: l = 1, mode: d = "query", unproject3D: h, onViewportActive: D, effects: w }) {
    const p = this.device.canvasContext.cssToDeviceRatio(), b = this._getPickable(g);
    if (!b || C.length === 0)
      return {
        result: [],
        emptyInfo: Rv({ viewports: C, x: t, y: s, pixelRatio: p })
      };
    this._resizeBuffer();
    const S = this.device.canvasContext.cssToDevicePixels([t, s], !0), K = [
      S.x + Math.floor(S.width / 2),
      S.y + Math.floor(S.height / 2)
    ], Y = Math.round(r * p), { width: T, height: E } = this.pickingFBO, H = this._getPickingRect({
      deviceX: K[0],
      deviceY: K[1],
      deviceRadius: Y,
      deviceWidth: T,
      deviceHeight: E
    }), R = {
      x: t - r,
      y: s - r,
      width: r * 2 + 1,
      height: r * 2 + 1
    };
    let x;
    const U = [], J = /* @__PURE__ */ new Set();
    for (let L = 0; L < l; L++) {
      let eg;
      if (H) {
        const ig = this._drawAndSample({
          layers: b,
          views: I,
          viewports: C,
          onViewportActive: D,
          deviceRect: H,
          cullRect: R,
          effects: w,
          pass: `picking:${d}`
        });
        eg = P3({
          ...ig,
          deviceX: K[0],
          deviceY: K[1],
          deviceRadius: Y,
          deviceRect: H
        });
      } else
        eg = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let Mg;
      if (eg.pickedLayer && h && this.depthFBO) {
        const { pickedColors: ig } = this._drawAndSample({
          layers: [eg.pickedLayer],
          views: I,
          viewports: C,
          onViewportActive: D,
          deviceRect: {
            x: eg.pickedX,
            y: eg.pickedY,
            width: 1,
            height: 1
          },
          cullRect: R,
          effects: w,
          pass: `picking:${d}:z`
        }, !0);
        ig[3] && (Mg = ig[0]);
      }
      eg.pickedLayer && L + 1 < l && (J.add(eg.pickedLayer), eg.pickedLayer.disablePickingIndex(eg.pickedObjectIndex)), x = j3({
        pickInfo: eg,
        lastPickedInfo: this.lastPickedInfo,
        mode: d,
        layers: b,
        viewports: C,
        x: t,
        y: s,
        z: Mg,
        pixelRatio: p
      });
      for (const ig of x.values())
        ig.layer && U.push(ig);
      if (!eg.pickedColor)
        break;
    }
    for (const L of J)
      L.restorePickingColors();
    return { result: U, emptyInfo: x.get(null) };
  }
  /** Pick all objects within the given bounding box */
  // eslint-disable-next-line max-statements
  _pickVisibleObjects({ layers: g, views: I, viewports: C, x: t, y: s, width: r = 1, height: l = 1, mode: d = "query", maxObjects: h = null, onViewportActive: D, effects: w }) {
    const p = this._getPickable(g);
    if (!p || C.length === 0)
      return [];
    this._resizeBuffer();
    const b = this.device.canvasContext.cssToDeviceRatio(), S = this.device.canvasContext.cssToDevicePixels([t, s], !0), K = S.x, Y = S.y + S.height, T = this.device.canvasContext.cssToDevicePixels([t + r, s + l], !0), E = T.x + T.width, H = T.y, R = {
      x: K,
      y: H,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: E - K,
      height: Y - H
    }, x = this._drawAndSample({
      layers: p,
      views: I,
      viewports: C,
      onViewportActive: D,
      deviceRect: R,
      cullRect: { x: t, y: s, width: r, height: l },
      effects: w,
      pass: `picking:${d}`
    }), U = Z3(x), J = /* @__PURE__ */ new Map(), L = [], eg = Number.isFinite(h);
    for (let Mg = 0; Mg < U.length && !(eg && L.length >= h); Mg++) {
      const ig = U[Mg];
      let Zg = {
        color: ig.pickedColor,
        layer: null,
        index: ig.pickedObjectIndex,
        picked: !0,
        x: t,
        y: s,
        pixelRatio: b
      };
      Zg = Ov({ layer: ig.pickedLayer, info: Zg, mode: d });
      const Kg = Zg.layer.id;
      J.has(Kg) || J.set(Kg, /* @__PURE__ */ new Set());
      const mg = J.get(Kg), Ng = Zg.object ?? Zg.index;
      mg.has(Ng) || (mg.add(Ng), L.push(Zg));
    }
    return L;
  }
  _drawAndSample({ layers: g, views: I, viewports: C, onViewportActive: t, deviceRect: s, cullRect: r, effects: l, pass: d }, h = !1) {
    const D = h ? this.depthFBO : this.pickingFBO, w = {
      layers: g,
      layerFilter: this.layerFilter,
      views: I,
      viewports: C,
      onViewportActive: t,
      pickingFBO: D,
      deviceRect: s,
      cullRect: r,
      effects: l,
      pass: d,
      pickZ: h,
      preRenderStats: {},
      isPicking: !0
    };
    for (const E of l)
      E.useInPicking && (w.preRenderStats[E.id] = E.preRender(w));
    const { decodePickingColor: p } = this.pickLayersPass.render(w), { x: b, y: S, width: K, height: Y } = s, T = new (h ? Float32Array : Uint8Array)(K * Y * 4);
    return this.device.readPixelsToArrayWebGL(D, {
      sourceX: b,
      sourceY: S,
      sourceWidth: K,
      sourceHeight: Y,
      target: T
    }), { pickedColors: T, decodePickingColor: p };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect({ deviceX: g, deviceY: I, deviceRadius: C, deviceWidth: t, deviceHeight: s }) {
    const r = Math.max(0, g - C), l = Math.max(0, I - C), d = Math.min(t, g + C + 1) - r, h = Math.min(s, I + C + 1) - l;
    return d <= 0 || h <= 0 ? null : { x: r, y: l, width: d, height: h };
  }
}
const E3 = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
}, R3 = "top-left", y1 = "__root";
class O3 {
  constructor({ deck: g, parentElement: I }) {
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = g, this.parentElement = I;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(g) {
    g.widgets && !Qt(g.widgets, this.widgets, 1) && this._setWidgets(g.widgets);
  }
  finalize() {
    for (const g of this.getWidgets())
      this._remove(g);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const g in this.containers)
      this.containers[g].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(g) {
    this.defaultWidgets.find((I) => I.id === g.id) || (this._add(g), this.defaultWidgets.push(g), this._setWidgets(this.widgets));
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(g) {
    const I = {};
    for (const C of this.resolvedWidgets)
      I[C.id] = C;
    this.resolvedWidgets.length = 0;
    for (const C of this.defaultWidgets)
      I[C.id] = null, this.resolvedWidgets.push(C);
    for (let C of g) {
      const t = I[C.id];
      t ? /* Widget placement changed */ t.viewId !== C.viewId || t.placement !== C.placement ? (this._remove(t), this._add(C)) : C !== t && (t.setProps(C.props), C = t) : this._add(C), I[C.id] = null, this.resolvedWidgets.push(C);
    }
    for (const C in I) {
      const t = I[C];
      t && this._remove(t);
    }
    this.widgets = g;
  }
  _add(g) {
    const { viewId: I = null, placement: C = R3 } = g, t = g.onAdd({ deck: this.deck, viewId: I });
    t && this._getContainer(I, C).append(t), g._element = t;
  }
  _remove(g) {
    g.onRemove?.(), g._element && g._element.remove(), g._element = void 0;
  }
  /* global document */
  _getContainer(g, I) {
    const C = g || y1;
    let t = this.containers[C];
    t || (t = document.createElement("div"), t.style.pointerEvents = "none", t.style.position = "absolute", t.style.overflow = "hidden", this.parentElement?.append(t), this.containers[C] = t);
    let s = t.querySelector(`.${I}`);
    return s || (s = document.createElement("div"), s.className = I, s.style.position = "absolute", s.style.zIndex = "2", Object.assign(s.style, E3[I]), t.append(s)), s;
  }
  _updateContainers() {
    const g = this.deck.width, I = this.deck.height;
    for (const C in this.containers) {
      const t = this.lastViewports[C] || null, s = C === y1 || t, r = this.containers[C];
      s ? (r.style.display = "block", r.style.left = `${t ? t.x : 0}px`, r.style.top = `${t ? t.y : 0}px`, r.style.width = `${t ? t.width : g}px`, r.style.height = `${t ? t.height : I}px`) : r.style.display = "none";
    }
  }
  onRedraw({ viewports: g, layers: I }) {
    const C = g.reduce((t, s) => (t[s.id] = s, t), {});
    for (const t of this.getWidgets()) {
      const { viewId: s } = t;
      if (s) {
        const r = C[s];
        r && (t.onViewportChange && t.onViewportChange(r), t.onRedraw?.({ viewports: [r], layers: I }));
      } else {
        if (t.onViewportChange)
          for (const r of g)
            t.onViewportChange(r);
        t.onRedraw?.({ viewports: g, layers: I });
      }
    }
    this.lastViewports = C, this._updateContainers();
  }
  onHover(g, I) {
    for (const C of this.getWidgets()) {
      const { viewId: t } = C;
      (!t || t === g.viewport?.id) && C.onHover?.(g, I);
    }
  }
  onEvent(g, I) {
    const C = MS[I.type];
    if (C)
      for (const t of this.getWidgets()) {
        const { viewId: s } = t;
        (!s || s === g.viewport?.id) && t[C]?.(g, I);
      }
  }
}
const N3 = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class k3 {
  constructor() {
    this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
  }
  onAdd({ deck: g }) {
    const I = document.createElement("div");
    return I.className = "deck-tooltip", Object.assign(I.style, N3), this.deck = g, this.element = I, I;
  }
  onRemove() {
    this.deck = void 0, this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(g) {
    this.isVisible && g.id === this.lastViewport?.id && g !== this.lastViewport && this.setTooltip(null);
  }
  onHover(g) {
    const { deck: I } = this, C = I && I.props.getTooltip;
    if (!C)
      return;
    const t = C(g);
    this.lastViewport = g.viewport, this.setTooltip(t, g.x, g.y);
  }
  setTooltip(g, I, C) {
    const t = this.element;
    if (t) {
      if (typeof g == "string")
        t.innerText = g;
      else if (g)
        g.text && (t.innerText = g.text), g.html && (t.innerHTML = g.html), g.className && (t.className = g.className);
      else {
        this.isVisible = !1, t.style.display = "none";
        return;
      }
      this.isVisible = !0, t.style.display = "block", t.style.transform = `translate(${I}px, ${C}px)`, g && typeof g == "object" && "style" in g && Object.assign(t.style, g.style);
    }
  }
}
var cf;
(function(A) {
  A[A.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", A[A.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", A[A.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", A[A.POINTS = 0] = "POINTS", A[A.LINES = 1] = "LINES", A[A.LINE_LOOP = 2] = "LINE_LOOP", A[A.LINE_STRIP = 3] = "LINE_STRIP", A[A.TRIANGLES = 4] = "TRIANGLES", A[A.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", A[A.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", A[A.ZERO = 0] = "ZERO", A[A.ONE = 1] = "ONE", A[A.SRC_COLOR = 768] = "SRC_COLOR", A[A.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", A[A.SRC_ALPHA = 770] = "SRC_ALPHA", A[A.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", A[A.DST_ALPHA = 772] = "DST_ALPHA", A[A.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", A[A.DST_COLOR = 774] = "DST_COLOR", A[A.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", A[A.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", A[A.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", A[A.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", A[A.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", A[A.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", A[A.FUNC_ADD = 32774] = "FUNC_ADD", A[A.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", A[A.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", A[A.BLEND_EQUATION = 32777] = "BLEND_EQUATION", A[A.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", A[A.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", A[A.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", A[A.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", A[A.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", A[A.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", A[A.BLEND_COLOR = 32773] = "BLEND_COLOR", A[A.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", A[A.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", A[A.LINE_WIDTH = 2849] = "LINE_WIDTH", A[A.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", A[A.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", A[A.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", A[A.FRONT_FACE = 2886] = "FRONT_FACE", A[A.DEPTH_RANGE = 2928] = "DEPTH_RANGE", A[A.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", A[A.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", A[A.DEPTH_FUNC = 2932] = "DEPTH_FUNC", A[A.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", A[A.STENCIL_FUNC = 2962] = "STENCIL_FUNC", A[A.STENCIL_FAIL = 2964] = "STENCIL_FAIL", A[A.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", A[A.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", A[A.STENCIL_REF = 2967] = "STENCIL_REF", A[A.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", A[A.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", A[A.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", A[A.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", A[A.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", A[A.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", A[A.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", A[A.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", A[A.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", A[A.VIEWPORT = 2978] = "VIEWPORT", A[A.SCISSOR_BOX = 3088] = "SCISSOR_BOX", A[A.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", A[A.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", A[A.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", A[A.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", A[A.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", A[A.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", A[A.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", A[A.RED_BITS = 3410] = "RED_BITS", A[A.GREEN_BITS = 3411] = "GREEN_BITS", A[A.BLUE_BITS = 3412] = "BLUE_BITS", A[A.ALPHA_BITS = 3413] = "ALPHA_BITS", A[A.DEPTH_BITS = 3414] = "DEPTH_BITS", A[A.STENCIL_BITS = 3415] = "STENCIL_BITS", A[A.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", A[A.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", A[A.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", A[A.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", A[A.SAMPLES = 32937] = "SAMPLES", A[A.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", A[A.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", A[A.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", A[A.VENDOR = 7936] = "VENDOR", A[A.RENDERER = 7937] = "RENDERER", A[A.VERSION = 7938] = "VERSION", A[A.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", A[A.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", A[A.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", A[A.STATIC_DRAW = 35044] = "STATIC_DRAW", A[A.STREAM_DRAW = 35040] = "STREAM_DRAW", A[A.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", A[A.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A[A.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", A[A.BUFFER_SIZE = 34660] = "BUFFER_SIZE", A[A.BUFFER_USAGE = 34661] = "BUFFER_USAGE", A[A.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", A[A.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", A[A.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", A[A.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", A[A.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", A[A.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", A[A.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", A[A.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", A[A.CULL_FACE = 2884] = "CULL_FACE", A[A.FRONT = 1028] = "FRONT", A[A.BACK = 1029] = "BACK", A[A.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", A[A.BLEND = 3042] = "BLEND", A[A.DEPTH_TEST = 2929] = "DEPTH_TEST", A[A.DITHER = 3024] = "DITHER", A[A.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", A[A.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", A[A.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", A[A.SCISSOR_TEST = 3089] = "SCISSOR_TEST", A[A.STENCIL_TEST = 2960] = "STENCIL_TEST", A[A.NO_ERROR = 0] = "NO_ERROR", A[A.INVALID_ENUM = 1280] = "INVALID_ENUM", A[A.INVALID_VALUE = 1281] = "INVALID_VALUE", A[A.INVALID_OPERATION = 1282] = "INVALID_OPERATION", A[A.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", A[A.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", A[A.CW = 2304] = "CW", A[A.CCW = 2305] = "CCW", A[A.DONT_CARE = 4352] = "DONT_CARE", A[A.FASTEST = 4353] = "FASTEST", A[A.NICEST = 4354] = "NICEST", A[A.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", A[A.BYTE = 5120] = "BYTE", A[A.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", A[A.SHORT = 5122] = "SHORT", A[A.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", A[A.INT = 5124] = "INT", A[A.UNSIGNED_INT = 5125] = "UNSIGNED_INT", A[A.FLOAT = 5126] = "FLOAT", A[A.DOUBLE = 5130] = "DOUBLE", A[A.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", A[A.ALPHA = 6406] = "ALPHA", A[A.RGB = 6407] = "RGB", A[A.RGBA = 6408] = "RGBA", A[A.LUMINANCE = 6409] = "LUMINANCE", A[A.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", A[A.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", A[A.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", A[A.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", A[A.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", A[A.VERTEX_SHADER = 35633] = "VERTEX_SHADER", A[A.COMPILE_STATUS = 35713] = "COMPILE_STATUS", A[A.DELETE_STATUS = 35712] = "DELETE_STATUS", A[A.LINK_STATUS = 35714] = "LINK_STATUS", A[A.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", A[A.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", A[A.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", A[A.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", A[A.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", A[A.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", A[A.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", A[A.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", A[A.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", A[A.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", A[A.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", A[A.SHADER_TYPE = 35663] = "SHADER_TYPE", A[A.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", A[A.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", A[A.NEVER = 512] = "NEVER", A[A.LESS = 513] = "LESS", A[A.EQUAL = 514] = "EQUAL", A[A.LEQUAL = 515] = "LEQUAL", A[A.GREATER = 516] = "GREATER", A[A.NOTEQUAL = 517] = "NOTEQUAL", A[A.GEQUAL = 518] = "GEQUAL", A[A.ALWAYS = 519] = "ALWAYS", A[A.KEEP = 7680] = "KEEP", A[A.REPLACE = 7681] = "REPLACE", A[A.INCR = 7682] = "INCR", A[A.DECR = 7683] = "DECR", A[A.INVERT = 5386] = "INVERT", A[A.INCR_WRAP = 34055] = "INCR_WRAP", A[A.DECR_WRAP = 34056] = "DECR_WRAP", A[A.NEAREST = 9728] = "NEAREST", A[A.LINEAR = 9729] = "LINEAR", A[A.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", A[A.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", A[A.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", A[A.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", A[A.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", A[A.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", A[A.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", A[A.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", A[A.TEXTURE_2D = 3553] = "TEXTURE_2D", A[A.TEXTURE = 5890] = "TEXTURE", A[A.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", A[A.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", A[A.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", A[A.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", A[A.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", A[A.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", A[A.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", A[A.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", A[A.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", A[A.TEXTURE0 = 33984] = "TEXTURE0", A[A.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", A[A.REPEAT = 10497] = "REPEAT", A[A.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", A[A.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", A[A.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", A[A.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", A[A.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", A[A.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", A[A.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", A[A.INT_VEC2 = 35667] = "INT_VEC2", A[A.INT_VEC3 = 35668] = "INT_VEC3", A[A.INT_VEC4 = 35669] = "INT_VEC4", A[A.BOOL = 35670] = "BOOL", A[A.BOOL_VEC2 = 35671] = "BOOL_VEC2", A[A.BOOL_VEC3 = 35672] = "BOOL_VEC3", A[A.BOOL_VEC4 = 35673] = "BOOL_VEC4", A[A.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", A[A.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", A[A.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", A[A.SAMPLER_2D = 35678] = "SAMPLER_2D", A[A.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", A[A.LOW_FLOAT = 36336] = "LOW_FLOAT", A[A.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", A[A.HIGH_FLOAT = 36338] = "HIGH_FLOAT", A[A.LOW_INT = 36339] = "LOW_INT", A[A.MEDIUM_INT = 36340] = "MEDIUM_INT", A[A.HIGH_INT = 36341] = "HIGH_INT", A[A.FRAMEBUFFER = 36160] = "FRAMEBUFFER", A[A.RENDERBUFFER = 36161] = "RENDERBUFFER", A[A.RGBA4 = 32854] = "RGBA4", A[A.RGB5_A1 = 32855] = "RGB5_A1", A[A.RGB565 = 36194] = "RGB565", A[A.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", A[A.STENCIL_INDEX = 6401] = "STENCIL_INDEX", A[A.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", A[A.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", A[A.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", A[A.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", A[A.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", A[A.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", A[A.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", A[A.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", A[A.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", A[A.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", A[A.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", A[A.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", A[A.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", A[A.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", A[A.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", A[A.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", A[A.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", A[A.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", A[A.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", A[A.NONE = 0] = "NONE", A[A.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", A[A.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", A[A.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", A[A.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", A[A.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", A[A.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", A[A.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", A[A.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", A[A.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", A[A.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", A[A.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", A[A.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", A[A.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", A[A.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", A[A.READ_BUFFER = 3074] = "READ_BUFFER", A[A.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", A[A.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", A[A.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", A[A.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", A[A.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", A[A.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", A[A.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", A[A.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", A[A.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", A[A.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", A[A.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", A[A.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", A[A.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", A[A.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", A[A.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", A[A.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", A[A.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", A[A.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", A[A.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", A[A.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", A[A.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", A[A.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", A[A.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", A[A.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", A[A.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", A[A.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", A[A.RED = 6403] = "RED", A[A.RGB8 = 32849] = "RGB8", A[A.RGBA8 = 32856] = "RGBA8", A[A.RGB10_A2 = 32857] = "RGB10_A2", A[A.TEXTURE_3D = 32879] = "TEXTURE_3D", A[A.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", A[A.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", A[A.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", A[A.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", A[A.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", A[A.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", A[A.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", A[A.SRGB = 35904] = "SRGB", A[A.SRGB8 = 35905] = "SRGB8", A[A.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", A[A.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", A[A.RGBA32F = 34836] = "RGBA32F", A[A.RGB32F = 34837] = "RGB32F", A[A.RGBA16F = 34842] = "RGBA16F", A[A.RGB16F = 34843] = "RGB16F", A[A.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", A[A.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", A[A.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", A[A.RGB9_E5 = 35901] = "RGB9_E5", A[A.RGBA32UI = 36208] = "RGBA32UI", A[A.RGB32UI = 36209] = "RGB32UI", A[A.RGBA16UI = 36214] = "RGBA16UI", A[A.RGB16UI = 36215] = "RGB16UI", A[A.RGBA8UI = 36220] = "RGBA8UI", A[A.RGB8UI = 36221] = "RGB8UI", A[A.RGBA32I = 36226] = "RGBA32I", A[A.RGB32I = 36227] = "RGB32I", A[A.RGBA16I = 36232] = "RGBA16I", A[A.RGB16I = 36233] = "RGB16I", A[A.RGBA8I = 36238] = "RGBA8I", A[A.RGB8I = 36239] = "RGB8I", A[A.RED_INTEGER = 36244] = "RED_INTEGER", A[A.RGB_INTEGER = 36248] = "RGB_INTEGER", A[A.RGBA_INTEGER = 36249] = "RGBA_INTEGER", A[A.R8 = 33321] = "R8", A[A.RG8 = 33323] = "RG8", A[A.R16F = 33325] = "R16F", A[A.R32F = 33326] = "R32F", A[A.RG16F = 33327] = "RG16F", A[A.RG32F = 33328] = "RG32F", A[A.R8I = 33329] = "R8I", A[A.R8UI = 33330] = "R8UI", A[A.R16I = 33331] = "R16I", A[A.R16UI = 33332] = "R16UI", A[A.R32I = 33333] = "R32I", A[A.R32UI = 33334] = "R32UI", A[A.RG8I = 33335] = "RG8I", A[A.RG8UI = 33336] = "RG8UI", A[A.RG16I = 33337] = "RG16I", A[A.RG16UI = 33338] = "RG16UI", A[A.RG32I = 33339] = "RG32I", A[A.RG32UI = 33340] = "RG32UI", A[A.R8_SNORM = 36756] = "R8_SNORM", A[A.RG8_SNORM = 36757] = "RG8_SNORM", A[A.RGB8_SNORM = 36758] = "RGB8_SNORM", A[A.RGBA8_SNORM = 36759] = "RGBA8_SNORM", A[A.RGB10_A2UI = 36975] = "RGB10_A2UI", A[A.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", A[A.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", A[A.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", A[A.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", A[A.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", A[A.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", A[A.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", A[A.HALF_FLOAT = 5131] = "HALF_FLOAT", A[A.RG = 33319] = "RG", A[A.RG_INTEGER = 33320] = "RG_INTEGER", A[A.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", A[A.CURRENT_QUERY = 34917] = "CURRENT_QUERY", A[A.QUERY_RESULT = 34918] = "QUERY_RESULT", A[A.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", A[A.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", A[A.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", A[A.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", A[A.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", A[A.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", A[A.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", A[A.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", A[A.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", A[A.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", A[A.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", A[A.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", A[A.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", A[A.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", A[A.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", A[A.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", A[A.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", A[A.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", A[A.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", A[A.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", A[A.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", A[A.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", A[A.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", A[A.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", A[A.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", A[A.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", A[A.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", A[A.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", A[A.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", A[A.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", A[A.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", A[A.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", A[A.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", A[A.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", A[A.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", A[A.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", A[A.SAMPLER_3D = 35679] = "SAMPLER_3D", A[A.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", A[A.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", A[A.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", A[A.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", A[A.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", A[A.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", A[A.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", A[A.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", A[A.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", A[A.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", A[A.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", A[A.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", A[A.MAX_SAMPLES = 36183] = "MAX_SAMPLES", A[A.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", A[A.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", A[A.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", A[A.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", A[A.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", A[A.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", A[A.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", A[A.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", A[A.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", A[A.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", A[A.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", A[A.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", A[A.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", A[A.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", A[A.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", A[A.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", A[A.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", A[A.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", A[A.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", A[A.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", A[A.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", A[A.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", A[A.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", A[A.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", A[A.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", A[A.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", A[A.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", A[A.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", A[A.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", A[A.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", A[A.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", A[A.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", A[A.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", A[A.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", A[A.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", A[A.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", A[A.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", A[A.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", A[A.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", A[A.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", A[A.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", A[A.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", A[A.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", A[A.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", A[A.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", A[A.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", A[A.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", A[A.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", A[A.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", A[A.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", A[A.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", A[A.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", A[A.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", A[A.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", A[A.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", A[A.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", A[A.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", A[A.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", A[A.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", A[A.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", A[A.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", A[A.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", A[A.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", A[A.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", A[A.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", A[A.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", A[A.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", A[A.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", A[A.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", A[A.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", A[A.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", A[A.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", A[A.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", A[A.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", A[A.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", A[A.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", A[A.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", A[A.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", A[A.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", A[A.OBJECT_TYPE = 37138] = "OBJECT_TYPE", A[A.SYNC_CONDITION = 37139] = "SYNC_CONDITION", A[A.SYNC_STATUS = 37140] = "SYNC_STATUS", A[A.SYNC_FLAGS = 37141] = "SYNC_FLAGS", A[A.SYNC_FENCE = 37142] = "SYNC_FENCE", A[A.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", A[A.UNSIGNALED = 37144] = "UNSIGNALED", A[A.SIGNALED = 37145] = "SIGNALED", A[A.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", A[A.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", A[A.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", A[A.WAIT_FAILED = 37149] = "WAIT_FAILED", A[A.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", A[A.COLOR = 6144] = "COLOR", A[A.DEPTH = 6145] = "DEPTH", A[A.STENCIL = 6146] = "STENCIL", A[A.MIN = 32775] = "MIN", A[A.MAX = 32776] = "MAX", A[A.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", A[A.STREAM_READ = 35041] = "STREAM_READ", A[A.STREAM_COPY = 35042] = "STREAM_COPY", A[A.STATIC_READ = 35045] = "STATIC_READ", A[A.STATIC_COPY = 35046] = "STATIC_COPY", A[A.DYNAMIC_READ = 35049] = "DYNAMIC_READ", A[A.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", A[A.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", A[A.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", A[A.INVALID_INDEX = 4294967295] = "INVALID_INDEX", A[A.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", A[A.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", A[A.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", A[A.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", A[A.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", A[A.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", A[A.R16_EXT = 33322] = "R16_EXT", A[A.RG16_EXT = 33324] = "RG16_EXT", A[A.RGB16_EXT = 32852] = "RGB16_EXT", A[A.RGBA16_EXT = 32859] = "RGBA16_EXT", A[A.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", A[A.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", A[A.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", A[A.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", A[A.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", A[A.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", A[A.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", A[A.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", A[A.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", A[A.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", A[A.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", A[A.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", A[A.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", A[A.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", A[A.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", A[A.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", A[A.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", A[A.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", A[A.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", A[A.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", A[A.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", A[A.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", A[A.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", A[A.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", A[A.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", A[A.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", A[A.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", A[A.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", A[A.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", A[A.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", A[A.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", A[A.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", A[A.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", A[A.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", A[A.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", A[A.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", A[A.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", A[A.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", A[A.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", A[A.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", A[A.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", A[A.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", A[A.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", A[A.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", A[A.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", A[A.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", A[A.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", A[A.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", A[A.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", A[A.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", A[A.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", A[A.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", A[A.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", A[A.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", A[A.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", A[A.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", A[A.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", A[A.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", A[A.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", A[A.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", A[A.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", A[A.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", A[A.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", A[A.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", A[A.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", A[A.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", A[A.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", A[A.LINE_WEBGL = 6913] = "LINE_WEBGL", A[A.FILL_WEBGL = 6914] = "FILL_WEBGL", A[A.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", A[A.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", A[A.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", A[A.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", A[A.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", A[A.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", A[A.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", A[A.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", A[A.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", A[A.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", A[A.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", A[A.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", A[A.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", A[A.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", A[A.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", A[A.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", A[A.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", A[A.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", A[A.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", A[A.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", A[A.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", A[A.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", A[A.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", A[A.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(cf || (cf = {}));
const OG = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, uC = (A, g, I) => g ? A.enable(I) : A.disable(I), D1 = (A, g, I) => A.hint(I, g), xt = (A, g, I) => A.pixelStorei(I, g), M1 = (A, g, I) => {
  const C = I === 36006 ? 36009 : 36008;
  return A.bindFramebuffer(C, g);
}, VD = (A, g, I) => {
  const t = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[I];
  A.bindBuffer(t, g);
};
function Zb(A) {
  return Array.isArray(A) || ArrayBuffer.isView(A) && !(A instanceof DataView);
}
const W3 = {
  3042: uC,
  32773: (A, g) => A.blendColor(...g),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (A, g) => A.clearColor(...g),
  3107: (A, g) => A.colorMask(...g),
  2884: uC,
  2885: (A, g) => A.cullFace(g),
  2929: uC,
  2931: (A, g) => A.clearDepth(g),
  2932: (A, g) => A.depthFunc(g),
  2928: (A, g) => A.depthRange(...g),
  2930: (A, g) => A.depthMask(g),
  3024: uC,
  35723: D1,
  35725: (A, g) => A.useProgram(g),
  36007: (A, g) => A.bindRenderbuffer(36161, g),
  36389: (A, g) => A.bindTransformFeedback?.(36386, g),
  34229: (A, g) => A.bindVertexArray(g),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: M1,
  36010: M1,
  // Buffers
  34964: VD,
  36662: VD,
  36663: VD,
  35053: VD,
  35055: VD,
  2886: (A, g) => A.frontFace(g),
  33170: D1,
  2849: (A, g) => A.lineWidth(g),
  32823: uC,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: uC,
  32926: uC,
  32928: uC,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: uC,
  3088: (A, g) => A.scissor(...g),
  2960: uC,
  2961: (A, g) => A.clearStencil(g),
  2968: (A, g) => A.stencilMaskSeparate(1028, g),
  36005: (A, g) => A.stencilMaskSeparate(1029, g),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (A, g) => A.viewport(...g),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: uC,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: uC,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: uC,
  12289: uC,
  12290: uC,
  12291: uC,
  12292: uC,
  12293: uC,
  12294: uC,
  12295: uC,
  // PIXEL PACK/UNPACK MODES
  3333: xt,
  3317: xt,
  37440: xt,
  37441: xt,
  37443: xt,
  3330: xt,
  3332: xt,
  3331: xt,
  3314: xt,
  32878: xt,
  3316: xt,
  3315: xt,
  32877: xt,
  // Function-style setters
  framebuffer: (A, g) => {
    const I = g && "handle" in g ? g.handle : g;
    return A.bindFramebuffer(36160, I);
  },
  blend: (A, g) => g ? A.enable(3042) : A.disable(3042),
  blendColor: (A, g) => A.blendColor(...g),
  blendEquation: (A, g) => {
    const I = typeof g == "number" ? [g, g] : g;
    A.blendEquationSeparate(...I);
  },
  blendFunc: (A, g) => {
    const I = g?.length === 2 ? [...g, ...g] : g;
    A.blendFuncSeparate(...I);
  },
  clearColor: (A, g) => A.clearColor(...g),
  clearDepth: (A, g) => A.clearDepth(g),
  clearStencil: (A, g) => A.clearStencil(g),
  colorMask: (A, g) => A.colorMask(...g),
  cull: (A, g) => g ? A.enable(2884) : A.disable(2884),
  cullFace: (A, g) => A.cullFace(g),
  depthTest: (A, g) => g ? A.enable(2929) : A.disable(2929),
  depthFunc: (A, g) => A.depthFunc(g),
  depthMask: (A, g) => A.depthMask(g),
  depthRange: (A, g) => A.depthRange(...g),
  dither: (A, g) => g ? A.enable(3024) : A.disable(3024),
  derivativeHint: (A, g) => {
    A.hint(35723, g);
  },
  frontFace: (A, g) => A.frontFace(g),
  mipmapHint: (A, g) => A.hint(33170, g),
  lineWidth: (A, g) => A.lineWidth(g),
  polygonOffsetFill: (A, g) => g ? A.enable(32823) : A.disable(32823),
  polygonOffset: (A, g) => A.polygonOffset(...g),
  sampleCoverage: (A, g) => A.sampleCoverage(g[0], g[1] || !1),
  scissorTest: (A, g) => g ? A.enable(3089) : A.disable(3089),
  scissor: (A, g) => A.scissor(...g),
  stencilTest: (A, g) => g ? A.enable(2960) : A.disable(2960),
  stencilMask: (A, g) => {
    g = Zb(g) ? g : [g, g];
    const [I, C] = g;
    A.stencilMaskSeparate(1028, I), A.stencilMaskSeparate(1029, C);
  },
  stencilFunc: (A, g) => {
    g = Zb(g) && g.length === 3 ? [...g, ...g] : g;
    const [I, C, t, s, r, l] = g;
    A.stencilFuncSeparate(1028, I, C, t), A.stencilFuncSeparate(1029, s, r, l);
  },
  stencilOp: (A, g) => {
    g = Zb(g) && g.length === 3 ? [...g, ...g] : g;
    const [I, C, t, s, r, l] = g;
    A.stencilOpSeparate(1028, I, C, t), A.stencilOpSeparate(1029, s, r, l);
  },
  viewport: (A, g) => A.viewport(...g)
};
function zA(A, g, I) {
  return g[A] !== void 0 ? g[A] : I[A];
}
const V3 = {
  blendEquation: (A, g, I) => A.blendEquationSeparate(zA(32777, g, I), zA(34877, g, I)),
  blendFunc: (A, g, I) => A.blendFuncSeparate(zA(32969, g, I), zA(32968, g, I), zA(32971, g, I), zA(32970, g, I)),
  polygonOffset: (A, g, I) => A.polygonOffset(zA(32824, g, I), zA(10752, g, I)),
  sampleCoverage: (A, g, I) => A.sampleCoverage(zA(32938, g, I), zA(32939, g, I)),
  stencilFuncFront: (A, g, I) => A.stencilFuncSeparate(1028, zA(2962, g, I), zA(2967, g, I), zA(2963, g, I)),
  stencilFuncBack: (A, g, I) => A.stencilFuncSeparate(1029, zA(34816, g, I), zA(36003, g, I), zA(36004, g, I)),
  stencilOpFront: (A, g, I) => A.stencilOpSeparate(1028, zA(2964, g, I), zA(2965, g, I), zA(2966, g, I)),
  stencilOpBack: (A, g, I) => A.stencilOpSeparate(1029, zA(34817, g, I), zA(34818, g, I), zA(34819, g, I))
}, w1 = {
  // GENERIC SETTERS
  enable: (A, g) => A({
    [g]: !0
  }),
  disable: (A, g) => A({
    [g]: !1
  }),
  pixelStorei: (A, g, I) => A({
    [g]: I
  }),
  hint: (A, g, I) => A({
    [g]: I
  }),
  // SPECIFIC SETTERS
  useProgram: (A, g) => A({
    35725: g
  }),
  bindRenderbuffer: (A, g, I) => A({
    36007: I
  }),
  bindTransformFeedback: (A, g, I) => A({
    36389: I
  }),
  bindVertexArray: (A, g) => A({
    34229: g
  }),
  bindFramebuffer: (A, g, I) => {
    switch (g) {
      case 36160:
        return A({
          36006: I,
          36010: I
        });
      case 36009:
        return A({ 36006: I });
      case 36008:
        return A({ 36010: I });
      default:
        return null;
    }
  },
  bindBuffer: (A, g, I) => {
    const C = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[g];
    return C ? A({ [C]: I }) : { valueChanged: !0 };
  },
  blendColor: (A, g, I, C, t) => A({
    32773: new Float32Array([g, I, C, t])
  }),
  blendEquation: (A, g) => A({
    32777: g,
    34877: g
  }),
  blendEquationSeparate: (A, g, I) => A({
    32777: g,
    34877: I
  }),
  blendFunc: (A, g, I) => A({
    32969: g,
    32968: I,
    32971: g,
    32970: I
  }),
  blendFuncSeparate: (A, g, I, C, t) => A({
    32969: g,
    32968: I,
    32971: C,
    32970: t
  }),
  clearColor: (A, g, I, C, t) => A({
    3106: new Float32Array([g, I, C, t])
  }),
  clearDepth: (A, g) => A({
    2931: g
  }),
  clearStencil: (A, g) => A({
    2961: g
  }),
  colorMask: (A, g, I, C, t) => A({
    3107: [g, I, C, t]
  }),
  cullFace: (A, g) => A({
    2885: g
  }),
  depthFunc: (A, g) => A({
    2932: g
  }),
  depthRange: (A, g, I) => A({
    2928: new Float32Array([g, I])
  }),
  depthMask: (A, g) => A({
    2930: g
  }),
  frontFace: (A, g) => A({
    2886: g
  }),
  lineWidth: (A, g) => A({
    2849: g
  }),
  polygonOffset: (A, g, I) => A({
    32824: g,
    10752: I
  }),
  sampleCoverage: (A, g, I) => A({
    32938: g,
    32939: I
  }),
  scissor: (A, g, I, C, t) => A({
    3088: new Int32Array([g, I, C, t])
  }),
  stencilMask: (A, g) => A({
    2968: g,
    36005: g
  }),
  stencilMaskSeparate: (A, g, I) => A({
    [g === 1028 ? 2968 : 36005]: I
  }),
  stencilFunc: (A, g, I, C) => A({
    2962: g,
    2967: I,
    2963: C,
    34816: g,
    36003: I,
    36004: C
  }),
  stencilFuncSeparate: (A, g, I, C, t) => A({
    [g === 1028 ? 2962 : 34816]: I,
    [g === 1028 ? 2967 : 36003]: C,
    [g === 1028 ? 2963 : 36004]: t
  }),
  stencilOp: (A, g, I, C) => A({
    2964: g,
    2965: I,
    2966: C,
    34817: g,
    34818: I,
    34819: C
  }),
  stencilOpSeparate: (A, g, I, C, t) => A({
    [g === 1028 ? 2964 : 34817]: I,
    [g === 1028 ? 2965 : 34818]: C,
    [g === 1028 ? 2966 : 34819]: t
  }),
  viewport: (A, g, I, C, t) => A({
    2978: [g, I, C, t]
  })
}, Ds = (A, g) => A.isEnabled(g), B1 = {
  3042: Ds,
  2884: Ds,
  2929: Ds,
  3024: Ds,
  32823: Ds,
  32926: Ds,
  32928: Ds,
  3089: Ds,
  2960: Ds,
  35977: Ds
}, x3 = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);
function Ef(A, g) {
  if (U3(g))
    return;
  const I = {};
  for (const t in g) {
    const s = Number(t), r = W3[t];
    r && (typeof r == "string" ? I[r] = !0 : r(A, g[t], s));
  }
  const C = A.state && A.state.cache;
  if (C)
    for (const t in I) {
      const s = V3[t];
      s(A, g, C);
    }
}
function Nv(A, g = OG) {
  if (typeof g == "number") {
    const t = g, s = B1[t];
    return s ? s(A, t) : A.getParameter(t);
  }
  const I = Array.isArray(g) ? g : Object.keys(g), C = {};
  for (const t of I) {
    const s = B1[t];
    C[t] = s ? s(A, Number(t)) : A.getParameter(Number(t));
  }
  return C;
}
function _3(A) {
  Ef(A, OG);
}
function U3(A) {
  for (const g in A)
    return !1;
  return !0;
}
function F3(A, g) {
  if (A === g)
    return !0;
  const I = Array.isArray(A) || ArrayBuffer.isView(A), C = Array.isArray(g) || ArrayBuffer.isView(g);
  if (I && C && A.length === g.length) {
    for (let t = 0; t < A.length; ++t)
      if (A[t] !== g[t])
        return !1;
    return !0;
  }
  return !1;
}
class hc {
  static get(g) {
    return g.state;
  }
  gl;
  program = null;
  stateStack = [];
  enable = !0;
  cache = null;
  log;
  initialized = !1;
  constructor(g, I) {
    this.gl = g, this.log = I?.log || (() => {
    }), this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push(g = {}) {
    this.stateStack.push({});
  }
  pop() {
    const g = this.stateStack[this.stateStack.length - 1];
    Ef(this.gl, g), this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(g, I) {
    if (this.cache = I.copyState ? Nv(g) : Object.assign({}, OG), this.initialized)
      throw new Error("WebGLStateTracker");
    this.initialized = !0, this.gl.state = this, Q3(g);
    for (const C in w1) {
      const t = w1[C];
      X3(g, C, t);
    }
    p1(g, "getParameter"), p1(g, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(g) {
    let I = !1, C;
    const t = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const s in g) {
      const r = g[s], l = this.cache[s];
      F3(r, l) || (I = !0, C = l, t && !(s in t) && (t[s] = l), this.cache[s] = r);
    }
    return { valueChanged: I, oldValue: C };
  }
}
function p1(A, g) {
  const I = A[g].bind(A);
  A[g] = function(t) {
    if (t === void 0 || x3.has(t))
      return I(t);
    const s = hc.get(A);
    return t in s.cache || (s.cache[t] = I(t)), s.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      s.cache[t]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      I(t)
    );
  }, Object.defineProperty(A[g], "name", {
    value: `${g}-from-cache`,
    configurable: !1
  });
}
function X3(A, g, I) {
  if (!A[g])
    return;
  const C = A[g].bind(A);
  A[g] = function(...s) {
    const r = hc.get(A), { valueChanged: l, oldValue: d } = I(r._updateCache, ...s);
    return l && C(...s), d;
  }, Object.defineProperty(A[g], "name", {
    value: `${g}-to-cache`,
    configurable: !1
  });
}
function Q3(A) {
  const g = A.useProgram.bind(A);
  A.useProgram = function(C) {
    const t = hc.get(A);
    t.program !== C && (g(C), t.program = C);
  };
}
function z3(A, g, I) {
  let C = "";
  const t = {
    preserveDrawingBuffer: !0,
    // failIfMajorPerformanceCaveat: true,
    ...I
  };
  let s = null;
  if (s ||= A.getContext("webgl2", t), t.failIfMajorPerformanceCaveat && (C ||= "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow."), !s && !I.failIfMajorPerformanceCaveat && (t.failIfMajorPerformanceCaveat = !1, s = A.getContext("webgl2", t), s.luma ||= {}, s.luma.softwareRenderer = !0), s || (s = A.getContext("webgl", {}), s && (s = null, C ||= "Your browser only supports WebGL1")), !s)
    throw C ||= "Your browser does not support WebGL", new Error(`Failed to create WebGL context: ${C}`);
  const { onContextLost: r, onContextRestored: l } = g;
  return A.addEventListener("webglcontextlost", (d) => r(d), !1), A.addEventListener("webglcontextrestored", (d) => l(d), !1), s.luma ||= {}, s;
}
function Zf(A, g, I) {
  return I[g] === void 0 && (I[g] = A.getExtension(g) || null), I[g];
}
function J3(A, g) {
  const I = A.getParameter(7936), C = A.getParameter(7937);
  Zf(A, "WEBGL_debug_renderer_info", g);
  const t = g.WEBGL_debug_renderer_info, s = A.getParameter(t ? t.UNMASKED_VENDOR_WEBGL : 7936), r = A.getParameter(t ? t.UNMASKED_RENDERER_WEBGL : 7937), l = s || I, d = r || C, h = A.getParameter(7938), D = kv(l, d), w = L3(l, d), p = q3(l, d);
  return {
    type: "webgl",
    gpu: D,
    gpuType: p,
    gpuBackend: w,
    vendor: l,
    renderer: d,
    version: h,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function kv(A, g) {
  return /NVIDIA/i.exec(A) || /NVIDIA/i.exec(g) ? "nvidia" : /INTEL/i.exec(A) || /INTEL/i.exec(g) ? "intel" : /Apple/i.exec(A) || /Apple/i.exec(g) ? "apple" : /AMD/i.exec(A) || /AMD/i.exec(g) || /ATI/i.exec(A) || /ATI/i.exec(g) ? "amd" : /SwiftShader/i.exec(A) || /SwiftShader/i.exec(g) ? "software" : "unknown";
}
function L3(A, g) {
  return /Metal/i.exec(A) || /Metal/i.exec(g) ? "metal" : /ANGLE/i.exec(A) || /ANGLE/i.exec(g) ? "opengl" : "unknown";
}
function q3(A, g) {
  if (/SwiftShader/i.exec(A) || /SwiftShader/i.exec(g))
    return "cpu";
  switch (kv(A, g)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function Wv(A) {
  switch (A) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(A));
}
const $D = "WEBGL_compressed_texture_s3tc", gM = "WEBGL_compressed_texture_s3tc_srgb", uf = "EXT_texture_compression_rgtc", df = "EXT_texture_compression_bptc", $3 = "WEBGL_compressed_texture_etc", gF = "WEBGL_compressed_texture_astc", IF = "WEBGL_compressed_texture_etc1", AF = "WEBGL_compressed_texture_pvrtc", CF = "WEBGL_compressed_texture_atc", m1 = "EXT_texture_norm16", b1 = "EXT_render_snorm", eF = "EXT_color_buffer_float", NG = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [b1],
  "norm16-renderable-webgl": [m1],
  "snorm16-renderable-webgl": [m1, b1],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [$D, gM, uf, df],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [uf],
  "texture-compression-bc7-webgl": [df],
  "texture-compression-etc2": [$3],
  "texture-compression-astc": [gF],
  "texture-compression-etc1-webgl": [IF],
  "texture-compression-pvrtc-webgl": [AF],
  "texture-compression-atc-webgl": [CF]
};
function tF(A) {
  return A in NG;
}
function iF(A, g, I) {
  return (NG[g] || []).every((t) => Zf(A, t, I));
}
const kG = {
  // 8-bit formats
  r8unorm: { gl: 33321, rb: !0 },
  r8snorm: { gl: 36756 },
  r8uint: { gl: 33330, rb: !0 },
  r8sint: { gl: 33329, rb: !0 },
  // 16-bit formats
  rg8unorm: { gl: 33323, rb: !0 },
  rg8snorm: { gl: 36757 },
  rg8uint: { gl: 33336, rb: !0 },
  rg8sint: { gl: 33335, rb: !0 },
  r16uint: { gl: 33332, rb: !0 },
  r16sint: { gl: 33331, rb: !0 },
  r16float: { gl: 33325, rb: !0 },
  "r16unorm-webgl": { gl: 33322, rb: !0 },
  "r16snorm-webgl": { gl: 36760 },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, rb: !0 },
  "rgb565unorm-webgl": { gl: 36194, rb: !0 },
  "rgb5a1unorm-webgl": { gl: 32855, rb: !0 },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849 },
  "rgb8snorm-webgl": { gl: 36758 },
  // 32-bit formats  
  rgba8unorm: { gl: 32856 },
  "rgba8unorm-srgb": { gl: 35907 },
  rgba8snorm: { gl: 36759 },
  rgba8uint: { gl: 36220 },
  rgba8sint: { gl: 36238 },
  // reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: { gl: 33338 },
  rg16sint: { gl: 33337 },
  rg16float: { gl: 33327, rb: !0 },
  "rg16unorm-webgl": { gl: 33324 },
  "rg16snorm-webgl": { gl: 36761 },
  r32uint: { gl: 33334, rb: !0 },
  r32sint: { gl: 33333, rb: !0 },
  r32float: { gl: 33326 },
  // Packed 32-bit formats
  rgb9e5ufloat: { gl: 35901 },
  // , filter: true},
  rg11b10ufloat: { gl: 35898, rb: !0 },
  rgb10a2unorm: { gl: 32857, rb: !0 },
  "rgb10a2uint-webgl": { gl: 36975, rb: !0 },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852 },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762 },
  // rgb not renderable
  // 64-bit formats
  rg32uint: { gl: 33340, rb: !0 },
  rg32sint: { gl: 33339, rb: !0 },
  rg32float: { gl: 33328, rb: !0 },
  rgba16uint: { gl: 36214, rb: !0 },
  rgba16sint: { gl: 36232, rb: !0 },
  rgba16float: { gl: 34842 },
  "rgba16unorm-webgl": { gl: 32859, rb: !0 },
  "rgba16snorm-webgl": { gl: 36763 },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": { gl: 34837, x: eF, dataFormat: 6407, types: [5126] },
  // 128-bit formats
  rgba32uint: { gl: 36208, rb: !0 },
  rgba32sint: { gl: 36226, rb: !0 },
  rgba32float: { gl: 34836, rb: !0 },
  // Depth and stencil formats
  stencil8: { gl: 36168, rb: !0 },
  // 8 stencil bits
  depth16unorm: { gl: 33189, dataFormat: 6402, types: [5123], rb: !0 },
  // 16 depth bits
  depth24plus: { gl: 33190, dataFormat: 6402, types: [5125] },
  depth32float: { gl: 36012, dataFormat: 6402, types: [5126], rb: !0 },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { gl: 35056, rb: !0, depthTexture: !0, dataFormat: 34041, types: [34042] },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": { gl: 36013, dataFormat: 34041, types: [36269], rb: !0 },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: $D },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: gM },
  "bc1-rgba-unorm": { gl: 33777, x: $D },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: gM },
  "bc2-rgba-unorm": { gl: 33778, x: $D },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: gM },
  "bc3-rgba-unorm": { gl: 33779, x: $D },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: gM },
  "bc4-r-unorm": { gl: 36283, x: uf },
  "bc4-r-snorm": { gl: 36284, x: uf },
  "bc5-rg-unorm": { gl: 36285, x: uf },
  "bc5-rg-snorm": { gl: 36286, x: uf },
  "bc6h-rgb-ufloat": { gl: 36495, x: df },
  "bc6h-rgb-float": { gl: 36494, x: df },
  "bc7-rgba-unorm": { gl: 36492, x: df },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: df },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492 },
  "etc2-rgb8unorm-srgb": { gl: 37494 },
  "etc2-rgb8a1unorm": { gl: 37496 },
  "etc2-rgb8a1unorm-srgb": { gl: 37497 },
  "etc2-rgba8unorm": { gl: 37493 },
  "etc2-rgba8unorm-srgb": { gl: 37495 },
  "eac-r11unorm": { gl: 37488 },
  "eac-r11snorm": { gl: 37489 },
  "eac-rg11unorm": { gl: 37490 },
  "eac-rg11snorm": { gl: 37491 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808 },
  "astc-4x4-unorm-srgb": { gl: 37840 },
  "astc-5x4-unorm": { gl: 37809 },
  "astc-5x4-unorm-srgb": { gl: 37841 },
  "astc-5x5-unorm": { gl: 37810 },
  "astc-5x5-unorm-srgb": { gl: 37842 },
  "astc-6x5-unorm": { gl: 37811 },
  "astc-6x5-unorm-srgb": { gl: 37843 },
  "astc-6x6-unorm": { gl: 37812 },
  "astc-6x6-unorm-srgb": { gl: 37844 },
  "astc-8x5-unorm": { gl: 37813 },
  "astc-8x5-unorm-srgb": { gl: 37845 },
  "astc-8x6-unorm": { gl: 37814 },
  "astc-8x6-unorm-srgb": { gl: 37846 },
  "astc-8x8-unorm": { gl: 37815 },
  "astc-8x8-unorm-srgb": { gl: 37847 },
  "astc-10x5-unorm": { gl: 37819 },
  "astc-10x5-unorm-srgb": { gl: 37851 },
  "astc-10x6-unorm": { gl: 37817 },
  "astc-10x6-unorm-srgb": { gl: 37849 },
  "astc-10x8-unorm": { gl: 37818 },
  "astc-10x8-unorm-srgb": { gl: 37850 },
  "astc-10x10-unorm": { gl: 37819 },
  "astc-10x10-unorm-srgb": { gl: 37851 },
  "astc-12x10-unorm": { gl: 37820 },
  "astc-12x10-unorm-srgb": { gl: 37852 },
  "astc-12x12-unorm": { gl: 37821 },
  "astc-12x12-unorm-srgb": { gl: 37853 },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840 },
  "pvrtc-rgba4unorm-webgl": { gl: 35842 },
  "pvrtc-rbg2unorm-webgl": { gl: 35841 },
  "pvrtc-rgba2unorm-webgl": { gl: 35843 },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196 },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986 },
  "atc-rgba-unorm-webgl": { gl: 35986 },
  "atc-rgbai-unorm-webgl": { gl: 34798 }
};
function nF(A, g, I) {
  let C = g.create;
  const t = kG[g.format];
  return t?.gl === void 0 && (C = !1), t?.x && (C = C && !!Zf(A, t.x, I)), {
    format: g.format,
    // @ts-ignore
    create: C && g.create,
    // @ts-ignore
    render: C && g.render,
    // @ts-ignore
    filter: C && g.filter,
    // @ts-ignore
    blend: C && g.blend,
    // @ts-ignore
    store: C && g.store
  };
}
function Vv(A) {
  const g = kG[A], I = aF(A), C = iG(A);
  return {
    internalFormat: I,
    format: g?.dataFormat || oF(C.channels, C.integer, C.normalized, I),
    // depth formats don't have a type
    type: C.dataType ? Wv(C.dataType) : g?.types?.[0] || 5121,
    compressed: C.compressed || !1
  };
}
function sF(A) {
  switch (iG(A).attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${A}`);
  }
}
function oF(A, g, I, C) {
  if (C === 6408 || C === 6407)
    return C;
  switch (A) {
    case "r":
      return g && !I ? 36244 : 6403;
    case "rg":
      return g && !I ? 33320 : 33319;
    case "rgb":
      return g && !I ? 36248 : 6407;
    case "rgba":
      return g && !I ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function aF(A) {
  const I = kG[A]?.gl;
  if (I === void 0)
    throw new Error(`Unsupported texture format ${A}`);
  return I;
}
const S1 = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class rF extends e4 {
  gl;
  extensions;
  testedFeatures = /* @__PURE__ */ new Set();
  constructor(g, I, C) {
    super([], C), this.gl = g, this.extensions = I, Zf(g, "EXT_color_buffer_float", I);
  }
  *[Symbol.iterator]() {
    const g = this.getFeatures();
    for (const I of g)
      this.has(I) && (yield I);
    return [];
  }
  has(g) {
    return this.disabledFeatures?.[g] ? !1 : (this.testedFeatures.has(g) || (this.testedFeatures.add(g), tF(g) && iF(this.gl, g, this.extensions) && this.features.add(g), this.getWebGLFeature(g) && this.features.add(g)), this.features.has(g));
  }
  // FOR DEVICE
  initializeFeatures() {
    const g = this.getFeatures().filter((I) => I !== "polygon-mode-webgl");
    for (const I of g)
      this.has(I);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(S1), ...Object.keys(NG)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(g) {
    const I = S1[g];
    return typeof I == "string" ? !!Zf(this.gl, I, this.extensions) : !!I;
  }
}
class lF extends C4 {
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  // WebGL does not support compute shaders
  // PRIVATE
  gl;
  limits = {};
  constructor(g) {
    super(), this.gl = g;
  }
  getParameter(g) {
    return this.limits[g] === void 0 && (this.limits[g] = this.gl.getParameter(g)), this.limits[g] || 0;
  }
}
class nM extends qp {
  device;
  gl;
  handle;
  colorAttachments = [];
  depthStencilAttachment = null;
  constructor(g, I) {
    super(g, I);
    const C = I.handle === null;
    this.device = g, this.gl = g.gl, this.handle = this.props.handle || C ? this.props.handle : this.gl.createFramebuffer(), C || (g.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props }), this.autoCreateAttachmentTextures(), this.updateAttachments());
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  updateAttachments() {
    const g = this.gl.bindFramebuffer(36160, this.handle);
    for (let I = 0; I < this.colorAttachments.length; ++I) {
      const C = this.colorAttachments[I];
      if (C) {
        const t = 36064 + I;
        this._attachTextureView(t, C);
      }
    }
    if (this.depthStencilAttachment) {
      const I = sF(this.depthStencilAttachment.props.format);
      this._attachTextureView(I, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const I = this.gl.checkFramebufferStatus(36160);
      if (I !== 36053)
        throw new Error(`Framebuffer ${uF(I)}`);
    }
    this.gl.bindFramebuffer(36160, g);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(g, I) {
    const { gl: C } = this.device, { texture: t } = I, s = I.props.baseMipLevel, r = I.props.baseArrayLayer;
    switch (C.bindTexture(t.glTarget, t.handle), t.glTarget) {
      case 35866:
      case 32879:
        C.framebufferTextureLayer(36160, g, t.handle, s, r);
        break;
      case 34067:
        const l = cF(r);
        C.framebufferTexture2D(36160, g, l, t.handle, s);
        break;
      case 3553:
        C.framebufferTexture2D(36160, g, 3553, t.handle, s);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    C.bindTexture(t.glTarget, null);
  }
}
function cF(A) {
  return A < 34069 ? A + 34069 : A;
}
function uF(A) {
  switch (A) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${A}`;
  }
}
class dF extends nG {
  device;
  format = "rgba8unorm";
  depthStencilFormat = "depth24plus";
  presentationSize;
  _framebuffer = null;
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  constructor(g, I) {
    super(I), this.device = g, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
  }
  getCurrentFramebuffer() {
    return this.update(), this._framebuffer = this._framebuffer || new nM(this.device, { handle: null }), this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const g = this.getPixelSize();
    (g[0] !== this.presentationSize[0] || g[1] !== this.presentationSize[1]) && (this.presentationSize = g, this.resize());
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(g) {
    if (this.device.gl && this.canvas) {
      const I = this.getDevicePixelRatio(g?.useDevicePixels);
      this.setDevicePixelRatio(I, g);
      return;
    }
  }
  commit() {
  }
}
async function xv(A, g) {
  const I = document.getElementsByTagName("head")[0];
  if (!I)
    throw new Error("loadScript");
  const C = document.createElement("script");
  return C.setAttribute("type", "text/javascript"), C.setAttribute("src", A), new Promise((t, s) => {
    C.onload = t, C.onerror = (r) => s(new Error(`Unable to load script '${A}': ${r}`)), I.appendChild(C);
  });
}
const fF = 1;
let _t = null, G1 = !1;
const WG = {
  debugSpectorJS: xg.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function hF(A) {
  if (!globalThis.SPECTOR)
    try {
      await xv(A.debugSpectorJSUrl || WG.debugSpectorJSUrl);
    } catch (g) {
      xg.warn(String(g));
    }
}
function yF(A) {
  if (A = { ...WG, ...A }, !A.debugSpectorJS)
    return null;
  if (!_t && globalThis.SPECTOR && !globalThis.luma?.spector) {
    xg.probe(fF, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const { Spector: g } = globalThis.SPECTOR;
    _t = new g(), globalThis.luma && (globalThis.luma.spector = _t);
  }
  if (!_t)
    return null;
  if (G1 || (G1 = !0, _t.spyCanvases(), _t?.onCaptureStarted.add((g) => xg.info("Spector capture started:", g)()), _t?.onCapture.add((g) => {
    xg.info("Spector capture complete:", g)(), _t?.getResultUI(), _t?.resultView.display(), _t?.resultView.addCapture(g);
  })), A.gl) {
    const g = A.gl, I = g.device;
    _t?.startCapture(A.gl, 500), g.device = I, new Promise((C) => setTimeout(C, 2e3)).then((C) => {
      xg.info("Spector capture stopped after 2 seconds")(), _t?.stopCapture();
    });
  }
  return _t;
}
const DF = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function _v(A) {
  return A.luma = A.luma || {}, A.luma;
}
async function MF() {
  Pc() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await xv(DF));
}
function wF(A, g = {}) {
  return g.debugWebGL || g.traceWebGL ? pF(A, g) : BF(A);
}
function BF(A) {
  const g = _v(A);
  return g.realContext ? g.realContext : A;
}
function pF(A, g) {
  if (!globalThis.WebGLDebugUtils)
    return xg.warn("webgl-debug not loaded")(), A;
  const I = _v(A);
  if (I.debugContext)
    return I.debugContext;
  globalThis.WebGLDebugUtils.init({ ...cf, ...A });
  const C = globalThis.WebGLDebugUtils.makeDebugContext(A, mF.bind(null, g), bF.bind(null, g));
  for (const r in cf)
    !(r in C) && typeof cf[r] == "number" && (C[r] = cf[r]);
  class t {
  }
  Object.setPrototypeOf(C, Object.getPrototypeOf(A)), Object.setPrototypeOf(t, C);
  const s = Object.create(t);
  return I.realContext = A, I.debugContext = s, s.debug = !0, s;
}
function K1(A, g) {
  g = Array.from(g).map((C) => C === void 0 ? "undefined" : C);
  let I = globalThis.WebGLDebugUtils.glFunctionArgsToString(A, g);
  return I = `${I.slice(0, 100)}${I.length > 100 ? "..." : ""}`, `gl.${A}(${I})`;
}
function mF(A, g, I, C) {
  C = Array.from(C).map((l) => l === void 0 ? "undefined" : l);
  const t = globalThis.WebGLDebugUtils.glEnumToString(g), s = globalThis.WebGLDebugUtils.glFunctionArgsToString(I, C), r = `${t} in gl.${I}(${s})`;
  xg.error(r)();
  debugger;
}
function bF(A, g, I) {
  let C = "";
  xg.level >= 1 && (C = K1(g, I), A.traceWebGL && xg.log(1, C)());
  for (const t of I)
    if (t === void 0) {
      C = C || K1(g, I);
      debugger;
    }
}
const jb = {};
function SF(A = "id") {
  jb[A] = jb[A] || 1;
  const g = jb[A]++;
  return `${A}-${g}`;
}
class sM extends GA {
  device;
  gl;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = 5123;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength;
  /** Number of bytes used */
  bytesUsed;
  constructor(g, I = {}) {
    super(g, I), this.device = g, this.gl = this.device.gl;
    const C = typeof I == "object" ? I.handle : void 0;
    this.handle = C || this.gl.createBuffer(), g.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data }), this.glTarget = GF(this.props.usage), this.glUsage = KF(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, I.data ? this._initWithData(I.data, I.byteOffset, I.byteLength) : this._initWithByteLength(I.byteLength || 0);
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(g, I = 0, C = g.byteLength + I) {
    const t = this.glTarget;
    this.gl.bindBuffer(t, this.handle), this.gl.bufferData(t, C, this.glUsage), this.gl.bufferSubData(t, I, g), this.gl.bindBuffer(t, null), this.bytesUsed = C, this.byteLength = C, this._setDebugData(g, I, C), this.trackAllocatedMemory(C);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(g) {
    let I = g;
    g === 0 && (I = new Float32Array(0));
    const C = this.glTarget;
    return this.gl.bindBuffer(C, this.handle), this.gl.bufferData(C, I, this.glUsage), this.gl.bindBuffer(C, null), this.bytesUsed = g, this.byteLength = g, this._setDebugData(null, 0, g), this.trackAllocatedMemory(g), this;
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  write(g, I = 0) {
    this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, I, g), this.gl.bindBuffer(36663, null), this._setDebugData(g, I, g.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(g = 0, I) {
    return this.readSyncWebGL(g, I);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL(g = 0, I) {
    I = I ?? this.byteLength - g;
    const C = new Uint8Array(I), t = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, g, C, t, I), this.gl.bindBuffer(36662, null), this._setDebugData(C, g, I), C;
  }
}
function GF(A) {
  return A & GA.INDEX ? 34963 : A & GA.VERTEX ? 34962 : A & GA.UNIFORM ? 35345 : 34962;
}
function KF(A) {
  return A & GA.INDEX || A & GA.VERTEX ? 35044 : A & GA.UNIFORM ? 35048 : 35044;
}
function TF(A) {
  const g = A.split(/\r?\n/), I = [];
  for (const C of g) {
    if (C.length <= 1)
      continue;
    const t = C.split(":");
    if (t.length === 2) {
      const [w, p] = t;
      I.push({
        message: p.trim(),
        type: T1(w),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [s, r, l, ...d] = t;
    let h = parseInt(l, 10);
    isNaN(h) && (h = 0);
    let D = parseInt(r, 10);
    isNaN(D) && (D = 0), I.push({
      message: d.join(":").trim(),
      type: T1(s),
      lineNum: h,
      linePos: D
      // TODO
    });
  }
  return I;
}
function T1(A) {
  const g = ["warning", "error", "info"], I = A.toLowerCase();
  return g.includes(I) ? I : "info";
}
class YF extends Lp {
  device;
  handle;
  constructor(g, I) {
    switch (super(g, I), this.device = g, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => this.compilationStatus);
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const g = this.device.gl.getShaderInfoLog(this.handle);
    return g ? TF(g) : [];
  }
  getTranslatedSource() {
    return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(g) {
    g = g.startsWith("#version ") ? g : `#version 300 es
${g}`;
    const { gl: I } = this.device;
    if (I.shaderSource(this.handle, g), I.compileShader(this.handle), !this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    xg.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), xg.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const g = async (t) => await new Promise((s) => setTimeout(s, t));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await g(10);
      return;
    }
    const { gl: C } = this.device;
    for (; ; ) {
      if (C.getShaderParameter(this.handle, 37297))
        return;
      await g(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
function PF(A, g, I, C) {
  if (HF(g))
    return C(A);
  const t = A;
  t.pushState();
  try {
    return ZF(A, g), Ef(t.gl, I), C(A);
  } finally {
    t.popState();
  }
}
function ZF(A, g) {
  const I = A, { gl: C } = I;
  if (g.cullMode)
    switch (g.cullMode) {
      case "none":
        C.disable(2884);
        break;
      case "front":
        C.enable(2884), C.cullFace(1028);
        break;
      case "back":
        C.enable(2884), C.cullFace(1029);
        break;
    }
  if (g.frontFace && C.frontFace(yc("frontFace", g.frontFace, {
    ccw: 2305,
    cw: 2304
  })), g.unclippedDepth && A.features.has("depth-clip-control") && C.enable(34383), g.depthBias !== void 0 && (C.enable(32823), C.polygonOffset(g.depthBias, g.depthBiasSlopeScale || 0)), g.provokingVertex && A.features.has("provoking-vertex-webgl")) {
    const s = I.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, r = yc("provokingVertex", g.provokingVertex, {
      first: 36429,
      last: 36430
    });
    s?.provokingVertexWEBGL(r);
  }
  if ((g.polygonMode || g.polygonOffsetLine) && A.features.has("polygon-mode-webgl")) {
    if (g.polygonMode) {
      const s = I.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, r = yc("polygonMode", g.polygonMode, {
        fill: 6914,
        line: 6913
      });
      s?.polygonModeWEBGL(1028, r), s?.polygonModeWEBGL(1029, r);
    }
    g.polygonOffsetLine && C.enable(10754);
  }
  if (A.features.has("shader-clip-cull-distance-webgl") && (g.clipDistance0 && C.enable(12288), g.clipDistance1 && C.enable(12289), g.clipDistance2 && C.enable(12290), g.clipDistance3 && C.enable(12291), g.clipDistance4 && C.enable(12292), g.clipDistance5 && C.enable(12293), g.clipDistance6 && C.enable(12294), g.clipDistance7 && C.enable(12295)), g.depthWriteEnabled !== void 0 && C.depthMask(vF("depthWriteEnabled", g.depthWriteEnabled)), g.depthCompare && (g.depthCompare !== "always" ? C.enable(2929) : C.disable(2929), C.depthFunc(GS("depthCompare", g.depthCompare))), g.stencilWriteMask) {
    const t = g.stencilWriteMask;
    C.stencilMaskSeparate(1028, t), C.stencilMaskSeparate(1029, t);
  }
  if (g.stencilReadMask && xg.warn("stencilReadMask not supported under WebGL"), g.stencilCompare) {
    const t = g.stencilReadMask || 4294967295, s = GS("depthCompare", g.stencilCompare);
    g.stencilCompare !== "always" ? C.enable(2960) : C.disable(2960), C.stencilFuncSeparate(1028, s, 0, t), C.stencilFuncSeparate(1029, s, 0, t);
  }
  if (g.stencilPassOperation && g.stencilFailOperation && g.stencilDepthFailOperation) {
    const t = vb("stencilPassOperation", g.stencilPassOperation), s = vb("stencilFailOperation", g.stencilFailOperation), r = vb("stencilDepthFailOperation", g.stencilDepthFailOperation);
    C.stencilOpSeparate(1028, s, r, t), C.stencilOpSeparate(1029, s, r, t);
  }
  switch (g.blend) {
    case !0:
      C.enable(3042);
      break;
    case !1:
      C.disable(3042);
      break;
  }
  if (g.blendColorOperation || g.blendAlphaOperation) {
    const t = Y1("blendColorOperation", g.blendColorOperation || "add"), s = Y1("blendAlphaOperation", g.blendAlphaOperation || "add");
    C.blendEquationSeparate(t, s);
    const r = WB("blendColorSrcFactor", g.blendColorSrcFactor || "one"), l = WB("blendColorDstFactor", g.blendColorDstFactor || "zero"), d = WB("blendAlphaSrcFactor", g.blendAlphaSrcFactor || "one"), h = WB("blendAlphaDstFactor", g.blendAlphaDstFactor || "zero");
    C.blendFuncSeparate(r, l, d, h);
  }
}
function GS(A, g) {
  return yc(A, g, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function vb(A, g) {
  return yc(A, g, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function Y1(A, g) {
  return yc(A, g, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function WB(A, g) {
  return yc(A, g, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function jF(A, g) {
  return `Illegal parameter ${g} for ${A}`;
}
function yc(A, g, I) {
  if (!(g in I))
    throw new Error(jF(A, g));
  return I[g];
}
function vF(A, g) {
  return g;
}
function HF(A) {
  let g = !0;
  for (const I in A) {
    g = !1;
    break;
  }
  return g;
}
function Uv(A) {
  const g = {};
  return A.addressModeU && (g[10242] = Hb(A.addressModeU)), A.addressModeV && (g[10243] = Hb(A.addressModeV)), A.addressModeW && (g[32882] = Hb(A.addressModeW)), A.magFilter && (g[10240] = KS(A.magFilter)), (A.minFilter || A.mipmapFilter) && (g[10241] = EF(A.minFilter || "linear", A.mipmapFilter)), A.lodMinClamp !== void 0 && (g[33082] = A.lodMinClamp), A.lodMaxClamp !== void 0 && (g[33083] = A.lodMaxClamp), A.type === "comparison-sampler" && (g[34892] = 34894), A.compare && (g[34893] = GS("compare", A.compare)), A.maxAnisotropy && (g[34046] = A.maxAnisotropy), g;
}
function Hb(A) {
  switch (A) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function KS(A) {
  switch (A) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function EF(A, g = "none") {
  if (!g)
    return KS(A);
  switch (g) {
    case "none":
      return KS(A);
    case "nearest":
      return A === "nearest" ? 9984 : 9986;
    case "linear":
      return A === "nearest" ? 9985 : 9987;
  }
}
class TS extends lM {
  device;
  handle;
  parameters;
  constructor(g, I) {
    super(g, I), this.device = g, this.parameters = Uv(I), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(g) {
    for (const [I, C] of Object.entries(g)) {
      const t = Number(I);
      switch (t) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, t, C);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, t, C);
          break;
      }
    }
  }
}
class ff extends Jp {
  device;
  gl;
  handle;
  // Does not have a WebGL representation
  texture;
  constructor(g, I) {
    super(g, { ...cA.defaultProps, ...I }), this.device = g, this.gl = this.device.gl, this.handle = null, this.texture = I.texture;
  }
}
const RF = "Failed to deduce GL constant from typed array";
function OF(A) {
  switch (ArrayBuffer.isView(A) ? A.constructor : A) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(RF);
  }
}
function NF(A, g) {
  const { clamped: I = !0 } = g || {};
  switch (A) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return I ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function Fv(A) {
  switch (A) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return 0;
  }
}
function kF(A) {
  switch (A) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return 0;
  }
}
function Ep(A, g, I) {
  if (WF(g))
    return I(A);
  const { nocatch: C = !0 } = g, t = hc.get(A);
  t.push(), Ef(A, g);
  let s;
  if (C)
    s = I(A), t.pop();
  else
    try {
      s = I(A);
    } finally {
      t.pop();
    }
  return s;
}
function WF(A) {
  for (const g in A)
    return !1;
  return !0;
}
function VF(A, g, I) {
  const { dimension: C, width: t, height: s, depth: r = 0 } = I, { glInternalFormat: l } = I, d = I.glTarget;
  switch (C) {
    case "2d-array":
    case "3d":
      A.texStorage3D(d, g, l, t, s, r);
      break;
    default:
      A.texStorage2D(d, g, l, t, s);
  }
}
function P1(A, g, I, C) {
  const { width: t, height: s } = C, { dimension: r, depth: l = 0, mipLevel: d = 0 } = C, { x: h = 0, y: D = 0, z: w = 0 } = C, { glFormat: p, glType: b } = C, S = Xv(C.glTarget, r, l), K = C.flipY ? { 37440: !0 } : {};
  Ep(A, K, () => {
    switch (r) {
      case "2d-array":
      case "3d":
        A.bindTexture(S, g), A.texSubImage3D(S, d, h, D, w, t, s, l, p, b, I), A.bindTexture(S, null);
        break;
      case "2d":
      case "cube":
        A.bindTexture(S, g), A.texSubImage2D(S, d, h, D, t, s, p, b, I), A.bindTexture(S, null);
        break;
      default:
        throw new Error(r);
    }
  });
}
function Z1(A, g, I) {
  const { dimension: C, width: t, height: s, depth: r = 0, mipLevel: l = 0, byteOffset: d = 0 } = I, { x: h = 0, y: D = 0, z: w = 0 } = I, { glFormat: p, glType: b, compressed: S } = I, K = Xv(I.glTarget, C, r);
  switch (C) {
    case "2d-array":
    case "3d":
      S ? A.compressedTexSubImage3D(K, l, h, D, w, t, s, r, p, g, d) : A.texSubImage3D(K, l, h, D, w, t, s, r, p, b, g, d);
      break;
    case "2d":
    case "cube":
      S ? A.compressedTexSubImage2D(K, l, h, D, t, s, p, g, d) : A.texSubImage2D(K, l, h, D, t, s, p, b, g, d);
      break;
    default:
      throw new Error(C);
  }
}
function xF(A) {
  switch (A) {
    case "1d":
      break;
    // not supported in any WebGL version
    case "2d":
      return 3553;
    // supported in WebGL1
    case "3d":
      return 32879;
    // supported in WebGL2
    case "cube":
      return 34067;
    // supported in WebGL1
    case "2d-array":
      return 35866;
  }
  throw new Error(A);
}
function Xv(A, g, I) {
  return g === "cube" ? 34069 + I : A;
}
function _F(A, g) {
  const {
    sourceX: I = 0,
    sourceY: C = 0,
    sourceAttachment: t = 0
    // TODO - support gl.readBuffer
  } = g || {};
  let {
    target: s = null,
    // following parameters are auto deduced if not provided
    sourceWidth: r,
    sourceHeight: l,
    sourceDepth: d,
    sourceFormat: h,
    sourceType: D
  } = g || {};
  const { framebuffer: w, deleteFramebuffer: p } = Qv(A), { gl: b, handle: S } = w;
  r ||= w.width, l ||= w.height;
  const K = w.colorAttachments[t]?.texture;
  if (!K)
    throw new Error(`Invalid framebuffer attachment ${t}`);
  d = K?.depth || 1, h ||= K?.glFormat || 6408, D ||= K?.glType || 5121, s = XF(s, D, h, r, l), D = D || OF(s);
  const Y = b.bindFramebuffer(36160, S);
  return b.readBuffer(36064 + t), b.readPixels(I, C, r, l, h, D, s), b.readBuffer(36064), b.bindFramebuffer(36160, Y || null), p && w.destroy(), s;
}
function UF(A, g) {
  const { target: I, sourceX: C = 0, sourceY: t = 0, sourceFormat: s = 6408, targetByteOffset: r = 0 } = g || {};
  let { sourceWidth: l, sourceHeight: d, sourceType: h } = g || {};
  const { framebuffer: D, deleteFramebuffer: w } = Qv(A);
  l = l || D.width, d = d || D.height;
  const p = D;
  h = h || 5121;
  let b = I;
  if (!b) {
    const K = Fv(s), Y = kF(h), T = r + l * d * K * Y;
    b = p.device.createBuffer({ byteLength: T });
  }
  const S = A.device.createCommandEncoder();
  return S.copyTextureToBuffer({
    sourceTexture: A,
    width: l,
    height: d,
    origin: [C, t],
    destinationBuffer: b,
    byteOffset: r
  }), S.destroy(), w && D.destroy(), b;
}
function Qv(A) {
  return A instanceof qp ? { framebuffer: A, deleteFramebuffer: !1 } : { framebuffer: FF(A), deleteFramebuffer: !0 };
}
function FF(A, g) {
  const { device: I, width: C, height: t, id: s } = A;
  return I.createFramebuffer({
    ...g,
    id: `framebuffer-for-${s}`,
    width: C,
    height: t,
    colorAttachments: [A]
  });
}
function XF(A, g, I, C, t, s) {
  if (A)
    return A;
  g ||= 5121;
  const r = NF(g, { clamped: !1 }), l = Fv(I);
  return new r(C * t * l);
}
class oM extends cA {
  // readonly MAX_ATTRIBUTES: number;
  device;
  gl;
  handle;
  sampler = void 0;
  // TODO - currently unused in WebGL. Create dummy sampler?
  view = void 0;
  // TODO - currently unused in WebGL. Create dummy view?
  mipmaps;
  // Texture type
  /** Whether the internal format is compressed */
  compressed;
  /**
   * The WebGL target corresponding to the texture type
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   */
  glTarget;
  /** The WebGL format - essentially channel structure */
  glFormat;
  /** The WebGL data format - the type of each channel */
  glType;
  /** The WebGL constant corresponding to the WebGPU style constant in format */
  glInternalFormat;
  // state
  /** Texture binding slot - TODO - move to texture view? */
  textureUnit = 0;
  constructor(g, I) {
    super(g, I);
    const C = { ...this.props };
    C.data = I.data, this.device = g, this.gl = this.device.gl, this.glTarget = xF(this.props.dimension);
    const t = Vv(this.props.format);
    this.glInternalFormat = t.internalFormat, this.glFormat = t.format, this.glType = t.type, this.compressed = t.compressed, this.mipmaps = !!this.props.mipmaps, this._initialize(C), Object.seal(this);
  }
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initialize(g) {
    this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, { ...this.props, data: g.data });
    let { width: I, height: C } = g;
    if (!I || !C) {
      const t = cA.getTextureDataSize(g.data);
      I = t?.width || 1, C = t?.height || 1;
    }
    if (this.width = I, this.height = C, this.depth = g.depth, this.setSampler(g.sampler), this.view = new ff(this.device, { ...this.props, texture: this }), this.bind(), VF(this.gl, this.mipLevels, this), g.data)
      switch (g.dimension) {
        case "1d":
          this.setTexture1DData(g.data);
          break;
        case "2d":
          this.setTexture2DData(g.data);
          break;
        case "3d":
          this.setTexture3DData(g.data);
          break;
        case "cube":
          this.setTextureCubeData(g.data);
          break;
        case "2d-array":
          this.setTextureArrayData(g.data);
          break;
        case "cube-array":
          this.setTextureCubeArrayData(g.data);
          break;
        // @ts-expect-error
        default:
          throw new Error(g.dimension);
      }
    this.mipmaps && this.generateMipmap();
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  createView(g) {
    return new ff(this.device, { ...g, texture: this });
  }
  setSampler(g = {}) {
    let I;
    g instanceof TS ? (this.sampler = g, I = g.props) : (this.sampler = new TS(this.device, g), I = g);
    const C = Uv(I);
    this._setSamplerParameters(C);
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(g) {
    if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (xg.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !g?.force)))
      try {
        this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
      } catch (C) {
        xg.warn(`Error generating mipmap for ${this}: ${C.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
  }
  // Image Data Setters
  copyExternalImage(g) {
    const I = cA.getExternalImageSize(g.image), C = { ...cA.defaultCopyExternalImageOptions, ...I, ...g }, { image: t, depth: s, mipLevel: r, x: l, y: d, z: h, flipY: D } = C;
    let { width: w, height: p } = C;
    const { dimension: b, glTarget: S, glFormat: K, glInternalFormat: Y, glType: T } = this;
    if (w = Math.min(w, this.width - l), p = Math.min(p, this.height - d), g.sourceX || g.sourceY)
      throw new Error("WebGL does not support sourceX/sourceY)");
    return P1(this.device.gl, this.handle, t, {
      dimension: b,
      mipLevel: r,
      x: l,
      y: d,
      z: h,
      width: w,
      height: p,
      depth: s,
      glFormat: K,
      glType: T,
      glTarget: S,
      flipY: D
    }), { width: C.width, height: C.height };
  }
  setTexture1DData(g) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Set a simple texture */
  setTexture2DData(g, I = 0) {
    this.bind();
    const C = cA.normalizeTextureData(g, this);
    C.length > 1 && this.props.mipmaps !== !1 && xg.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    for (let t = 0; t < C.length; t++) {
      const s = C[t];
      this._setMipLevel(I, t, s);
    }
    this.unbind();
  }
  /**
   * Sets a 3D texture
   * @param data
   */
  setTexture3DData(g) {
    if (this.props.dimension !== "3d")
      throw new Error(this.id);
    ArrayBuffer.isView(g) && (this.bind(), Z1(this.device.gl, g, this), this.unbind());
  }
  /**
   * Set a Texture Cube Data
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  setTextureCubeData(g, I = 0) {
    if (this.props.dimension !== "cube")
      throw new Error(this.id);
    for (const C of cA.CubeFaces)
      this.setTextureCubeFaceData(g[C], C);
  }
  /**
   * Sets an entire texture array
   * @param data
   */
  setTextureArrayData(g) {
    throw this.props.dimension !== "2d-array" ? new Error(this.id) : new Error("setTextureArrayData not implemented.");
  }
  /**
   * Sets an entire texture cube array
   * @param data
   */
  setTextureCubeArrayData(g) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  setTextureCubeFaceData(g, I, C = 0) {
    Array.isArray(g) && g.length > 1 && this.props.mipmaps !== !1 && xg.warn(`${this.id} has mipmap and multiple LODs.`)();
    const t = cA.CubeFaces.indexOf(I);
    this.setTexture2DData(g, t);
  }
  // DEPRECATED METHODS
  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */
  update() {
    throw new Error("Texture.update() not implemented. Use ExternalTexture");
  }
  // INTERNAL METHODS
  /** @todo update this method to accept LODs */
  setImageDataForFace(g) {
    const {
      face: I,
      width: C,
      height: t,
      pixels: s,
      data: r,
      format: l = 6408,
      type: d = 5121
      // generateMipmap = false // TODO
    } = g, { gl: h } = this, D = s || r;
    this.bind(), D instanceof Promise ? D.then((w) => this.setImageDataForFace(Object.assign({}, g, {
      face: I,
      data: w,
      pixels: w
    }))) : this.width || this.height ? h.texImage2D(I, 0, l, C, t, 0, l, d, D) : h.texImage2D(I, 0, l, l, d, D);
  }
  _getImageDataMap(g) {
    for (let I = 0; I < cA.CubeFaces.length; ++I) {
      const C = cA.CubeFaces[I];
      g[C] && (g[34069 + I] = g[C], delete g[C]);
    }
    return g;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(g) {
    xg.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(g))(), this.gl.bindTexture(this.glTarget, this.handle);
    for (const [I, C] of Object.entries(g)) {
      const t = Number(I), s = C;
      switch (t) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, t, s);
          break;
        case 10241:
          this.gl.texParameteri(this.glTarget, t, s);
          break;
        case 10242:
        case 10243:
          this.gl.texParameteri(this.glTarget, t, s);
          break;
        case 34046:
          this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, t, s);
          break;
        default:
          this.gl.texParameteri(this.glTarget, t, s);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  // INTERNAL SETTERS
  /**
   * Copy a region of data from a CPU memory buffer into this texture.
   * @todo -   GLUnpackParameters parameters
   */
  _setMipLevel(g, I, C, t = this.glTarget) {
    if (cA.isExternalImage(C)) {
      P1(this.device.gl, this.handle, C, {
        ...this,
        depth: g,
        mipLevel: I,
        glTarget: t,
        flipY: this.props.flipY
      });
      return;
    }
    if (cA.isTextureLevelData(C)) {
      Z1(this.device.gl, C.data, {
        ...this,
        depth: g,
        mipLevel: I,
        glTarget: t
      });
      return;
    }
    throw new Error("Texture: invalid image data");
  }
  // HELPERS
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(g) {
    const { gl: I } = this;
    return g !== void 0 && (this.textureUnit = g, I.activeTexture(33984 + g)), I.bindTexture(this.glTarget, this.handle), g;
  }
  unbind(g) {
    const { gl: I } = this;
    return g !== void 0 && (this.textureUnit = g, I.activeTexture(33984 + g)), I.bindTexture(this.glTarget, null), g;
  }
}
const QF = [1, 2, 4, 8];
class zF extends rc {
  device;
  /** Parameters that should be applied before each draw call */
  glParameters;
  constructor(g, I) {
    super(g, I), this.device = g;
    let C;
    if (!I?.parameters?.viewport)
      if (I?.framebuffer) {
        const { width: s, height: r } = I.framebuffer;
        C = [0, 0, s, r];
      } else {
        const [s, r] = g.getCanvasContext().getDrawingBufferSize();
        C = [0, 0, s, r];
      }
    if (this.device.pushState(), this.setParameters({ viewport: C, ...this.props.parameters }), this.props.framebuffer?.handle)
      if (this.props.framebuffer) {
        const s = this.props.framebuffer.colorAttachments.map((r, l) => 36064 + l);
        this.device.gl.drawBuffers(s);
      } else
        this.device.gl.drawBuffers([1029]);
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(g) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(g) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(g = {}) {
    const I = { ...this.glParameters };
    I.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (I.depthMask = !this.props.depthReadOnly), I.stencilMask = this.props.stencilReadOnly ? 0 : 1, I[35977] = this.props.discard, g.viewport && (g.viewport.length >= 6 ? (I.viewport = g.viewport.slice(0, 4), I.depthRange = [g.viewport[4], g.viewport[5]]) : I.viewport = g.viewport), g.scissorRect && (I.scissorTest = !0, I.scissor = g.scissorRect), g.blendConstant && (I.blendColor = g.blendConstant), g.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), g[2967] = g.stencilReference), g.colorMask && (I.colorMask = QF.map((C) => !!(C & g.colorMask))), this.glParameters = I, Ef(this.device.gl, I);
  }
  beginOcclusionQuery(g) {
    this.props.occlusionQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    this.props.occlusionQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const g = { ...this.glParameters };
    let I = 0;
    this.props.clearColors && this.props.clearColors.forEach((C, t) => {
      C && this.clearColorBuffer(t, C);
    }), this.props.clearColor !== !1 && this.props.clearColors === void 0 && (I |= 16384, g.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (I |= 256, g.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (I |= 1024, g.clearStencil = this.props.clearStencil), I !== 0 && Ep(this.device.gl, g, () => {
      this.device.gl.clear(I);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(g = 0, I = [0, 0, 0, 0]) {
    Ep(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (I.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, g, I);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, g, I);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, g, I);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
}
function JF(A) {
  return LF.includes(A);
}
const LF = [
  35678,
  35680,
  35679,
  35682,
  36289,
  36292,
  36293,
  36298,
  36299,
  36300,
  36303,
  36306,
  36307,
  36308,
  36311
], zv = {
  5126: [5126, 1, "float", "f32", "float32"],
  35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  5124: [5124, 1, "int", "i32", "sint32"],
  35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  35669: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  5125: [5125, 1, "uint", "u32", "uint32"],
  36294: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  36295: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  36296: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  35670: [5126, 1, "bool", "f32", "float32"],
  35671: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  35672: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  35673: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  35674: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  35685: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  35686: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  35687: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  35675: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  35676: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function Jv(A) {
  const g = zv[A];
  if (!g)
    throw new Error("uniform");
  const [I, C, , t] = g;
  return { format: t, components: C, glType: I };
}
function qF(A) {
  const g = zv[A];
  if (!g)
    throw new Error("attribute");
  const [, I, , C, t] = g;
  return { attributeType: C, vertexFormat: t, components: I };
}
function $F(A, g) {
  const I = {
    attributes: [],
    bindings: []
  };
  I.attributes = gX(A, g);
  const C = CX(A, g);
  for (const l of C) {
    const d = l.uniforms.map((h) => ({
      name: h.name,
      format: h.format,
      byteOffset: h.byteOffset,
      byteStride: h.byteStride,
      arrayLength: h.arrayLength
    }));
    I.bindings.push({
      type: "uniform",
      name: l.name,
      group: 0,
      location: l.location,
      visibility: (l.vertex ? 1 : 0) & (l.fragment ? 2 : 0),
      minBindingSize: l.byteLength,
      uniforms: d
    });
  }
  const t = AX(A, g);
  let s = 0;
  for (const l of t)
    if (JF(l.type)) {
      const { viewDimension: d, sampleType: h } = tX(l.type);
      I.bindings.push({
        type: "texture",
        name: l.name,
        group: 0,
        location: s,
        viewDimension: d,
        sampleType: h
      }), l.textureUnit = s, s += 1;
    }
  t.length && (I.uniforms = t);
  const r = IX(A, g);
  return r?.length && (I.varyings = r), I;
}
function gX(A, g) {
  const I = [], C = A.getProgramParameter(g, 35721);
  for (let t = 0; t < C; t++) {
    const s = A.getActiveAttrib(g, t);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: r,
      type: l
      /* , size*/
    } = s, d = A.getAttribLocation(g, r);
    if (d >= 0) {
      const { attributeType: h } = qF(l), D = /instance/i.test(r) ? "instance" : "vertex";
      I.push({
        name: r,
        location: d,
        stepMode: D,
        type: h
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return I.sort((t, s) => t.location - s.location), I;
}
function IX(A, g) {
  const I = [], C = A.getProgramParameter(g, 35971);
  for (let t = 0; t < C; t++) {
    const s = A.getTransformFeedbackVarying(g, t);
    if (!s)
      throw new Error("activeInfo");
    const { name: r, type: l, size: d } = s, { glType: h, components: D } = Jv(l), w = { location: t, name: r, type: h, size: d * D };
    I.push(w);
  }
  return I.sort((t, s) => t.location - s.location), I;
}
function AX(A, g) {
  const I = [], C = A.getProgramParameter(g, 35718);
  for (let t = 0; t < C; t++) {
    const s = A.getActiveUniform(g, t);
    if (!s)
      throw new Error("activeInfo");
    const { name: r, size: l, type: d } = s, { name: h, isArray: D } = iX(r);
    let w = A.getUniformLocation(g, h);
    const p = {
      // WebGL locations are uniquely typed but just numbers
      location: w,
      name: h,
      size: l,
      type: d,
      isArray: D
    };
    if (I.push(p), p.size > 1)
      for (let b = 0; b < p.size; b++) {
        const S = `${h}[${b}]`;
        w = A.getUniformLocation(g, S);
        const K = {
          ...p,
          name: S,
          location: w
        };
        I.push(K);
      }
  }
  return I;
}
function CX(A, g) {
  const I = (s, r) => A.getActiveUniformBlockParameter(g, s, r), C = [], t = A.getProgramParameter(g, 35382);
  for (let s = 0; s < t; s++) {
    const r = {
      name: A.getActiveUniformBlockName(g, s) || "",
      location: I(s, 35391),
      byteLength: I(s, 35392),
      vertex: I(s, 35396),
      fragment: I(s, 35398),
      uniformCount: I(s, 35394),
      uniforms: []
    }, l = I(s, 35395) || [], d = A.getActiveUniforms(g, l, 35383), h = A.getActiveUniforms(g, l, 35384), D = A.getActiveUniforms(g, l, 35387), w = A.getActiveUniforms(g, l, 35388);
    for (let p = 0; p < r.uniformCount; ++p) {
      const b = A.getActiveUniform(g, l[p]);
      if (!b)
        throw new Error("activeInfo");
      r.uniforms.push({
        name: b.name,
        format: Jv(d[p]).format,
        type: d[p],
        arrayLength: h[p],
        byteOffset: D[p],
        byteStride: w[p]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    C.push(r);
  }
  return C.sort((s, r) => s.location - r.location), C;
}
const eX = {
  35678: ["2d", "float"],
  35680: ["cube", "float"],
  35679: ["3d", "float"],
  35682: ["3d", "depth"],
  36289: ["2d-array", "float"],
  36292: ["2d-array", "depth"],
  36293: ["cube", "float"],
  36298: ["2d", "sint"],
  36299: ["3d", "sint"],
  36300: ["cube", "sint"],
  36303: ["2d-array", "uint"],
  36306: ["2d", "uint"],
  36307: ["3d", "uint"],
  36308: ["cube", "uint"],
  36311: ["2d-array", "uint"]
};
function tX(A) {
  const g = eX[A];
  if (!g)
    throw new Error("sampler");
  const [I, C] = g;
  return { viewDimension: I, sampleType: C };
}
function iX(A) {
  if (A[A.length - 1] !== "]")
    return {
      name: A,
      length: 1,
      isArray: !1
    };
  const I = /([^[]*)(\[[0-9]+\])?/.exec(A);
  if (!I || I.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${A}`);
  return {
    name: I[1],
    length: I[2] ? 1 : 0,
    isArray: !!I[2]
  };
}
function nX(A, g, I, C) {
  const t = A;
  let s = C;
  s === !0 && (s = 1), s === !1 && (s = 0);
  const r = typeof s == "number" ? [s] : s;
  switch (I) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof C != "number")
        throw new Error("samplers must be set to integers");
      return A.uniform1i(g, C);
    case 5126:
      return A.uniform1fv(g, r);
    case 35664:
      return A.uniform2fv(g, r);
    case 35665:
      return A.uniform3fv(g, r);
    case 35666:
      return A.uniform4fv(g, r);
    case 5124:
      return A.uniform1iv(g, r);
    case 35667:
      return A.uniform2iv(g, r);
    case 35668:
      return A.uniform3iv(g, r);
    case 35669:
      return A.uniform4iv(g, r);
    case 35670:
      return A.uniform1iv(g, r);
    case 35671:
      return A.uniform2iv(g, r);
    case 35672:
      return A.uniform3iv(g, r);
    case 35673:
      return A.uniform4iv(g, r);
    // WEBGL2 - unsigned integers
    case 5125:
      return t.uniform1uiv(g, r, 1);
    case 36294:
      return t.uniform2uiv(g, r, 2);
    case 36295:
      return t.uniform3uiv(g, r, 3);
    case 36296:
      return t.uniform4uiv(g, r, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return A.uniformMatrix2fv(g, !1, r);
    case 35675:
      return A.uniformMatrix3fv(g, !1, r);
    case 35676:
      return A.uniformMatrix4fv(g, !1, r);
    // WebGL2 - rectangular matrices
    case 35685:
      return t.uniformMatrix2x3fv(g, !1, r);
    case 35686:
      return t.uniformMatrix2x4fv(g, !1, r);
    case 35687:
      return t.uniformMatrix3x2fv(g, !1, r);
    case 35688:
      return t.uniformMatrix3x4fv(g, !1, r);
    case 35689:
      return t.uniformMatrix4x2fv(g, !1, r);
    case 35690:
      return t.uniformMatrix4x3fv(g, !1, r);
  }
  throw new Error("Illegal uniform");
}
function sX(A) {
  return Kv(A) !== null || typeof A == "number" || typeof A == "boolean";
}
function oX(A) {
  const g = { bindings: {}, uniforms: {} };
  return Object.keys(A).forEach((I) => {
    const C = A[I];
    sX(C) ? g.uniforms[I] = C : g.bindings[I] = C;
  }), g;
}
function aX(A) {
  switch (A) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(A);
  }
}
function rX(A) {
  switch (A) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(A);
  }
}
const j1 = 4;
class lX extends mf {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  constructor(g, I) {
    super(g, I), this.device = g, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, { id: this.props.id }), this.vs = I.vs, this.fs = I.fs;
    const { varyings: C, bufferMode: t = 35981 } = I;
    C && C.length > 0 && (this.varyings = C, this.device.gl.transformFeedbackVaryings(this.handle, C, t)), this._linkShaders(), xg.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = $F(this.device.gl, this.handle), xg.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = cX(this.introspectedLayout, I.shaderLayout);
  }
  destroy() {
    this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(g, I) {
    for (const [C, t] of Object.entries(g)) {
      const s = this.shaderLayout.bindings.find((r) => r.name === C) || this.shaderLayout.bindings.find((r) => r.name === `${C}Uniforms`);
      if (!s) {
        const r = this.shaderLayout.bindings.map((l) => `"${l.name}"`).join(", ");
        I?.disableWarnings || xg.warn(`No binding "${C}" in render pipeline "${this.id}", expected one of ${r}`, t)();
        continue;
      }
      switch (t || xg.warn(`Unsetting binding "${C}" in render pipeline "${this.id}"`)(), s.type) {
        case "uniform":
          if (!(t instanceof sM) && !(t.buffer instanceof sM))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(t instanceof ff || t instanceof oM || t instanceof nM))
            throw new Error("texture value");
          break;
        case "sampler":
          xg.warn(`Ignoring sampler ${C}`)();
          break;
        default:
          throw new Error(s.type);
      }
      this.bindings[C] = t;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(g) {
    const {
      renderPass: I,
      parameters: C = this.props.parameters,
      topology: t = this.props.topology,
      vertexArray: s,
      vertexCount: r,
      // indexCount,
      instanceCount: l,
      isInstanced: d = !1,
      firstVertex: h = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: D
    } = g, w = aX(t), p = !!s.indexBuffer, b = s.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success")
      return xg.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable())
      return xg.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    this.device.gl.useProgram(this.handle), s.bindBeforeRender(I), D && D.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const S = I;
    return PF(this.device, C, S.glParameters, () => {
      p && d ? this.device.gl.drawElementsInstanced(
        w,
        r || 0,
        // indexCount?
        b,
        h,
        l || 0
      ) : p ? this.device.gl.drawElements(w, r || 0, b, h) : d ? this.device.gl.drawArraysInstanced(w, h, r || 0, l || 0) : this.device.gl.drawArrays(w, h, r || 0), D && D.end();
    }), s.unbindAfterRender(I), !0;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(g) {
    const { bindings: I } = oX(g);
    Object.keys(I).forEach((C) => {
      xg.warn(`Unsupported value "${JSON.stringify(I[C])}" used in setUniforms() for key ${C}. Use setBindings() instead?`)();
    }), Object.assign(this.uniforms, g);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl: g } = this.device;
    if (g.attachShader(this.handle, this.vs.handle), g.attachShader(this.handle, this.fs.handle), xg.time(j1, `linkProgram for ${this.id}`)(), g.linkProgram(this.handle), xg.timeEnd(j1, `linkProgram for ${this.id}`)(), xg.level, !this.device.features.has("compilation-status-async-webgl")) {
      const C = this._getLinkStatus();
      this._reportLinkStatus(C);
      return;
    }
    xg.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), xg.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const I = this._getLinkStatus();
    this._reportLinkStatus(I);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(g) {
    switch (g) {
      case "success":
        return;
      default:
        switch (this.vs.compilationStatus) {
          case "error":
            throw this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`);
          case "pending":
            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());
            break;
        }
        switch (this.fs?.compilationStatus) {
          case "error":
            throw this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`);
          case "pending":
            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());
            break;
        }
        const I = this.device.gl.getProgramInfoLog(this.handle);
        throw new Error(`Error during ${g}: ${I}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl: g } = this.device;
    return g.getProgramParameter(this.handle, 35714) ? (g.validateProgram(this.handle), g.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const g = async (t) => await new Promise((s) => setTimeout(s, t));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await g(10);
      return;
    }
    const { gl: C } = this.device;
    for (; ; ) {
      if (C.getProgramParameter(this.handle, 37297))
        return;
      await g(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let g = !0;
    for (const I of this.shaderLayout.bindings)
      !this.bindings[I.name] && !this.bindings[I.name.replace(/Uniforms$/, "")] && (xg.warn(`Binding ${I.name} not found in ${this.id}`)(), g = !1);
    return g;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const { gl: g } = this.device;
    g.useProgram(this.handle);
    let I = 0, C = 0;
    for (const t of this.shaderLayout.bindings) {
      const s = this.bindings[t.name] || this.bindings[t.name.replace(/Uniforms$/, "")];
      if (!s)
        throw new Error(`No value for binding ${t.name} in ${this.id}`);
      switch (t.type) {
        case "uniform":
          const { name: r } = t, l = g.getUniformBlockIndex(this.handle, r);
          if (l === 4294967295)
            throw new Error(`Invalid uniform block name ${r}`);
          g.uniformBlockBinding(this.handle, C, l), s instanceof sM ? g.bindBufferBase(35345, C, s.handle) : g.bindBufferRange(
            35345,
            C,
            // @ts-expect-error
            s.buffer.handle,
            // @ts-expect-error
            s.offset || 0,
            // @ts-expect-error
            s.size || s.buffer.byteLength - s.offset
          ), C += 1;
          break;
        case "texture":
          if (!(s instanceof ff || s instanceof oM || s instanceof nM))
            throw new Error("texture");
          let d;
          if (s instanceof ff)
            d = s.texture;
          else if (s instanceof oM)
            d = s;
          else if (s instanceof nM && s.colorAttachments[0] instanceof ff)
            xg.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), d = s.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          g.activeTexture(33984 + I), g.bindTexture(d.glTarget, d.handle), I += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${t.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const g of this.shaderLayout.uniforms || []) {
      const { name: I, location: C, type: t, textureUnit: s } = g, r = this.uniforms[I] ?? s;
      r !== void 0 && nX(this.device.gl, C, t, r);
    }
  }
}
function cX(A, g) {
  const I = {
    ...A,
    attributes: A.attributes.map((C) => ({ ...C }))
  };
  for (const C of g?.attributes || []) {
    const t = I.attributes.find((s) => s.name === C.name);
    t ? (t.type = C.type || t.type, t.stepMode = C.stepMode || t.stepMode) : xg.warn(`shader layout attribute ${C.name} not present in shader`);
  }
  return I;
}
class uX extends oG {
  device;
  commands = [];
  constructor(g) {
    super(g, {}), this.device = g;
  }
  submitCommands(g = this.commands) {
    for (const I of g)
      switch (I.name) {
        case "copy-buffer-to-buffer":
          dX(this.device, I.options);
          break;
        case "copy-buffer-to-texture":
          fX(this.device, I.options);
          break;
        case "copy-texture-to-buffer":
          hX(this.device, I.options);
          break;
        case "copy-texture-to-texture":
          yX(this.device, I.options);
          break;
        // case 'clear-texture':
        //   _clearTexture(this.device, command.options);
        //   break;
        default:
          throw new Error(I.name);
      }
  }
}
function dX(A, g) {
  const I = g.sourceBuffer, C = g.destinationBuffer;
  A.gl.bindBuffer(36662, I.handle), A.gl.bindBuffer(36663, C.handle), A.gl.copyBufferSubData(36662, 36663, g.sourceOffset ?? 0, g.destinationOffset ?? 0, g.size), A.gl.bindBuffer(36662, null), A.gl.bindBuffer(36663, null);
}
function fX(A, g) {
  throw new Error("Not implemented");
}
function hX(A, g) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: I,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: C = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: t = "all",
    /** Width to copy */
    width: s = g.sourceTexture.width,
    /** Height to copy */
    height: r = g.sourceTexture.height,
    depthOrArrayLayers: l = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: d = [0, 0],
    /** Destination buffer */
    destinationBuffer: h,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: D = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: w,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: p
  } = g;
  if (t !== "all")
    throw new Error("aspect not supported in WebGL");
  if (C !== 0 || l !== 0 || w || p)
    throw new Error("not implemented");
  const { framebuffer: b, destroyFramebuffer: S } = Lv(I);
  let K;
  try {
    const Y = h, T = s || b.width, E = r || b.height, H = Vv(b.colorAttachments[0].texture.props.format), R = H.format, x = H.type;
    A.gl.bindBuffer(35051, Y.handle), K = A.gl.bindFramebuffer(36160, b.handle), A.gl.readPixels(d[0], d[1], T, E, R, x, D);
  } finally {
    A.gl.bindBuffer(35051, null), K !== void 0 && A.gl.bindFramebuffer(36160, K), S && b.destroy();
  }
}
function yX(A, g) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: I,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: C = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: t = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: s = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture: r
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = g;
  let {
    width: l = g.destinationTexture.width,
    height: d = g.destinationTexture.height
    // depthOrArrayLayers = 0
  } = g;
  const { framebuffer: h, destroyFramebuffer: D } = Lv(I), [w, p] = t, [b, S, K] = s, Y = A.gl.bindFramebuffer(36160, h.handle);
  let T = null, E;
  if (r instanceof oM)
    T = r, l = Number.isFinite(l) ? l : T.width, d = Number.isFinite(d) ? d : T.height, T.bind(0), E = T.glTarget;
  else
    throw new Error("invalid destination");
  switch (E) {
    case 3553:
    case 34067:
      A.gl.copyTexSubImage2D(E, C, b, S, w, p, l, d);
      break;
    case 35866:
    case 32879:
      A.gl.copyTexSubImage3D(E, C, b, S, K, w, p, l, d);
      break;
  }
  T && T.unbind(), A.gl.bindFramebuffer(36160, Y), D && h.destroy();
}
function Lv(A) {
  if (A instanceof cA) {
    const { width: g, height: I, id: C } = A;
    return { framebuffer: A.device.createFramebuffer({
      id: `framebuffer-for-${C}`,
      width: g,
      height: I,
      colorAttachments: [A]
    }), destroyFramebuffer: !0 };
  }
  return { framebuffer: A, destroyFramebuffer: !1 };
}
class DX extends sG {
  device;
  commandBuffer;
  constructor(g, I) {
    super(g, I), this.device = g, this.commandBuffer = new uX(g);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(g) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options: g });
  }
  copyBufferToTexture(g) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options: g });
  }
  copyTextureToBuffer(g) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options: g });
  }
  copyTextureToTexture(g) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options: g });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(g) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(g) {
  }
  resolveQuerySet(g, I, C) {
  }
}
function MX(A) {
  const { target: g, source: I, start: C = 0, count: t = 1 } = A, s = I.length, r = t * s;
  let l = 0;
  for (let d = C; l < s; l++)
    g[d++] = I[l];
  for (; l < r; )
    l < r - l ? (g.copyWithin(C + l, C, C + l), l *= 2) : (g.copyWithin(C + l, C, C + r - l), l = r);
  return A.target;
}
class VG extends aG {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(g) {
    return vN() === "Chrome";
  }
  // Create a VertexArray
  constructor(g, I) {
    super(g, I), this.device = g, this.handle = this.device.gl.createVertexArray();
  }
  destroy() {
    super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(g) {
    const I = g;
    if (I && I.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, I ? I.handle : null), this.indexBuffer = I, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(g, I) {
    const C = I;
    if (C.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const { size: t, type: s, stride: r, offset: l, normalized: d, integer: h, divisor: D } = this._getAccessor(g);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, C.handle), h ? this.device.gl.vertexAttribIPointer(g, t, s, r, l) : this.device.gl.vertexAttribPointer(g, t, s, d, r, l), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(g), this.device.gl.vertexAttribDivisor(g, D || 0), this.attributes[g] = C, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(g, I) {
    this._enable(g, !1), this.attributes[g] = I;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let g = 0; g < this.maxVertexAttributes; ++g) {
      const I = this.attributes[g];
      ArrayBuffer.isView(I) && this.device.setConstantAttributeWebGL(g, I);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(g) {
    const I = this.attributeInfos[g];
    if (!I)
      throw new Error(`Unknown attribute location ${g}`);
    const C = Wv(I.bufferDataType);
    return {
      size: I.bufferComponents,
      type: C,
      stride: I.byteStride,
      offset: I.byteOffset,
      normalized: I.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: I.integer,
      divisor: I.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(g, I = !0) {
    const t = VG.isConstantAttributeZeroSupported(this.device) || g !== 0;
    (I || t) && (g = Number(g), this.device.gl.bindVertexArray(this.handle), I ? this.device.gl.enableVertexAttribArray(g) : this.device.gl.disableVertexAttribArray(g), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(g, I) {
    const C = wX(I), t = C.byteLength * g, s = C.length * g;
    if (this.buffer && t !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${t} !== ${this.buffer.byteLength}.`);
    let r = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({ byteLength: t }), r = r || !BX(C, this.bufferValue), r) {
      const l = j4(I.constructor, s);
      MX({ target: l, source: C, start: 0, count: s }), this.buffer.write(l), this.bufferValue = I;
    }
    return this.buffer;
  }
}
function wX(A) {
  return Array.isArray(A) ? new Float32Array(A) : A;
}
function BX(A, g) {
  if (!A || !g || A.length !== g.length || A.constructor !== g.constructor)
    return !1;
  for (let I = 0; I < A.length; ++I)
    if (A[I] !== g[I])
      return !1;
  return !0;
}
class pX extends rG {
  device;
  gl;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = !0;
  _bound = !1;
  constructor(g, I) {
    super(g, I), this.device = g, this.gl = g.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, I.buffers && this.setBuffers(I.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin(g = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(rX(g));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(g) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const I in g)
        this.setBuffer(I, g[I]);
    });
  }
  setBuffer(g, I) {
    const C = this._getVaryingIndex(g), { buffer: t, byteLength: s, byteOffset: r } = this._getBufferRange(I);
    if (C < 0) {
      this.unusedBuffers[g] = t, xg.warn(`${this.id} unusedBuffers varying buffer ${g}`)();
      return;
    }
    this.buffers[C] = { buffer: t, byteLength: s, byteOffset: r }, this.bindOnUse || this._bindBuffer(C, t, r, s);
  }
  getBuffer(g) {
    if (v1(g))
      return this.buffers[g] || null;
    const I = this._getVaryingIndex(g);
    return I >= 0 ? this.buffers[I] : null;
  }
  bind(g = this.handle) {
    if (typeof g != "function")
      return this.gl.bindTransformFeedback(36386, g), this;
    let I;
    return this._bound ? I = g() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, I = g(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), I;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(g) {
    if (g instanceof sM)
      return { buffer: g, byteOffset: 0, byteLength: g.byteLength };
    const { buffer: I, byteOffset: C = 0, byteLength: t = g.buffer.byteLength } = g;
    return { buffer: I, byteOffset: C, byteLength: t };
  }
  _getVaryingIndex(g) {
    if (v1(g))
      return Number(g);
    for (const I of this.layout.varyings)
      if (g === I.name)
        return I.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const g in this.buffers) {
      const { buffer: I, byteLength: C, byteOffset: t } = this._getBufferRange(this.buffers[g]);
      this._bindBuffer(Number(g), I, t, C);
    }
  }
  _unbindBuffers() {
    for (const g in this.buffers)
      this.gl.bindBufferBase(35982, Number(g), null);
  }
  _bindBuffer(g, I, C = 0, t) {
    const s = I && I.handle;
    !s || t === void 0 ? this.gl.bindBufferBase(35982, g, s) : this.gl.bindBufferRange(35982, g, s, C, t);
  }
}
function v1(A) {
  return typeof A == "number" ? Number.isInteger(A) : /^\d+$/.test(A);
}
class mX extends lG {
  device;
  handle;
  target = null;
  _queryPending = !1;
  _pollingPromise = null;
  get [Symbol.toStringTag]() {
    return "Query";
  }
  // Create a query class
  constructor(g, I) {
    if (super(g, I), this.device = g, I.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    this.handle = this.device.gl.createQuery(), Object.seal(this);
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(g) {
    return this._begin(g?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(g) {
    this._queryPending || (this.target = g, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const g = this.device.gl.getQueryParameter(this.handle, 34919);
    return g && (this._queryPending = !1), g;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(g = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise)
      return this._pollingPromise;
    let I = 0;
    return this._pollingPromise = new Promise((C, t) => {
      const s = () => {
        this.isResultAvailable() ? (C(this.getResult()), this._pollingPromise = null) : I++ > g ? (t("Timed out"), this._pollingPromise = null) : requestAnimationFrame(s);
      };
      requestAnimationFrame(s);
    }), this._pollingPromise;
  }
}
class hf extends hr {
  //
  // Public `Device` API
  //
  /** type of this device */
  type = "webgl";
  // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
  /** The underlying WebGL context */
  handle;
  features;
  limits;
  info;
  canvasContext;
  lost;
  _resolveContextLost;
  /** WebGL2 context. */
  gl;
  debug = !1;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = !1;
  /** Instance of Spector.js (if initialized) */
  spectorJS;
  //
  // Public API
  //
  constructor(g) {
    super({ ...g, id: g.id || SF("webgl-device") });
    const I = hr._getCanvasContextProps(g);
    if (!I)
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    let C = I.canvas?.gl?.device;
    if (C)
      throw new Error(`WebGL context already attached to device ${C.id}`);
    this.canvasContext = new dF(this, I), this.lost = new Promise((D) => {
      this._resolveContextLost = D;
    });
    const t = { ...g.webgl };
    I.alphaMode === "premultiplied" && (t.premultipliedAlpha = !0), g.powerPreference !== void 0 && (t.powerPreference = g.powerPreference);
    const r = this.props._handle || z3(this.canvasContext.canvas, {
      onContextLost: (D) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      }),
      // eslint-disable-next-line no-console
      onContextRestored: (D) => console.log("WebGL context restored")
    }, t);
    if (!r)
      throw new Error("WebGL context creation failed");
    if (C = r.device, C) {
      if (g._reuseDevices)
        return xg.log(1, `Not creating a new Device, instead returning a reference to Device ${C.id} already attached to WebGL context`, C)(), C._reused = !0, C;
      throw new Error(`WebGL context already attached to device ${C.id}`);
    }
    this.handle = r, this.gl = r, this.spectorJS = yF({ ...this.props, gl: this.handle }), this.gl.device = this, this.gl._version = 2, this.info = J3(this.gl, this._extensions), this.limits = new lF(this.gl), this.features = new rF(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), I.autoResize !== !1 && this.canvasContext.resize(), new hc(this.gl, {
      log: (...D) => xg.log(1, ...D)()
    }).trackState(this.gl, { copyState: !1 });
    const d = g.debugWebGL || g.debug, h = g.debugWebGL;
    d && (this.gl = wF(this.gl, { debugWebGL: d, traceWebGL: h }), xg.warn("WebGL debug mode activated. Performance reduced.")(), g.debugWebGL && (xg.level = Math.max(xg.level, 1)));
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    !this.props._reuseDevices && !this._reused && delete this.gl.device;
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(g) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(g) {
    const I = this._normalizeBufferProps(g);
    return new sM(this, I);
  }
  createTexture(g) {
    return new oM(this, g);
  }
  createExternalTexture(g) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(g) {
    return new TS(this, g);
  }
  createShader(g) {
    return new YF(this, g);
  }
  createFramebuffer(g) {
    return new nM(this, g);
  }
  createVertexArray(g) {
    return new VG(this, g);
  }
  createTransformFeedback(g) {
    return new pX(this, g);
  }
  createQuerySet(g) {
    return new mX(this, g);
  }
  createRenderPipeline(g) {
    return new lX(this, g);
  }
  beginRenderPass(g) {
    return new zF(this, g);
  }
  createComputePipeline(g) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(g) {
    throw new Error("ComputePass not supported in WebGL");
  }
  renderPass = null;
  createCommandEncoder(g = {}) {
    return new DX(this, g);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    this.renderPass?.end(), this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(g, I) {
    return _F(g, I);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(g, I) {
    return UF(g, I);
  }
  setParametersWebGL(g) {
    Ef(this.gl, g);
  }
  getParametersWebGL(g) {
    return Nv(this.gl, g);
  }
  withParametersWebGL(g, I) {
    return Ep(this.gl, g, I);
  }
  resetWebGL() {
    xg.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), _3(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(g) {
    return nF(this.gl, g, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let g = !1;
    const C = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return C && (g = !0, C.loseContext()), this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    }), g;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    hc.get(this.gl).push();
  }
  /** Restores previously saved context state */
  popState() {
    hc.get(this.gl).pop();
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(g, I) {
    g.__SPECTOR_Metadata = I;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(g, I) {
    const C = Number(g);
    for (const t in this.gl)
      if (this.gl[t] === C)
        return `GL.${t}`;
    return I?.emptyIfUnknown ? "" : String(g);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(g) {
    const I = { emptyIfUnknown: !0 };
    return Object.entries(g).reduce((C, [t, s]) => (C[`${t}:${this.getGLKey(t, I)}`] = `${s}:${this.getGLKey(s, I)}`, C), {});
  }
  /** Store constants */
  _constants;
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(g, I) {
    const C = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(C).fill(null);
    const t = this._constants[g];
    switch (t && KX(t, I) && xg.info(1, `setConstantAttributeWebGL(${g}) could have been skipped, value unchanged`)(), this._constants[g] = I, I.constructor) {
      case Float32Array:
        bX(this, g, I);
        break;
      case Int32Array:
        SX(this, g, I);
        break;
      case Uint32Array:
        GX(this, g, I);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(g) {
    return Zf(this.gl, g, this._extensions), this._extensions;
  }
}
function bX(A, g, I) {
  switch (I.length) {
    case 1:
      A.gl.vertexAttrib1fv(g, I);
      break;
    case 2:
      A.gl.vertexAttrib2fv(g, I);
      break;
    case 3:
      A.gl.vertexAttrib3fv(g, I);
      break;
    case 4:
      A.gl.vertexAttrib4fv(g, I);
      break;
  }
}
function SX(A, g, I) {
  A.gl.vertexAttribI4iv(g, I);
}
function GX(A, g, I) {
  A.gl.vertexAttribI4uiv(g, I);
}
function KX(A, g) {
  if (!A || !g || A.length !== g.length || A.constructor !== g.constructor)
    return !1;
  for (let I = 0; I < A.length; ++I)
    if (A[I] !== g[I])
      return !1;
  return !0;
}
const TX = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
}, YX = (A) => ({
  drawBuffersWEBGL(g) {
    return A.drawBuffers(g);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
}), PX = (A) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return A.createVertexArray();
  },
  deleteVertexArrayOES(g) {
    return A.deleteVertexArray(g);
  },
  isVertexArrayOES(g) {
    return A.isVertexArray(g);
  },
  bindVertexArrayOES(g) {
    return A.bindVertexArray(g);
  }
}), ZX = (A) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE(...g) {
    return A.drawArraysInstanced(...g);
  },
  drawElementsInstancedANGLE(...g) {
    return A.drawElementsInstanced(...g);
  },
  vertexAttribDivisorANGLE(...g) {
    return A.vertexAttribDivisor(...g);
  }
});
function jX(A = !0) {
  const g = HTMLCanvasElement.prototype;
  if (!A && g.originalGetContext) {
    g.getContext = g.originalGetContext, g.originalGetContext = void 0;
    return;
  }
  g.originalGetContext = g.getContext, g.getContext = function(I, C) {
    if (I === "webgl" || I === "experimental-webgl") {
      const t = this.originalGetContext("webgl2", C);
      return t instanceof HTMLElement && vX(t), t;
    }
    return this.originalGetContext(I, C);
  };
}
function vX(A) {
  A.getExtension("EXT_color_buffer_float");
  const g = {
    ...TX,
    WEBGL_disjoint_timer_query: A.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: YX(A),
    OES_vertex_array_object: PX(A),
    ANGLE_instanced_arrays: ZX(A)
  }, I = A.getExtension;
  A.getExtension = function(t) {
    const s = I.call(A, t);
    return s || (t in g ? g[t] : null);
  };
  const C = A.getSupportedExtensions;
  A.getSupportedExtensions = function() {
    return (C.apply(A) || [])?.concat(Object.keys(g));
  };
}
const VB = 1;
class HX extends o4 {
  /** type of device's created by this adapter */
  type = "webgl";
  constructor() {
    super(), hr.defaultProps = { ...hr.defaultProps, ...WG }, hf.adapter = this;
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(g) {
    jX(g);
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(g) {
    if (g instanceof hf)
      return g;
    if (g?.device instanceof hr)
      return g.device;
    if (!EX(g))
      throw new Error("Invalid WebGL2RenderingContext");
    return new hf({
      _handle: g,
      createCanvasContext: { canvas: g.canvas, autoResize: !1 }
    });
  }
  async create(g = {}) {
    xg.groupCollapsed(VB, "WebGLDevice created")();
    const I = [];
    (g.debugWebGL || g.debug) && I.push(MF()), g.debugSpectorJS && I.push(hF(g));
    const C = await Promise.allSettled(I);
    for (const r of C)
      r.status === "rejected" && xg.error(`Failed to initialize debug libraries ${r.reason}`)();
    const t = new hf(g), s = `${t._reused ? "Reusing" : "Created"} device with WebGL2 ${t.debug ? "debug " : ""}context: ${t.info.vendor}, ${t.info.renderer} for canvas: ${t.canvasContext.id}`;
    return xg.probe(VB, s)(), xg.table(VB, t.info)(), xg.groupEnd(VB)(), t;
  }
}
function EX(A) {
  return typeof WebGL2RenderingContext < "u" && A instanceof WebGL2RenderingContext ? !0 : !!(A && Number.isFinite(A._version));
}
const H1 = new HX();
function ar() {
}
const RX = ({ isDragging: A }) => A ? "grabbing" : "grab", qv = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {},
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: ar,
  onWebGLInitialized: ar,
  onResize: ar,
  onViewStateChange: ar,
  onInteractionStateChange: ar,
  onBeforeRender: ar,
  onAfterRender: ar,
  onLoad: ar,
  onError: (A) => uA.error(A.message, A.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: RX,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class e0 {
  constructor(g) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new Qp({ id: "deck.gl" }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (C) => {
      const { _pickRequest: t } = this;
      if (C.type === "pointerleave")
        t.x = -1, t.y = -1, t.radius = 0;
      else {
        if (C.leftButton || C.rightButton)
          return;
        {
          const s = C.offsetCenter;
          if (!s)
            return;
          t.x = s.x, t.y = s.y, t.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = { x: t.x, y: t.y }), t.event = C;
    }, this._onEvent = (C) => {
      const t = MS[C.type], s = C.offsetCenter;
      if (!t || !s || !this.layerManager)
        return;
      const r = this.layerManager.getLayers(), l = this.deckPicker.getLastPickedObject({
        x: s.x,
        y: s.y,
        layers: r,
        viewports: this.getViewports(s)
      }, this._lastPointerDownInfo), { layer: d } = l, h = d && (d[t] || d.props[t]), D = this.props[t];
      let w = !1;
      h && (w = h.call(d, l, C)), w || (D?.(l, C), this.widgetManager.onEvent(l, C));
    }, this._onPointerDown = (C) => {
      if (this.device?.type === "webgpu")
        return;
      const t = C.offsetCenter, s = this._pick("pickObject", "pickObject Time", {
        x: t.x,
        y: t.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = s.result[0] || s.emptyInfo;
    }, this.props = { ...qv, ...g }, g = this.props, g.viewState && g.initialViewState && uA.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, g.device && (this.device = g.device);
    let I = this.device;
    !I && g.gl && (g.gl instanceof WebGLRenderingContext && uA.error("WebGL1 context not supported.")(), I = H1.attach(g.gl)), I || (I = CS.createDevice({
      type: "best-available",
      // luma by default throws if a device is already attached
      // asynchronous device creation could happen after finalize() is called
      // TODO - createDevice should support AbortController?
      _reuseDevices: !0,
      adapters: [H1],
      ...g.deviceProps,
      createCanvasContext: {
        canvas: this._createCanvas(g),
        useDevicePixels: this.props.useDevicePixels,
        // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`
        autoResize: !1
      }
    })), this.animationLoop = this._createAnimationLoop(I, g), this.setProps(g), g._typedArrayManagerProps && fM.setOptions(g._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(g) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in g && uA.removed("onLayerHover", "onHover")(), "onLayerClick" in g && uA.removed("onLayerClick", "onClick")(), g.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Qt(this.props.initialViewState, g.initialViewState, 3) && (this.viewState = g.initialViewState), Object.assign(this.props, g), this._setCanvasSize(this.props);
    const I = Object.create(this.props);
    Object.assign(I, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), this.animationLoop?.setProps(I), this.layerManager && (this.viewManager.setProps(I), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(I), this.effectManager.setProps(I), this.deckRenderer.setProps(I), this.deckPicker.setProps(I), this.widgetManager.setProps(I)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(g = { clearRedrawFlags: !1 }) {
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let I = this._needsRedraw;
    g.clearRedrawFlags && (this._needsRedraw = !1);
    const C = this.viewManager.needsRedraw(g), t = this.layerManager.needsRedraw(g), s = this.effectManager.needsRedraw(g), r = this.deckRenderer.needsRedraw(g);
    return I = I || C || t || s || r, I;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(g) {
    if (!this.layerManager)
      return;
    let I = this.needsRedraw({ clearRedrawFlags: !0 });
    I = g || I, I && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(I) : this._drawLayers(I));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return Ge(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(g) {
    return Ge(this.viewManager), this.viewManager.getViewports(g);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(g) {
    const I = this._pick("pickObject", "pickObject Time", g).result;
    return I.length ? I[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(g) {
    return g.depth = g.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", g).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(g) {
    return this._pick("pickObjects", "pickObjects Time", g);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(g, I = !1) {
    for (const C in g)
      this.layerManager.resourceManager.add({ resourceId: C, data: g[C], forceUpdate: I });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(g) {
    for (const I of g)
      this.layerManager.resourceManager.remove(I);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(g) {
    this.effectManager.addDefaultEffect(g);
  }
  _addDefaultShaderModule(g) {
    this.layerManager.addDefaultShaderModule(g);
  }
  _removeDefaultShaderModule(g) {
    this.layerManager?.removeDefaultShaderModule(g);
  }
  _pick(g, I, C) {
    Ge(this.deckPicker);
    const { stats: t } = this;
    t.get("Pick Count").incrementCount(), t.get(I).timeStart();
    const s = this.deckPicker[g]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(C),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(C),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...C
    });
    return t.get(I).timeEnd(), s;
  }
  /** Resolve props.canvas to element */
  _createCanvas(g) {
    let I = g.canvas;
    return typeof I == "string" && (I = document.getElementById(I), Ge(I)), I || (I = document.createElement("canvas"), I.id = g.id || "deckgl-overlay", (g.parent || document.body).appendChild(I)), Object.assign(I.style, g.style), I;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(g) {
    if (!this.canvas)
      return;
    const { width: I, height: C } = g;
    if (I || I === 0) {
      const t = Number.isFinite(I) ? `${I}px` : I;
      this.canvas.style.width = t;
    }
    if (C || C === 0) {
      const t = Number.isFinite(C) ? `${C}px` : C;
      this.canvas.style.position = g.style?.position || "absolute", this.canvas.style.height = t;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const { canvas: g } = this;
    if (!g)
      return;
    const I = g.clientWidth ?? g.width, C = g.clientHeight ?? g.height;
    (I !== this.width || C !== this.height) && (this.width = I, this.height = C, this.viewManager?.setProps({ width: I, height: C }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({ width: I, height: C }));
  }
  _createAnimationLoop(g, I) {
    const {
      // width,
      // height,
      gl: C,
      // debug,
      onError: t,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels: s
    } = I;
    return new VU({
      device: g,
      useDevicePixels: s,
      // TODO v9
      autoResizeDrawingBuffer: !C,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (r) => this._setDevice(r.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: t
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views: g } = this.props, I = Array.isArray(g) ? g : (
      // If null, default to a full screen map view port
      g ? [g] : [new Ev({ id: "default-view" })]
    );
    return I.length && this.props.controller && (I[0].props.controller = this.props.controller), I;
  }
  _onContextLost() {
    const { onError: g } = this.props;
    this.animationLoop && g && g(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    if (this.device?.type === "webgpu")
      return;
    const { _pickRequest: g } = this;
    if (g.event) {
      const { result: I, emptyInfo: C } = this._pick("pickObject", "pickObject Time", g);
      this.cursorState.isHovering = I.length > 0;
      let t = C, s = !1;
      for (const r of I)
        t = r, s = r.layer?.onHover(r, g.event) || s;
      s || (this.props.onHover?.(t, g.event), this.widgetManager.onHover(t, g.event)), g.event = null;
    }
  }
  _updateCursor() {
    const g = this.props.parent || this.canvas;
    g && (g.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(g) {
    if (this.device = g, !this.animationLoop)
      return;
    this.canvas || (this.canvas = this.device.canvasContext?.canvas), this.device.type === "webgl" && this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device.type === "webgl" && this.props.onWebGLInitialized(this.device.gl);
    const I = new Gv();
    I.play(), this.animationLoop.attachTimeline(I), this.eventManager = new h9(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(A1).map((t) => {
        const [s, r, l, d] = A1[t], h = this.props.eventRecognizerOptions?.[t], D = { ...r, ...h, event: t };
        return {
          recognizer: new s(D),
          recognizeWith: l,
          requestFailure: d
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const t in MS)
      this.eventManager.on(t, this._onEvent);
    this.viewManager = new l3({
      timeline: I,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const C = this.viewManager.getViewports()[0];
    this.layerManager = new r3(this.device, {
      deck: this,
      stats: this.stats,
      viewport: C,
      timeline: I
    }), this.effectManager = new S3({
      deck: this,
      device: this.device
    }), this.deckRenderer = new T3(this.device), this.deckPicker = new H3(this.device), this.widgetManager = new O3({
      deck: this,
      parentElement: this.canvas?.parentElement
    }), this.widgetManager.addDefault(new k3()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(g, I) {
    const { device: C, gl: t } = this.layerManager.context;
    this.props.onBeforeRender({ device: C, gl: t });
    const s = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...I
    };
    this.deckRenderer?.renderLayers(s), s.pass === "screen" && this.widgetManager.onRedraw({
      viewports: s.viewports,
      layers: s.layers
    }), this.props.onAfterRender({ device: C, gl: t });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), uA.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this.device?.type !== "webgpu" && this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(g) {
    const I = this.props.onViewStateChange(g) || g.viewState;
    this.viewState && (this.viewState = { ...this.viewState, [g.viewId]: I }, this.props.viewState || this.viewManager && this.viewManager.setProps({ viewState: this.viewState }));
  }
  _onInteractionStateChange(g) {
    this.cursorState.isDragging = g.isDragging || !1, this.props.onInteractionStateChange(g);
  }
  _getFrameStats() {
    const { stats: g } = this;
    g.get("frameRate").timeEnd(), g.get("frameRate").timeStart();
    const I = this.animationLoop.stats;
    g.get("GPU Time").addTime(I.get("GPU Time").lastTiming), g.get("CPU Time").addTime(I.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics: g, stats: I } = this;
    g.fps = I.get("frameRate").getHz(), g.setPropsTime = I.get("setProps Time").time, g.updateAttributesTime = I.get("Update Attributes").time, g.framesRedrawn = I.get("Redraw Count").count, g.pickTime = I.get("pickObject Time").time + I.get("pickMultipleObjects Time").time + I.get("pickObjects Time").time, g.pickCount = I.get("Pick Count").count, g.gpuTime = I.get("GPU Time").time, g.cpuTime = I.get("CPU Time").time, g.gpuTimePerFrame = I.get("GPU Time").getAverageTime(), g.cpuTimePerFrame = I.get("CPU Time").getAverageTime();
    const C = CS.stats.get("Memory Usage");
    g.bufferMemory = C.get("Buffer Memory").count, g.textureMemory = C.get("Texture Memory").count, g.renderbufferMemory = C.get("Renderbuffer Memory").count, g.gpuMemory = C.get("GPU Memory").count;
  }
}
e0.defaultProps = qv;
e0.VERSION = CV;
function OX(A) {
  switch (A) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return Ij(A);
  }
}
const NX = gj;
function xB(A, g, I) {
  const C = I === "webgpu" && g.type === "uint8" ? "unorm8" : g.type;
  return {
    attribute: A,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: g.size > 1 ? `${C}x${g.size}` : g.type,
    byteOffset: g.offset || 0
    // Note stride is set on the top level
  };
}
function cc(A) {
  return A.stride || A.size * A.bytesPerElement;
}
function kX(A, g) {
  return A.type === g.type && A.size === g.size && cc(A) === cc(g) && (A.offset || 0) === (g.offset || 0);
}
function YS(A, g) {
  g.offset && uA.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const I = cc(A), C = g.vertexOffset !== void 0 ? g.vertexOffset : A.vertexOffset || 0, t = g.elementOffset || 0, s = (
    // offsets defined by the attribute
    C * I + t * A.bytesPerElement + // offsets defined by external buffers if any
    (A.offset || 0)
  );
  return {
    ...g,
    offset: s,
    stride: I
  };
}
function WX(A, g) {
  const I = YS(A, g);
  return {
    high: I,
    low: {
      ...I,
      offset: I.offset + A.size * 4
    }
  };
}
class VX {
  /* eslint-disable max-statements */
  constructor(g, I, C) {
    this._buffer = null, this.device = g, this.id = I.id || "", this.size = I.size || 1;
    const t = I.logicalType || I.type, s = t === "float64";
    let { defaultValue: r } = I;
    r = Number.isFinite(r) ? [r] : r || new Array(this.size).fill(0);
    let l;
    s ? l = "float32" : !t && I.isIndexed ? l = "uint32" : l = t || "float32";
    let d = OX(t || l);
    this.doublePrecision = s, s && I.fp64 === !1 && (d = Float32Array), this.value = null, this.settings = {
      ...I,
      defaultType: d,
      defaultValue: r,
      logicalType: t,
      type: l,
      normalized: l.includes("norm"),
      size: this.size,
      bytesPerElement: d.BYTES_PER_ELEMENT
    }, this.state = {
      ...C,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const g = this.getAccessor();
    return g.vertexOffset ? g.vertexOffset * cc(g) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(g) {
    this.state.numInstances = g;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), fM.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue(g = this.id, I = null) {
    const C = {};
    if (this.state.constant) {
      const t = this.value;
      if (I) {
        const s = YS(this.getAccessor(), I), r = s.offset / t.BYTES_PER_ELEMENT, l = s.size || this.size;
        C[g] = t.subarray(r, r + l);
      } else
        C[g] = t;
    } else
      C[g] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? C[`${g}64Low`] = C[g] : C[`${g}64Low`] = new Float32Array(this.size)), C;
  }
  _getBufferLayout(g = this.id, I = null) {
    const C = this.getAccessor(), t = [], s = {
      name: this.id,
      byteStride: cc(C),
      attributes: t
    };
    if (this.doublePrecision) {
      const r = WX(C, I || {});
      t.push(xB(g, { ...C, ...r.high }, this.device.type), xB(`${g}64Low`, {
        ...C,
        ...r.low
      }, this.device.type));
    } else if (I) {
      const r = YS(C, I);
      t.push(xB(g, { ...C, ...r }, this.device.type));
    } else
      t.push(xB(g, C, this.device.type));
    return s;
  }
  setAccessor(g) {
    this.state.bufferAccessor = g;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let g = null;
    if (this.state.constant && this.value) {
      const I = Array.from(this.value);
      g = [I, I];
    } else {
      const { value: I, numInstances: C, size: t } = this, s = C * t;
      if (I && s && I.length >= s) {
        const r = new Array(t).fill(1 / 0), l = new Array(t).fill(-1 / 0);
        for (let d = 0; d < s; )
          for (let h = 0; h < t; h++) {
            const D = I[d++];
            D < r[h] && (r[h] = D), D > l[h] && (l[h] = D);
          }
        g = [r, l];
      }
    }
    return this.state.bounds = g, g;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(g) {
    const { state: I } = this;
    let C;
    ArrayBuffer.isView(g) ? C = { value: g } : g instanceof GA ? C = { buffer: g } : C = g;
    const t = { ...this.settings, ...C };
    if (ArrayBuffer.isView(C.value)) {
      if (!C.type)
        if (this.doublePrecision && C.value instanceof Float64Array)
          t.type = "float32";
        else {
          const r = NX(C.value);
          t.type = t.normalized ? r.replace("int", "norm") : r;
        }
      t.bytesPerElement = C.value.BYTES_PER_ELEMENT, t.stride = cc(t);
    }
    if (I.bounds = null, C.constant) {
      let s = C.value;
      if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!I.constant || !this._areValuesEqual(s, this.value)))
        return !1;
      I.externalBuffer = null, I.constant = !0, this.value = ArrayBuffer.isView(s) ? s : new Float32Array(s);
    } else if (C.buffer) {
      const s = C.buffer;
      I.externalBuffer = s, I.constant = !1, this.value = C.value || null;
    } else if (C.value) {
      this._checkExternalBuffer(C);
      let s = C.value;
      I.externalBuffer = null, I.constant = !1, this.value = s;
      let { buffer: r } = this;
      const l = cc(t), d = (t.vertexOffset || 0) * l;
      if (this.doublePrecision && s instanceof Float64Array && (s = Sb(s, t)), this.settings.isIndexed) {
        const D = this.settings.defaultType;
        s.constructor !== D && (s = new D(s));
      }
      const h = s.byteLength + d + l * 2;
      (!r || r.byteLength < h) && (r = this._createBuffer(h)), r.write(s, d);
    }
    return this.setAccessor(t), !0;
  }
  updateSubBuffer(g = {}) {
    this.state.bounds = null;
    const I = this.value, { startOffset: C = 0, endOffset: t } = g;
    this.buffer.write(this.doublePrecision && I instanceof Float64Array ? Sb(I, {
      size: this.size,
      startIndex: C,
      endIndex: t
    }) : I.subarray(C, t), C * I.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(g, I = !1) {
    const { state: C } = this, t = C.allocatedValue, s = fM.allocate(t, g + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: I
    });
    this.value = s;
    const { byteOffset: r } = this;
    let { buffer: l } = this;
    return (!l || l.byteLength < s.byteLength + r) && (l = this._createBuffer(s.byteLength + r), I && t && l.write(t instanceof Float64Array ? Sb(t, this) : t, r)), C.allocatedValue = s, C.constant = !1, C.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(g) {
    const { value: I } = g;
    if (!ArrayBuffer.isView(I))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const C = this.settings.defaultType;
    let t = !1;
    if (this.doublePrecision && (t = I.BYTES_PER_ELEMENT < 4), t)
      throw new Error(`Attribute ${this.id} does not support ${I.constructor.name}`);
    !(I instanceof C) && this.settings.normalized && !("normalized" in g) && uA.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(g) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(g).map((I) => (I + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(g).map((I) => (I + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(g).map((I) => I / 255);
      case "unorm16":
        return new Float32Array(g).map((I) => I / 65535);
      default:
        return g;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(g, I, C) {
    const { defaultValue: t, size: s } = this.settings;
    if (Number.isFinite(g))
      return I[C] = g, I;
    if (!g) {
      let r = s;
      for (; --r >= 0; )
        I[C + r] = t[r];
      return I;
    }
    switch (s) {
      case 4:
        I[C + 3] = Number.isFinite(g[3]) ? g[3] : t[3];
      case 3:
        I[C + 2] = Number.isFinite(g[2]) ? g[2] : t[2];
      case 2:
        I[C + 1] = Number.isFinite(g[1]) ? g[1] : t[1];
      case 1:
        I[C + 0] = Number.isFinite(g[0]) ? g[0] : t[0];
        break;
      default:
        let r = s;
        for (; --r >= 0; )
          I[C + r] = Number.isFinite(g[r]) ? g[r] : t[r];
    }
    return I;
  }
  _areValuesEqual(g, I) {
    if (!g || !I)
      return !1;
    const { size: C } = this;
    for (let t = 0; t < C; t++)
      if (g[t] !== I[t])
        return !1;
    return !0;
  }
  _createBuffer(g) {
    this._buffer && this._buffer.destroy();
    const { isIndexed: I, type: C } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
      usage: (I ? GA.INDEX : GA.VERTEX) | GA.COPY_DST,
      indexType: I ? C : void 0,
      byteLength: g
    }), this._buffer;
  }
}
const E1 = [], R1 = [];
function xX(A, g = 0, I = 1 / 0) {
  let C = E1;
  const t = {
    index: -1,
    data: A,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return A ? typeof A[Symbol.iterator] == "function" ? C = A : A.length > 0 && (R1.length = A.length, C = R1) : C = E1, (g > 0 || Number.isFinite(I)) && (C = (Array.isArray(C) ? C : Array.from(C)).slice(g, I), t.index = g - 1), { iterable: C, objectInfo: t };
}
function $v(A) {
  return A && A[Symbol.asyncIterator];
}
function _X(A, g) {
  const { size: I, stride: C, offset: t, startIndices: s, nested: r } = g, l = A.BYTES_PER_ELEMENT, d = C ? C / l : I, h = t ? t / l : 0, D = Math.floor((A.length - h) / d);
  return (w, { index: p, target: b }) => {
    if (!s) {
      const T = p * d + h;
      for (let E = 0; E < I; E++)
        b[E] = A[T + E];
      return b;
    }
    const S = s[p], K = s[p + 1] || D;
    let Y;
    if (r) {
      Y = new Array(K - S);
      for (let T = S; T < K; T++) {
        const E = T * d + h;
        b = new Array(I);
        for (let H = 0; H < I; H++)
          b[H] = A[E + H];
        Y[T - S] = b;
      }
    } else if (d === I)
      Y = A.subarray(S * I + h, K * I + h);
    else {
      Y = new A.constructor((K - S) * I);
      let T = 0;
      for (let E = S; E < K; E++) {
        const H = E * d + h;
        for (let R = 0; R < I; R++)
          Y[T++] = A[H + R];
      }
    }
    return Y;
  };
}
const UX = [], ap = [[0, 1 / 0]];
function FX(A, g) {
  if (A === ap || (g[0] < 0 && (g[0] = 0), g[0] >= g[1]))
    return A;
  const I = [], C = A.length;
  let t = 0;
  for (let s = 0; s < C; s++) {
    const r = A[s];
    r[1] < g[0] ? (I.push(r), t = s + 1) : r[0] > g[1] ? I.push(r) : g = [Math.min(r[0], g[0]), Math.max(r[1], g[1])];
  }
  return I.splice(t, 0, g), I;
}
const XX = {
  interpolation: {
    duration: 0,
    easing: (A) => A
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function gH(A, g) {
  if (!A)
    return null;
  Number.isFinite(A) && (A = { type: "interpolation", duration: A });
  const I = A.type || "interpolation";
  return {
    ...XX[I],
    ...g,
    ...A,
    type: I
  };
}
class IH extends VX {
  constructor(g, I) {
    super(g, I, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: ap
    }), this.constant = !1, this.settings.update = I.update || (I.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(g) {
    this.state.startIndices = g;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags: g = !1 } = {}) {
    const I = this.state.needsRedraw;
    return this.state.needsRedraw = I && !g, I;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(g) {
    var I;
    (I = this.state).layoutChanged || (I.layoutChanged = !kX(g, this.getAccessor())), super.setAccessor(g);
  }
  getUpdateTriggers() {
    const { accessor: g } = this.settings;
    return [this.id].concat(typeof g != "function" && g || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(g) {
    if (!g || !this.supportsTransition())
      return null;
    const { accessor: I } = this.settings, C = this.settings.transition, t = Array.isArray(I) ? (
      // @ts-ignore
      g[I.find((s) => g[s])]
    ) : (
      // @ts-ignore
      g[I]
    );
    return gH(t, C);
  }
  setNeedsUpdate(g = this.id, I) {
    if (this.state.needsUpdate = this.state.needsUpdate || g, this.setNeedsRedraw(g), I) {
      const { startRow: C = 0, endRow: t = 1 / 0 } = I;
      this.state.updateRanges = FX(this.state.updateRanges, [C, t]);
    } else
      this.state.updateRanges = ap;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = UX;
  }
  setNeedsRedraw(g = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || g;
  }
  allocate(g) {
    const { state: I, settings: C } = this;
    return C.noAlloc ? !1 : C.update ? (super.allocate(g, I.updateRanges !== ap), !0) : !1;
  }
  updateBuffer({ numInstances: g, data: I, props: C, context: t }) {
    if (!this.needsUpdate())
      return !1;
    const { state: { updateRanges: s }, settings: { update: r, noAlloc: l } } = this;
    let d = !0;
    if (r) {
      for (const [h, D] of s)
        r.call(t, this, { data: I, startRow: h, endRow: D, props: C, numInstances: g });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [h, D] of s) {
          const w = Number.isFinite(h) ? this.getVertexOffset(h) : 0, p = Number.isFinite(D) ? this.getVertexOffset(D) : l || !Number.isFinite(g) ? this.value.length : g * this.size;
          super.updateSubBuffer({ startOffset: w, endOffset: p });
        }
      this._checkAttributeArray();
    } else
      d = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), d;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(g) {
    return this.device.type === "webgpu" || g === void 0 || typeof g == "function" ? !1 : (this.setData({ constant: !0, value: g }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(g) {
    const { state: I } = this;
    return g ? (this.clearNeedsUpdate(), I.lastExternalBuffer === g || (I.lastExternalBuffer = g, this.setNeedsRedraw(), this.setData(g)), !0) : (I.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(g, I = null) {
    const { state: C, settings: t } = this;
    if (!g)
      return C.binaryValue = null, C.binaryAccessor = null, !1;
    if (t.noAlloc)
      return !1;
    if (C.binaryValue === g)
      return this.clearNeedsUpdate(), !0;
    if (C.binaryValue = g, this.setNeedsRedraw(), t.transform || I !== this.startIndices) {
      ArrayBuffer.isView(g) && (g = { value: g });
      const r = g;
      Ge(ArrayBuffer.isView(r.value), `invalid ${t.accessor}`);
      const l = !!r.size && r.size !== this.size;
      return C.binaryAccessor = _X(r.value, {
        size: r.size || this.size,
        stride: r.stride,
        offset: r.offset,
        startIndices: I,
        nested: l
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(g), !0;
  }
  getVertexOffset(g) {
    const { startIndices: I } = this;
    return (I ? g < I.length ? I[g] : this.numInstances : g) * this.size;
  }
  getValue() {
    const g = this.settings.shaderAttributes, I = super.getValue();
    if (!g)
      return I;
    for (const C in g)
      Object.assign(I, super.getValue(C, g[C]));
    return I;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(g) {
    this.state.layoutChanged = !1;
    const I = this.settings.shaderAttributes, C = super._getBufferLayout(), { stepMode: t } = this.settings;
    if (t === "dynamic" ? C.stepMode = g ? g.isInstanced ? "instance" : "vertex" : "instance" : C.stepMode = t ?? "vertex", !I)
      return C;
    for (const s in I) {
      const r = super._getBufferLayout(s, I[s]);
      C.attributes.push(...r.attributes);
    }
    return C;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(g, { data: I, startRow: C, endRow: t, props: s, numInstances: r }) {
    if (g.constant && this.context.device.type !== "webgpu")
      return;
    const { settings: l, state: d, value: h, size: D, startIndices: w } = g, { accessor: p, transform: b } = l;
    let S = d.binaryAccessor || // @ts-ignore
    (typeof p == "function" ? p : s[p]);
    typeof S != "function" && (S = () => S), Ge(typeof S == "function", `accessor "${p}" is not a function`);
    let K = g.getVertexOffset(C);
    const { iterable: Y, objectInfo: T } = xX(I, C, t);
    for (const E of Y) {
      T.index++;
      let H = S(E, T);
      if (b && (H = b.call(this, H)), w) {
        const R = (T.index < w.length - 1 ? w[T.index + 1] : r) - w[T.index];
        if (H && Array.isArray(H[0])) {
          let x = K;
          for (const U of H)
            g._normalizeValue(U, h, x), x += D;
        } else H && H.length > D ? h.set(H, K) : (g._normalizeValue(H, T.target, 0), i3({
          target: h,
          source: T.target,
          start: K,
          count: R
        }));
        K += R * D;
      } else
        g._normalizeValue(H, h, K), K += D;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings: g } = this;
    if (!(g.noAlloc || typeof g.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value: g } = this, I = Math.min(4, this.size);
    if (g && g.length >= I) {
      let C = !0;
      switch (I) {
        case 4:
          C = C && Number.isFinite(g[3]);
        case 3:
          C = C && Number.isFinite(g[2]);
        case 2:
          C = C && Number.isFinite(g[1]);
        case 1:
          C = C && Number.isFinite(g[0]);
          break;
        default:
          C = !1;
      }
      if (!C)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function Eb(A) {
  const { source: g, target: I, start: C = 0, size: t, getData: s } = A, r = A.end || I.length, l = g.length, d = r - C;
  if (l > d) {
    I.set(g.subarray(0, d), C);
    return;
  }
  if (I.set(g, C), !s)
    return;
  let h = l;
  for (; h < d; ) {
    const D = s(h, g);
    for (let w = 0; w < t; w++)
      I[C + h] = D[w] || 0, h++;
  }
}
function QX({ source: A, target: g, size: I, getData: C, sourceStartIndices: t, targetStartIndices: s }) {
  if (!t || !s)
    return Eb({
      source: A,
      target: g,
      size: I,
      getData: C
    }), g;
  let r = 0, l = 0;
  const d = C && ((D, w) => C(D + l, w)), h = Math.min(t.length, s.length);
  for (let D = 1; D < h; D++) {
    const w = t[D] * I, p = s[D] * I;
    Eb({
      source: A.subarray(r, w),
      target: g,
      start: l,
      end: p,
      size: I,
      getData: d
    }), r = w, l = p;
  }
  return l < g.length && Eb({
    // @ts-ignore
    source: [],
    target: g,
    start: l,
    size: I,
    getData: d
  }), g;
}
function zX(A) {
  const { device: g, settings: I, value: C } = A, t = new IH(g, I);
  return t.setData({
    value: C instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: I.normalized
  }), t;
}
function AH(A) {
  switch (A) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${A}"`);
  }
}
function CH(A) {
  switch (A) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function eH(A) {
  A.push(A.shift());
}
function JX(A, g) {
  const { doublePrecision: I, settings: C, value: t, size: s } = A, r = I && t instanceof Float64Array ? 2 : 1;
  let l = 0;
  const { shaderAttributes: d } = A.settings;
  if (d)
    for (const h of Object.values(d))
      l = Math.max(l, h.vertexOffset ?? 0);
  return (C.noAlloc ? t.length : (g + l) * s) * r;
}
function tH({ device: A, source: g, target: I }) {
  return (!I || I.byteLength < g.byteLength) && (I?.destroy(), I = A.createBuffer({
    byteLength: g.byteLength,
    usage: g.usage
  })), I;
}
function iH({ device: A, buffer: g, attribute: I, fromLength: C, toLength: t, fromStartIndices: s, getData: r = (l) => l }) {
  const l = I.doublePrecision && I.value instanceof Float64Array ? 2 : 1, d = I.size * l, h = I.byteOffset, D = I.settings.bytesPerElement < 4 ? h / I.settings.bytesPerElement * 4 : h, w = I.startIndices, p = s && w, b = I.isConstant;
  if (!p && g && C >= t)
    return g;
  const S = I.value instanceof Float64Array ? Float32Array : I.value.constructor, K = b ? I.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new S(I.getBuffer().readSyncWebGL(h, t * S.BYTES_PER_ELEMENT).buffer)
  );
  if (I.settings.normalized && !b) {
    const H = r;
    r = (R, x) => I.normalizeConstant(H(R, x));
  }
  const Y = b ? (H, R) => r(K, R) : (H, R) => r(K.subarray(H + h, H + h + d), R), T = g ? new Float32Array(g.readSyncWebGL(D, C * 4).buffer) : new Float32Array(0), E = new Float32Array(t);
  return QX({
    source: T,
    target: E,
    sourceStartIndices: s,
    targetStartIndices: w,
    size: d,
    getData: Y
  }), (!g || g.byteLength < E.byteLength + D) && (g?.destroy(), g = A.createBuffer({
    byteLength: E.byteLength + D,
    usage: 35050
  })), g.write(E, D), g;
}
class nH {
  constructor({ device: g, attribute: I, timeline: C }) {
    this.buffers = [], this.currentLength = 0, this.device = g, this.transition = new A0(C), this.attribute = I, this.attributeInTransition = zX(I), this.currentStartIndices = I.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(g, I, C = 1 / 0) {
    this.settings = g, this.currentStartIndices = this.attribute.startIndices, this.currentLength = JX(this.attribute, I), this.transition.start({ ...g, duration: C });
  }
  update() {
    const g = this.transition.update();
    return g && this.onUpdate(), g;
  }
  setBuffer(g) {
    this.attributeInTransition.setData({
      buffer: g,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const g of this.buffers)
      g.destroy();
    this.buffers.length = 0;
  }
}
class LX extends nH {
  constructor({ device: g, attribute: I, timeline: C }) {
    super({ device: g, attribute: I, timeline: C }), this.type = "interpolation", this.transform = I2(g, I);
  }
  start(g, I) {
    const C = this.currentLength, t = this.currentStartIndices;
    if (super.start(g, I, g.duration), g.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers: s, attribute: r } = this;
    eH(s), s[0] = iH({
      device: this.device,
      buffer: s[0],
      attribute: r,
      fromLength: C,
      toLength: this.currentLength,
      fromStartIndices: t,
      getData: g.enter
    }), s[1] = tH({
      device: this.device,
      source: s[0],
      target: s[1]
    }), this.setBuffer(s[1]);
    const { transform: l } = this, d = l.model;
    let h = Math.floor(this.currentLength / r.size);
    sH(r) && (h /= 2), d.setVertexCount(h), r.isConstant ? (d.setAttributes({ aFrom: s[0] }), d.setConstantAttributes({ aTo: r.value })) : d.setAttributes({
      aFrom: s[0],
      aTo: r.getBuffer()
    }), l.transformFeedback.setBuffers({ vCurrent: s[1] });
  }
  onUpdate() {
    const { duration: g, easing: I } = this.settings, { time: C } = this.transition;
    let t = C / g;
    I && (t = I(t));
    const { model: s } = this.transform, r = { time: t };
    s.shaderInputs.setProps({ interpolation: r }), this.transform.run({ discard: !0 });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const qX = `uniform interpolationUniforms {
  float time;
} interpolation;
`, O1 = {
  name: "interpolation",
  vs: qX,
  uniformTypes: {
    time: "f32"
  }
}, $X = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, g2 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function sH(A) {
  return A.doublePrecision && A.value instanceof Float64Array;
}
function I2(A, g) {
  const I = g.size, C = AH(I), t = CH(I), s = g.getBufferLayout();
  return sH(g) ? new Pf(A, {
    vs: g2,
    bufferLayout: [
      {
        name: "aFrom",
        byteStride: 8 * I,
        attributes: [
          { attribute: "aFrom", format: t, byteOffset: 0 },
          { attribute: "aFrom64Low", format: t, byteOffset: 4 * I }
        ]
      },
      {
        name: "aTo",
        byteStride: 8 * I,
        attributes: [
          { attribute: "aTo", format: t, byteOffset: 0 },
          { attribute: "aTo64Low", format: t, byteOffset: 4 * I }
        ]
      }
    ],
    // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
    modules: [n_, O1],
    defines: {
      ATTRIBUTE_TYPE: C,
      ATTRIBUTE_SIZE: I
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    bufferMode: 35980,
    disableWarnings: !0
  }) : new Pf(A, {
    vs: $X,
    bufferLayout: [
      { name: "aFrom", format: t },
      { name: "aTo", format: s.attributes[0].format }
    ],
    modules: [O1],
    defines: {
      ATTRIBUTE_TYPE: C
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: !0
  });
}
class A2 extends nH {
  constructor({ device: g, attribute: I, timeline: C }) {
    super({ device: g, attribute: I, timeline: C }), this.type = "spring", this.texture = s2(g), this.framebuffer = o2(g, this.texture), this.transform = n2(g, I);
  }
  start(g, I) {
    const C = this.currentLength, t = this.currentStartIndices;
    super.start(g, I);
    const { buffers: s, attribute: r } = this;
    for (let d = 0; d < 2; d++)
      s[d] = iH({
        device: this.device,
        buffer: s[d],
        attribute: r,
        fromLength: C,
        toLength: this.currentLength,
        fromStartIndices: t,
        getData: g.enter
      });
    s[2] = tH({
      device: this.device,
      source: s[0],
      target: s[2]
    }), this.setBuffer(s[1]);
    const { model: l } = this.transform;
    l.setVertexCount(Math.floor(this.currentLength / r.size)), r.isConstant ? l.setConstantAttributes({ aTo: r.value }) : l.setAttributes({ aTo: r.getBuffer() });
  }
  onUpdate() {
    const { buffers: g, transform: I, framebuffer: C, transition: t } = this, s = this.settings;
    I.model.setAttributes({
      aPrev: g[0],
      aCur: g[1]
    }), I.transformFeedback.setBuffers({ vNext: g[2] });
    const r = {
      stiffness: s.stiffness,
      damping: s.damping
    };
    I.model.shaderInputs.setProps({ spring: r }), I.run({
      framebuffer: C,
      discard: !1,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    }), eH(g), this.setBuffer(g[1]), this.device.readPixelsToArrayWebGL(C)[0] > 0 || t.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const C2 = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, e2 = {
  name: "spring",
  vs: C2,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
}, t2 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, i2 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function n2(A, g) {
  const I = AH(g.size), C = CH(g.size);
  return new Pf(A, {
    vs: t2,
    fs: i2,
    bufferLayout: [
      { name: "aPrev", format: C },
      { name: "aCur", format: C },
      { name: "aTo", format: g.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    modules: [e2],
    defines: { ATTRIBUTE_TYPE: I },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function s2(A) {
  return A.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: !1,
    width: 1,
    height: 1
  });
}
function o2(A, g) {
  return A.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [g]
  });
}
const a2 = {
  interpolation: LX,
  spring: A2
};
class r2 {
  constructor(g, { id: I, timeline: C }) {
    if (!g)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = I, this.device = g, this.timeline = C, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const g in this.transitions)
      this._removeTransition(g);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes: g, transitions: I, numInstances: C }) {
    this.numInstances = C || 1;
    for (const t in g) {
      const s = g[t], r = s.getTransitionSetting(I);
      r && this._updateAttribute(t, s, r);
    }
    for (const t in this.transitions) {
      const s = g[t];
      (!s || !s.getTransitionSetting(I)) && this._removeTransition(t);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(g) {
    const I = this.transitions[g];
    return I && I.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const g = {};
    for (const I in this.transitions) {
      const C = this.transitions[I];
      C.inProgress && (g[I] = C.attributeInTransition);
    }
    return g;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const I in this.transitions)
      this.transitions[I].update() && (this.needsRedraw = !0);
    const g = this.needsRedraw;
    return this.needsRedraw = !1, g;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(g) {
    this.transitions[g].delete(), delete this.transitions[g];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(g, I, C) {
    const t = this.transitions[g];
    let s = !t || t.type !== C.type;
    if (s) {
      t && this._removeTransition(g);
      const r = a2[C.type];
      r ? this.transitions[g] = new r({
        attribute: I,
        timeline: this.timeline,
        device: this.device
      }) : (uA.error(`unsupported transition type '${C.type}'`)(), s = !1);
    }
    (s || I.needsRedraw()) && (this.needsRedraw = !0, this.transitions[g].start(C, this.numInstances));
  }
}
const N1 = "attributeManager.invalidate", l2 = "attributeManager.updateStart", c2 = "attributeManager.updateEnd", u2 = "attribute.updateStart", d2 = "attribute.allocate", f2 = "attribute.updateEnd";
class h2 {
  constructor(g, { id: I = "attribute-manager", stats: C, timeline: t } = {}) {
    this.mergeBoundsMemoized = GM(TU), this.id = I, this.device = g, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = C, this.attributeTransitionManager = new r2(g, {
      id: `${I}-transitions`,
      timeline: t
    }), Object.seal(this);
  }
  finalize() {
    for (const g in this.attributes)
      this.attributes[g].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(g = { clearRedrawFlags: !1 }) {
    const I = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !g.clearRedrawFlags, I && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(g) {
    this._add(g);
  }
  // Adds attributes
  addInstanced(g) {
    this._add(g, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(g) {
    for (const I of g)
      this.attributes[I] !== void 0 && (this.attributes[I].delete(), delete this.attributes[I]);
  }
  // Marks an attribute for update
  invalidate(g, I) {
    const C = this._invalidateTrigger(g, I);
    Xe(N1, this, g, C);
  }
  invalidateAll(g) {
    for (const I in this.attributes)
      this.attributes[I].setNeedsUpdate(I, g);
    Xe(N1, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data: g, numInstances: I, startIndices: C = null, transitions: t, props: s = {}, buffers: r = {}, context: l = {} }) {
    let d = !1;
    Xe(l2, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const h in this.attributes) {
      const D = this.attributes[h], w = D.settings.accessor;
      D.startIndices = C, D.numInstances = I, s[h] && uA.removed(`props.${h}`, `data.attributes.${h}`)(), D.setExternalBuffer(r[h]) || D.setBinaryValue(typeof w == "string" ? r[w] : void 0, g.startIndices) || typeof w == "string" && !r[w] && D.setConstantValue(s[w]) || D.needsUpdate() && (d = !0, this._updateAttribute({
        attribute: D,
        numInstances: I,
        data: g,
        props: s,
        context: l
      })), this.needsRedraw = this.needsRedraw || D.needsRedraw();
    }
    d && Xe(c2, this, I), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: I,
      transitions: t
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager: g } = this, I = g.run();
    return this.needsRedraw = this.needsRedraw || I, I;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(g) {
    const I = g.map((C) => this.attributes[C]?.getBounds());
    return this.mergeBoundsMemoized(I);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(g = { clearChangedFlags: !1 }) {
    const { attributes: I, attributeTransitionManager: C } = this, t = { ...C.getAttributes() };
    for (const s in I) {
      const r = I[s];
      r.needsRedraw(g) && !C.hasAttribute(s) && (t[s] = r);
    }
    return t;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(g) {
    return Object.values(this.getAttributes()).map((I) => I.getBufferLayout(g));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(g, I) {
    for (const C in g) {
      const t = g[C], s = {
        ...t,
        id: C,
        size: t.isIndexed && 1 || t.size || 1,
        ...I
      };
      this.attributes[C] = new IH(this.device, s);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const g = {};
    for (const I in this.attributes)
      this.attributes[I].getUpdateTriggers().forEach((t) => {
        g[t] || (g[t] = []), g[t].push(I);
      });
    this.updateTriggers = g;
  }
  _invalidateTrigger(g, I) {
    const { attributes: C, updateTriggers: t } = this, s = t[g];
    return s && s.forEach((r) => {
      const l = C[r];
      l && l.setNeedsUpdate(l.id, I);
    }), s;
  }
  _updateAttribute(g) {
    const { attribute: I, numInstances: C } = g;
    if (Xe(u2, I), I.constant) {
      I.setConstantValue(I.value);
      return;
    }
    I.allocate(C) && Xe(d2, I, C), I.updateBuffer(g) && (this.needsRedraw = !0, Xe(f2, I, C));
  }
}
class y2 extends A0 {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time: g, settings: { fromValue: I, toValue: C, duration: t, easing: s } } = this, r = s(g / t);
    this._value = Kp(I, C, r);
  }
}
const k1 = 1e-5;
function W1(A, g, I, C, t) {
  const s = g - A, l = (I - g) * t, d = -s * C;
  return l + d + s + g;
}
function D2(A, g, I, C, t) {
  if (Array.isArray(I)) {
    const s = [];
    for (let r = 0; r < I.length; r++)
      s[r] = W1(A[r], g[r], I[r], C, t);
    return s;
  }
  return W1(A, g, I, C, t);
}
function V1(A, g) {
  if (Array.isArray(A)) {
    let I = 0;
    for (let C = 0; C < A.length; C++) {
      const t = A[C] - g[C];
      I += t * t;
    }
    return Math.sqrt(I);
  }
  return Math.abs(A - g);
}
class M2 extends A0 {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue: g, toValue: I, damping: C, stiffness: t } = this.settings, { _prevValue: s = g, _currValue: r = g } = this;
    let l = D2(s, r, I, C, t);
    const d = V1(l, I), h = V1(l, r);
    d < k1 && h < k1 && (l = I, this.end()), this._prevValue = r, this._currValue = l;
  }
}
const w2 = {
  interpolation: y2,
  spring: M2
};
class B2 {
  constructor(g) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = g;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(g, I, C, t) {
    const { transitions: s } = this;
    if (s.has(g)) {
      const d = s.get(g), { value: h = d.settings.fromValue } = d;
      I = h, this.remove(g);
    }
    if (t = gH(t), !t)
      return;
    const r = w2[t.type];
    if (!r) {
      uA.error(`unsupported transition type '${t.type}'`)();
      return;
    }
    const l = new r(this.timeline);
    l.start({
      ...t,
      fromValue: I,
      toValue: C
    }), s.set(g, l);
  }
  remove(g) {
    const { transitions: I } = this;
    I.has(g) && (I.get(g).cancel(), I.delete(g));
  }
  update() {
    const g = {};
    for (const [I, C] of this.transitions)
      C.update(), g[I] = C.value, C.inProgress || this.remove(I);
    return g;
  }
  clear() {
    for (const g of this.transitions.keys())
      this.remove(g);
  }
}
function p2(A) {
  const g = A[fc];
  for (const I in g) {
    const C = g[I], { validate: t } = C;
    if (t && !t(A[I], C))
      throw new Error(`Invalid prop ${I}: ${A[I]}`);
  }
}
function m2(A, g) {
  const I = oH({
    newProps: A,
    oldProps: g,
    propTypes: A[fc],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  }), C = S2(A, g);
  let t = !1;
  return C || (t = G2(A, g)), {
    dataChanged: C,
    propsChanged: I,
    updateTriggersChanged: t,
    extensionsChanged: K2(A, g),
    transitionsChanged: b2(A, g)
  };
}
function b2(A, g) {
  if (!A.transitions)
    return !1;
  const I = {}, C = A[fc];
  let t = !1;
  for (const s in A.transitions) {
    const r = C[s], l = r && r.type;
    (l === "number" || l === "color" || l === "array") && PS(A[s], g[s], r) && (I[s] = !0, t = !0);
  }
  return t ? I : !1;
}
function oH({ newProps: A, oldProps: g, ignoreProps: I = {}, propTypes: C = {}, triggerName: t = "props" }) {
  if (g === A)
    return !1;
  if (typeof A != "object" || A === null)
    return `${t} changed shallowly`;
  if (typeof g != "object" || g === null)
    return `${t} changed shallowly`;
  for (const s of Object.keys(A))
    if (!(s in I)) {
      if (!(s in g))
        return `${t}.${s} added`;
      const r = PS(A[s], g[s], C[s]);
      if (r)
        return `${t}.${s} ${r}`;
    }
  for (const s of Object.keys(g))
    if (!(s in I)) {
      if (!(s in A))
        return `${t}.${s} dropped`;
      if (!Object.hasOwnProperty.call(A, s)) {
        const r = PS(A[s], g[s], C[s]);
        if (r)
          return `${t}.${s} ${r}`;
      }
    }
  return !1;
}
function PS(A, g, I) {
  let C = I && I.equal;
  return C && !C(A, g, I) || !C && (C = A && g && A.equals, C && !C.call(A, g)) ? "changed deeply" : !C && g !== A ? "changed shallowly" : null;
}
function S2(A, g) {
  if (g === null)
    return "oldProps is null, initial diff";
  let I = !1;
  const { dataComparator: C, _dataDiff: t } = A;
  return C ? C(A.data, g.data) || (I = "Data comparator detected a change") : A.data !== g.data && (I = "A new data container was supplied"), I && t && (I = t(A.data, g.data) || I), I;
}
function G2(A, g) {
  if (g === null)
    return { all: !0 };
  if ("all" in A.updateTriggers && x1(A, g, "all"))
    return { all: !0 };
  const I = {};
  let C = !1;
  for (const t in A.updateTriggers)
    t !== "all" && x1(A, g, t) && (I[t] = !0, C = !0);
  return C ? I : !1;
}
function K2(A, g) {
  if (g === null)
    return !0;
  const I = g.extensions, { extensions: C } = A;
  if (C === I)
    return !1;
  if (!I || !C || C.length !== I.length)
    return !0;
  for (let t = 0; t < C.length; t++)
    if (!C[t].equals(I[t]))
      return !0;
  return !1;
}
function x1(A, g, I) {
  let C = A.updateTriggers[I];
  C = C ?? {};
  let t = g.updateTriggers[I];
  return t = t ?? {}, oH({
    oldProps: t,
    newProps: C,
    triggerName: I
  });
}
const T2 = "count(): argument not an object", Y2 = "count(): argument not a container";
function P2(A) {
  if (!j2(A))
    throw new Error(T2);
  if (typeof A.count == "function")
    return A.count();
  if (Number.isFinite(A.size))
    return A.size;
  if (Number.isFinite(A.length))
    return A.length;
  if (Z2(A))
    return Object.keys(A).length;
  throw new Error(Y2);
}
function Z2(A) {
  return A !== null && typeof A == "object" && A.constructor === Object;
}
function j2(A) {
  return A !== null && typeof A == "object";
}
function _1(A, g) {
  if (!g)
    return A;
  const I = { ...A, ...g };
  if ("defines" in g && (I.defines = { ...A.defines, ...g.defines }), "modules" in g && (I.modules = (A.modules || []).concat(g.modules), g.modules.some((C) => C.name === "project64"))) {
    const C = I.modules.findIndex((t) => t.name === "project32");
    C >= 0 && I.modules.splice(C, 1);
  }
  if ("inject" in g)
    if (!A.inject)
      I.inject = g.inject;
    else {
      const C = { ...A.inject };
      for (const t in g.inject)
        C[t] = (C[t] || "") + g.inject[t];
      I.inject = C;
    }
  return I;
}
const v2 = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, ZS = {};
function H2(A, g, I, C) {
  if (I instanceof cA)
    return I;
  I.constructor && I.constructor.name !== "Object" && (I = { data: I });
  let t = null;
  I.compressed && (t = {
    minFilter: "linear",
    mipmapFilter: I.data.length > 1 ? "nearest" : "linear"
  });
  const s = g.createTexture({
    ...I,
    sampler: {
      ...v2,
      ...t,
      ...C
    },
    mipmaps: !0
  });
  return ZS[s.id] = A, s;
}
function E2(A, g) {
  !g || !(g instanceof cA) || ZS[g.id] === A && (g.delete(), delete ZS[g.id]);
}
const R2 = {
  boolean: {
    validate(A, g) {
      return !0;
    },
    equal(A, g, I) {
      return !!A == !!g;
    }
  },
  number: {
    validate(A, g) {
      return Number.isFinite(A) && (!("max" in g) || A <= g.max) && (!("min" in g) || A >= g.min);
    }
  },
  color: {
    validate(A, g) {
      return g.optional && !A || jS(A) && (A.length === 3 || A.length === 4);
    },
    equal(A, g, I) {
      return Qt(A, g, 1);
    }
  },
  accessor: {
    validate(A, g) {
      const I = Rp(A);
      return I === "function" || I === Rp(g.value);
    },
    equal(A, g, I) {
      return typeof g == "function" ? !0 : Qt(A, g, 1);
    }
  },
  array: {
    validate(A, g) {
      return g.optional && !A || jS(A);
    },
    equal(A, g, I) {
      const { compare: C } = I, t = Number.isInteger(C) ? C : C ? 1 : 0;
      return C ? Qt(A, g, t) : A === g;
    }
  },
  object: {
    equal(A, g, I) {
      if (I.ignore)
        return !0;
      const { compare: C } = I, t = Number.isInteger(C) ? C : C ? 1 : 0;
      return C ? Qt(A, g, t) : A === g;
    }
  },
  function: {
    validate(A, g) {
      return g.optional && !A || typeof A == "function";
    },
    equal(A, g, I) {
      return !I.compare && I.ignore !== !1 || A === g;
    }
  },
  data: {
    transform: (A, g, I) => {
      if (!A)
        return A;
      const { dataTransform: C } = I.props;
      return C ? C(A) : typeof A.shape == "string" && A.shape.endsWith("-table") && Array.isArray(A.data) ? A.data : A;
    }
  },
  image: {
    transform: (A, g, I) => {
      const C = I.context;
      return !C || !C.device ? null : H2(I.id, C.device, A, {
        ...g.parameters,
        ...I.props.textureParameters
      });
    },
    release: (A, g, I) => {
      E2(I.id, A);
    }
  }
};
function O2(A) {
  const g = {}, I = {}, C = {};
  for (const [t, s] of Object.entries(A)) {
    const r = s?.deprecatedFor;
    if (r)
      C[t] = Array.isArray(r) ? r : [r];
    else {
      const l = N2(t, s);
      g[t] = l, I[t] = l.value;
    }
  }
  return { propTypes: g, defaultProps: I, deprecatedProps: C };
}
function N2(A, g) {
  switch (Rp(g)) {
    case "object":
      return xD(A, g);
    case "array":
      return xD(A, { type: "array", value: g, compare: !1 });
    case "boolean":
      return xD(A, { type: "boolean", value: g });
    case "number":
      return xD(A, { type: "number", value: g });
    case "function":
      return xD(A, { type: "function", value: g, compare: !0 });
    default:
      return { name: A, type: "unknown", value: g };
  }
}
function xD(A, g) {
  return "type" in g ? { name: A, ...R2[g.type], ...g } : "value" in g ? { name: A, type: Rp(g.value), ...g } : { name: A, type: "object", value: g };
}
function jS(A) {
  return Array.isArray(A) || ArrayBuffer.isView(A);
}
function Rp(A) {
  return jS(A) ? "array" : A === null ? "null" : typeof A;
}
function k2(A, g) {
  let I;
  for (let s = g.length - 1; s >= 0; s--) {
    const r = g[s];
    "extensions" in r && (I = r.extensions);
  }
  const C = vS(A.constructor, I), t = Object.create(C);
  t[Hp] = A, t[pc] = {}, t[fr] = {};
  for (let s = 0; s < g.length; ++s) {
    const r = g[s];
    for (const l in r)
      t[l] = r[l];
  }
  return Object.freeze(t), t;
}
const W2 = "_mergedDefaultProps";
function vS(A, g) {
  if (!(A instanceof t0.constructor))
    return {};
  let I = W2;
  if (g)
    for (const t of g) {
      const s = t.constructor;
      s && (I += `:${s.extensionName || s.name}`);
    }
  const C = aH(A, I);
  return C || (A[I] = V2(A, g || []));
}
function V2(A, g) {
  if (!A.prototype)
    return null;
  const C = Object.getPrototypeOf(A), t = vS(C), s = aH(A, "defaultProps") || {}, r = O2(s), l = Object.assign(/* @__PURE__ */ Object.create(null), t, r.defaultProps), d = Object.assign(/* @__PURE__ */ Object.create(null), t?.[fc], r.propTypes), h = Object.assign(/* @__PURE__ */ Object.create(null), t?.[Pb], r.deprecatedProps);
  for (const D of g) {
    const w = vS(D.constructor);
    w && (Object.assign(l, w), Object.assign(d, w[fc]), Object.assign(h, w[Pb]));
  }
  return x2(l, A), U2(l, d), _2(l, h), l[fc] = d, l[Pb] = h, g.length === 0 && !xG(A, "_propTypes") && (A._propTypes = d), l;
}
function x2(A, g) {
  const I = X2(g);
  Object.defineProperties(A, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: I
    }
  });
}
function _2(A, g) {
  for (const I in g)
    Object.defineProperty(A, I, {
      enumerable: !1,
      set(C) {
        const t = `${this.id}: ${I}`;
        for (const s of g[I])
          xG(this, s) || (this[s] = C);
        uA.deprecated(t, g[I].join("/"))();
      }
    });
}
function U2(A, g) {
  const I = {}, C = {};
  for (const t in g) {
    const s = g[t], { name: r, value: l } = s;
    s.async && (I[r] = l, C[r] = F2(r));
  }
  A[wf] = I, A[pc] = {}, Object.defineProperties(A, C);
}
function F2(A) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(g) {
      typeof g == "string" || g instanceof Promise || $v(g) ? this[pc][A] = g : this[fr][A] = g;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[fr]) {
        if (A in this[fr])
          return this[fr][A] || this[wf][A];
        if (A in this[pc]) {
          const g = this[Hp] && this[Hp].internalState;
          if (g && g.hasAsyncProp(A))
            return g.getAsyncProp(A) || this[wf][A];
        }
      }
      return this[wf][A];
    }
  };
}
function xG(A, g) {
  return Object.prototype.hasOwnProperty.call(A, g);
}
function aH(A, g) {
  return xG(A, g) && A[g];
}
function X2(A) {
  const g = A.componentName;
  return g || uA.warn(`${A.name}.componentName not specified`)(), g || A.name;
}
let Q2 = 0;
class t0 {
  constructor(...g) {
    this.props = k2(this, g), this.id = this.props.id, this.count = Q2++;
  }
  // clone this layer with modified props
  clone(g) {
    const { props: I } = this, C = {};
    for (const t in I[wf])
      t in I[fr] ? C[t] = I[fr][t] : t in I[pc] && (C[t] = I[pc][t]);
    return new this.constructor({ ...I, ...C, ...g });
  }
}
t0.componentName = "Component";
t0.defaultProps = {};
const z2 = Object.freeze({});
class J2 {
  constructor(g) {
    this.component = g, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const g in this.asyncProps) {
      const I = this.asyncProps[g];
      I && I.type && I.type.release && I.type.release(I.resolvedValue, I.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || z2;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(g) {
    return g in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(g) {
    const I = this.asyncProps[g];
    return I && I.resolvedValue;
  }
  isAsyncPropLoading(g) {
    if (g) {
      const I = this.asyncProps[g];
      return !!(I && I.pendingLoadCount > 0 && I.pendingLoadCount !== I.resolvedLoadCount);
    }
    for (const I in this.asyncProps)
      if (this.isAsyncPropLoading(I))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(g, I) {
    this._watchPromise(g, Promise.resolve(I));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(g) {
    this.component = g[Hp] || this.component;
    const I = g[fr] || {}, C = g[pc] || g, t = g[wf] || {};
    for (const s in I) {
      const r = I[s];
      this._createAsyncPropData(s, t[s]), this._updateAsyncProp(s, r), I[s] = this.getAsyncProp(s);
    }
    for (const s in C) {
      const r = C[s];
      this._createAsyncPropData(s, t[s]), this._updateAsyncProp(s, r);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(g, I) {
    return null;
  }
  _onResolve(g, I) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(g, I) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(g, I) {
    if (this._didAsyncInputValueChange(g, I)) {
      if (typeof I == "string" && (I = this._fetch(g, I)), I instanceof Promise) {
        this._watchPromise(g, I);
        return;
      }
      if ($v(I)) {
        this._resolveAsyncIterable(g, I);
        return;
      }
      this._setPropValue(g, I);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const g in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, g, {
          enumerable: !0,
          value: this.oldProps[g]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(g, I) {
    const C = this.asyncProps[g];
    return I === C.resolvedValue || I === C.lastValue ? !1 : (C.lastValue = I, !0);
  }
  // Set normal, non-async value
  _setPropValue(g, I) {
    this._freezeAsyncOldProps();
    const C = this.asyncProps[g];
    C && (I = this._postProcessValue(C, I), C.resolvedValue = I, C.pendingLoadCount++, C.resolvedLoadCount = C.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(g, I, C) {
    const t = this.asyncProps[g];
    t && C >= t.resolvedLoadCount && I !== void 0 && (this._freezeAsyncOldProps(), t.resolvedValue = I, t.resolvedLoadCount = C, this.onAsyncPropUpdated(g, I));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(g, I) {
    const C = this.asyncProps[g];
    if (C) {
      C.pendingLoadCount++;
      const t = C.pendingLoadCount;
      I.then((s) => {
        this.component && (s = this._postProcessValue(C, s), this._setAsyncPropValue(g, s, t), this._onResolve(g, s));
      }).catch((s) => {
        this._onError(g, s);
      });
    }
  }
  async _resolveAsyncIterable(g, I) {
    if (g !== "data") {
      this._setPropValue(g, I);
      return;
    }
    const C = this.asyncProps[g];
    if (!C)
      return;
    C.pendingLoadCount++;
    const t = C.pendingLoadCount;
    let s = [], r = 0;
    for await (const l of I) {
      if (!this.component)
        return;
      const { dataTransform: d } = this.component.props;
      d ? s = d(l, s) : s = s.concat(l), Object.defineProperty(s, "__diff", {
        enumerable: !1,
        value: [{ startRow: r, endRow: s.length }]
      }), r = s.length, this._setAsyncPropValue(g, s, t);
    }
    this._onResolve(g, s);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(g, I) {
    const C = g.type;
    return C && this.component && (C.release && C.release(g.resolvedValue, C, this.component), C.transform) ? C.transform(I, C, this.component) : I;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(g, I) {
    if (!this.asyncProps[g]) {
      const t = this.component && this.component.props[fc];
      this.asyncProps[g] = {
        type: t && t[g],
        lastValue: null,
        resolvedValue: I,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class L2 extends J2 {
  constructor({ attributeManager: g, layer: I }) {
    super(I), this.attributeManager = g, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(g, I) {
    const C = this.layer, t = C?.props.fetch;
    return t ? t(I, { propName: g, layer: C }) : super._fetch(g, I);
  }
  _onResolve(g, I) {
    const C = this.layer;
    if (C) {
      const t = C.props.onDataLoad;
      g === "data" && t && t(I, { propName: g, layer: C });
    }
  }
  _onError(g, I) {
    const C = this.layer;
    C && C.raiseError(I, `loading ${g} of ${this.layer}`);
  }
}
const q2 = "layer.changeFlag", $2 = "layer.initialize", g7 = "layer.update", I7 = "layer.finalize", A7 = "layer.matched", U1 = 2 ** 24 - 1, C7 = Object.freeze([]), e7 = GM(({ oldViewport: A, viewport: g }) => A.equals(g));
let Bn = new Uint8ClampedArray(0);
const t7 = {
  // data: Special handling for null, see below
  data: { type: "data", value: C7, async: !0 },
  dataComparator: { type: "function", value: null, optional: !0 },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (A) => A && A.__diff,
    optional: !0
  },
  dataTransform: { type: "function", value: null, optional: !0 },
  onDataLoad: { type: "function", value: null, optional: !0 },
  onError: { type: "function", value: null, optional: !0 },
  fetch: {
    type: "function",
    value: (A, { propName: g, layer: I, loaders: C, loadOptions: t, signal: s }) => {
      const { resourceManager: r } = I.context;
      t = t || I.getLoadOptions(), C = C || I.props.loaders, s && (t = {
        ...t,
        fetch: {
          ...t?.fetch,
          signal: s
        }
      });
      let l = r.contains(A);
      return !l && !t && (r.add({ resourceId: A, data: iS(A, C), persistent: !1 }), l = !0), l ? r.subscribe({
        resourceId: A,
        onChange: (d) => I.internalState?.reloadAsyncProp(g, d),
        consumerId: I.id,
        requestId: g
      }) : iS(A, C, t);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: !0 },
  onClick: { type: "function", value: null, optional: !0 },
  onDragStart: { type: "function", value: null, optional: !0 },
  onDrag: { type: "function", value: null, optional: !0 },
  onDragEnd: { type: "function", value: null, optional: !0 },
  coordinateSystem: gA.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
  modelMatrix: { type: "array", value: null, compare: !0, optional: !0 },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: !0, compare: 2 },
  loadOptions: { type: "object", value: null, optional: !0, ignore: !0 },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: !0, ignore: !0 },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex: A }) => [0, -A * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
class TM extends t0 {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = sf.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let g = this;
    for (; g.parent; )
      g = g.parent;
    return g;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(g) {
    Ge(this.internalState);
    const I = this.internalState.viewport || this.context.viewport, C = Sv(g, {
      viewport: I,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [t, s, r] = wv(C, I.pixelProjectionMatrix);
    return g.length === 2 ? [t, s] : [t, s, r];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(g) {
    return Ge(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(g);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(g, I) {
    Ge(this.internalState);
    const C = this.internalState.viewport || this.context.viewport;
    return HU(g, {
      viewport: C,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...I
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !0;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(g) {
    this.setChangeFlags({ stateChanged: !0 }), Object.assign(this.state, g), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const g = this.state;
    return g && (g.models || g.model && [g.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps(...g) {
    for (const I of this.getModels())
      I.shaderInputs.setProps(...g);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem: g } = this.props;
    return g === gA.DEFAULT || g === gA.LNGLAT || g === gA.CARTESIAN;
  }
  // Event handling
  onHover(g, I) {
    return this.props.onHover && this.props.onHover(g, I) || !1;
  }
  onClick(g, I) {
    return this.props.onClick && this.props.onClick(g, I) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(g, I = []) {
    return I[0] = g + 1 & 255, I[1] = g + 1 >> 8 & 255, I[2] = g + 1 >> 8 >> 8 & 255, I;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(g) {
    Ge(g instanceof Uint8Array);
    const [I, C, t] = g;
    return I + C * 256 + t * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : P2(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(g) {
    g = _1(g, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const I of this.props.extensions)
      g = _1(g, I.getShaders.call(this, I));
    return g;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(g) {
    return g.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(g) {
    const I = this.getAttributeManager(), { dataChanged: C } = g.changeFlags;
    if (C && I)
      if (Array.isArray(C))
        for (const t of C)
          I.invalidateAll(t);
      else
        I.invalidateAll();
    if (I) {
      const { props: t } = g, s = this.internalState.hasPickingBuffer, r = Number.isInteger(t.highlightedObjectIndex) || t.pickable || t.extensions.some((l) => l.getNeedsPickingBuffer.call(this, l));
      if (s !== r) {
        this.internalState.hasPickingBuffer = r;
        const { pickingColors: l, instancePickingColors: d } = I.attributes, h = l || d;
        h && (r && h.constant && (h.constant = !1, I.invalidate(h.id)), !h.value && !r && (h.constant = !0, h.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(g) {
    for (const C of this.getModels())
      C.destroy();
    const I = this.getAttributeManager();
    I && I.finalize(), this.context && this.context.resourceManager.unsubscribe({ consumerId: this.id }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(g) {
    for (const I of this.getModels())
      I.draw(g.renderPass);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info: g, mode: I, sourceLayer: C }) {
    const { index: t } = g;
    return t >= 0 && Array.isArray(this.props.data) && (g.object = this.props.data[t]), g;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(g, I) {
    I && (g = new Error(`${I}: ${g.message}`, { cause: g })), this.props.onError?.(g) || this.context?.onError?.(g, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(g = { clearRedrawFlags: !1 }) {
    return this._getNeedsRedraw(g);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(g) {
    if (!this.internalState)
      return;
    const I = this.internalState.viewport;
    this.internalState.viewport = g, (!I || !e7({ oldViewport: I, viewport: g })) && (this.setChangeFlags({ viewportChanged: !0 }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(g = "all") {
    const I = this.getAttributeManager();
    I && (g === "all" ? I.invalidateAll() : I.invalidate(g));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(g) {
    let I = !1;
    for (const C in g)
      g[C].layoutChanged() && (I = !0);
    for (const C of this.getModels())
      this._setModelAttributes(C, g, I);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const g = this.getAttributeManager();
    if (!g)
      return;
    const I = this.props, C = this.getNumInstances(), t = this.getStartIndices();
    g.update({
      data: I.data,
      numInstances: C,
      startIndices: t,
      props: I,
      transitions: I.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: I.data.attributes,
      context: this
    });
    const s = g.getChangedAttributes({ clearChangedFlags: !0 });
    this.updateAttributes(s);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const g = this.getAttributeManager();
    g && g.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions: g } = this.internalState;
    if (g.active) {
      const I = g.update(), C = Object.create(this.props);
      for (const t in I)
        Object.defineProperty(C, t, { value: I[t] });
      return C;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(g, { numInstances: I }) {
    if (g.constant)
      return;
    const C = Math.floor(Bn.length / 4);
    if (this.internalState.usesPickingColorCache = !0, C < I) {
      I > U1 && uA.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), Bn = fM.allocate(Bn, I, {
        size: 4,
        copy: !0,
        maxCount: Math.max(I, U1)
      });
      const t = Math.floor(Bn.length / 4), s = [0, 0, 0];
      for (let r = C; r < t; r++)
        this.encodePickingColor(r, s), Bn[r * 4 + 0] = s[0], Bn[r * 4 + 1] = s[1], Bn[r * 4 + 2] = s[2], Bn[r * 4 + 3] = 0;
    }
    g.value = Bn.subarray(0, I * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(g, I, C = !1) {
    if (!Object.keys(I).length)
      return;
    if (C) {
      const l = this.getAttributeManager();
      g.setBufferLayout(l.getBufferLayouts(g)), I = l.getAttributes();
    }
    const t = g.userData?.excludeAttributes || {}, s = {}, r = {};
    for (const l in I) {
      if (t[l])
        continue;
      const d = I[l].getValue();
      for (const h in d) {
        const D = d[h];
        D instanceof GA ? I[l].settings.isIndexed ? g.setIndexBuffer(D) : s[h] = D : D && (r[h] = D);
      }
    }
    g.setAttributes(s), g.setConstantAttributes(r);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(g) {
    const I = this.props.data;
    if (!("attributes" in I)) {
      this._disablePickingIndex(g);
      return;
    }
    const { pickingColors: C, instancePickingColors: t } = this.getAttributeManager().attributes, s = C || t, r = s && I.attributes && I.attributes[s.id];
    if (r && r.value) {
      const l = r.value, d = this.encodePickingColor(g);
      for (let h = 0; h < I.length; h++) {
        const D = s.getVertexOffset(h);
        l[D] === d[0] && l[D + 1] === d[1] && l[D + 2] === d[2] && this._disablePickingIndex(h);
      }
    } else
      this._disablePickingIndex(g);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(g) {
    const { pickingColors: I, instancePickingColors: C } = this.getAttributeManager().attributes, t = I || C;
    if (!t)
      return;
    const s = t.getVertexOffset(g), r = t.getVertexOffset(g + 1);
    t.buffer.write(new Uint8Array(r - s), s);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors: g, instancePickingColors: I } = this.getAttributeManager().attributes, C = g || I;
    C && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && C.value.buffer !== Bn.buffer && (C.value = Bn.subarray(0, C.value.length)), C.updateSubBuffer({ startOffset: 0 }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    Ge(!this.internalState), Ge(Number.isFinite(this.props.coordinateSystem)), Xe($2, this);
    const g = this._getAttributeManager();
    g && g.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new L2({
      attributeManager: g,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (uA.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), g)
    }), this.internalState.uniformTransitions = new B2(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const I of this.props.extensions)
      I.initializeState.call(this, this.context, I);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(g) {
    Xe(A7, this, this === g);
    const { state: I, internalState: C } = g;
    this !== g && (this.internalState = C, this.state = I, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const g = this.needsUpdate();
    if (Xe(g7, this, g), !g)
      return;
    const I = this.props, C = this.context, t = this.internalState, s = C.viewport, r = this._updateUniformTransition();
    t.propsInTransition = r, C.viewport = t.viewport || s, this.props = r;
    try {
      const l = this._getUpdateParams(), d = this.getModels();
      if (C.device)
        this.updateState(l);
      else
        try {
          this.updateState(l);
        } catch {
        }
      for (const D of this.props.extensions)
        D.updateState.call(this, l, D);
      this.setNeedsRedraw(), this._updateAttributes();
      const h = this.getModels()[0] !== d[0];
      this._postUpdate(l, h);
    } finally {
      C.viewport = s, this.props = I, this._clearChangeFlags(), t.needsUpdate = !1, t.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    Xe(I7, this), this.finalizeState(this.context);
    for (const g of this.props.extensions)
      g.finalizeState.call(this, this.context, g);
  }
  // Calculates uniforms
  _drawLayer({ renderPass: g, shaderModuleProps: I = null, uniforms: C = {}, parameters: t = {} }) {
    this._updateAttributeTransition();
    const s = this.props, r = this.context;
    this.props = this.internalState.propsInTransition || s;
    try {
      I && this.setShaderModuleProps(I);
      const { getPolygonOffset: l } = this.props, d = l && l(C) || [0, 0];
      r.device instanceof hf && r.device.setParametersWebGL({ polygonOffset: d });
      for (const h of this.getModels())
        h.device.type === "webgpu" ? h.setParameters({ ...h.parameters, ...t }) : h.setParameters(t);
      if (r.device instanceof hf)
        r.device.withParametersWebGL(t, () => {
          const h = { renderPass: g, shaderModuleProps: I, uniforms: C, parameters: t, context: r };
          for (const D of this.props.extensions)
            D.draw.call(this, h, D);
          this.draw(h);
        });
      else {
        const h = { renderPass: g, shaderModuleProps: I, uniforms: C, parameters: t, context: r };
        for (const D of this.props.extensions)
          D.draw.call(this, h, D);
        this.draw(h);
      }
    } finally {
      this.props = s;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(g) {
    if (!this.internalState)
      return;
    const { changeFlags: I } = this.internalState;
    for (const t in g)
      if (g[t]) {
        let s = !1;
        switch (t) {
          case "dataChanged":
            const r = g[t], l = I[t];
            r && Array.isArray(l) && (I.dataChanged = Array.isArray(r) ? l.concat(r) : r, s = !0);
          default:
            I[t] || (I[t] = g[t], s = !0);
        }
        s && Xe(q2, this, t, g);
      }
    const C = !!(I.dataChanged || I.updateTriggersChanged || I.propsChanged || I.extensionsChanged);
    I.propsOrDataChanged = C, I.somethingChanged = C || I.viewportChanged || I.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(g, I) {
    const C = m2(g, I);
    if (C.updateTriggersChanged)
      for (const t in C.updateTriggersChanged)
        C.updateTriggersChanged[t] && this.invalidateAttribute(t);
    if (C.transitionsChanged)
      for (const t in C.transitionsChanged)
        this.internalState.uniformTransitions.add(t, I[t], g[t], g.transitions?.[t]);
    return this.setChangeFlags(C);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    p2(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(g) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(g);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(g) {
    const I = {
      // @ts-ignore
      highlightedObjectColor: g.picked ? g.color : null
    }, { highlightColor: C } = this.props;
    g.picked && typeof C == "function" && (I.highlightColor = C(g)), this.setShaderModuleProps({ picking: I }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const g = this.context;
    return new h2(g.device, {
      id: this.props.id,
      stats: g.stats,
      timeline: g.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(g, I) {
    const { props: C, oldProps: t } = g, s = this.state.model;
    s?.isInstanced && s.setInstanceCount(this.getNumInstances());
    const { autoHighlight: r, highlightedObjectIndex: l, highlightColor: d } = C;
    if (I || t.autoHighlight !== r || t.highlightedObjectIndex !== l || t.highlightColor !== d) {
      const h = {};
      Array.isArray(d) && (h.highlightColor = d), (I || t.autoHighlight !== r || l !== t.highlightedObjectIndex) && (h.highlightedObjectColor = Number.isFinite(l) && l >= 0 ? this.encodePickingColor(l) : null), this.setShaderModuleProps({ picking: h });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(g) {
    if (!this.internalState)
      return !1;
    let I = !1;
    I = I || this.internalState.needsRedraw && this.id;
    const C = this.getAttributeManager(), t = C ? C.getNeedsRedraw(g) : !1;
    if (I = I || t, I)
      for (const s of this.props.extensions)
        s.onNeedsRedraw.call(this, s);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !g.clearRedrawFlags, I;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
TM.defaultProps = t7;
TM.layerName = "Layer";
const Rb = Math.PI / 180;
function i7({ height: A, focalDistance: g, orbitAxis: I, rotationX: C, rotationOrbit: t, zoom: s }) {
  const r = I === "Z" ? [0, 0, 1] : [0, 1, 0], l = I === "Z" ? [0, -g, 0] : [0, 0, g], d = new Jt().lookAt({ eye: l, up: r });
  d.rotateX(C * Rb), I === "Z" ? d.rotateZ(t * Rb) : d.rotateY(t * Rb);
  const h = Math.pow(2, s) / A;
  return d.scale(h), d;
}
class n7 extends vc {
  constructor(g) {
    const {
      height: I,
      projectionMatrix: C,
      fovy: t = 50,
      // For setting camera position
      orbitAxis: s = "Z",
      // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'
      target: r = [0, 0, 0],
      // Which point is camera looking at, default origin
      rotationX: l = 0,
      // Rotating angle around X axis
      rotationOrbit: d = 0,
      // Rotating angle around orbit axis
      zoom: h = 0
    } = g, D = C ? C[5] / 2 : jG(t);
    super({
      ...g,
      // in case viewState contains longitude/latitude values,
      // make sure that the base Viewport class does not treat this as a geospatial viewport
      longitude: void 0,
      viewMatrix: i7({
        height: I || 1,
        focalDistance: D,
        orbitAxis: s,
        rotationX: l,
        rotationOrbit: d,
        zoom: h
      }),
      fovy: t,
      focalDistance: D,
      position: r,
      zoom: h
    }), this.projectedCenter = this.project(this.center);
  }
  unproject(g, { topLeft: I = !0 } = {}) {
    const [C, t, s = this.projectedCenter[2]] = g, r = I ? t : this.height - t, [l, d, h] = KM([C, r, s], this.pixelUnprojectionMatrix);
    return [l, d, h];
  }
  panByPosition(g, I) {
    const C = this.project(g), t = [
      this.width / 2 + C[0] - I[0],
      this.height / 2 + C[1] - I[1],
      this.projectedCenter[2]
    ];
    return {
      target: this.unproject(t)
    };
  }
}
const s7 = new Jt().lookAt({ eye: [0, 0, 1] });
function o7({ width: A, height: g, near: I, far: C, padding: t }) {
  let s = -A / 2, r = A / 2, l = -g / 2, d = g / 2;
  if (t) {
    const { left: h = 0, right: D = 0, top: w = 0, bottom: p = 0 } = t, b = xC((h + A - D) / 2, 0, A) - A / 2, S = xC((w + g - p) / 2, 0, g) - g / 2;
    s -= b, r -= b, l += S, d += S;
  }
  return new Jt().ortho({
    left: s,
    right: r,
    bottom: l,
    top: d,
    near: I,
    far: C
  });
}
class a7 extends vc {
  constructor(g) {
    const { width: I, height: C, near: t = 0.1, far: s = 1e3, zoom: r = 0, target: l = [0, 0, 0], padding: d = null, flipY: h = !0 } = g, D = Array.isArray(r) ? r[0] : r, w = Array.isArray(r) ? r[1] : r, p = Math.min(D, w), b = Math.pow(2, p);
    let S;
    if (D !== w) {
      const K = Math.pow(2, D), Y = Math.pow(2, w);
      S = {
        unitsPerMeter: [K / b, Y / b, 1],
        metersPerUnit: [b / K, b / Y, 1]
      };
    }
    super({
      ...g,
      // in case viewState contains longitude/latitude values,
      // make sure that the base Viewport class does not treat this as a geospatial viewport
      longitude: void 0,
      position: l,
      viewMatrix: s7.clone().scale([b, b * (h ? -1 : 1), b]),
      projectionMatrix: o7({
        width: I || 1,
        height: C || 1,
        padding: d,
        near: t,
        far: s
      }),
      zoom: p,
      distanceScales: S
    });
  }
  projectFlat([g, I]) {
    const { unitsPerMeter: C } = this.distanceScales;
    return [g * C[0], I * C[1]];
  }
  unprojectFlat([g, I]) {
    const { metersPerUnit: C } = this.distanceScales;
    return [g * C[0], I * C[1]];
  }
  /* Needed by LinearInterpolator */
  panByPosition(g, I) {
    const C = KM(I, this.pixelUnprojectionMatrix), t = this.projectFlat(g), s = Tp([], t, qj([], C)), r = Tp([], this.center, s);
    return { target: this.unprojectFlat(r) };
  }
}
class rH extends Hv {
  constructor(g) {
    const {
      /* Viewport arguments */
      width: I,
      // Width of viewport
      height: C,
      // Height of viewport
      rotationX: t = 0,
      // Rotation around x axis
      rotationOrbit: s = 0,
      // Rotation around orbit axis
      target: r = [0, 0, 0],
      zoom: l = 0,
      /* Viewport constraints */
      minRotationX: d = -90,
      maxRotationX: h = 90,
      minZoom: D = -1 / 0,
      maxZoom: w = 1 / 0,
      /** Interaction states, required to calculate change during transform */
      // Model state when the pan operation first started
      startPanPosition: p,
      // Model state when the rotate operation first started
      startRotatePos: b,
      startRotationX: S,
      startRotationOrbit: K,
      // Model state when the zoom operation first started
      startZoomPosition: Y,
      startZoom: T
    } = g;
    super({
      width: I,
      height: C,
      rotationX: t,
      rotationOrbit: s,
      target: r,
      zoom: l,
      minRotationX: d,
      maxRotationX: h,
      minZoom: D,
      maxZoom: w
    }, {
      startPanPosition: p,
      startRotatePos: b,
      startRotationX: S,
      startRotationOrbit: K,
      startZoomPosition: Y,
      startZoom: T
    }), this.makeViewport = g.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos: g }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(g)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  pan({ pos: g, startPosition: I }) {
    const C = this.getState().startPanPosition || I;
    if (!C)
      return this;
    const s = this.makeViewport(this.getViewportProps()).panByPosition(C, g);
    return this._getUpdatedState(s);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  rotateStart({ pos: g }) {
    return this._getUpdatedState({
      startRotatePos: g,
      startRotationX: this.getViewportProps().rotationX,
      startRotationOrbit: this.getViewportProps().rotationOrbit
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the pointer is
   */
  rotate({ pos: g, deltaAngleX: I = 0, deltaAngleY: C = 0 }) {
    const { startRotatePos: t, startRotationX: s, startRotationOrbit: r } = this.getState(), { width: l, height: d } = this.getViewportProps();
    if (!t || s === void 0 || r === void 0)
      return this;
    let h;
    if (g) {
      let D = (g[0] - t[0]) / l;
      const w = (g[1] - t[1]) / d;
      (s < -90 || s > 90) && (D *= -1), h = {
        rotationX: s + w * 180,
        rotationOrbit: r + D * 180
      };
    } else
      h = {
        rotationX: s + C,
        rotationOrbit: r + I
      };
    return this._getUpdatedState(h);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }
  // shortest path between two view states
  shortestPathFrom(g) {
    const I = g.getViewportProps(), C = { ...this.getViewportProps() }, { rotationOrbit: t } = C;
    return Math.abs(t - I.rotationOrbit) > 180 && (C.rotationOrbit = t < 0 ? t + 360 : t - 360), C;
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  zoomStart({ pos: g }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(g),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current target is
   * @param {[Number, Number]} startPos - the target position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos: g, startPos: I, scale: C }) {
    let { startZoom: t, startZoomPosition: s } = this.getState();
    if (s || (t = this.getViewportProps().zoom, s = this._unproject(I) || this._unproject(g)), !s)
      return this;
    const r = this._calculateNewZoom({ scale: C, startZoom: t }), l = this.makeViewport({ ...this.getViewportProps(), zoom: r });
    return this._getUpdatedState({
      zoom: r,
      ...l.panByPosition(s, g)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }
  zoomIn(g = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({ scale: g })
    });
  }
  zoomOut(g = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({ scale: 1 / g })
    });
  }
  moveLeft(g = 50) {
    return this._panFromCenter([-g, 0]);
  }
  moveRight(g = 50) {
    return this._panFromCenter([g, 0]);
  }
  moveUp(g = 50) {
    return this._panFromCenter([0, -g]);
  }
  moveDown(g = 50) {
    return this._panFromCenter([0, g]);
  }
  rotateLeft(g = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit - g
    });
  }
  rotateRight(g = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit + g
    });
  }
  rotateUp(g = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX - g
    });
  }
  rotateDown(g = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX + g
    });
  }
  /* Private methods */
  _unproject(g) {
    const I = this.makeViewport(this.getViewportProps());
    return g && I.unproject(g);
  }
  // Calculates new zoom
  _calculateNewZoom({ scale: g, startZoom: I }) {
    const { maxZoom: C, minZoom: t } = this.getViewportProps();
    I === void 0 && (I = this.getViewportProps().zoom);
    const s = I + Math.log2(g);
    return xC(s, t, C);
  }
  _panFromCenter(g) {
    const { width: I, height: C, target: t } = this.getViewportProps();
    return this.pan({
      startPosition: t,
      pos: [I / 2 + g[0], C / 2 + g[1]]
    });
  }
  _getUpdatedState(g) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...g
    });
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(g) {
    const { maxZoom: I, minZoom: C, zoom: t, maxRotationX: s, minRotationX: r, rotationOrbit: l } = g;
    return g.zoom = Array.isArray(t) ? [xC(t[0], C, I), xC(t[1], C, I)] : xC(t, C, I), g.rotationX = xC(g.rotationX, r, s), (l < -180 || l > 180) && (g.rotationOrbit = bU(l + 180, 360) - 180), g;
  }
}
class r7 extends RG {
  constructor() {
    super(...arguments), this.ControllerState = rH, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new C0({
        transitionProps: {
          compare: ["target", "zoom", "rotationX", "rotationOrbit"],
          required: ["target", "zoom"]
        }
      })
    };
  }
}
class lH extends Mr {
  constructor(g = {}) {
    super(g), this.props.orbitAxis = g.orbitAxis || "Z";
  }
  getViewportType() {
    return n7;
  }
  get ControllerType() {
    return r7;
  }
}
lH.displayName = "OrbitView";
class l7 extends rH {
  constructor(g) {
    super(g), this.zoomAxis = g.zoomAxis || "all";
  }
  _calculateNewZoom({ scale: g, startZoom: I }) {
    const { maxZoom: C, minZoom: t } = this.getViewportProps();
    I === void 0 && (I = this.getViewportProps().zoom);
    let s = Math.log2(g);
    if (Array.isArray(I)) {
      let [r, l] = I;
      switch (this.zoomAxis) {
        case "X":
          r = xC(r + s, t, C);
          break;
        case "Y":
          l = xC(l + s, t, C);
          break;
        default:
          let d = Math.min(r + s, l + s);
          d < t && (s += t - d), d = Math.max(r + s, l + s), d > C && (s += C - d), r += s, l += s;
      }
      return [r, l];
    }
    return xC(I + s, t, C);
  }
}
class c7 extends RG {
  constructor() {
    super(...arguments), this.ControllerState = l7, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new C0(["target", "zoom"])
    }, this.dragMode = "pan";
  }
  _onPanRotate() {
    return !1;
  }
}
class _G extends Mr {
  constructor(g = {}) {
    super(g);
  }
  getViewportType() {
    return a7;
  }
  get ControllerType() {
    return c7;
  }
}
_G.displayName = "OrthographicView";
class UG {
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
  }
  constructor(g) {
    g && (this.opts = g);
  }
  /** Returns true if two extensions are equivalent */
  equals(g) {
    return this === g ? !0 : this.constructor === g.constructor && Qt(this.opts, g.opts, 1);
  }
  /** Only called if attached to a primitive layer */
  getShaders(g) {
    return null;
  }
  /** Only called if attached to a CompositeLayer */
  getSubLayerProps(g) {
    const { defaultProps: I } = g.constructor, C = {
      updateTriggers: {}
    };
    for (const t in I)
      if (t in this.props) {
        const s = I[t], r = this.props[t];
        C[t] = r, s && s.type === "accessor" && (C.updateTriggers[t] = this.props.updateTriggers[t], typeof r == "function" && (C[t] = this.getSubLayerAccessor(r)));
      }
    return C;
  }
  /* eslint-disable @typescript-eslint/no-empty-function */
  initializeState(g, I) {
  }
  updateState(g, I) {
  }
  onNeedsRedraw(g) {
  }
  getNeedsPickingBuffer(g) {
    return !1;
  }
  draw(g, I) {
  }
  finalizeState(g, I) {
  }
}
UG.defaultProps = {};
UG.extensionName = "LayerExtension";
const F1 = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`, u7 = {
  name: "pointCloud",
  vs: F1,
  fs: F1,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
}, d7 = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, f7 = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, cH = [0, 0, 0, 255], uH = [0, 0, 1], h7 = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (A) => A.position },
  getNormal: { type: "accessor", value: uH },
  getColor: { type: "accessor", value: cH },
  material: !0,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function y7(A) {
  const { header: g, attributes: I } = A;
  if (!(!g || !I) && (A.length = g.vertexCount, I.POSITION && (I.instancePositions = I.POSITION), I.NORMAL && (I.instanceNormals = I.NORMAL), I.COLOR_0)) {
    const { size: C, value: t } = I.COLOR_0;
    I.instanceColors = { size: C, type: "unorm8", value: t };
  }
}
class FG extends TM {
  getShaders() {
    return super.getShaders({
      vs: d7,
      fs: f7,
      modules: [yv, iv, pv, u7]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: uH
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: cH
      }
    });
  }
  updateState(g) {
    const { changeFlags: I, props: C } = g;
    super.updateState(g), I.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), I.dataChanged && y7(C.data);
  }
  draw({ uniforms: g }) {
    const { pointSize: I, sizeUnits: C } = this.props, t = this.state.model, s = {
      sizeUnits: wc[C],
      radiusPixels: I
    };
    t.shaderInputs.setProps({ pointCloud: s }), t.draw(this.context.renderPass);
  }
  _getModel() {
    const g = [];
    for (let I = 0; I < 3; I++) {
      const C = I / 3 * Math.PI * 2;
      g.push(Math.cos(C) * 2, Math.sin(C) * 2, 0);
    }
    return new Bc(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Pv({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(g)
        }
      }),
      isInstanced: !0
    });
  }
}
FG.layerName = "PointCloudLayer";
FG.defaultProps = h7;
const X1 = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`, D7 = {
  name: "scatterplot",
  vs: X1,
  fs: X1,
  source: "",
  uniformTypes: {
    radiusScale: "f32",
    radiusMinPixels: "f32",
    radiusMaxPixels: "f32",
    lineWidthScale: "f32",
    lineWidthMinPixels: "f32",
    lineWidthMaxPixels: "f32",
    stroked: "f32",
    filled: "f32",
    antialiasing: "f32",
    billboard: "f32",
    radiusUnits: "i32",
    lineWidthUnits: "i32"
  }
}, M7 = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
), w7 = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
), B7 = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
), Q1 = [0, 0, 0, 255], p7 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: !1,
  filled: !0,
  billboard: !1,
  antialiasing: !0,
  getPosition: { type: "accessor", value: (A) => A.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: Q1 },
  getLineColor: { type: "accessor", value: Q1 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
class i0 extends TM {
  getShaders() {
    return super.getShaders({
      vs: M7,
      fs: w7,
      source: B7,
      modules: [yv, pv, D7]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: !0,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: !0,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: !0,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: !0,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(g) {
    super.updateState(g), g.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
  }
  draw({ uniforms: g }) {
    const { radiusUnits: I, radiusScale: C, radiusMinPixels: t, radiusMaxPixels: s, stroked: r, filled: l, billboard: d, antialiasing: h, lineWidthUnits: D, lineWidthScale: w, lineWidthMinPixels: p, lineWidthMaxPixels: b } = this.props, S = {
      stroked: r,
      filled: l,
      billboard: d,
      antialiasing: h,
      radiusUnits: wc[I],
      radiusScale: C,
      radiusMinPixels: t,
      radiusMaxPixels: s,
      lineWidthUnits: wc[D],
      lineWidthScale: w,
      lineWidthMinPixels: p,
      lineWidthMaxPixels: b
    }, K = this.state.model;
    K.shaderInputs.setProps({ scatterplot: S }), K.draw(this.context.renderPass);
  }
  _getModel() {
    const g = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Bc(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Pv({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(g) }
        }
      }),
      isInstanced: !0
    });
  }
}
i0.defaultProps = p7;
i0.layerName = "ScatterplotLayer";
const dH = (
  /* glsl */
  `uniform dataFilterUniforms {
  bool useSoftMargin;
  bool enabled;
  bool transformSize;
  bool transformColor;
#ifdef DATAFILTER_TYPE
  DATAFILTER_TYPE min;
  DATAFILTER_TYPE softMin;
  DATAFILTER_TYPE softMax;
  DATAFILTER_TYPE max;
#ifdef DATAFILTER_DOUBLE
  DATAFILTER_TYPE min64High;
  DATAFILTER_TYPE max64High;
#endif
#endif
#ifdef DATACATEGORY_TYPE
  highp uvec4 categoryBitMask;
#endif
} dataFilter;
`
), m7 = (
  /* glsl */
  `
#ifdef DATAFILTER_TYPE
  in DATAFILTER_TYPE filterValues;
#ifdef DATAFILTER_DOUBLE
  in DATAFILTER_TYPE filterValues64Low;
#endif
#endif

#ifdef DATACATEGORY_TYPE
  in DATACATEGORY_TYPE filterCategoryValues;
#endif

out float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}

#ifdef DATAFILTER_TYPE
  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {
    if (dataFilter.useSoftMargin) {
      // smoothstep results are undefined if edge0  edge1
      // Fallback to ignore filterSoftRange if it is truncated by filterRange
      DATAFILTER_TYPE leftInRange = mix(
        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),
        step(dataFilter.min, valueFromMin),
        step(dataFilter.softMin, dataFilter.min)
      );
      DATAFILTER_TYPE rightInRange = mix(
        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),
        step(valueFromMax, dataFilter.max),
        step(dataFilter.max, dataFilter.softMax)
      );
      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)
      );
    }
  }
#endif

#ifdef DATACATEGORY_TYPE
  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {
    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask
    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];
    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks
    uvec2 dataFilter_masks = uvec2(
      dataFilter.categoryBitMask[category.x / 32u],
      dataFilter.categoryBitMask[category.y / 32u + 2u]
    );
    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks
    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;
    #else // Four 32-bit masks
    uvec4 dataFilter_masks = dataFilter.categoryBitMask;
    #endif

    // Shift mask and extract relevant bits
    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);
    dataFilter_bits &= 1u;

    #if DATACATEGORY_CHANNELS == 1
    if(dataFilter_bits == 0u) dataFilter_value = 0.0;
    #else
    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;
    #endif
  }
#endif
`
), fH = `
${dH}
${m7}
`, b7 = (
  /* glsl */
  `
in float dataFilter_value;
`
), hH = `
${dH}
${b7}
`;
function yH(A) {
  if (!A || !("extensions" in A))
    return {};
  const { filterRange: g = [-1, 1], filterEnabled: I = !0, filterTransformSize: C = !0, filterTransformColor: t = !0, categoryBitMask: s } = A, r = A.filterSoftRange || g;
  return {
    ...Number.isFinite(g[0]) ? {
      min: g[0],
      softMin: r[0],
      softMax: r[1],
      max: g[1]
    } : {
      min: g.map((l) => l[0]),
      softMin: r.map((l) => l[0]),
      softMax: r.map((l) => l[1]),
      max: g.map((l) => l[1])
    },
    enabled: I,
    useSoftMargin: !!A.filterSoftRange,
    transformSize: I && C,
    transformColor: I && t,
    ...s && { categoryBitMask: s }
  };
}
function S7(A) {
  if (!A || !("extensions" in A))
    return {};
  const g = yH(A);
  if (Number.isFinite(g.min)) {
    const I = Math.fround(g.min);
    g.min -= I, g.softMin -= I, g.min64High = I;
    const C = Math.fround(g.max);
    g.max -= C, g.softMax -= C, g.max64High = C;
  } else {
    const I = g.min.map(Math.fround);
    g.min = g.min.map((t, s) => t - I[s]), g.softMin = g.softMin.map((t, s) => t - I[s]), g.min64High = I;
    const C = g.max.map(Math.fround);
    g.max = g.max.map((t, s) => t - C[s]), g.softMax = g.softMax.map((t, s) => t - C[s]), g.max64High = C;
  }
  return g;
}
const DH = {
  "vs:#main-start": (
    /* glsl */
    `
    dataFilter_value = 1.0;
    if (dataFilter.enabled) {
      #ifdef DATAFILTER_TYPE
        #ifdef DATAFILTER_DOUBLE
          dataFilter_setValue(
            filterValues - dataFilter.min64High + filterValues64Low,
            filterValues - dataFilter.max64High + filterValues64Low
          );
        #else
          dataFilter_setValue(filterValues, filterValues);
        #endif
      #endif

      #ifdef DATACATEGORY_TYPE
        dataFilter_setCategoryValue(filterCategoryValues);
      #endif
    }
  `
  ),
  "vs:#main-end": (
    /* glsl */
    `
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `
  ),
  "vs:DECKGL_FILTER_SIZE": (
    /* glsl */
    `
    if (dataFilter.transformSize) {
      size = size * dataFilter_value;
    }
  `
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (dataFilter_value == 0.0) discard;
    if (dataFilter.transformColor) {
      color.a *= dataFilter_value;
    }
  `
  )
};
function MH(A) {
  const { categorySize: g, filterSize: I, fp64: C } = A, t = {
    useSoftMargin: "i32",
    enabled: "i32",
    transformSize: "i32",
    transformColor: "i32"
  };
  if (I) {
    const s = I === 1 ? "f32" : `vec${I}<f32>`;
    t.min = s, t.softMin = s, t.softMax = s, t.max = s, C && (t.min64High = s, t.max64High = s);
  }
  return g && (t.categoryBitMask = "vec4<i32>"), t;
}
const G7 = {
  name: "dataFilter",
  vs: fH,
  fs: hH,
  inject: DH,
  getUniforms: yH,
  uniformTypesFromOptions: MH
}, K7 = {
  name: "dataFilter",
  vs: fH,
  fs: hH,
  inject: DH,
  getUniforms: S7,
  uniformTypesFromOptions: MH
}, T7 = `#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`, Y7 = `#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`, P7 = [
  "float32-renderable-webgl",
  // ability to render to float texture
  "texture-blend-float-webgl"
  // ability to blend when rendering to float texture
];
function Z7(A) {
  return P7.every((g) => A.features.has(g));
}
function j7(A, g) {
  return g ? A.createFramebuffer({
    width: 1,
    height: 1,
    colorAttachments: [
      A.createTexture({
        format: "rgba32float",
        mipmaps: !1
      })
    ]
  }) : A.createFramebuffer({
    width: 256,
    height: 64,
    colorAttachments: [A.createTexture({ format: "rgba8unorm", mipmaps: !1 })]
  });
}
function v7(A, g, I, C) {
  return I.defines.NON_INSTANCED_MODEL = 1, C && (I.defines.FLOAT_TARGET = 1), new Bc(A, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: !1,
    topology: "point-list",
    disableWarnings: !0,
    vs: T7,
    fs: Y7,
    bufferLayout: g,
    ...I
  });
}
const H7 = {
  blend: !0,
  blendColorSrcFactor: "one",
  blendColorDstFactor: "one",
  blendAlphaSrcFactor: "one",
  blendAlphaDstFactor: "one",
  blendColorOperation: "add",
  blendAlphaOperation: "add",
  depthCompare: "never"
}, E7 = {
  getFilterValue: { type: "accessor", value: 0 },
  getFilterCategory: { type: "accessor", value: 0 },
  onFilteredItemsChange: { type: "function", value: null, optional: !0 },
  filterEnabled: !0,
  filterRange: [-1, 1],
  filterSoftRange: null,
  filterCategories: [0],
  filterTransformSize: !0,
  filterTransformColor: !0
}, R7 = {
  categorySize: 0,
  filterSize: 1,
  fp64: !1,
  countItems: !1
}, O7 = {
  1: "uint",
  2: "uvec2",
  3: "uvec3",
  4: "uvec4"
}, N7 = {
  1: "float",
  2: "vec2",
  3: "vec3",
  4: "vec4"
};
class Op extends UG {
  constructor(g = {}) {
    super({ ...R7, ...g });
  }
  getShaders(g) {
    const { categorySize: I, filterSize: C, fp64: t } = g.opts, s = {};
    I && (s.DATACATEGORY_TYPE = O7[I], s.DATACATEGORY_CHANNELS = I), C && (s.DATAFILTER_TYPE = N7[C], s.DATAFILTER_DOUBLE = !!t);
    const r = t ? K7 : G7;
    return r.uniformTypes = r.uniformTypesFromOptions(g.opts), { modules: [r], defines: s };
  }
  initializeState(g, I) {
    const C = this.getAttributeManager(), { categorySize: t, filterSize: s, fp64: r } = I.opts;
    C && (s && C.add({
      filterValues: {
        size: s,
        type: r ? "float64" : "float32",
        stepMode: "dynamic",
        accessor: "getFilterValue"
      }
    }), t && C.add({
      filterCategoryValues: {
        size: t,
        stepMode: "dynamic",
        accessor: "getFilterCategory",
        type: "uint32",
        transform: t === 1 ? (d) => I._getCategoryKey.call(this, d, 0) : (d) => d.map((h, D) => I._getCategoryKey.call(this, h, D))
      }
    }));
    const { device: l } = this.context;
    if (C && I.opts.countItems) {
      const d = Z7(l);
      C.add({
        filterVertexIndices: {
          size: d ? 1 : 2,
          vertexOffset: 1,
          type: "unorm8",
          accessor: (w, { index: p }) => {
            const b = w && w.__source ? w.__source.index : p;
            return d ? (b + 1) % 255 : [(b + 1) % 255, Math.floor(b / 255) % 255];
          },
          shaderAttributes: {
            filterPrevIndices: {
              vertexOffset: 0
            },
            filterIndices: {
              vertexOffset: 1
            }
          }
        }
      });
      const h = j7(l, d), D = v7(l, C.getBufferLayouts({ isInstanced: !1 }), I.getShaders.call(this, I), d);
      this.setState({ filterFBO: h, filterModel: D });
    }
  }
  // eslint-disable-next-line complexity
  updateState({ props: g, oldProps: I, changeFlags: C }, t) {
    const s = this.getAttributeManager(), { categorySize: r } = t.opts;
    if (this.state.filterModel) {
      const l = (
        // attributeManager must be defined for filterModel to be set
        s.attributes.filterValues?.needsUpdate() || s.attributes.filterCategoryValues?.needsUpdate() || g.filterEnabled !== I.filterEnabled || g.filterRange !== I.filterRange || g.filterSoftRange !== I.filterSoftRange || g.filterCategories !== I.filterCategories
      );
      l && this.setState({ filterNeedsUpdate: l });
    }
    s?.attributes.filterCategoryValues && ((s.attributes.filterCategoryValues.needsUpdate() || !Qt(g.filterCategories, I.filterCategories, 2)) && this.setState({ categoryBitMask: null }), C.dataChanged && (this.setState({
      categoryMap: Array(r).fill(0).map(() => ({}))
    }), s.attributes.filterCategoryValues.setNeedsUpdate("categoryMap")));
  }
  // eslint-disable-next-line max-statements
  draw(g, I) {
    const C = this.state.filterFBO, t = this.state.filterModel, s = this.state.filterNeedsUpdate;
    this.state.categoryBitMask || I._updateCategoryBitMask.call(this, g, I);
    const { onFilteredItemsChange: r, extensions: l, filterEnabled: d, filterRange: h, filterSoftRange: D, filterTransformSize: w, filterTransformColor: p, filterCategories: b } = this.props, S = {
      extensions: l,
      filterEnabled: d,
      filterRange: h,
      filterSoftRange: D,
      filterTransformSize: w,
      filterTransformColor: p,
      filterCategories: b
    };
    if (this.state.categoryBitMask && (S.categoryBitMask = this.state.categoryBitMask), this.setShaderModuleProps({ dataFilter: S }), s && r && t) {
      const K = this.getAttributeManager(), { attributes: { filterValues: Y, filterCategoryValues: T, filterVertexIndices: E } } = K;
      t.setVertexCount(this.getNumInstances());
      const H = {
        ...Y?.getValue(),
        ...T?.getValue(),
        ...E?.getValue()
      };
      t.setAttributes(H), t.shaderInputs.setProps({
        dataFilter: S
      });
      const R = [0, 0, C.width, C.height], x = t.device.beginRenderPass({
        id: "data-filter-aggregation",
        framebuffer: C,
        parameters: { viewport: R },
        clearColor: [0, 0, 0, 0]
      });
      t.setParameters(H7), t.draw(x), x.end();
      const U = t.device.readPixelsToArrayWebGL(C);
      let J = 0;
      for (let L = 0; L < U.length; L++)
        J += U[L];
      r({ id: this.id, count: J }), this.state.filterNeedsUpdate = !1;
    }
  }
  finalizeState() {
    const g = this.state.filterFBO, I = this.state.filterModel;
    g?.destroy(), I?.destroy();
  }
  /**
   * Updates the bitmask used on the GPU to perform the filter based on the
   * `filterCategories` prop. The mapping between categories and bit in the bitmask
   * is performed by `_getCategoryKey()`
   */
  _updateCategoryBitMask(g, I) {
    const { categorySize: C } = I.opts;
    if (!C)
      return;
    const { filterCategories: t } = this.props, s = new Uint32Array([0, 0, 0, 0]), r = C === 1 ? [t] : t, l = C === 1 ? 128 : C === 2 ? 64 : 32;
    for (let d = 0; d < r.length; d++) {
      const h = r[d];
      for (const D of h) {
        const w = I._getCategoryKey.call(this, D, d);
        if (w < l) {
          const p = d * (l / 32) + Math.floor(w / 32);
          s[p] += Math.pow(2, w % 32);
        } else
          uA.warn(`Exceeded maximum number of categories (${l})`)();
      }
    }
    this.state.categoryBitMask = s;
  }
  /**
   * Returns an index of bit in the bitmask for a given category. If the category has
   * not yet been assigned a bit, a new one is assigned.
   */
  _getCategoryKey(g, I) {
    const C = this.state.categoryMap[I];
    return g in C || (C[g] = Object.keys(C).length), C[g];
  }
}
Op.defaultProps = E7;
Op.extensionName = "DataFilterExtension";
const k7 = (A) => {
  A = A.replace(/^#/, "");
  const g = parseInt(A, 16), I = g >> 16 & 255, C = g >> 8 & 255, t = g & 255;
  return [I, C, t];
};
function W7(A, g) {
  switch (g) {
    case "float32":
      return new Float32Array(A.buffer, A.byteOffset, A.byteLength / 4);
    case "float16":
      return new Uint16Array(A.buffer, A.byteOffset, A.byteLength / 2);
    case "uint16":
      return new Uint16Array(A.buffer, A.byteOffset, A.byteLength / 2);
    default:
      throw new Error(`Unsupported DType: ${g}`);
  }
}
function V7(A) {
  const g = new Float32Array(A.length);
  for (let I = 0; I < A.length; I++) {
    const C = A[I], t = (C & 32768) >> 15, s = (C & 31744) >> 10, r = C & 1023;
    let l;
    s === 0 ? r === 0 ? l = 0 : l = Math.pow(2, -14) * (r / 1024) : s === 31 ? l = r === 0 ? 1 / 0 : NaN : l = Math.pow(2, s - 15) * (1 + r / 1024), g[I] = t ? -l : l;
  }
  return g;
}
const z1 = (A, g, {
  selectedCategories: I,
  hiddenCategoryIds: C,
  coloringAnnotation: t,
  NumericThreshold: s,
  customColors: r,
  categoryColors: l
}) => {
  let d = !1, h = !0;
  for (const w in I) {
    const p = I[w];
    if (p !== null) {
      d = !0;
      const b = g.annotations[w]?.[A];
      if (b == null || Number(b) !== p) {
        h = !1;
        break;
      }
    }
  }
  if (d && !h)
    return [0, 0, 0, 5];
  let D = !1;
  for (const w in g.annotations) {
    const p = g.annotations[w]?.[A];
    if (p != null && w in C && C[w] && C[w].has(
      Number(p)
    )) {
      D = !0;
      break;
    }
  }
  if (D)
    return [0, 0, 0, 5];
  if (g.numeric) {
    const w = g.numeric, p = w.values, b = w.ContinuousConfig.Min, S = w.ContinuousConfig.Max, K = p[A];
    if (K < s)
      return [0, 0, 0, 5];
    const Y = (K - b) / (S - b + 1e-6);
    return [
      Math.floor(255 * Y),
      50,
      Math.floor(255 * (1 - Y)),
      Math.floor(180 * Y)
    ];
  } else {
    const w = g.annotations[t];
    if (!w) {
      const K = A * 4;
      return [
        g.originalColor[K],
        g.originalColor[K + 1],
        g.originalColor[K + 2],
        g.originalColor[K + 3] ?? 255
      ];
    }
    const p = w[A], b = p != null ? Number(p) : null;
    if (b !== null && r[t]?.[b])
      return [...k7(r[t][b]), 255];
    if (b !== null && l[t]?.[b])
      return [...l[t][b], 255];
    const S = A * 4;
    return [
      g.originalColor[S],
      g.originalColor[S + 1],
      g.originalColor[S + 2],
      g.originalColor[S + 3] ?? 255
    ];
  }
}, x7 = "4.3.3", wH = {
  dataType: null,
  batchType: null,
  name: "LAS",
  id: "las",
  module: "las",
  version: x7,
  worker: !0,
  extensions: ["las", "laz"],
  // LAZ is the "compressed" flavor of LAS,
  mimeTypes: ["application/octet-stream"],
  // TODO - text version?
  text: !0,
  binary: !0,
  tests: ["LAS"],
  options: {
    las: {
      shape: "mesh",
      fp64: !1,
      skip: 1,
      colorDepth: 8
    }
  }
};
({
  ...wH
});
const _7 = "data:text/javascript;base64,InVzZSBzdHJpY3QiOwooKCkgPT4gewogIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzOwogIHZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHsKICAgIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzOwogIH07CgogIC8vIChkaXNhYmxlZCk6Li4vLi4vbm9kZV9tb2R1bGVzL3BhdGgvcGF0aC5qcwogIHZhciByZXF1aXJlX3BhdGggPSBfX2NvbW1vbkpTKHsKICAgICIoZGlzYWJsZWQpOi4uLy4uL25vZGVfbW9kdWxlcy9wYXRoL3BhdGguanMiKCkgewogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOmZzCiAgdmFyIHJlcXVpcmVfZnMgPSBfX2NvbW1vbkpTKHsKICAgICIoZGlzYWJsZWQpOmZzIigpIHsKICAgIH0KICB9KTsKCiAgLy8gLi4vd29ya2VyLXV0aWxzL3NyYy9saWIvbm9kZS93b3JrZXJfdGhyZWFkcy1icm93c2VyLnRzCiAgdmFyIHBhcmVudFBvcnQgPSBudWxsOwoKICAvLyAuLi93b3JrZXItdXRpbHMvc3JjL2xpYi93b3JrZXItdXRpbHMvZ2V0LXRyYW5zZmVyLWxpc3QudHMKICBmdW5jdGlvbiBnZXRUcmFuc2Zlckxpc3Qob2JqZWN0LCByZWN1cnNpdmUgPSB0cnVlLCB0cmFuc2ZlcnMpIHsKICAgIGNvbnN0IHRyYW5zZmVyc1NldCA9IHRyYW5zZmVycyB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpOwogICAgaWYgKCFvYmplY3QpIHsKICAgIH0gZWxzZSBpZiAoaXNUcmFuc2ZlcmFibGUob2JqZWN0KSkgewogICAgICB0cmFuc2ZlcnNTZXQuYWRkKG9iamVjdCk7CiAgICB9IGVsc2UgaWYgKGlzVHJhbnNmZXJhYmxlKG9iamVjdC5idWZmZXIpKSB7CiAgICAgIHRyYW5zZmVyc1NldC5hZGQob2JqZWN0LmJ1ZmZlcik7CiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7CiAgICB9IGVsc2UgaWYgKHJlY3Vyc2l2ZSAmJiB0eXBlb2Ygb2JqZWN0ID09PSAib2JqZWN0IikgewogICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHsKICAgICAgICBnZXRUcmFuc2Zlckxpc3Qob2JqZWN0W2tleV0sIHJlY3Vyc2l2ZSwgdHJhbnNmZXJzU2V0KTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHRyYW5zZmVycyA9PT0gdm9pZCAwID8gQXJyYXkuZnJvbSh0cmFuc2ZlcnNTZXQpIDogW107CiAgfQogIGZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKG9iamVjdCkgewogICAgaWYgKCFvYmplY3QpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgaWYgKHR5cGVvZiBNZXNzYWdlUG9ydCAhPT0gInVuZGVmaW5lZCIgJiYgb2JqZWN0IGluc3RhbmNlb2YgTWVzc2FnZVBvcnQpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICBpZiAodHlwZW9mIEltYWdlQml0bWFwICE9PSAidW5kZWZpbmVkIiAmJiBvYmplY3QgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAidW5kZWZpbmVkIiAmJiBvYmplY3QgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICByZXR1cm4gZmFsc2U7CiAgfQoKICAvLyAuLi93b3JrZXItdXRpbHMvc3JjL2xpYi93b3JrZXItZmFybS93b3JrZXItYm9keS50cwogIGFzeW5jIGZ1bmN0aW9uIGdldFBhcmVudFBvcnQoKSB7CiAgICByZXR1cm4gcGFyZW50UG9ydDsKICB9CiAgdmFyIG9uTWVzc2FnZVdyYXBwZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwogIHZhciBXb3JrZXJCb2R5ID0gY2xhc3MgewogICAgLyoqIENoZWNrIHRoYXQgd2UgYXJlIGFjdHVhbGx5IGluIGEgd29ya2VyIHRocmVhZCAqLwogICAgc3RhdGljIGFzeW5jIGluV29ya2VyVGhyZWFkKCkgewogICAgICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiIHx8IEJvb2xlYW4oYXdhaXQgZ2V0UGFyZW50UG9ydCgpKTsKICAgIH0KICAgIC8qCiAgICAgKiAodHlwZTogV29ya2VyTWVzc2FnZVR5cGUsIHBheWxvYWQ6IFdvcmtlck1lc3NhZ2VQYXlsb2FkKSA9PiBhbnkKICAgICAqLwogICAgc3RhdGljIHNldCBvbm1lc3NhZ2Uob25NZXNzYWdlKSB7CiAgICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkgewogICAgICAgIGNvbnN0IHBhcmVudFBvcnQyID0gYXdhaXQgZ2V0UGFyZW50UG9ydCgpOwogICAgICAgIGNvbnN0IHsgdHlwZSwgcGF5bG9hZCB9ID0gcGFyZW50UG9ydDIgPyBtZXNzYWdlIDogbWVzc2FnZS5kYXRhOwogICAgICAgIG9uTWVzc2FnZSh0eXBlLCBwYXlsb2FkKTsKICAgICAgfQogICAgICBnZXRQYXJlbnRQb3J0KCkudGhlbigocGFyZW50UG9ydDIpID0+IHsKICAgICAgICBpZiAocGFyZW50UG9ydDIpIHsKICAgICAgICAgIHBhcmVudFBvcnQyLm9uKCJtZXNzYWdlIiwgKG1lc3NhZ2UpID0+IHsKICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKTsKICAgICAgICAgIH0pOwogICAgICAgICAgcGFyZW50UG9ydDIub24oImV4aXQiLCAoKSA9PiBjb25zb2xlLmRlYnVnKCJOb2RlIHdvcmtlciBjbG9zaW5nIikpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICAgIHN0YXRpYyBhc3luYyBhZGRFdmVudExpc3RlbmVyKG9uTWVzc2FnZSkgewogICAgICBsZXQgb25NZXNzYWdlV3JhcHBlciA9IG9uTWVzc2FnZVdyYXBwZXJNYXAuZ2V0KG9uTWVzc2FnZSk7CiAgICAgIGlmICghb25NZXNzYWdlV3JhcHBlcikgewogICAgICAgIG9uTWVzc2FnZVdyYXBwZXIgPSBhc3luYyAobWVzc2FnZSkgPT4gewogICAgICAgICAgaWYgKCFpc0tub3duTWVzc2FnZShtZXNzYWdlKSkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBwYXJlbnRQb3J0MyA9IGF3YWl0IGdldFBhcmVudFBvcnQoKTsKICAgICAgICAgIGNvbnN0IHsgdHlwZSwgcGF5bG9hZCB9ID0gcGFyZW50UG9ydDMgPyBtZXNzYWdlIDogbWVzc2FnZS5kYXRhOwogICAgICAgICAgb25NZXNzYWdlKHR5cGUsIHBheWxvYWQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgY29uc3QgcGFyZW50UG9ydDIgPSBhd2FpdCBnZXRQYXJlbnRQb3J0KCk7CiAgICAgIGlmIChwYXJlbnRQb3J0MikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoIm5vdCBpbXBsZW1lbnRlZCIpOwogICAgICB9IGVsc2UgewogICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIG9uTWVzc2FnZVdyYXBwZXIpOwogICAgICB9CiAgICB9CiAgICBzdGF0aWMgYXN5bmMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpIHsKICAgICAgY29uc3Qgb25NZXNzYWdlV3JhcHBlciA9IG9uTWVzc2FnZVdyYXBwZXJNYXAuZ2V0KG9uTWVzc2FnZSk7CiAgICAgIG9uTWVzc2FnZVdyYXBwZXJNYXAuZGVsZXRlKG9uTWVzc2FnZSk7CiAgICAgIGNvbnN0IHBhcmVudFBvcnQyID0gYXdhaXQgZ2V0UGFyZW50UG9ydCgpOwogICAgICBpZiAocGFyZW50UG9ydDIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJub3QgaW1wbGVtZW50ZWQiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBvbk1lc3NhZ2VXcmFwcGVyKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZW5kIGEgbWVzc2FnZSBmcm9tIGEgd29ya2VyIHRvIGNyZWF0aW5nIHRocmVhZCAobWFpbiB0aHJlYWQpCiAgICAgKiBAcGFyYW0gdHlwZQogICAgICogQHBhcmFtIHBheWxvYWQKICAgICAqLwogICAgc3RhdGljIGFzeW5jIHBvc3RNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHsKICAgICAgY29uc3QgZGF0YSA9IHsgc291cmNlOiAibG9hZGVycy5nbCIsIHR5cGUsIHBheWxvYWQgfTsKICAgICAgY29uc3QgdHJhbnNmZXJMaXN0ID0gZ2V0VHJhbnNmZXJMaXN0KHBheWxvYWQpOwogICAgICBjb25zdCBwYXJlbnRQb3J0MiA9IGF3YWl0IGdldFBhcmVudFBvcnQoKTsKICAgICAgaWYgKHBhcmVudFBvcnQyKSB7CiAgICAgICAgcGFyZW50UG9ydDIucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7CiAgICAgIH0KICAgIH0KICB9OwogIGZ1bmN0aW9uIGlzS25vd25NZXNzYWdlKG1lc3NhZ2UpIHsKICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbWVzc2FnZTsKICAgIHJldHVybiB0eXBlID09PSAibWVzc2FnZSIgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YS5zb3VyY2UgPT09ICJzdHJpbmciICYmIGRhdGEuc291cmNlLnN0YXJ0c1dpdGgoImxvYWRlcnMuZ2wiKTsKICB9CgogIC8vIC4uL2xvYWRlci11dGlscy9zcmMvbGliL3dvcmtlci1sb2FkZXItdXRpbHMvY3JlYXRlLWxvYWRlci13b3JrZXIudHMKICB2YXIgcmVxdWVzdElkID0gMDsKICBhc3luYyBmdW5jdGlvbiBjcmVhdGVMb2FkZXJXb3JrZXIobG9hZGVyKSB7CiAgICBpZiAoIWF3YWl0IFdvcmtlckJvZHkuaW5Xb3JrZXJUaHJlYWQoKSkgewogICAgICByZXR1cm47CiAgICB9CiAgICBXb3JrZXJCb2R5Lm9ubWVzc2FnZSA9IGFzeW5jICh0eXBlLCBwYXlsb2FkKSA9PiB7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgInByb2Nlc3MiOgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgY29uc3QgeyBpbnB1dCwgb3B0aW9ucyA9IHt9LCBjb250ZXh0ID0ge30gfSA9IHBheWxvYWQ7CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlRGF0YSh7CiAgICAgICAgICAgICAgbG9hZGVyLAogICAgICAgICAgICAgIGFycmF5QnVmZmVyOiBpbnB1dCwKICAgICAgICAgICAgICBvcHRpb25zLAogICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZmV0Y2ggbWlzc2luZwogICAgICAgICAgICAgIGNvbnRleHQ6IHsKICAgICAgICAgICAgICAgIC4uLmNvbnRleHQsCiAgICAgICAgICAgICAgICBfcGFyc2U6IHBhcnNlT25NYWluVGhyZWFkCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgV29ya2VyQm9keS5wb3N0TWVzc2FnZSgiZG9uZSIsIHsgcmVzdWx0IH0pOwogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogIiI7CiAgICAgICAgICAgIFdvcmtlckJvZHkucG9zdE1lc3NhZ2UoImVycm9yIiwgeyBlcnJvcjogbWVzc2FnZSB9KTsKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrOwogICAgICAgIGRlZmF1bHQ6CiAgICAgIH0KICAgIH07CiAgfQogIGZ1bmN0aW9uIHBhcnNlT25NYWluVGhyZWFkKGFycmF5QnVmZmVyLCBsb2FkZXIsIG9wdGlvbnMsIGNvbnRleHQpIHsKICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgICAgIGNvbnN0IGlkID0gcmVxdWVzdElkKys7CiAgICAgIGNvbnN0IG9uTWVzc2FnZSA9ICh0eXBlLCBwYXlsb2FkMikgPT4gewogICAgICAgIGlmIChwYXlsb2FkMi5pZCAhPT0gaWQpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICBjYXNlICJkb25lIjoKICAgICAgICAgICAgV29ya2VyQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7CiAgICAgICAgICAgIHJlc29sdmUocGF5bG9hZDIucmVzdWx0KTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJlcnJvciI6CiAgICAgICAgICAgIFdvcmtlckJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpOwogICAgICAgICAgICByZWplY3QocGF5bG9hZDIuZXJyb3IpOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgfQogICAgICB9OwogICAgICBXb3JrZXJCb2R5LmFkZEV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTsKICAgICAgY29uc3QgcGF5bG9hZCA9IHsgaWQsIGlucHV0OiBhcnJheUJ1ZmZlciwgb3B0aW9ucyB9OwogICAgICBXb3JrZXJCb2R5LnBvc3RNZXNzYWdlKCJwcm9jZXNzIiwgcGF5bG9hZCk7CiAgICB9KTsKICB9CiAgYXN5bmMgZnVuY3Rpb24gcGFyc2VEYXRhKHsKICAgIGxvYWRlciwKICAgIGFycmF5QnVmZmVyLAogICAgb3B0aW9ucywKICAgIGNvbnRleHQKICB9KSB7CiAgICBsZXQgZGF0YTsKICAgIGxldCBwYXJzZXI7CiAgICBpZiAobG9hZGVyLnBhcnNlU3luYyB8fCBsb2FkZXIucGFyc2UpIHsKICAgICAgZGF0YSA9IGFycmF5QnVmZmVyOwogICAgICBwYXJzZXIgPSBsb2FkZXIucGFyc2VTeW5jIHx8IGxvYWRlci5wYXJzZTsKICAgIH0gZWxzZSBpZiAobG9hZGVyLnBhcnNlVGV4dFN5bmMpIHsKICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTsKICAgICAgZGF0YSA9IHRleHREZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIHBhcnNlciA9IGxvYWRlci5wYXJzZVRleHRTeW5jOwogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCBkYXRhIHdpdGggJHtsb2FkZXIubmFtZX0gbG9hZGVyYCk7CiAgICB9CiAgICBvcHRpb25zID0gewogICAgICAuLi5vcHRpb25zLAogICAgICBtb2R1bGVzOiBsb2FkZXIgJiYgbG9hZGVyLm9wdGlvbnMgJiYgbG9hZGVyLm9wdGlvbnMubW9kdWxlcyB8fCB7fSwKICAgICAgd29ya2VyOiBmYWxzZQogICAgfTsKICAgIHJldHVybiBhd2FpdCBwYXJzZXIoZGF0YSwgeyAuLi5vcHRpb25zIH0sIGNvbnRleHQsIGxvYWRlcik7CiAgfQoKICAvLyBzcmMvbGFzLWxvYWRlci50cwogIHZhciBWRVJTSU9OID0gdHJ1ZSA/ICI0LjMuMiIgOiAibGF0ZXN0IjsKICB2YXIgTEFTTG9hZGVyID0gewogICAgZGF0YVR5cGU6IG51bGwsCiAgICBiYXRjaFR5cGU6IG51bGwsCiAgICBuYW1lOiAiTEFTIiwKICAgIGlkOiAibGFzIiwKICAgIG1vZHVsZTogImxhcyIsCiAgICB2ZXJzaW9uOiBWRVJTSU9OLAogICAgd29ya2VyOiB0cnVlLAogICAgZXh0ZW5zaW9uczogWyJsYXMiLCAibGF6Il0sCiAgICAvLyBMQVogaXMgdGhlICJjb21wcmVzc2VkIiBmbGF2b3Igb2YgTEFTLAogICAgbWltZVR5cGVzOiBbImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSJdLAogICAgLy8gVE9ETyAtIHRleHQgdmVyc2lvbj8KICAgIHRleHQ6IHRydWUsCiAgICBiaW5hcnk6IHRydWUsCiAgICB0ZXN0czogWyJMQVMiXSwKICAgIG9wdGlvbnM6IHsKICAgICAgbGFzOiB7CiAgICAgICAgc2hhcGU6ICJtZXNoIiwKICAgICAgICBmcDY0OiBmYWxzZSwKICAgICAgICBza2lwOiAxLAogICAgICAgIGNvbG9yRGVwdGg6IDgKICAgICAgfQogICAgfQogIH07CgogIC8vIC4uL3NjaGVtYS9zcmMvbGliL3RhYmxlL3NpbXBsZS10YWJsZS9kYXRhLXR5cGUudHMKICBmdW5jdGlvbiBnZXREYXRhVHlwZUZyb21UeXBlZEFycmF5KGFycmF5KSB7CiAgICBzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7CiAgICAgIGNhc2UgSW50OEFycmF5OgogICAgICAgIHJldHVybiAiaW50OCI7CiAgICAgIGNhc2UgVWludDhBcnJheToKICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheToKICAgICAgICByZXR1cm4gInVpbnQ4IjsKICAgICAgY2FzZSBJbnQxNkFycmF5OgogICAgICAgIHJldHVybiAiaW50MTYiOwogICAgICBjYXNlIFVpbnQxNkFycmF5OgogICAgICAgIHJldHVybiAidWludDE2IjsKICAgICAgY2FzZSBJbnQzMkFycmF5OgogICAgICAgIHJldHVybiAiaW50MzIiOwogICAgICBjYXNlIFVpbnQzMkFycmF5OgogICAgICAgIHJldHVybiAidWludDMyIjsKICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6CiAgICAgICAgcmV0dXJuICJmbG9hdDMyIjsKICAgICAgY2FzZSBGbG9hdDY0QXJyYXk6CiAgICAgICAgcmV0dXJuICJmbG9hdDY0IjsKICAgICAgZGVmYXVsdDoKICAgICAgICByZXR1cm4gIm51bGwiOwogICAgfQogIH0KCiAgLy8gLi4vc2NoZW1hL3NyYy9saWIvbWVzaC9tZXNoLXV0aWxzLnRzCiAgZnVuY3Rpb24gZ2V0TWVzaEJvdW5kaW5nQm94KGF0dHJpYnV0ZXMpIHsKICAgIGxldCBtaW5YID0gSW5maW5pdHk7CiAgICBsZXQgbWluWSA9IEluZmluaXR5OwogICAgbGV0IG1pblogPSBJbmZpbml0eTsKICAgIGxldCBtYXhYID0gLUluZmluaXR5OwogICAgbGV0IG1heFkgPSAtSW5maW5pdHk7CiAgICBsZXQgbWF4WiA9IC1JbmZpbml0eTsKICAgIGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMuUE9TSVRJT04gPyBhdHRyaWJ1dGVzLlBPU0lUSU9OLnZhbHVlIDogW107CiAgICBjb25zdCBsZW4gPSBwb3NpdGlvbnMgJiYgcG9zaXRpb25zLmxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHsKICAgICAgY29uc3QgeCA9IHBvc2l0aW9uc1tpXTsKICAgICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICsgMV07CiAgICAgIGNvbnN0IHogPSBwb3NpdGlvbnNbaSArIDJdOwogICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDsKICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7CiAgICAgIG1pblogPSB6IDwgbWluWiA/IHogOiBtaW5aOwogICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDsKICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7CiAgICAgIG1heFogPSB6ID4gbWF4WiA/IHogOiBtYXhaOwogICAgfQogICAgcmV0dXJuIFsKICAgICAgW21pblgsIG1pblksIG1pblpdLAogICAgICBbbWF4WCwgbWF4WSwgbWF4Wl0KICAgIF07CiAgfQoKICAvLyAuLi9zY2hlbWEvc3JjL2xpYi9tZXNoL2RlZHVjZS1tZXNoLXNjaGVtYS50cwogIGZ1bmN0aW9uIGRlZHVjZU1lc2hTY2hlbWEoYXR0cmlidXRlcywgbWV0YWRhdGEgPSB7fSkgewogICAgY29uc3QgZmllbGRzID0gZGVkdWNlTWVzaEZpZWxkcyhhdHRyaWJ1dGVzKTsKICAgIHJldHVybiB7IGZpZWxkcywgbWV0YWRhdGEgfTsKICB9CiAgZnVuY3Rpb24gZGVkdWNlTWVzaEZpZWxkKG5hbWUsIGF0dHJpYnV0ZSwgb3B0aW9uYWxNZXRhZGF0YSkgewogICAgY29uc3QgdHlwZSA9IGdldERhdGFUeXBlRnJvbVR5cGVkQXJyYXkoYXR0cmlidXRlLnZhbHVlKTsKICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9uYWxNZXRhZGF0YSA/IG9wdGlvbmFsTWV0YWRhdGEgOiBtYWtlTWVzaEF0dHJpYnV0ZU1ldGFkYXRhKGF0dHJpYnV0ZSk7CiAgICByZXR1cm4gewogICAgICBuYW1lLAogICAgICB0eXBlOiB7IHR5cGU6ICJmaXhlZC1zaXplLWxpc3QiLCBsaXN0U2l6ZTogYXR0cmlidXRlLnNpemUsIGNoaWxkcmVuOiBbeyBuYW1lOiAidmFsdWUiLCB0eXBlIH1dIH0sCiAgICAgIG51bGxhYmxlOiBmYWxzZSwKICAgICAgbWV0YWRhdGEKICAgIH07CiAgfQogIGZ1bmN0aW9uIGRlZHVjZU1lc2hGaWVsZHMoYXR0cmlidXRlcykgewogICAgY29uc3QgZmllbGRzID0gW107CiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykgewogICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdOwogICAgICBmaWVsZHMucHVzaChkZWR1Y2VNZXNoRmllbGQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSk7CiAgICB9CiAgICByZXR1cm4gZmllbGRzOwogIH0KICBmdW5jdGlvbiBtYWtlTWVzaEF0dHJpYnV0ZU1ldGFkYXRhKGF0dHJpYnV0ZSkgewogICAgY29uc3QgcmVzdWx0ID0ge307CiAgICBpZiAoImJ5dGVPZmZzZXQiIGluIGF0dHJpYnV0ZSkgewogICAgICByZXN1bHQuYnl0ZU9mZnNldCA9IGF0dHJpYnV0ZS5ieXRlT2Zmc2V0LnRvU3RyaW5nKDEwKTsKICAgIH0KICAgIGlmICgiYnl0ZVN0cmlkZSIgaW4gYXR0cmlidXRlKSB7CiAgICAgIHJlc3VsdC5ieXRlU3RyaWRlID0gYXR0cmlidXRlLmJ5dGVTdHJpZGUudG9TdHJpbmcoMTApOwogICAgfQogICAgaWYgKCJub3JtYWxpemVkIiBpbiBhdHRyaWJ1dGUpIHsKICAgICAgcmVzdWx0Lm5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZC50b1N0cmluZygpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CgogIC8vIHNyYy9saWIvbGlicy9sYXotcGVyZi50cwogIGZ1bmN0aW9uIGdldE1vZHVsZSgpIHsKICAgIHZhciBNb2R1bGUyID0gdHlwZW9mIE1vZHVsZTIgIT09ICJ1bmRlZmluZWQiID8gTW9kdWxlMiA6IHt9OwogICAgdmFyIG1vZHVsZU92ZXJyaWRlcyA9IHt9OwogICAgdmFyIGtleTsKICAgIGZvciAoa2V5IGluIE1vZHVsZTIpIHsKICAgICAgaWYgKE1vZHVsZTIuaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICAgIG1vZHVsZU92ZXJyaWRlc1trZXldID0gTW9kdWxlMltrZXldOwogICAgICB9CiAgICB9CiAgICB2YXIgYXJndW1lbnRzXyA9IFtdOwogICAgdmFyIHRoaXNQcm9ncmFtID0gIi4vdGhpcy5wcm9ncmFtIjsKICAgIHZhciBxdWl0XyA9IGZ1bmN0aW9uKHN0YXR1cywgdG9UaHJvdykgewogICAgICB0aHJvdyB0b1Rocm93OwogICAgfTsKICAgIHZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSBmYWxzZTsKICAgIHZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSBmYWxzZTsKICAgIHZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gZmFsc2U7CiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSBmYWxzZTsKICAgIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT09ICJvYmplY3QiOwogICAgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICJmdW5jdGlvbiI7CiAgICBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHlwZW9mIHByb2Nlc3MgPT09ICJvYmplY3QiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09PSAib2JqZWN0IiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09PSAic3RyaW5nIjsKICAgIEVOVklST05NRU5UX0lTX1NIRUxMID0gIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSOwogICAgdmFyIHNjcmlwdERpcmVjdG9yeSA9ICIiOwogICAgZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7CiAgICAgIGlmIChNb2R1bGUyWyJsb2NhdGVGaWxlIl0pIHsKICAgICAgICByZXR1cm4gTW9kdWxlMlsibG9jYXRlRmlsZSJdKHBhdGgsIHNjcmlwdERpcmVjdG9yeSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7CiAgICB9CiAgICB2YXIgcmVhZF8sIHJlYWRBc3luYywgcmVhZEJpbmFyeSwgc2V0V2luZG93VGl0bGU7CiAgICB2YXIgbm9kZUZTOwogICAgdmFyIG5vZGVQYXRoOwogICAgaWYgKEVOVklST05NRU5UX0lTX05PREUpIHsKICAgICAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikgewogICAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHJlcXVpcmVfcGF0aCgpLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KSArICIvIjsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBkaXJuYW1lID0gdHlwZW9mIF9fZGlybmFtZSAhPT0gInVuZGVmaW5lZCIgPyBfX2Rpcm5hbWUgOiAiIjsKICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBkaXJuYW1lICsgIi8iOwogICAgICB9CiAgICAgIHJlYWRfID0gZnVuY3Rpb24gc2hlbGxfcmVhZChmaWxlbmFtZSwgYmluYXJ5KSB7CiAgICAgICAgdmFyIHJldCA9IHRyeVBhcnNlQXNEYXRhVVJJKGZpbGVuYW1lKTsKICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICByZXR1cm4gYmluYXJ5ID8gcmV0IDogcmV0LnRvU3RyaW5nKCk7CiAgICAgICAgfQogICAgICAgIGlmICghbm9kZUZTKQogICAgICAgICAgbm9kZUZTID0gcmVxdWlyZV9mcygpOwogICAgICAgIGlmICghbm9kZVBhdGgpCiAgICAgICAgICBub2RlUGF0aCA9IHJlcXVpcmVfcGF0aCgpOwogICAgICAgIGZpbGVuYW1lID0gbm9kZVBhdGhbIm5vcm1hbGl6ZSJdKGZpbGVuYW1lKTsKICAgICAgICByZXR1cm4gbm9kZUZTWyJyZWFkRmlsZVN5bmMiXShmaWxlbmFtZSwgYmluYXJ5ID8gbnVsbCA6ICJ1dGY4Iik7CiAgICAgIH07CiAgICAgIHJlYWRCaW5hcnkgPSBmdW5jdGlvbiByZWFkQmluYXJ5MihmaWxlbmFtZSkgewogICAgICAgIHZhciByZXQgPSByZWFkXyhmaWxlbmFtZSwgdHJ1ZSk7CiAgICAgICAgaWYgKCFyZXQuYnVmZmVyKSB7CiAgICAgICAgICByZXQgPSBuZXcgVWludDhBcnJheShyZXQpOwogICAgICAgIH0KICAgICAgICBhc3NlcnQocmV0LmJ1ZmZlcik7CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfTsKICAgICAgaWYgKHByb2Nlc3NbImFyZ3YiXS5sZW5ndGggPiAxKSB7CiAgICAgICAgdGhpc1Byb2dyYW0gPSBwcm9jZXNzWyJhcmd2Il1bMV0ucmVwbGFjZSgvXFwvZywgIi8iKTsKICAgICAgfQogICAgICBhcmd1bWVudHNfID0gcHJvY2Vzc1siYXJndiJdLnNsaWNlKDIpOwogICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICBtb2R1bGVbImV4cG9ydHMiXSA9IE1vZHVsZTI7CiAgICAgIH0KICAgICAgcHJvY2Vzc1sib24iXSgidW5jYXVnaHRFeGNlcHRpb24iLCBmdW5jdGlvbihleCkgewogICAgICAgIGlmICghKGV4IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHsKICAgICAgICAgIHRocm93IGV4OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHByb2Nlc3NbIm9uIl0oInVuaGFuZGxlZFJlamVjdGlvbiIsIGFib3J0KTsKICAgICAgcXVpdF8gPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBwcm9jZXNzWyJleGl0Il0oc3RhdHVzKTsKICAgICAgfTsKICAgICAgTW9kdWxlMlsiaW5zcGVjdCJdID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuICJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XSI7CiAgICAgIH07CiAgICB9IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7CiAgICAgIGlmICh0eXBlb2YgcmVhZCAhPSAidW5kZWZpbmVkIikgewogICAgICAgIHJlYWRfID0gZnVuY3Rpb24gc2hlbGxfcmVhZChmKSB7CiAgICAgICAgICB2YXIgZGF0YTIgPSB0cnlQYXJzZUFzRGF0YVVSSShmKTsKICAgICAgICAgIGlmIChkYXRhMikgewogICAgICAgICAgICByZXR1cm4gaW50QXJyYXlUb1N0cmluZyhkYXRhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhZChmKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIHJlYWRCaW5hcnkgPSBmdW5jdGlvbiByZWFkQmluYXJ5MihmKSB7CiAgICAgICAgdmFyIGRhdGEyOwogICAgICAgIGRhdGEyID0gdHJ5UGFyc2VBc0RhdGFVUkkoZik7CiAgICAgICAgaWYgKGRhdGEyKSB7CiAgICAgICAgICByZXR1cm4gZGF0YTI7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgcmVhZGJ1ZmZlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpOwogICAgICAgIH0KICAgICAgICBkYXRhMiA9IHJlYWQoZiwgImJpbmFyeSIpOwogICAgICAgIGFzc2VydCh0eXBlb2YgZGF0YTIgPT09ICJvYmplY3QiKTsKICAgICAgICByZXR1cm4gZGF0YTI7CiAgICAgIH07CiAgICAgIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSAidW5kZWZpbmVkIikgewogICAgICAgIGFyZ3VtZW50c18gPSBzY3JpcHRBcmdzOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHMgIT0gInVuZGVmaW5lZCIpIHsKICAgICAgICBhcmd1bWVudHNfID0gYXJndW1lbnRzOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgcXVpdCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIHF1aXRfID0gZnVuY3Rpb24oc3RhdHVzKSB7CiAgICAgICAgICBxdWl0KHN0YXR1cyk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIHByaW50ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gInVuZGVmaW5lZCIpCiAgICAgICAgICBjb25zb2xlID0ge307CiAgICAgICAgY29uc29sZS5sb2cgPSBwcmludDsKICAgICAgICBjb25zb2xlLndhcm4gPSBjb25zb2xlLmVycm9yID0gdHlwZW9mIHByaW50RXJyICE9PSAidW5kZWZpbmVkIiA/IHByaW50RXJyIDogcHJpbnQ7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikgewogICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7CiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmOwogICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHsKICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzsKICAgICAgfQogICAgICBpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoImJsb2I6IikgIT09IDApIHsKICAgICAgICBzY3JpcHREaXJlY3RvcnkgPSBzY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsIHNjcmlwdERpcmVjdG9yeS5sYXN0SW5kZXhPZigiLyIpICsgMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gIiI7CiAgICAgIH0KICAgICAgewogICAgICAgIHJlYWRfID0gZnVuY3Rpb24gc2hlbGxfcmVhZCh1cmwpIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsKICAgICAgICAgICAgeGhyLm9wZW4oIkdFVCIsIHVybCwgZmFsc2UpOwogICAgICAgICAgICB4aHIuc2VuZChudWxsKTsKICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7CiAgICAgICAgICB9IGNhdGNoIChlcnIyKSB7CiAgICAgICAgICAgIHZhciBkYXRhMiA9IHRyeVBhcnNlQXNEYXRhVVJJKHVybCk7CiAgICAgICAgICAgIGlmIChkYXRhMikgewogICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheVRvU3RyaW5nKGRhdGEyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aHJvdyBlcnIyOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikgewogICAgICAgICAgcmVhZEJpbmFyeSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkyKHVybCkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsKICAgICAgICAgICAgICB4aHIub3BlbigiR0VUIiwgdXJsLCBmYWxzZSk7CiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICJhcnJheWJ1ZmZlciI7CiAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHsKICAgICAgICAgICAgICB2YXIgZGF0YTIgPSB0cnlQYXJzZUFzRGF0YVVSSSh1cmwpOwogICAgICAgICAgICAgIGlmIChkYXRhMikgewogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0aHJvdyBlcnIyOwogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICByZWFkQXN5bmMgPSBmdW5jdGlvbiByZWFkQXN5bmMyKHVybCwgb25sb2FkLCBvbmVycm9yKSB7CiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgICB4aHIub3BlbigiR0VUIiwgdXJsLCB0cnVlKTsKICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAiYXJyYXlidWZmZXIiOwogICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIHhocl9vbmxvYWQoKSB7CiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCB4aHIuc3RhdHVzID09IDAgJiYgeGhyLnJlc3BvbnNlKSB7CiAgICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBkYXRhMiA9IHRyeVBhcnNlQXNEYXRhVVJJKHVybCk7CiAgICAgICAgICAgIGlmIChkYXRhMikgewogICAgICAgICAgICAgIG9ubG9hZChkYXRhMi5idWZmZXIpOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBvbmVycm9yKCk7CiAgICAgICAgICB9OwogICAgICAgICAgeGhyLm9uZXJyb3IgPSBvbmVycm9yOwogICAgICAgICAgeGhyLnNlbmQobnVsbCk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBzZXRXaW5kb3dUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7CiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTsKICAgICAgfTsKICAgIH0gZWxzZSB7CiAgICB9CiAgICB2YXIgb3V0ID0gTW9kdWxlMlsicHJpbnQiXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpOwogICAgdmFyIGVyciA9IE1vZHVsZTJbInByaW50RXJyIl0gfHwgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7CiAgICBmb3IgKGtleSBpbiBtb2R1bGVPdmVycmlkZXMpIHsKICAgICAgaWYgKG1vZHVsZU92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgICAgTW9kdWxlMltrZXldID0gbW9kdWxlT3ZlcnJpZGVzW2tleV07CiAgICAgIH0KICAgIH0KICAgIG1vZHVsZU92ZXJyaWRlcyA9IG51bGw7CiAgICBpZiAoTW9kdWxlMlsiYXJndW1lbnRzIl0pCiAgICAgIGFyZ3VtZW50c18gPSBNb2R1bGUyWyJhcmd1bWVudHMiXTsKICAgIGlmIChNb2R1bGUyWyJ0aGlzUHJvZ3JhbSJdKQogICAgICB0aGlzUHJvZ3JhbSA9IE1vZHVsZTJbInRoaXNQcm9ncmFtIl07CiAgICBpZiAoTW9kdWxlMlsicXVpdCJdKQogICAgICBxdWl0XyA9IE1vZHVsZTJbInF1aXQiXTsKICAgIHZhciBTVEFDS19BTElHTiA9IDE2OwogICAgZnVuY3Rpb24gZHluYW1pY0FsbG9jKHNpemUpIHsKICAgICAgdmFyIHJldCA9IEhFQVAzMltEWU5BTUlDVE9QX1BUUiA+PiAyXTsKICAgICAgdmFyIGVuZCA9IHJldCArIHNpemUgKyAxNSAmIC0xNjsKICAgICAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSID4+IDJdID0gZW5kOwogICAgICByZXR1cm4gcmV0OwogICAgfQogICAgZnVuY3Rpb24gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSkgewogICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICBjYXNlICJpMSI6CiAgICAgICAgY2FzZSAiaTgiOgogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgY2FzZSAiaTE2IjoKICAgICAgICAgIHJldHVybiAyOwogICAgICAgIGNhc2UgImkzMiI6CiAgICAgICAgICByZXR1cm4gNDsKICAgICAgICBjYXNlICJpNjQiOgogICAgICAgICAgcmV0dXJuIDg7CiAgICAgICAgY2FzZSAiZmxvYXQiOgogICAgICAgICAgcmV0dXJuIDQ7CiAgICAgICAgY2FzZSAiZG91YmxlIjoKICAgICAgICAgIHJldHVybiA4OwogICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09ICIqIikgewogICAgICAgICAgICByZXR1cm4gNDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gImkiKSB7CiAgICAgICAgICAgIHZhciBiaXRzID0gTnVtYmVyKHR5cGUuc3Vic3RyKDEpKTsKICAgICAgICAgICAgYXNzZXJ0KGJpdHMgJSA4ID09PSAwLCAiZ2V0TmF0aXZlVHlwZVNpemUgaW52YWxpZCBiaXRzICIgKyBiaXRzICsgIiwgdHlwZSAiICsgdHlwZSk7CiAgICAgICAgICAgIHJldHVybiBiaXRzIC8gODsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gd2Fybk9uY2UodGV4dCkgewogICAgICBpZiAoIXdhcm5PbmNlLnNob3duKQogICAgICAgIHdhcm5PbmNlLnNob3duID0ge307CiAgICAgIGlmICghd2Fybk9uY2Uuc2hvd25bdGV4dF0pIHsKICAgICAgICB3YXJuT25jZS5zaG93blt0ZXh0XSA9IDE7CiAgICAgICAgZXJyKHRleHQpOwogICAgICB9CiAgICB9CiAgICB2YXIganNDYWxsU3RhcnRJbmRleCA9IDE7CiAgICB2YXIgZnVuY3Rpb25Qb2ludGVycyA9IG5ldyBBcnJheSgwKTsKICAgIHZhciBmdW5jV3JhcHBlcnMgPSB7fTsKICAgIGZ1bmN0aW9uIGR5bkNhbGwoc2lnLCBwdHIsIGFyZ3MpIHsKICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gTW9kdWxlMlsiZHluQ2FsbF8iICsgc2lnXS5hcHBseShudWxsLCBbcHRyXS5jb25jYXQoYXJncykpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBNb2R1bGUyWyJkeW5DYWxsXyIgKyBzaWddLmNhbGwobnVsbCwgcHRyKTsKICAgICAgfQogICAgfQogICAgdmFyIHRlbXBSZXQwID0gMDsKICAgIHZhciBzZXRUZW1wUmV0MCA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHRlbXBSZXQwID0gdmFsdWU7CiAgICB9OwogICAgdmFyIGdldFRlbXBSZXQwID0gZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiB0ZW1wUmV0MDsKICAgIH07CiAgICB2YXIgR0xPQkFMX0JBU0UgPSA4OwogICAgdmFyIHdhc21CaW5hcnk7CiAgICBpZiAoTW9kdWxlMlsid2FzbUJpbmFyeSJdKQogICAgICB3YXNtQmluYXJ5ID0gTW9kdWxlMlsid2FzbUJpbmFyeSJdOwogICAgdmFyIG5vRXhpdFJ1bnRpbWU7CiAgICBpZiAoTW9kdWxlMlsibm9FeGl0UnVudGltZSJdKQogICAgICBub0V4aXRSdW50aW1lID0gTW9kdWxlMlsibm9FeGl0UnVudGltZSJdOwogICAgZnVuY3Rpb24gc2V0VmFsdWUocHRyLCB2YWx1ZSwgdHlwZSwgbm9TYWZlKSB7CiAgICAgIHR5cGUgPSB0eXBlIHx8ICJpOCI7CiAgICAgIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aCAtIDEpID09PSAiKiIpCiAgICAgICAgdHlwZSA9ICJpMzIiOwogICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICBjYXNlICJpMSI6CiAgICAgICAgICBIRUFQOFtwdHIgPj4gMF0gPSB2YWx1ZTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgImk4IjoKICAgICAgICAgIEhFQVA4W3B0ciA+PiAwXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiaTE2IjoKICAgICAgICAgIEhFQVAxNltwdHIgPj4gMV0gPSB2YWx1ZTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgImkzMiI6CiAgICAgICAgICBIRUFQMzJbcHRyID4+IDJdID0gdmFsdWU7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJpNjQiOgogICAgICAgICAgdGVtcEk2NCA9IFsKICAgICAgICAgICAgdmFsdWUgPj4+IDAsCiAgICAgICAgICAgICh0ZW1wRG91YmxlID0gdmFsdWUsICtNYXRoX2Ficyh0ZW1wRG91YmxlKSA+PSAxID8gdGVtcERvdWJsZSA+IDAgPyAoTWF0aF9taW4oK01hdGhfZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYpLCA0Mjk0OTY3Mjk1KSB8IDApID4+PiAwIDogfn4rTWF0aF9jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYpID4+PiAwIDogMCkKICAgICAgICAgIF0sIEhFQVAzMltwdHIgPj4gMl0gPSB0ZW1wSTY0WzBdLCBIRUFQMzJbcHRyICsgNCA+PiAyXSA9IHRlbXBJNjRbMV07CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJmbG9hdCI6CiAgICAgICAgICBIRUFQRjMyW3B0ciA+PiAyXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiZG91YmxlIjoKICAgICAgICAgIEhFQVBGNjRbcHRyID4+IDNdID0gdmFsdWU7CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgYWJvcnQoImludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICIgKyB0eXBlKTsKICAgICAgfQogICAgfQogICAgdmFyIEFCT1JUID0gZmFsc2U7CiAgICB2YXIgRVhJVFNUQVRVUyA9IDA7CiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCB0ZXh0KSB7CiAgICAgIGlmICghY29uZGl0aW9uKSB7CiAgICAgICAgYWJvcnQoIkFzc2VydGlvbiBmYWlsZWQ6ICIgKyB0ZXh0KTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZ2V0Q0Z1bmMoaWRlbnQpIHsKICAgICAgdmFyIGZ1bmMgPSBNb2R1bGUyWyJfIiArIGlkZW50XTsKICAgICAgYXNzZXJ0KGZ1bmMsICJDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uICIgKyBpZGVudCArICIsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZCIpOwogICAgICByZXR1cm4gZnVuYzsKICAgIH0KICAgIGZ1bmN0aW9uIGNjYWxsKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJncywgb3B0cykgewogICAgICB2YXIgdG9DID0gewogICAgICAgIHN0cmluZzogZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgICB2YXIgcmV0MiA9IDA7CiAgICAgICAgICBpZiAoc3RyICE9PSBudWxsICYmIHN0ciAhPT0gdm9pZCAwICYmIHN0ciAhPT0gMCkgewogICAgICAgICAgICB2YXIgbGVuID0gKHN0ci5sZW5ndGggPDwgMikgKyAxOwogICAgICAgICAgICByZXQyID0gc3RhY2tBbGxvYyhsZW4pOwogICAgICAgICAgICBzdHJpbmdUb1VURjgoc3RyLCByZXQyLCBsZW4pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJldDI7CiAgICAgICAgfSwKICAgICAgICBhcnJheTogZnVuY3Rpb24oYXJyKSB7CiAgICAgICAgICB2YXIgcmV0MiA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7CiAgICAgICAgICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQyKTsKICAgICAgICAgIHJldHVybiByZXQyOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldDIpIHsKICAgICAgICBpZiAocmV0dXJuVHlwZSA9PT0gInN0cmluZyIpCiAgICAgICAgICByZXR1cm4gVVRGOFRvU3RyaW5nKHJldDIpOwogICAgICAgIGlmIChyZXR1cm5UeXBlID09PSAiYm9vbGVhbiIpCiAgICAgICAgICByZXR1cm4gQm9vbGVhbihyZXQyKTsKICAgICAgICByZXR1cm4gcmV0MjsKICAgICAgfQogICAgICB2YXIgZnVuYyA9IGdldENGdW5jKGlkZW50KTsKICAgICAgdmFyIGNBcmdzID0gW107CiAgICAgIHZhciBzdGFjayA9IDA7CiAgICAgIGlmIChhcmdzKSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgY29udmVydGVyID0gdG9DW2FyZ1R5cGVzW2ldXTsKICAgICAgICAgIGlmIChjb252ZXJ0ZXIpIHsKICAgICAgICAgICAgaWYgKHN0YWNrID09PSAwKQogICAgICAgICAgICAgIHN0YWNrID0gc3RhY2tTYXZlKCk7CiAgICAgICAgICAgIGNBcmdzW2ldID0gY29udmVydGVyKGFyZ3NbaV0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY0FyZ3NbaV0gPSBhcmdzW2ldOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgcmV0ID0gZnVuYy5hcHBseShudWxsLCBjQXJncyk7CiAgICAgIHJldCA9IGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpOwogICAgICBpZiAoc3RhY2sgIT09IDApCiAgICAgICAgc3RhY2tSZXN0b3JlKHN0YWNrKTsKICAgICAgcmV0dXJuIHJldDsKICAgIH0KICAgIHZhciBBTExPQ19OT05FID0gMzsKICAgIHZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gInVuZGVmaW5lZCIgPyBuZXcgVGV4dERlY29kZXIoInV0ZjgiKSA6IHZvaWQgMDsKICAgIGZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXAsIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHsKICAgICAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkOwogICAgICB2YXIgZW5kUHRyID0gaWR4OwogICAgICB3aGlsZSAoaGVhcFtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpCiAgICAgICAgKytlbmRQdHI7CiAgICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwLnN1YmFycmF5ICYmIFVURjhEZWNvZGVyKSB7CiAgICAgICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwLnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHN0ciA9ICIiOwogICAgICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHsKICAgICAgICAgIHZhciB1MCA9IGhlYXBbaWR4KytdOwogICAgICAgICAgaWYgKCEodTAgJiAxMjgpKSB7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgdTEgPSBoZWFwW2lkeCsrXSAmIDYzOwogICAgICAgICAgaWYgKCh1MCAmIDIyNCkgPT0gMTkyKSB7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCAmIDMxKSA8PCA2IHwgdTEpOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB1MiA9IGhlYXBbaWR4KytdICYgNjM7CiAgICAgICAgICBpZiAoKHUwICYgMjQwKSA9PSAyMjQpIHsKICAgICAgICAgICAgdTAgPSAodTAgJiAxNSkgPDwgMTIgfCB1MSA8PCA2IHwgdTI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB1MCA9ICh1MCAmIDcpIDw8IDE4IHwgdTEgPDwgMTIgfCB1MiA8PCA2IHwgaGVhcFtpZHgrK10gJiA2MzsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh1MCA8IDY1NTM2KSB7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBjaCA9IHUwIC0gNjU1MzY7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgY2ggPj4gMTAsIDU2MzIwIHwgY2ggJiAxMDIzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHN0cjsKICAgIH0KICAgIGZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7CiAgICAgIHJldHVybiBwdHIgPyBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIDogIiI7CiAgICB9CiAgICBmdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsIGhlYXAsIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSB7CiAgICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKQogICAgICAgIHJldHVybiAwOwogICAgICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7CiAgICAgIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgaWYgKHUgPj0gNTUyOTYgJiYgdSA8PSA1NzM0MykgewogICAgICAgICAgdmFyIHUxID0gc3RyLmNoYXJDb2RlQXQoKytpKTsKICAgICAgICAgIHUgPSA2NTUzNiArICgodSAmIDEwMjMpIDw8IDEwKSB8IHUxICYgMTAyMzsKICAgICAgICB9CiAgICAgICAgaWYgKHUgPD0gMTI3KSB7CiAgICAgICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IHU7CiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDIwNDcpIHsKICAgICAgICAgIGlmIChvdXRJZHggKyAxID49IGVuZElkeCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDE5MiB8IHUgPj4gNjsKICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSAmIDYzOwogICAgICAgIH0gZWxzZSBpZiAodSA8PSA2NTUzNSkgewogICAgICAgICAgaWYgKG91dElkeCArIDIgPj0gZW5kSWR4KQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMjI0IHwgdSA+PiAxMjsKICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSA+PiA2ICYgNjM7CiAgICAgICAgICBoZWFwW291dElkeCsrXSA9IDEyOCB8IHUgJiA2MzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMjQwIHwgdSA+PiAxODsKICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSA+PiAxMiAmIDYzOwogICAgICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCB1ID4+IDYgJiA2MzsKICAgICAgICAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgdSAmIDYzOwogICAgICAgIH0KICAgICAgfQogICAgICBoZWFwW291dElkeF0gPSAwOwogICAgICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7CiAgICB9CiAgICBmdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgewogICAgICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTsKICAgIH0KICAgIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHsKICAgICAgdmFyIGxlbiA9IDA7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKQogICAgICAgICAgdSA9IDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApIHwgc3RyLmNoYXJDb2RlQXQoKytpKSAmIDEwMjM7CiAgICAgICAgaWYgKHUgPD0gMTI3KQogICAgICAgICAgKytsZW47CiAgICAgICAgZWxzZSBpZiAodSA8PSAyMDQ3KQogICAgICAgICAgbGVuICs9IDI7CiAgICAgICAgZWxzZSBpZiAodSA8PSA2NTUzNSkKICAgICAgICAgIGxlbiArPSAzOwogICAgICAgIGVsc2UKICAgICAgICAgIGxlbiArPSA0OwogICAgICB9CiAgICAgIHJldHVybiBsZW47CiAgICB9CiAgICB2YXIgVVRGMTZEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAidW5kZWZpbmVkIiA/IG5ldyBUZXh0RGVjb2RlcigidXRmLTE2bGUiKSA6IHZvaWQgMDsKICAgIGZ1bmN0aW9uIFVURjE2VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkgewogICAgICB2YXIgZW5kUHRyID0gcHRyOwogICAgICB2YXIgaWR4ID0gZW5kUHRyID4+IDE7CiAgICAgIHZhciBtYXhJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZCAvIDI7CiAgICAgIHdoaWxlICghKGlkeCA+PSBtYXhJZHgpICYmIEhFQVBVMTZbaWR4XSkKICAgICAgICArK2lkeDsKICAgICAgZW5kUHRyID0gaWR4IDw8IDE7CiAgICAgIGlmIChlbmRQdHIgLSBwdHIgPiAzMiAmJiBVVEYxNkRlY29kZXIpIHsKICAgICAgICByZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTguc3ViYXJyYXkocHRyLCBlbmRQdHIpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgaSA9IDA7CiAgICAgICAgdmFyIHN0ciA9ICIiOwogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICB2YXIgY29kZVVuaXQgPSBIRUFQMTZbcHRyICsgaSAqIDIgPj4gMV07CiAgICAgICAgICBpZiAoY29kZVVuaXQgPT0gMCB8fCBpID09IG1heEJ5dGVzVG9SZWFkIC8gMikKICAgICAgICAgICAgcmV0dXJuIHN0cjsKICAgICAgICAgICsraTsKICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVVbml0KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHN0cmluZ1RvVVRGMTYoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgewogICAgICBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB2b2lkIDApIHsKICAgICAgICBtYXhCeXRlc1RvV3JpdGUgPSAyMTQ3NDgzNjQ3OwogICAgICB9CiAgICAgIGlmIChtYXhCeXRlc1RvV3JpdGUgPCAyKQogICAgICAgIHJldHVybiAwOwogICAgICBtYXhCeXRlc1RvV3JpdGUgLT0gMjsKICAgICAgdmFyIHN0YXJ0UHRyID0gb3V0UHRyOwogICAgICB2YXIgbnVtQ2hhcnNUb1dyaXRlID0gbWF4Qnl0ZXNUb1dyaXRlIDwgc3RyLmxlbmd0aCAqIDIgPyBtYXhCeXRlc1RvV3JpdGUgLyAyIDogc3RyLmxlbmd0aDsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGFyc1RvV3JpdGU7ICsraSkgewogICAgICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgIEhFQVAxNltvdXRQdHIgPj4gMV0gPSBjb2RlVW5pdDsKICAgICAgICBvdXRQdHIgKz0gMjsKICAgICAgfQogICAgICBIRUFQMTZbb3V0UHRyID4+IDFdID0gMDsKICAgICAgcmV0dXJuIG91dFB0ciAtIHN0YXJ0UHRyOwogICAgfQogICAgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNihzdHIpIHsKICAgICAgcmV0dXJuIHN0ci5sZW5ndGggKiAyOwogICAgfQogICAgZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7CiAgICAgIHZhciBpID0gMDsKICAgICAgdmFyIHN0ciA9ICIiOwogICAgICB3aGlsZSAoIShpID49IG1heEJ5dGVzVG9SZWFkIC8gNCkpIHsKICAgICAgICB2YXIgdXRmMzIgPSBIRUFQMzJbcHRyICsgaSAqIDQgPj4gMl07CiAgICAgICAgaWYgKHV0ZjMyID09IDApCiAgICAgICAgICBicmVhazsKICAgICAgICArK2k7CiAgICAgICAgaWYgKHV0ZjMyID49IDY1NTM2KSB7CiAgICAgICAgICB2YXIgY2ggPSB1dGYzMiAtIDY1NTM2OwogICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCBjaCA+PiAxMCwgNTYzMjAgfCBjaCAmIDEwMjMpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBzdHI7CiAgICB9CiAgICBmdW5jdGlvbiBzdHJpbmdUb1VURjMyKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHsKICAgICAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlID0gMjE0NzQ4MzY0NzsKICAgICAgfQogICAgICBpZiAobWF4Qnl0ZXNUb1dyaXRlIDwgNCkKICAgICAgICByZXR1cm4gMDsKICAgICAgdmFyIHN0YXJ0UHRyID0gb3V0UHRyOwogICAgICB2YXIgZW5kUHRyID0gc3RhcnRQdHIgKyBtYXhCeXRlc1RvV3JpdGUgLSA0OwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgIGlmIChjb2RlVW5pdCA+PSA1NTI5NiAmJiBjb2RlVW5pdCA8PSA1NzM0MykgewogICAgICAgICAgdmFyIHRyYWlsU3Vycm9nYXRlID0gc3RyLmNoYXJDb2RlQXQoKytpKTsKICAgICAgICAgIGNvZGVVbml0ID0gNjU1MzYgKyAoKGNvZGVVbml0ICYgMTAyMykgPDwgMTApIHwgdHJhaWxTdXJyb2dhdGUgJiAxMDIzOwogICAgICAgIH0KICAgICAgICBIRUFQMzJbb3V0UHRyID4+IDJdID0gY29kZVVuaXQ7CiAgICAgICAgb3V0UHRyICs9IDQ7CiAgICAgICAgaWYgKG91dFB0ciArIDQgPiBlbmRQdHIpCiAgICAgICAgICBicmVhazsKICAgICAgfQogICAgICBIRUFQMzJbb3V0UHRyID4+IDJdID0gMDsKICAgICAgcmV0dXJuIG91dFB0ciAtIHN0YXJ0UHRyOwogICAgfQogICAgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMihzdHIpIHsKICAgICAgdmFyIGxlbiA9IDA7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgdmFyIGNvZGVVbml0ID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgaWYgKGNvZGVVbml0ID49IDU1Mjk2ICYmIGNvZGVVbml0IDw9IDU3MzQzKQogICAgICAgICAgKytpOwogICAgICAgIGxlbiArPSA0OwogICAgICB9CiAgICAgIHJldHVybiBsZW47CiAgICB9CiAgICBmdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksIGJ1ZmZlcjIpIHsKICAgICAgSEVBUDguc2V0KGFycmF5LCBidWZmZXIyKTsKICAgIH0KICAgIGZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlcjIsIGRvbnRBZGROdWxsKSB7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgSEVBUDhbYnVmZmVyMisrID4+IDBdID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgIH0KICAgICAgaWYgKCFkb250QWRkTnVsbCkKICAgICAgICBIRUFQOFtidWZmZXIyID4+IDBdID0gMDsKICAgIH0KICAgIHZhciBidWZmZXIsIEhFQVA4LCBIRUFQVTgsIEhFQVAxNiwgSEVBUFUxNiwgSEVBUDMyLCBIRUFQVTMyLCBIRUFQRjMyLCBIRUFQRjY0OwogICAgZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmKSB7CiAgICAgIGJ1ZmZlciA9IGJ1ZjsKICAgICAgTW9kdWxlMlsiSEVBUDgiXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShidWYpOwogICAgICBNb2R1bGUyWyJIRUFQMTYiXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGJ1Zik7CiAgICAgIE1vZHVsZTJbIkhFQVAzMiJdID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmKTsKICAgICAgTW9kdWxlMlsiSEVBUFU4Il0gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShidWYpOwogICAgICBNb2R1bGUyWyJIRUFQVTE2Il0gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1Zik7CiAgICAgIE1vZHVsZTJbIkhFQVBVMzIiXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmKTsKICAgICAgTW9kdWxlMlsiSEVBUEYzMiJdID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmKTsKICAgICAgTW9kdWxlMlsiSEVBUEY2NCJdID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmKTsKICAgIH0KICAgIHZhciBTVEFDS19CQVNFID0gMjIzODQsIERZTkFNSUNfQkFTRSA9IDUyNjUyNjQsIERZTkFNSUNUT1BfUFRSID0gMjIxNzY7CiAgICB2YXIgSU5JVElBTF9JTklUSUFMX01FTU9SWSA9IE1vZHVsZTJbIklOSVRJQUxfTUVNT1JZIl0gfHwgMTY3NzcyMTYwOwogICAgaWYgKE1vZHVsZTJbImJ1ZmZlciJdKSB7CiAgICAgIGJ1ZmZlciA9IE1vZHVsZTJbImJ1ZmZlciJdOwogICAgfSBlbHNlIHsKICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKElOSVRJQUxfSU5JVElBTF9NRU1PUlkpOwogICAgfQogICAgSU5JVElBTF9JTklUSUFMX01FTU9SWSA9IGJ1ZmZlci5ieXRlTGVuZ3RoOwogICAgdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmZmVyKTsKICAgIEhFQVAzMltEWU5BTUlDVE9QX1BUUiA+PiAyXSA9IERZTkFNSUNfQkFTRTsKICAgIGZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykgewogICAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHsKICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKTsKICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGNhbGxiYWNrKE1vZHVsZTIpOwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQogICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2suZnVuYzsKICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBpZiAoY2FsbGJhY2suYXJnID09PSB2b2lkIDApIHsKICAgICAgICAgICAgTW9kdWxlMlsiZHluQ2FsbF92Il0oZnVuYyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBNb2R1bGUyWyJkeW5DYWxsX3ZpIl0oZnVuYywgY2FsbGJhY2suYXJnKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgZnVuYyhjYWxsYmFjay5hcmcgPT09IHZvaWQgMCA/IG51bGwgOiBjYWxsYmFjay5hcmcpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgdmFyIF9fQVRQUkVSVU5fXyA9IFtdOwogICAgdmFyIF9fQVRJTklUX18gPSBbXTsKICAgIHZhciBfX0FUTUFJTl9fID0gW107CiAgICB2YXIgX19BVFBPU1RSVU5fXyA9IFtdOwogICAgdmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlOwogICAgdmFyIHJ1bnRpbWVFeGl0ZWQgPSBmYWxzZTsKICAgIGZ1bmN0aW9uIHByZVJ1bigpIHsKICAgICAgaWYgKE1vZHVsZTJbInByZVJ1biJdKSB7CiAgICAgICAgaWYgKHR5cGVvZiBNb2R1bGUyWyJwcmVSdW4iXSA9PSAiZnVuY3Rpb24iKQogICAgICAgICAgTW9kdWxlMlsicHJlUnVuIl0gPSBbTW9kdWxlMlsicHJlUnVuIl1dOwogICAgICAgIHdoaWxlIChNb2R1bGUyWyJwcmVSdW4iXS5sZW5ndGgpIHsKICAgICAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZTJbInByZVJ1biJdLnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pOwogICAgfQogICAgZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7CiAgICAgIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7CiAgICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pOwogICAgfQogICAgZnVuY3Rpb24gcHJlTWFpbigpIHsKICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyk7CiAgICB9CiAgICBmdW5jdGlvbiBleGl0UnVudGltZSgpIHsKICAgICAgcnVudGltZUV4aXRlZCA9IHRydWU7CiAgICB9CiAgICBmdW5jdGlvbiBwb3N0UnVuKCkgewogICAgICBpZiAoTW9kdWxlMlsicG9zdFJ1biJdKSB7CiAgICAgICAgaWYgKHR5cGVvZiBNb2R1bGUyWyJwb3N0UnVuIl0gPT0gImZ1bmN0aW9uIikKICAgICAgICAgIE1vZHVsZTJbInBvc3RSdW4iXSA9IFtNb2R1bGUyWyJwb3N0UnVuIl1dOwogICAgICAgIHdoaWxlIChNb2R1bGUyWyJwb3N0UnVuIl0ubGVuZ3RoKSB7CiAgICAgICAgICBhZGRPblBvc3RSdW4oTW9kdWxlMlsicG9zdFJ1biJdLnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTsKICAgIH0KICAgIGZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7CiAgICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTsKICAgIH0KICAgIGZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikgewogICAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpOwogICAgfQogICAgdmFyIE1hdGhfYWJzID0gTWF0aC5hYnM7CiAgICB2YXIgTWF0aF9jZWlsID0gTWF0aC5jZWlsOwogICAgdmFyIE1hdGhfZmxvb3IgPSBNYXRoLmZsb29yOwogICAgdmFyIE1hdGhfbWluID0gTWF0aC5taW47CiAgICB2YXIgcnVuRGVwZW5kZW5jaWVzID0gMDsKICAgIHZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7CiAgICB2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsKICAgIGZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHsKICAgICAgcnVuRGVwZW5kZW5jaWVzKys7CiAgICAgIGlmIChNb2R1bGUyWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0pIHsKICAgICAgICBNb2R1bGUyWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0ocnVuRGVwZW5kZW5jaWVzKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkgewogICAgICBydW5EZXBlbmRlbmNpZXMtLTsKICAgICAgaWYgKE1vZHVsZTJbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXSkgewogICAgICAgIE1vZHVsZTJbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXShydW5EZXBlbmRlbmNpZXMpOwogICAgICB9CiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPT0gMCkgewogICAgICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkgewogICAgICAgICAgY2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7CiAgICAgICAgICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7CiAgICAgICAgfQogICAgICAgIGlmIChkZXBlbmRlbmNpZXNGdWxmaWxsZWQpIHsKICAgICAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDsKICAgICAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7CiAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgTW9kdWxlMlsicHJlbG9hZGVkSW1hZ2VzIl0gPSB7fTsKICAgIE1vZHVsZTJbInByZWxvYWRlZEF1ZGlvcyJdID0ge307CiAgICBmdW5jdGlvbiBhYm9ydCh3aGF0KSB7CiAgICAgIGlmIChNb2R1bGUyWyJvbkFib3J0Il0pIHsKICAgICAgICBNb2R1bGUyWyJvbkFib3J0Il0od2hhdCk7CiAgICAgIH0KICAgICAgd2hhdCArPSAiIjsKICAgICAgb3V0KHdoYXQpOwogICAgICBlcnIod2hhdCk7CiAgICAgIEFCT1JUID0gdHJ1ZTsKICAgICAgRVhJVFNUQVRVUyA9IDE7CiAgICAgIHdoYXQgPSAiYWJvcnQoIiArIHdoYXQgKyAiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby4iOwogICAgICB0aHJvdyB3aGF0OwogICAgfQogICAgdmFyIG1lbW9yeUluaXRpYWxpemVyID0gbnVsbDsKICAgIGZ1bmN0aW9uIGhhc1ByZWZpeChzdHIsIHByZWZpeCkgewogICAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID8gc3RyLnN0YXJ0c1dpdGgocHJlZml4KSA6IHN0ci5pbmRleE9mKHByZWZpeCkgPT09IDA7CiAgICB9CiAgICB2YXIgZGF0YVVSSVByZWZpeCA9ICJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsIjsKICAgIGZ1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSkgewogICAgICByZXR1cm4gaGFzUHJlZml4KGZpbGVuYW1lLCBkYXRhVVJJUHJlZml4KTsKICAgIH0KICAgIHZhciBmaWxlVVJJUHJlZml4ID0gImZpbGU6Ly8iOwogICAgdmFyIHRlbXBEb3VibGU7CiAgICB2YXIgdGVtcEk2NDsKICAgIF9fQVRJTklUX18ucHVzaCh7CiAgICAgIGZ1bmM6IGZ1bmN0aW9uKCkgewogICAgICAgIGdsb2JhbEN0b3JzKCk7CiAgICAgIH0KICAgIH0pOwogICAgbWVtb3J5SW5pdGlhbGl6ZXIgPSAiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFBQUFBQUFBQUFBUERnME1Dd29KQ0E0QUFRTUdDZ29KRFFFQ0JBY0xDd29NQXdRRkNBd01Dd3NHQndnSkRRME1DZ29MREEwT0RnMEpDZ3NNRFE0UERnZ0pDZ3NNRFE0UEFBRUNBd1FGQmdjQkFBRUNBd1FGQmdJQkFBRUNBd1FGQXdJQkFBRUNBd1FFQXdJQkFBRUNBd1VFQXdJQkFBRUNCZ1VFQXdJQkFBRUhCZ1VFQXdJQkFNZ1BBQUFvRFFBQUVCQUFBQ0FRQUFESUR3QUFVQTBBQUJBUUFBQWdFQUFBRVFBS0FCRVJFUUFBQUFBRkFBQUFBQUFBQ1FBQUFBQUxBQUFBQUFBQUFBQVJBQThLRVJFUkF3b0hBQUVBQ1FzTEFBQUpCZ3NBQUFzQUJoRUFBQUFSRVJFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ3dBQUFBQUFBQUFBRVFBS0NoRVJFUUFLQUFBQ0FBa0xBQUFBQ1FBTEFBQUxBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0FBQUFBQUFBQUFBQUFBQXdBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUFBQUFBQUFBQUFBQUFBTkFBQUFCQTBBQUFBQUNRNEFBQUFBQUE0QUFBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFEd0FBQUFBUEFBQUFBQWtRQUFBQUFBQVFBQUFRQUFBU0FBQUFFaElTQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQklBQUFBU0VoSUFBQUFBQUFBSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTEFBQUFBQUFBQUFBQUFBQUtBQUFBQUFvQUFBQUFDUXNBQUFBQUFBc0FBQXNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFBQUFBQUFBQUFBQUFBREFBQUFBQU1BQUFBQUFrTUFBQUFBQUFNQUFBTUFBQXdNVEl6TkRVMk56ZzVRVUpEUkVWR0dSSkVPd0kvTEVjVVBUTXdDaHNHUmt0Rk53OUpEbzRYQTBBZFBHa3JOaDlLTFJ3QklDVXBJUWdNRlJZaUxoQTRQZ3MwTVJoa2RIVjJMMEVKZnprUkkwTXlRb21LaXdVRUppZ25EU29lTll3SEdraVRFNVNWQUFBQUFBQUFBQUFBU1d4c1pXZGhiQ0JpZVhSbElITmxjWFZsYm1ObEFFUnZiV0ZwYmlCbGNuSnZjZ0JTWlhOMWJIUWdibTkwSUhKbGNISmxjMlZ1ZEdGaWJHVUFUbTkwSUdFZ2RIUjVBRkJsY20xcGMzTnBiMjRnWkdWdWFXVmtBRTl3WlhKaGRHbHZiaUJ1YjNRZ2NHVnliV2wwZEdWa0FFNXZJSE4xWTJnZ1ptbHNaU0J2Y2lCa2FYSmxZM1J2Y25rQVRtOGdjM1ZqYUNCd2NtOWpaWE56QUVacGJHVWdaWGhwYzNSekFGWmhiSFZsSUhSdmJ5QnNZWEpuWlNCbWIzSWdaR0YwWVNCMGVYQmxBRTV2SUhOd1lXTmxJR3hsWm5RZ2IyNGdaR1YyYVdObEFFOTFkQ0J2WmlCdFpXMXZjbmtBVW1WemIzVnlZMlVnWW5WemVRQkpiblJsY25KMWNIUmxaQ0J6ZVhOMFpXMGdZMkZzYkFCU1pYTnZkWEpqWlNCMFpXMXdiM0poY21sc2VTQjFibUYyWVdsc1lXSnNaUUJKYm5aaGJHbGtJSE5sWldzQVEzSnZjM010WkdWMmFXTmxJR3hwYm1zQVVtVmhaQzF2Ym14NUlHWnBiR1VnYzNsemRHVnRBRVJwY21WamRHOXllU0J1YjNRZ1pXMXdkSGtBUTI5dWJtVmpkR2x2YmlCeVpYTmxkQ0JpZVNCd1pXVnlBRTl3WlhKaGRHbHZiaUIwYVcxbFpDQnZkWFFBUTI5dWJtVmpkR2x2YmlCeVpXWjFjMlZrQUVodmMzUWdhWE1nWkc5M2JnQkliM04wSUdseklIVnVjbVZoWTJoaFlteGxBRUZrWkhKbGMzTWdhVzRnZFhObEFFSnliMnRsYmlCd2FYQmxBRWt2VHlCbGNuSnZjZ0JPYnlCemRXTm9JR1JsZG1salpTQnZjaUJoWkdSeVpYTnpBRUpzYjJOcklHUmxkbWxqWlNCeVpYRjFhWEpsWkFCT2J5QnpkV05vSUdSbGRtbGpaUUJPYjNRZ1lTQmthWEpsWTNSdmNua0FTWE1nWVNCa2FYSmxZM1J2Y25rQVZHVjRkQ0JtYVd4bElHSjFjM2tBUlhobFl5Qm1iM0p0WVhRZ1pYSnliM0lBU1c1MllXeHBaQ0JoY21kMWJXVnVkQUJCY21kMWJXVnVkQ0JzYVhOMElIUnZieUJzYjI1bkFGTjViV0p2YkdsaklHeHBibXNnYkc5dmNBQkdhV3hsYm1GdFpTQjBiMjhnYkc5dVp3QlViMjhnYldGdWVTQnZjR1Z1SUdacGJHVnpJR2x1SUhONWMzUmxiUUJPYnlCbWFXeGxJR1JsYzJOeWFYQjBiM0p6SUdGMllXbHNZV0pzWlFCQ1lXUWdabWxzWlNCa1pYTmpjbWx3ZEc5eUFFNXZJR05vYVd4a0lIQnliMk5sYzNNQVFtRmtJR0ZrWkhKbGMzTUFSbWxzWlNCMGIyOGdiR0Z5WjJVQVZHOXZJRzFoYm5rZ2JHbHVhM01BVG04Z2JHOWphM01nWVhaaGFXeGhZbXhsQUZKbGMyOTFjbU5sSUdSbFlXUnNiMk5ySUhkdmRXeGtJRzlqWTNWeUFGTjBZWFJsSUc1dmRDQnlaV052ZG1WeVlXSnNaUUJRY21WMmFXOTFjeUJ2ZDI1bGNpQmthV1ZrQUU5d1pYSmhkR2x2YmlCallXNWpaV3hsWkFCR2RXNWpkR2x2YmlCdWIzUWdhVzF3YkdWdFpXNTBaV1FBVG04Z2JXVnpjMkZuWlNCdlppQmtaWE5wY21Wa0lIUjVjR1VBU1dSbGJuUnBabWxsY2lCeVpXMXZkbVZrQUVSbGRtbGpaU0J1YjNRZ1lTQnpkSEpsWVcwQVRtOGdaR0YwWVNCaGRtRnBiR0ZpYkdVQVJHVjJhV05sSUhScGJXVnZkWFFBVDNWMElHOW1JSE4wY21WaGJYTWdjbVZ6YjNWeVkyVnpBRXhwYm1zZ2FHRnpJR0psWlc0Z2MyVjJaWEpsWkFCUWNtOTBiMk52YkNCbGNuSnZjZ0JDWVdRZ2JXVnpjMkZuWlFCR2FXeGxJR1JsYzJOeWFYQjBiM0lnYVc0Z1ltRmtJSE4wWVhSbEFFNXZkQ0JoSUhOdlkydGxkQUJFWlhOMGFXNWhkR2x2YmlCaFpHUnlaWE56SUhKbGNYVnBjbVZrQUUxbGMzTmhaMlVnZEc5dklHeGhjbWRsQUZCeWIzUnZZMjlzSUhkeWIyNW5JSFI1Y0dVZ1ptOXlJSE52WTJ0bGRBQlFjbTkwYjJOdmJDQnViM1FnWVhaaGFXeGhZbXhsQUZCeWIzUnZZMjlzSUc1dmRDQnpkWEJ3YjNKMFpXUUFVMjlqYTJWMElIUjVjR1VnYm05MElITjFjSEJ2Y25SbFpBQk9iM1FnYzNWd2NHOXlkR1ZrQUZCeWIzUnZZMjlzSUdaaGJXbHNlU0J1YjNRZ2MzVndjRzl5ZEdWa0FFRmtaSEpsYzNNZ1ptRnRhV3g1SUc1dmRDQnpkWEJ3YjNKMFpXUWdZbmtnY0hKdmRHOWpiMndBUVdSa2NtVnpjeUJ1YjNRZ1lYWmhhV3hoWW14bEFFNWxkSGR2Y21zZ2FYTWdaRzkzYmdCT1pYUjNiM0pySUhWdWNtVmhZMmhoWW14bEFFTnZibTVsWTNScGIyNGdjbVZ6WlhRZ1lua2dibVYwZDI5eWF3QkRiMjV1WldOMGFXOXVJR0ZpYjNKMFpXUUFUbThnWW5WbVptVnlJSE53WVdObElHRjJZV2xzWVdKc1pRQlRiMk5yWlhRZ2FYTWdZMjl1Ym1WamRHVmtBRk52WTJ0bGRDQnViM1FnWTI5dWJtVmpkR1ZrQUVOaGJtNXZkQ0J6Wlc1a0lHRm1kR1Z5SUhOdlkydGxkQ0J6YUhWMFpHOTNiZ0JQY0dWeVlYUnBiMjRnWVd4eVpXRmtlU0JwYmlCd2NtOW5jbVZ6Y3dCUGNHVnlZWFJwYjI0Z2FXNGdjSEp2WjNKbGMzTUFVM1JoYkdVZ1ptbHNaU0JvWVc1a2JHVUFVbVZ0YjNSbElFa3ZUeUJsY25KdmNnQlJkVzkwWVNCbGVHTmxaV1JsWkFCT2J5QnRaV1JwZFcwZ1ptOTFibVFBVjNKdmJtY2diV1ZrYVhWdElIUjVjR1VBVG04Z1pYSnliM0lnYVc1bWIzSnRZWFJwYjI0QUFBQUFBQURnRmdBQW1SZ0FBR0FRQUFBQUFBQUE0QllBQUVJWkFBQmdFQUFBQUFBQUFPQVdBQUFxR2dBQVNBOEFBQUFBQUFDNEZnQUFOQnNBQU9BV0FBQ2ZHZ0FBTUFvQUFBQUFBQURnRmdBQWFSc0FBRWdQQUFBQUFBQUE0QllBQUlvYkFBQklEd0FBQUFBQUFMZ1dBQUFQSEFBQTRCWUFBSHdjQUFCSUR3QUFBQUFBQU9BV0FBQ1ZIQUFBU0E4QUFBQUFBQURnRmdBQUhoMEFBRWdQQUFBQUFBQUE0QllBQUhjZEFBQklEd0FBQUFBQUFPQVdBQUNRSFFBQVNBOEFBQUFBQUFEZ0ZnQUFRaDRBQUVnUEFBQUFBQUFBNEJZQUFJY2VBQUJnRUFBQUFBQUFBT0FXQUFDa0h3QUFTQThBQUFBQUFBQzRGZ0FBWnlBQUFPQVdBQURrSHdBQThBb0FBQUFBQUFEZ0ZnQUFqeUFBQUdBUUFBQUFBQUFBdUJZQUFNTWlBQURnRmdBQUFpSUFBQmdMQUFBQUFBQUE0QllBQU9FaUFBQmdFQUFBQUFBQUFPQVdBQURRSkFBQUdBc0FBQUFBQUFEZ0ZnQUFrU1VBQUdBUUFBQUFBQUFBNEJZQUFJQW5BQUFZQ3dBQUFBQUFBT0FXQUFBOUtBQUFZQkFBQUFBQUFBRGdGZ0FBSkNvQUFCZ0xBQUFBQUFBQTRCWUFBT2txQUFCZ0VBQUFBQUFBQU9BV0FBRGdMQUFBOEFvQUFBQUFBQURnRmdBQXVpMEFBR0FRQUFBQUFBQUE0QllBQU5zdkFBRHdDZ0FBQUFBQUFPQVdBQURUTUFBQVlCQUFBQUFBQUFEZ0ZnQUFNRE1BQVBBS0FBQUFBQUFBNEJZQUFDUTBBQUJnRUFBQUFBQUFBT0FXQUFCNU5nQUE4QW9BQUFBQUFBRGdGZ0FBaXpjQUFHQVFBQUFBQUFBQTRCWUFBQnc2QUFCZ0VBQUFBQUFBQU9BV0FBQ2RPZ0FBWUJBQUFBQUFBQURnRmdBQVhqc0FBUEFLQUFBQUFBQUE0QllBQUxVN0FBQmdFQUFBQUFBQUFPQVdBQURNUEFBQUdBc0FBQUFBQUFEZ0ZnQUFUejBBQUdBUUFBQUFBQUFBNEJZQUFMNCtBQUFZQ3dBQUFBQUFBT0FXQUFCQlB3QUFZQkFBQUFBQUFBRGdGZ0FBc0VBQUFCZ0xBQUFBQUFBQTRCWUFBRE5CQUFCZ0VBQUFBQUFBQU9BV0FBQ2lRZ0FBR0FzQUFBQUFBQURnRmdBQUpVTUFBR0FRQUFBQUFBQUE0QllBQUpSRUFBQVlDd0FBQUFBQUFPQVdBQUFYUlFBQVlCQUFBQUFBQUFEZ0ZnQUFoa1lBQUJnTEFBQUFBQUFBNEJZQUFBbEhBQUJnRUFBQUFBQUFBTGdXQUFCNFNBQUFpQmNBQUlCSUFBQUFBQUFBSUEwQUFJZ1hBQUNKU0FBQUFRQUFBQ0FOQUFDNEZnQUFxa2dBQUlnWEFBQzZTQUFBQUFBQUFFZ05BQUNJRndBQXkwZ0FBQUVBQUFCSURRQUF1QllBQUJoTUFBQzRGZ0FBTjB3QUFMZ1dBQUJXVEFBQXVCWUFBSFZNQUFDNEZnQUFsRXdBQUxnV0FBQ3pUQUFBdUJZQUFOSk1BQUM0RmdBQThVd0FBTGdXQUFBUVRRQUF1QllBQUM5TkFBQzRGZ0FBVGswQUFMZ1dBQUJ0VFFBQXVCWUFBSXhOQUFDa0Z3QUFuMDBBQUFBQUFBQUJBQUFBOEEwQUFBQUFBQUM0RmdBQTRVMEFBS1FYQUFBSFRnQUFBQUFBQUFFQUFBRHdEUUFBQUFBQUFLUVhBQUJKVGdBQUFBQUFBQUVBQUFEd0RRQUFBQUFBQUtRWEFBQ0lUZ0FBQUFBQUFBRUFBQUR3RFFBQUFBQUFBS1FYQUFESFRnQUFBQUFBQUFFQUFBRHdEUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUC8vLy8vL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFMZ1dBQUROVHdBQTRCWUFBQzFRQUFBQUR3QUFBQUFBQU9BV0FBRGFUd0FBRUE4QUFBQUFBQUM0RmdBQSswOEFBT0FXQUFBSVVBQUE4QTRBQUFBQUFBRGdGZ0FBaGxBQUFPZ09BQUFBQUFBQTRCWUFBSk5RQUFEb0RnQUFBQUFBQU9BV0FBQ2pVQUFBNkE0QUFBQUFBQURnRmdBQXRWQUFBRGdQQUFBQUFBQUE0QllBQU1aUUFBQTREd0FBQUFBQUFPQVdBQURYVUFBQUFBOEFBQUFBQUFEZ0ZnQUErVkFBQUhnUEFBQUFBQUFBNEJZQUFCMVJBQUFBRHdBQUFBQUFBT0FXQUFCQ1VRQUFlQThBQUFBQUFBRGdGZ0FBamxFQUFBQVBBQUFBQUFBQWJCY0FBTFpSQUFCc0Z3QUF1RkVBQUd3WEFBQzdVUUFBYkJjQUFMMVJBQUJzRndBQXYxRUFBR3dYQUFEQlVRQUFiQmNBQU1OUkFBQnNGd0FBeFZFQUFHd1hBQURIVVFBQWJCY0FBTWxSQUFCc0Z3QUF5MUVBQUd3WEFBRE5VUUFBYkJjQUFNOVJBQUJzRndBQTBWRUFBT0FXQUFEVFVRQUE4QTRBQUFBQUFBRGdGZ0FBUmxJQUFPZ09BQUFBQUFBQXVCWUFBR0pTQUFDa0Z3QUFlMUlBQUFBQUFBQUJBQUFBV0JBQUFBQUFBQURnRmdBQTlGSUFBSWdRQUFBQUFBQUE0QllBQUJkVEFBQ1lFQUFBQUFBQUFMZ1dBQUF1VXdBQTRCWUFBSEJUQUFDSUVBQUFBQUFBQU9BV0FBQ1NVd0FBU0E4QUFBQUFBQUFBQUFBQUFBb0FBQUVBQUFBQ0FBQUFBd0FBQUFFQUFBQUVBQUFBQUFBQUFCQUtBQUFCQUFBQUJRQUFBQVlBQUFBQ0FBQUFCd0FBQUFBQUFBQWdDZ0FBQ0FBQUFBa0FBQUFCQUFBQUFBQUFBRGdLQUFBS0FBQUFDd0FBQUFJQUFBQUJBQUFBREFBQUFBMEFBQUFDQUFBQUF3QUFBQU1BQUFBQUFBQUFTQW9BQUFnQUFBQU9BQUFBQVFBQUFBQUFBQUJZQ2dBQUNBQUFBQThBQUFBQkFBQUFBQUFBQUlBS0FBQUlBQUFBRUFBQUFBRUFBQUFBQUFBQWNBb0FBQWdBQUFBUkFBQUFBUUFBQUFBQUFBQ1FDZ0FBQ0FBQUFCSUFBQUFCQUFBQUFBQUFBS0FLQUFBSUFBQUFFd0FBQUFFQUFBQUFBQUFBc0FvQUFBZ0FBQUFVQUFBQUFRQUFBQUFBQUFEQUNnQUFDQUFBQUJVQUFBQUJBQUFBQUFBQUFOQUtBQUFCQUFBQUZnQUFBQmNBQUFBRUFBQUFHQUFBQUFBQUFBRGdDZ0FBQ0FBQUFCa0FBQUFCQUFBQUFBQUFBUGdLQUFBRkFBQUFHZ0FBQUJzQUFBQUFBQUFBOEFvQUFBRUFBQUFjQUFBQUhRQUFBQUFBQUFBSUN3QUFBUUFBQUI0QUFBQWZBQUFBQmdBQUFDQUFBQUFBQUFBQUlBc0FBQ0VBQUFBaUFBQUFCd0FBQUFnQUFBQUFBQUFBR0FzQUFDTUFBQUFrQUFBQUJ3QUFBQWtBQUFBQUFBQUFNQXNBQUFFQUFBQWxBQUFBSmdBQUFBb0FBQUFuQUFBQUFBQUFBRUFMQUFBb0FBQUFLUUFBQUFjQUFBQUxBQUFBQUFBQUFGQUxBQUFCQUFBQUtnQUFBQ3NBQUFBTUFBQUFMQUFBQUFBQUFBQmdDd0FBTFFBQUFDNEFBQUFIQUFBQURRQUFBQUFBQUFCd0N3QUFBUUFBQUM4QUFBQXdBQUFBRGdBQUFERUFBQUFBQUFBQWdBc0FBRElBQUFBekFBQUFCd0FBQUE4QUFBQUFBQUFBa0FzQUFBRUFBQUEwQUFBQU5RQUFBQkFBQUFBMkFBQUFBQUFBQUtBTEFBQVJBQUFBTndBQUFEZ0FBQUFBQUFBQXNBc0FBQUVBQUFBNUFBQUFPZ0FBQUJJQUFBQTdBQUFBQUFBQUFNQUxBQUFUQUFBQVBBQUFBRDBBQUFBQUFBQUEwQXNBQUFFQUFBQStBQUFBUHdBQUFCUUFBQUJBQUFBQUFBQUFBT0FMQUFBVkFBQUFRUUFBQUVJQUFBQUFBQUFBOEFzQUFBRUFBQUJEQUFBQVJBQUFBQllBQUFCRkFBQUFBQUFBQUFBTUFBQVhBQUFBUmdBQUFFY0FBQUFBQUFBQUVBd0FBQUVBQUFCSUFBQUFTUUFBQUJnQUFBQktBQUFBQUFBQUFDQU1BQUFCQUFBQVN3QUFBRXdBQUFBWkFBQUFUUUFBQUFBQUFBQXdEQUFBQVFBQUFFNEFBQUJQQUFBQUdnQUFBRkFBQUFBQUFBQUFRQXdBQUJzQUFBQlJBQUFBVWdBQUFBQUFBQUJRREFBQUFRQUFBRk1BQUFCVUFBQUFIQUFBQUZVQUFBQUFBQUFBWUF3QUFGWUFBQUJYQUFBQUJ3QUFBQjBBQUFBQUFBQUFjQXdBQUFFQUFBQllBQUFBV1FBQUFCNEFBQUJhQUFBQUFBQUFBSUFNQUFCYkFBQUFYQUFBQUFjQUFBQWZBQUFBQUFBQUFKQU1BQUFCQUFBQVhRQUFBRjRBQUFBZ0FBQUFYd0FBQUFBQUFBQ2dEQUFBWUFBQUFHRUFBQUFIQUFBQUlRQUFBQUFBQUFDd0RBQUFBUUFBQUdJQUFBQmpBQUFBSWdBQUFHUUFBQUFBQUFBQXdBd0FBR1VBQUFCbUFBQUFCd0FBQUNNQUFBQUFBQUFBMEF3QUFBRUFBQUJuQUFBQWFBQUFBQ1FBQUFCcEFBQUFBQUFBQU9BTUFBQnFBQUFBYXdBQUFBY0FBQUFsQUFBQUFBQUFBUEFNQUFBQkFBQUFiQUFBQUcwQUFBQW1BQUFBYmdBQUFBQUFBQUFBRFFBQWJ3QUFBSEFBQUFBSEFBQUFKd0FBQUFBQUFBQVFEUUFBQVFBQUFIRUFBQUJ5QUFBQUtBQUFBSE1BQUFBb0RRQUF5QThBQUNnTkFBQUlFQUFBRUJBQUFDZ05BQUJRRFFBQXlBOEFBRkFOQUFBZ0VBQUF5QThBQUZBTkFBQUlFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQnNWQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEd0RnQUFkQUFBQUhVQUFBQjJBQUFBZHdBQUFBSUFBQUFCQUFBQUFRQUFBQUVBQUFBQUFBQUFHQThBQUhRQUFBQjRBQUFBZGdBQUFIY0FBQUFDQUFBQUFnQUFBQUlBQUFBQ0FBQUFBQUFBQUNnUEFBQjVBQUFBZWdBQUFBUUFBQUFBQUFBQU9BOEFBSHNBQUFCOEFBQUFCUUFBQUFBQUFBQklEd0FBQ0FBQUFIMEFBQUFCQUFBQUFBQUFBRmdQQUFCN0FBQUFmZ0FBQUFVQUFBQUFBQUFBYUE4QUFIc0FBQUIvQUFBQUJRQUFBQUFBQUFDNER3QUFkQUFBQUlBQUFBQjJBQUFBZHdBQUFBTUFBQUFBQUFBQWlBOEFBSFFBQUFDQkFBQUFkZ0FBQUhjQUFBQUVBQUFBQUFBQUFEZ1FBQUIwQUFBQWdnQUFBSFlBQUFCM0FBQUFBZ0FBQUFNQUFBQURBQUFBQXdBQUFBQUFBQUJJRUFBQWd3QUFBSVFBQUFBR0FBQUFBQUFBQUhnUUFBQ0ZBQUFBaGdBQUFBY0FBQUFCQUFBQUJRQUFBQVlBQUFBQ0FBQUFBQUFBQUtBUUFBQ0ZBQUFBaHdBQUFBZ0FBQUFEQUFBQUJRQUFBQVlBQUFBRUFBQUE0QmNBQUFRWUFBQUFBQUFBc0JBQUFJZ0FBQUNKQUFBQUFRQUFBRXhCVTFwcGNBQnZjR1Z1QUdkbGRGQnZhVzUwQUdkbGRFTnZkVzUwQUVSNWJtRnRhV05NUVZOYWFYQUFZV1JrUm1sbGJHUkdiRzloZEdsdVp3QmhaR1JHYVdWc1pGTnBaMjVsWkFCaFpHUkdhV1ZzWkZWdWMybG5ibVZrQUU1VGRETmZYekl5TUY5ZmMyaGhjbVZrWDNCMGNsOXdiMmx1ZEdWeVNWQk9ObXhoYzNwcGNEZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlU1VFh6RTBaR1ZtWVhWc2RGOWtaV3hsZEdWSlV6TmZSVVZPVTE4NVlXeHNiMk5oZEc5eVNWTXpYMFZGUlVVQVRsTjBNMTlmTWpFMFpHVm1ZWFZzZEY5a1pXeGxkR1ZKVGpac1lYTjZhWEEzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSUUJPVTNRelgxOHlNakJmWDNOb1lYSmxaRjl3ZEhKZmNHOXBiblJsY2tsUVRqWnNZWE42YVhBeWFXODJjbVZoWkdWeU1UQmlZWE5wWTE5bWFXeGxTVTVUTVY4M2MzUnlaV0Z0Y3pFemJXVnRiM0o1WDNOMGNtVmhiVVZGUlU1VFh6RTBaR1ZtWVhWc2RGOWtaV3hsZEdWSlV6ZGZSVVZPVTE4NVlXeHNiMk5oZEc5eVNWTTNYMFZGUlVVQVRsTjBNMTlmTWpFMFpHVm1ZWFZzZEY5a1pXeGxkR1ZKVGpac1lYTjZhWEF5YVc4MmNtVmhaR1Z5TVRCaVlYTnBZMTltYVd4bFNVNVRNVjgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGQUV4QlUwWUFUalpzWVhONmFYQXhNMmx1ZG1Gc2FXUmZiV0ZuYVdORkFHRnNiRzlqWVhSdmNqeFVQam82WVd4c2IyTmhkR1VvYzJsNlpWOTBJRzRwSUNkdUp5QmxlR05sWldSeklHMWhlR2x0ZFcwZ2MzVndjRzl5ZEdWa0lITnBlbVVBUm1sc1pTQnRZV2RwWXlCcGN5QnViM1FnZG1Gc2FXUUFUbE4wTTE5Zk1qRXdYMTltZFc1amRHbHZialpmWDJaMWJtTkpXazQyYkdGemVtbHdNbWx2Tm5KbFlXUmxjakV3WW1GemFXTmZabWxzWlVsT1V6SmZOM04wY21WaGJYTXhNMjFsYlc5eWVWOXpkSEpsWVcxRlJURXhYM1poYkdsa1lYUnZjbk5GZGtWVmJGSk9Vek5mTm1obFlXUmxja1ZGWDA1VFh6bGhiR3h2WTJGMGIzSkpVMEpmUlVWR2RsTkJYMFZGUlFCT1UzUXpYMTh5TVRCZlgyWjFibU4wYVc5dU5sOWZZbUZ6WlVsR2RsSk9ObXhoYzNwcGNESnBielpvWldGa1pYSkZSVVZGQUU0MmJHRnplbWx3TWpGdmJHUmZjM1I1YkdWZlkyOXRjSEpsYzNOcGIyNUZBRTQyYkdGemVtbHdNVFJ1YjNSZlkyOXRjSEpsYzNObFpFVUFWR2hsSUdacGJHVWdjMlZsYlhNZ2RHOGdhR0YyWlNCdmJHUWdjM1I1YkdVZ1kyOXRjSEpsYzNOcGIyNGdkMmhwWTJnZ2FYTWdibTkwSUhOMWNIQnZjblJsWkFCVWFHVWdabWxzWlNCa2IyVnpiaWQwSUhObFpXMGdkRzhnWW1VZ1kyOXRjSEpsYzNObFpBQmFUalpzWVhONmFYQXlhVzgyY21WaFpHVnlNVEJpWVhOcFkxOW1hV3hsU1U1VFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVVeE1WOTJZV3hwWkdGMGIzSnpSWFpGVld4U1RsTXdYelpvWldGa1pYSkZSVjhBYkdGemVtbHdJR1Z1WTI5a1pXUUFUalpzWVhONmFYQXhNMjV2WDJ4aGMzcHBjRjkyYkhKRkFFNDJiR0Z6ZW1sd01qVnNZWE42YVhCZlptOXliV0YwWDNWdWMzVndjRzl5ZEdWa1JRQlBibXg1SUV4QlUzcHBjQ0JRVDBsT1ZGZEpVMFVnUTBoVlRrdEZSQ0JrWldOdmJYQnlaWE56YjNJZ2FYTWdjM1Z3Y0c5eWRHVmtBRTV2SUV4QlUzcHBjQ0JXVEZJZ2QyRnpJR1p2ZFc1a0lHbHVJSFJvWlNCV1RGSnpJSE5sWTNScGIyNEFUalpzWVhONmFYQXlNbU5vZFc1clgzUmhZbXhsWDNKbFlXUmZaWEp5YjNKRkFFTm9kVzVySUhSaFlteGxJRzltWm5ObGRDQTlQU0F0TVNCcGN5QnViM1FnYzNWd2NHOXlkR1ZrSUdGMElIUm9hWE1nZEdsdFpRQk9ObXhoYzNwcGNERXpibTkwWDNOMWNIQnZjblJsWkVVQVRqWnNZWE42YVhBeU5uVnVhMjV2ZDI1ZlkyaDFibXRmZEdGaWJHVmZabTl5YldGMFJRQmphSFZ1YTE5emFYcGxJRDA5SUhWcGJuUXViV0Y0SUdseklHNXZkQ0J6ZFhCd2IzSjBaV1FnWVhRZ2RHaHBjeUIwYVcxbExnQlVhR1Z5WlNCM1lYTWdZU0J3Y205aWJHVnRJSEpsWVdScGJtY2dkR2hsSUdOb2RXNXJJSFJoWW14bEFGUm9aU0JqYUhWdWF5QjBZV0pzWlNCMlpYSnphVzl1SUc1MWJXSmxjaUJwY3lCMWJtdHViM2R1QUU0MmJHRnplbWx3TVRGbGJtUmZiMlpmWm1sc1pVVUFVbVZoWTJobFpDQkZibVFnYjJZZ1ptbHNaUUJKYm5aaGJHbGtJRzUxYldKbGNpQnZaaUJ6ZVcxaWIyeHpBRTVUZEROZlh6SXlNRjlmYzJoaGNtVmtYM0IwY2w5d2IybHVkR1Z5U1ZCT05teGhjM3BwY0Roa1pXTnZaR1Z5Y3pFd1lYSnBkR2h0WlhScFkwbE9VekZmTW1sdk1UaGZYMmxtYzNSeVpXRnRYM2R5WVhCd1pYSkpUbE14WHpkemRISmxZVzF6TVROdFpXMXZjbmxmYzNSeVpXRnRSVVZGUlVWT1UxOHhOR1JsWm1GMWJIUmZaR1ZzWlhSbFNWTTVYMFZGVGxOZk9XRnNiRzlqWVhSdmNrbFRPVjlGUlVWRkFFNVRkRE5mWHpJeE5HUmxabUYxYkhSZlpHVnNaWFJsU1U0MmJHRnplbWx3T0dSbFkyOWtaWEp6TVRCaGNtbDBhRzFsZEdsalNVNVRNVjh5YVc4eE9GOWZhV1p6ZEhKbFlXMWZkM0poY0hCbGNrbE9VekZmTjNOMGNtVmhiWE14TTIxbGJXOXllVjl6ZEhKbFlXMUZSVVZGUlVWRkFFNDJiR0Z6ZW1sd01UbDFibXR1YjNkdVgzTmphR1Z0WVY5MGVYQmxSUUJVYUdVZ1RFRmFJSE5qYUdWdFlTQnBjeUJ1YjNRZ2NtVmpiMmR1YVhwbFpBQk9ObXhoYzNwcGNEZG1iM0p0WVhSek1qWmtlVzVoYldsalgyWnBaV3hrWDJSbFkyOXRjSEpsYzNOdmNrbE9VMTg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTmZNbWx2TVRoZlgybG1jM1J5WldGdFgzZHlZWEJ3WlhKSlRsTmZOM04wY21WaGJYTXhNMjFsYlc5eWVWOXpkSEpsWVcxRlJVVkZSVVZGQUU0MmJHRnplbWx3TjJadmNtMWhkSE15TUdSNWJtRnRhV05mWkdWamIyMXdjbVZ6YzI5eVJRQk9VM1F6WDE4eU1qQmZYM05vWVhKbFpGOXdkSEpmY0c5cGJuUmxja2xRVGpac1lYTjZhWEEzWm05eWJXRjBjekkyWkhsdVlXMXBZMTltYVdWc1pGOWtaV052YlhCeVpYTnpiM0pKVGxNeFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGxPVXpGZk1tbHZNVGhmWDJsbWMzUnlaV0Z0WDNkeVlYQndaWEpKVGxNeFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVWRlJVVkZSVTVUWHpFMFpHVm1ZWFZzZEY5a1pXeGxkR1ZKVTBOZlJVVk9VMTg1WVd4c2IyTmhkRzl5U1ZORFgwVkZSVVVBVGxOME0xOWZNakUwWkdWbVlYVnNkRjlrWld4bGRHVkpUalpzWVhONmFYQTNabTl5YldGMGN6STJaSGx1WVcxcFkxOW1hV1ZzWkY5a1pXTnZiWEJ5WlhOemIzSkpUbE14WHpoa1pXTnZaR1Z5Y3pFd1lYSnBkR2h0WlhScFkwbE9VekZmTW1sdk1UaGZYMmxtYzNSeVpXRnRYM2R5WVhCd1pYSkpUbE14WHpkemRISmxZVzF6TVROdFpXMXZjbmxmYzNSeVpXRnRSVVZGUlVWRlJVVkZBRTQyYkdGemVtbHdOMlp2Y20xaGRITXlObVI1Ym1GdGFXTmZaR1ZqYjIxd2NtVnpjMjl5WDJacFpXeGtTVTVUWHpoa1pXTnZaR1Z5Y3pFd1lYSnBkR2h0WlhScFkwbE9VMTh5YVc4eE9GOWZhV1p6ZEhKbFlXMWZkM0poY0hCbGNrbE9VMTgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGVGxNd1h6Vm1hV1ZzWkVsT1V6QmZNMnhoY3pkd2IybHVkREV3UlU1VE1GOHlNSE4wWVc1a1lYSmtYMlJwWm1aZmJXVjBhRzlrU1ZORFgwVkZSVVZGUlFCT05teGhjM3BwY0RkbWIzSnRZWFJ6TVRCaVlYTmxYMlpwWld4a1JRQk9VM1F6WDE4eU1qQmZYM05vWVhKbFpGOXdkSEpmY0c5cGJuUmxja2xRVGpac1lYTjZhWEEzWm05eWJXRjBjekkyWkhsdVlXMXBZMTlrWldOdmJYQnlaWE56YjNKZlptbGxiR1JKVGxNeFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGxPVXpGZk1tbHZNVGhmWDJsbWMzUnlaV0Z0WDNkeVlYQndaWEpKVGxNeFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVWRlJVVk9VekpmTldacFpXeGtTVTVUTWw4emJHRnpOM0J2YVc1ME1UQkZUbE15WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpVMFZmUlVWRlJVVkZUbE5mTVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxUU1Y5RlJVNVRYemxoYkd4dlkyRjBiM0pKVTBsZlJVVkZSUUJPVTNRelgxOHlNVFJrWldaaGRXeDBYMlJsYkdWMFpVbE9ObXhoYzNwcGNEZG1iM0p0WVhSek1qWmtlVzVoYldsalgyUmxZMjl0Y0hKbGMzTnZjbDltYVdWc1pFbE9VekZmT0dSbFkyOWtaWEp6TVRCaGNtbDBhRzFsZEdsalNVNVRNVjh5YVc4eE9GOWZhV1p6ZEhKbFlXMWZkM0poY0hCbGNrbE9VekZmTjNOMGNtVmhiWE14TTIxbGJXOXllVjl6ZEhKbFlXMUZSVVZGUlU1VE1sODFabWxsYkdSSlRsTXlYek5zWVhNM2NHOXBiblF4TUVWT1V6SmZNakJ6ZEdGdVpHRnlaRjlrYVdabVgyMWxkR2h2WkVsVFJWOUZSVVZGUlVWRlJRQk9ObXhoYzNwcGNEZG1iM0p0WVhSek1qWmtlVzVoYldsalgyUmxZMjl0Y0hKbGMzTnZjbDltYVdWc1pFbE9VMTg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTmZNbWx2TVRoZlgybG1jM1J5WldGdFgzZHlZWEJ3WlhKSlRsTmZOM04wY21WaGJYTXhNMjFsYlc5eWVWOXpkSEpsWVcxRlJVVkZSVTVUTUY4MVptbGxiR1JKVGxNd1h6TnNZWE0zWjNCemRHbHRaVVZPVXpCZk1qQnpkR0Z1WkdGeVpGOWthV1ptWDIxbGRHaHZaRWxUUTE5RlJVVkZSVVVBVGxOME0xOWZNakl3WDE5emFHRnlaV1JmY0hSeVgzQnZhVzUwWlhKSlVFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTXhYekpwYnpFNFgxOXBabk4wY21WaGJWOTNjbUZ3Y0dWeVNVNVRNVjgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGVGxNeVh6Vm1hV1ZzWkVsT1V6SmZNMnhoY3pkbmNITjBhVzFsUlU1VE1sOHlNSE4wWVc1a1lYSmtYMlJwWm1aZmJXVjBhRzlrU1ZORlgwVkZSVVZGUlU1VFh6RTBaR1ZtWVhWc2RGOWtaV3hsZEdWSlUwbGZSVVZPVTE4NVlXeHNiMk5oZEc5eVNWTkpYMFZGUlVVQVRsTjBNMTlmTWpFMFpHVm1ZWFZzZEY5a1pXeGxkR1ZKVGpac1lYTjZhWEEzWm05eWJXRjBjekkyWkhsdVlXMXBZMTlrWldOdmJYQnlaWE56YjNKZlptbGxiR1JKVGxNeFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGxPVXpGZk1tbHZNVGhmWDJsbWMzUnlaV0Z0WDNkeVlYQndaWEpKVGxNeFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVWRlJVVk9VekpmTldacFpXeGtTVTVUTWw4emJHRnpOMmR3YzNScGJXVkZUbE15WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpVMFZmUlVWRlJVVkZSVVVBVGpac1lYTjZhWEEzWm05eWJXRjBjekkyWkhsdVlXMXBZMTlrWldOdmJYQnlaWE56YjNKZlptbGxiR1JKVGxOZk9HUmxZMjlrWlhKek1UQmhjbWwwYUcxbGRHbGpTVTVUWHpKcGJ6RTRYMTlwWm5OMGNtVmhiVjkzY21Gd2NHVnlTVTVUWHpkemRISmxZVzF6TVROdFpXMXZjbmxmYzNSeVpXRnRSVVZGUlVWT1V6QmZOV1pwWld4a1NVNVRNRjh6YkdGek0zSm5Za1ZPVXpCZk1qQnpkR0Z1WkdGeVpGOWthV1ptWDIxbGRHaHZaRWxUUTE5RlJVVkZSVVVBVGxOME0xOWZNakl3WDE5emFHRnlaV1JmY0hSeVgzQnZhVzUwWlhKSlVFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTXhYekpwYnpFNFgxOXBabk4wY21WaGJWOTNjbUZ3Y0dWeVNVNVRNVjgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGVGxNeVh6Vm1hV1ZzWkVsT1V6SmZNMnhoY3pOeVoySkZUbE15WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpVMFZmUlVWRlJVVkZUbE5mTVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxUU1Y5RlJVNVRYemxoYkd4dlkyRjBiM0pKVTBsZlJVVkZSUUJPVTNRelgxOHlNVFJrWldaaGRXeDBYMlJsYkdWMFpVbE9ObXhoYzNwcGNEZG1iM0p0WVhSek1qWmtlVzVoYldsalgyUmxZMjl0Y0hKbGMzTnZjbDltYVdWc1pFbE9VekZmT0dSbFkyOWtaWEp6TVRCaGNtbDBhRzFsZEdsalNVNVRNVjh5YVc4eE9GOWZhV1p6ZEhKbFlXMWZkM0poY0hCbGNrbE9VekZmTjNOMGNtVmhiWE14TTIxbGJXOXllVjl6ZEhKbFlXMUZSVVZGUlU1VE1sODFabWxsYkdSSlRsTXlYek5zWVhNemNtZGlSVTVUTWw4eU1ITjBZVzVrWVhKa1gyUnBabVpmYldWMGFHOWtTVk5GWDBWRlJVVkZSVVZGQUU0MmJHRnplbWx3TjJadmNtMWhkSE15Tm1SNWJtRnRhV05mWkdWamIyMXdjbVZ6YzI5eVgyWnBaV3hrU1U1VFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGxPVTE4eWFXOHhPRjlmYVdaemRISmxZVzFmZDNKaGNIQmxja2xPVTE4M2MzUnlaV0Z0Y3pFemJXVnRiM0o1WDNOMGNtVmhiVVZGUlVWRlRsTXdYelZtYVdWc1pFbE9VekJmTTJ4aGN6RXdaWGgwY21GaWVYUmxjMFZPVXpCZk1qQnpkR0Z1WkdGeVpGOWthV1ptWDIxbGRHaHZaRWxUUTE5RlJVVkZSVVVBVGxOME0xOWZNakl3WDE5emFHRnlaV1JmY0hSeVgzQnZhVzUwWlhKSlVFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTXhYekpwYnpFNFgxOXBabk4wY21WaGJWOTNjbUZ3Y0dWeVNVNVRNVjgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGVGxNeVh6Vm1hV1ZzWkVsT1V6SmZNMnhoY3pFd1pYaDBjbUZpZVhSbGMwVk9VekpmTWpCemRHRnVaR0Z5WkY5a2FXWm1YMjFsZEdodlpFbFRSVjlGUlVWRlJVVk9VMTh4TkdSbFptRjFiSFJmWkdWc1pYUmxTVk5KWDBWRlRsTmZPV0ZzYkc5allYUnZja2xUU1Y5RlJVVkZBRTVUZEROZlh6SXhOR1JsWm1GMWJIUmZaR1ZzWlhSbFNVNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTXhYekpwYnpFNFgxOXBabk4wY21WaGJWOTNjbUZ3Y0dWeVNVNVRNVjgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGVGxNeVh6Vm1hV1ZzWkVsT1V6SmZNMnhoY3pFd1pYaDBjbUZpZVhSbGMwVk9VekpmTWpCemRHRnVaR0Z5WkY5a2FXWm1YMjFsZEdodlpFbFRSVjlGUlVWRlJVVkZSUUJPTm14aGMzcHBjRGRtYjNKdFlYUnpNakZrZVc1aGJXbGpYMlJsWTI5dGNISmxjM052Y2pGSlRsTmZPR1JsWTI5a1pYSnpNVEJoY21sMGFHMWxkR2xqU1U1VFh6SnBiekU0WDE5cFpuTjBjbVZoYlY5M2NtRndjR1Z5U1U1VFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVWRlJVVk9VekJmTVRseVpXTnZjbVJmWkdWamIyMXdjbVZ6YzI5eVNVcE9VekJmTldacFpXeGtTVTVUTUY4emJHRnpOM0J2YVc1ME1UQkZUbE13WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpVMFJmUlVWRlJVVkZSVVZGQUU1VGRETmZYekl5TUY5ZmMyaGhjbVZrWDNCMGNsOXdiMmx1ZEdWeVNWQk9ObXhoYzNwcGNEZG1iM0p0WVhSek1qRmtlVzVoYldsalgyUmxZMjl0Y0hKbGMzTnZjakZKVGxNeFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGxPVXpGZk1tbHZNVGhmWDJsbWMzUnlaV0Z0WDNkeVlYQndaWEpKVGxNeFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVWRlJVVk9VekpmTVRseVpXTnZjbVJmWkdWamIyMXdjbVZ6YzI5eVNVcE9VekpmTldacFpXeGtTVTVUTWw4emJHRnpOM0J2YVc1ME1UQkZUbE15WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpVMFpmUlVWRlJVVkZSVVZGVGxOZk1UUmtaV1poZFd4MFgyUmxiR1YwWlVsVFMxOUZSVTVUWHpsaGJHeHZZMkYwYjNKSlUwdGZSVVZGUlFCT1UzUXpYMTh5TVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxPTm14aGMzcHBjRGRtYjNKdFlYUnpNakZrZVc1aGJXbGpYMlJsWTI5dGNISmxjM052Y2pGSlRsTXhYemhrWldOdlpHVnljekV3WVhKcGRHaHRaWFJwWTBsT1V6RmZNbWx2TVRoZlgybG1jM1J5WldGdFgzZHlZWEJ3WlhKSlRsTXhYemR6ZEhKbFlXMXpNVE50WlcxdmNubGZjM1J5WldGdFJVVkZSVVZPVXpKZk1UbHlaV052Y21SZlpHVmpiMjF3Y21WemMyOXlTVXBPVXpKZk5XWnBaV3hrU1U1VE1sOHpiR0Z6TjNCdmFXNTBNVEJGVGxNeVh6SXdjM1JoYm1SaGNtUmZaR2xtWmw5dFpYUm9iMlJKVTBaZlJVVkZSVVZGUlVWRlJVVUFUalpzWVhONmFYQTNabTl5YldGMGN6SXhaSGx1WVcxcFkxOWtaV052YlhCeVpYTnpiM0l4U1U1VFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGxPVTE4eWFXOHhPRjlmYVdaemRISmxZVzFmZDNKaGNIQmxja2xPVTE4M2MzUnlaV0Z0Y3pFemJXVnRiM0o1WDNOMGNtVmhiVVZGUlVWRlRsTXdYekU1Y21WamIzSmtYMlJsWTI5dGNISmxjM052Y2tsS1RsTXdYelZtYVdWc1pFbE9VekJmTTJ4aGN6ZHdiMmx1ZERFd1JVNVRNRjh5TUhOMFlXNWtZWEprWDJScFptWmZiV1YwYUc5a1NWTkVYMFZGUlVWT1UwSmZTVTVUUTE4M1ozQnpkR2x0WlVWT1UwVmZTVk5JWDBWRlJVVkZSVVZGUlFCT1UzUXpYMTh5TWpCZlgzTm9ZWEpsWkY5d2RISmZjRzlwYm5SbGNrbFFUalpzWVhONmFYQTNabTl5YldGMGN6SXhaSGx1WVcxcFkxOWtaV052YlhCeVpYTnpiM0l4U1U1VE1WODRaR1ZqYjJSbGNuTXhNR0Z5YVhSb2JXVjBhV05KVGxNeFh6SnBiekU0WDE5cFpuTjBjbVZoYlY5M2NtRndjR1Z5U1U1VE1WODNjM1J5WldGdGN6RXpiV1Z0YjNKNVgzTjBjbVZoYlVWRlJVVkZUbE15WHpFNWNtVmpiM0prWDJSbFkyOXRjSEpsYzNOdmNrbEtUbE15WHpWbWFXVnNaRWxPVXpKZk0yeGhjemR3YjJsdWRERXdSVTVUTWw4eU1ITjBZVzVrWVhKa1gyUnBabVpmYldWMGFHOWtTVk5HWDBWRlJVVk9VMFJmU1U1VFJWODNaM0J6ZEdsdFpVVk9VMGRmU1ZOS1gwVkZSVVZGUlVWRlJVNVRYekUwWkdWbVlYVnNkRjlrWld4bGRHVkpVMDVmUlVWT1UxODVZV3hzYjJOaGRHOXlTVk5PWDBWRlJVVUFUbE4wTTE5Zk1qRTBaR1ZtWVhWc2RGOWtaV3hsZEdWSlRqWnNZWE42YVhBM1ptOXliV0YwY3pJeFpIbHVZVzFwWTE5a1pXTnZiWEJ5WlhOemIzSXhTVTVUTVY4NFpHVmpiMlJsY25NeE1HRnlhWFJvYldWMGFXTkpUbE14WHpKcGJ6RTRYMTlwWm5OMGNtVmhiVjkzY21Gd2NHVnlTVTVUTVY4M2MzUnlaV0Z0Y3pFemJXVnRiM0o1WDNOMGNtVmhiVVZGUlVWRlRsTXlYekU1Y21WamIzSmtYMlJsWTI5dGNISmxjM052Y2tsS1RsTXlYelZtYVdWc1pFbE9VekpmTTJ4aGN6ZHdiMmx1ZERFd1JVNVRNbDh5TUhOMFlXNWtZWEprWDJScFptWmZiV1YwYUc5a1NWTkdYMFZGUlVWT1UwUmZTVTVUUlY4M1ozQnpkR2x0WlVWT1UwZGZTVk5LWDBWRlJVVkZSVVZGUlVWRkFFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU1XUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlNVWxPVTE4NFpHVmpiMlJsY25NeE1HRnlhWFJvYldWMGFXTkpUbE5mTW1sdk1UaGZYMmxtYzNSeVpXRnRYM2R5WVhCd1pYSkpUbE5mTjNOMGNtVmhiWE14TTIxbGJXOXllVjl6ZEhKbFlXMUZSVVZGUlU1VE1GOHhPWEpsWTI5eVpGOWtaV052YlhCeVpYTnpiM0pKU2s1VE1GODFabWxsYkdSSlRsTXdYek5zWVhNM2NHOXBiblF4TUVWT1V6QmZNakJ6ZEdGdVpHRnlaRjlrYVdabVgyMWxkR2h2WkVsVFJGOUZSVVZGVGxOQ1gwbE9VME5mTTNKbllrVk9VMFZmU1ZOSVgwVkZSVVZGUlVWRlJRQk9VM1F6WDE4eU1qQmZYM05vWVhKbFpGOXdkSEpmY0c5cGJuUmxja2xRVGpac1lYTjZhWEEzWm05eWJXRjBjekl4WkhsdVlXMXBZMTlrWldOdmJYQnlaWE56YjNJeFNVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSlRsTXhYekpwYnpFNFgxOXBabk4wY21WaGJWOTNjbUZ3Y0dWeVNVNVRNVjgzYzNSeVpXRnRjekV6YldWdGIzSjVYM04wY21WaGJVVkZSVVZGVGxNeVh6RTVjbVZqYjNKa1gyUmxZMjl0Y0hKbGMzTnZja2xLVGxNeVh6Vm1hV1ZzWkVsT1V6SmZNMnhoY3pkd2IybHVkREV3UlU1VE1sOHlNSE4wWVc1a1lYSmtYMlJwWm1aZmJXVjBhRzlrU1ZOR1gwVkZSVVZPVTBSZlNVNVRSVjh6Y21kaVJVNVRSMTlKVTBwZlJVVkZSVVZGUlVWRlRsTmZNVFJrWldaaGRXeDBYMlJsYkdWMFpVbFRUbDlGUlU1VFh6bGhiR3h2WTJGMGIzSkpVMDVmUlVWRlJRQk9VM1F6WDE4eU1UUmtaV1poZFd4MFgyUmxiR1YwWlVsT05teGhjM3BwY0RkbWIzSnRZWFJ6TWpGa2VXNWhiV2xqWDJSbFkyOXRjSEpsYzNOdmNqRkpUbE14WHpoa1pXTnZaR1Z5Y3pFd1lYSnBkR2h0WlhScFkwbE9VekZmTW1sdk1UaGZYMmxtYzNSeVpXRnRYM2R5WVhCd1pYSkpUbE14WHpkemRISmxZVzF6TVROdFpXMXZjbmxmYzNSeVpXRnRSVVZGUlVWT1V6SmZNVGx5WldOdmNtUmZaR1ZqYjIxd2NtVnpjMjl5U1VwT1V6SmZOV1pwWld4a1NVNVRNbDh6YkdGek4zQnZhVzUwTVRCRlRsTXlYekl3YzNSaGJtUmhjbVJmWkdsbVpsOXRaWFJvYjJSSlUwWmZSVVZGUlU1VFJGOUpUbE5GWHpOeVoySkZUbE5IWDBsVFNsOUZSVVZGUlVWRlJVVkZSUUJPTm14aGMzcHBjRGRtYjNKdFlYUnpNakZrZVc1aGJXbGpYMlJsWTI5dGNISmxjM052Y2pGSlRsTmZPR1JsWTI5a1pYSnpNVEJoY21sMGFHMWxkR2xqU1U1VFh6SnBiekU0WDE5cFpuTjBjbVZoYlY5M2NtRndjR1Z5U1U1VFh6ZHpkSEpsWVcxek1UTnRaVzF2Y25sZmMzUnlaV0Z0UlVWRlJVVk9VekJmTVRseVpXTnZjbVJmWkdWamIyMXdjbVZ6YzI5eVNVcE9VekJmTldacFpXeGtTVTVUTUY4emJHRnpOM0J2YVc1ME1UQkZUbE13WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpVMFJmUlVWRlJVNVRRbDlKVGxORFh6ZG5jSE4wYVcxbFJVNVRSVjlKVTBoZlJVVkZSVTVUUWw5SlRsTkRYek55WjJKRlRsTkZYMGxUUzE5RlJVVkZSVVZGUlVVQVRsTjBNMTlmTWpJd1gxOXphR0Z5WldSZmNIUnlYM0J2YVc1MFpYSkpVRTQyYkdGemVtbHdOMlp2Y20xaGRITXlNV1I1Ym1GdGFXTmZaR1ZqYjIxd2NtVnpjMjl5TVVsT1V6RmZPR1JsWTI5a1pYSnpNVEJoY21sMGFHMWxkR2xqU1U1VE1WOHlhVzh4T0Y5ZmFXWnpkSEpsWVcxZmQzSmhjSEJsY2tsT1V6RmZOM04wY21WaGJYTXhNMjFsYlc5eWVWOXpkSEpsWVcxRlJVVkZSVTVUTWw4eE9YSmxZMjl5WkY5a1pXTnZiWEJ5WlhOemIzSkpTazVUTWw4MVptbGxiR1JKVGxNeVh6TnNZWE0zY0c5cGJuUXhNRVZPVXpKZk1qQnpkR0Z1WkdGeVpGOWthV1ptWDIxbGRHaHZaRWxUUmw5RlJVVkZUbE5FWDBsT1UwVmZOMmR3YzNScGJXVkZUbE5IWDBsVFNsOUZSVVZGVGxORVgwbE9VMFZmTTNKbllrVk9VMGRmU1ZOTlgwVkZSVVZGUlVWRlJVNVRYekUwWkdWbVlYVnNkRjlrWld4bGRHVkpVMUZmUlVWT1UxODVZV3hzYjJOaGRHOXlTVk5SWDBWRlJVVUFUbE4wTTE5Zk1qRTBaR1ZtWVhWc2RGOWtaV3hsZEdWSlRqWnNZWE42YVhBM1ptOXliV0YwY3pJeFpIbHVZVzFwWTE5a1pXTnZiWEJ5WlhOemIzSXhTVTVUTVY4NFpHVmpiMlJsY25NeE1HRnlhWFJvYldWMGFXTkpUbE14WHpKcGJ6RTRYMTlwWm5OMGNtVmhiVjkzY21Gd2NHVnlTVTVUTVY4M2MzUnlaV0Z0Y3pFemJXVnRiM0o1WDNOMGNtVmhiVVZGUlVWRlRsTXlYekU1Y21WamIzSmtYMlJsWTI5dGNISmxjM052Y2tsS1RsTXlYelZtYVdWc1pFbE9VekpmTTJ4aGN6ZHdiMmx1ZERFd1JVNVRNbDh5TUhOMFlXNWtZWEprWDJScFptWmZiV1YwYUc5a1NWTkdYMFZGUlVWT1UwUmZTVTVUUlY4M1ozQnpkR2x0WlVWT1UwZGZTVk5LWDBWRlJVVk9VMFJmU1U1VFJWOHpjbWRpUlU1VFIxOUpVMDFmUlVWRlJVVkZSVVZGUlVVQVRsTjBNMTlmTWpJd1gxOXphR0Z5WldSZmNIUnlYM0J2YVc1MFpYSkpVREV3WW5WbVgzTjBjbVZoYlU1VFh6RTBaR1ZtWVhWc2RGOWtaV3hsZEdWSlV6RmZSVVZPVTE4NVlXeHNiMk5oZEc5eVNWTXhYMFZGUlVVQVRsTjBNMTlmTWpFMFpHVm1ZWFZzZEY5a1pXeGxkR1ZKTVRCaWRXWmZjM1J5WldGdFJVVUFUbE4wTTE5Zk1qSXdYMTl6YUdGeVpXUmZjSFJ5WDNCdmFXNTBaWEpKVUU0MmJHRnplbWx3T0dSbFkyOWtaWEp6TVRCaGNtbDBhRzFsZEdsalNURXdZblZtWDNOMGNtVmhiVVZGVGxOZk1UUmtaV1poZFd4MFgyUmxiR1YwWlVsVE5WOUZSVTVUWHpsaGJHeHZZMkYwYjNKSlV6VmZSVVZGUlFCT1UzUXpYMTh5TVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxPTm14aGMzcHBjRGhrWldOdlpHVnljekV3WVhKcGRHaHRaWFJwWTBreE1HSjFabDl6ZEhKbFlXMUZSVVZGQUU0MmJHRnplbWx3TjJadmNtMWhkSE15Tm1SNWJtRnRhV05mWm1sbGJHUmZaR1ZqYjIxd2NtVnpjMjl5U1U1VFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGt4TUdKMVpsOXpkSEpsWVcxRlJVVkZBRTVUZEROZlh6SXlNRjlmYzJoaGNtVmtYM0IwY2w5d2IybHVkR1Z5U1ZCT05teGhjM3BwY0RkbWIzSnRZWFJ6TWpaa2VXNWhiV2xqWDJacFpXeGtYMlJsWTI5dGNISmxjM052Y2tsT1V6RmZPR1JsWTI5a1pYSnpNVEJoY21sMGFHMWxkR2xqU1RFd1luVm1YM04wY21WaGJVVkZSVVZPVTE4eE5HUmxabUYxYkhSZlpHVnNaWFJsU1ZNNFgwVkZUbE5mT1dGc2JHOWpZWFJ2Y2tsVE9GOUZSVVZGQUU1VGRETmZYekl4TkdSbFptRjFiSFJmWkdWc1pYUmxTVTQyYkdGemVtbHdOMlp2Y20xaGRITXlObVI1Ym1GdGFXTmZabWxsYkdSZlpHVmpiMjF3Y21WemMyOXlTVTVUTVY4NFpHVmpiMlJsY25NeE1HRnlhWFJvYldWMGFXTkpNVEJpZFdaZmMzUnlaV0Z0UlVWRlJVVkZBRTQyYkdGemVtbHdOMlp2Y20xaGRITXlObVI1Ym1GdGFXTmZaR1ZqYjIxd2NtVnpjMjl5WDJacFpXeGtTVTVUWHpoa1pXTnZaR1Z5Y3pFd1lYSnBkR2h0WlhScFkwa3hNR0oxWmw5emRISmxZVzFGUlU1VE1GODFabWxsYkdSSmFVNVRNRjh5TUhOMFlXNWtZWEprWDJScFptWmZiV1YwYUc5a1NXbEZSVVZGUlVVQVRsTjBNMTlmTWpJd1gxOXphR0Z5WldSZmNIUnlYM0J2YVc1MFpYSkpVRTQyYkdGemVtbHdOMlp2Y20xaGRITXlObVI1Ym1GdGFXTmZaR1ZqYjIxd2NtVnpjMjl5WDJacFpXeGtTVTVUTVY4NFpHVmpiMlJsY25NeE1HRnlhWFJvYldWMGFXTkpNVEJpZFdaZmMzUnlaV0Z0UlVWT1V6SmZOV1pwWld4a1NXbE9VekpmTWpCemRHRnVaR0Z5WkY5a2FXWm1YMjFsZEdodlpFbHBSVVZGUlVWRlRsTmZNVFJrWldaaGRXeDBYMlJsYkdWMFpVbFRRMTlGUlU1VFh6bGhiR3h2WTJGMGIzSkpVME5mUlVWRlJRQk9VM1F6WDE4eU1UUmtaV1poZFd4MFgyUmxiR1YwWlVsT05teGhjM3BwY0RkbWIzSnRZWFJ6TWpaa2VXNWhiV2xqWDJSbFkyOXRjSEpsYzNOdmNsOW1hV1ZzWkVsT1V6RmZPR1JsWTI5a1pYSnpNVEJoY21sMGFHMWxkR2xqU1RFd1luVm1YM04wY21WaGJVVkZUbE15WHpWbWFXVnNaRWxwVGxNeVh6SXdjM1JoYm1SaGNtUmZaR2xtWmw5dFpYUm9iMlJKYVVWRlJVVkZSVVZGQUU0MmJHRnplbWx3TjJadmNtMWhkSE15Tm1SNWJtRnRhV05mWkdWamIyMXdjbVZ6YzI5eVgyWnBaV3hrU1U1VFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGt4TUdKMVpsOXpkSEpsWVcxRlJVNVRNRjgxWm1sbGJHUkphazVUTUY4eU1ITjBZVzVrWVhKa1gyUnBabVpmYldWMGFHOWtTV3BGUlVWRlJVVUFUbE4wTTE5Zk1qSXdYMTl6YUdGeVpXUmZjSFJ5WDNCdmFXNTBaWEpKVUU0MmJHRnplbWx3TjJadmNtMWhkSE15Tm1SNWJtRnRhV05mWkdWamIyMXdjbVZ6YzI5eVgyWnBaV3hrU1U1VE1WODRaR1ZqYjJSbGNuTXhNR0Z5YVhSb2JXVjBhV05KTVRCaWRXWmZjM1J5WldGdFJVVk9VekpmTldacFpXeGtTV3BPVXpKZk1qQnpkR0Z1WkdGeVpGOWthV1ptWDIxbGRHaHZaRWxxUlVWRlJVVkZUbE5mTVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxUUTE5RlJVNVRYemxoYkd4dlkyRjBiM0pKVTBOZlJVVkZSUUJPVTNRelgxOHlNVFJrWldaaGRXeDBYMlJsYkdWMFpVbE9ObXhoYzNwcGNEZG1iM0p0WVhSek1qWmtlVzVoYldsalgyUmxZMjl0Y0hKbGMzTnZjbDltYVdWc1pFbE9VekZmT0dSbFkyOWtaWEp6TVRCaGNtbDBhRzFsZEdsalNURXdZblZtWDNOMGNtVmhiVVZGVGxNeVh6Vm1hV1ZzWkVscVRsTXlYekl3YzNSaGJtUmhjbVJmWkdsbVpsOXRaWFJvYjJSSmFrVkZSVVZGUlVWRkFFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRYemhrWldOdlpHVnljekV3WVhKcGRHaHRaWFJwWTBreE1HSjFabDl6ZEhKbFlXMUZSVTVUTUY4MVptbGxiR1JKWVU1VE1GOHlNSE4wWVc1a1lYSmtYMlJwWm1aZmJXVjBhRzlrU1dGRlJVVkZSVVVBVGxOME0xOWZNakl3WDE5emFHRnlaV1JmY0hSeVgzQnZhVzUwWlhKSlVFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSk1UQmlkV1pmYzNSeVpXRnRSVVZPVXpKZk5XWnBaV3hrU1dGT1V6SmZNakJ6ZEdGdVpHRnlaRjlrYVdabVgyMWxkR2h2WkVsaFJVVkZSVVZGVGxOZk1UUmtaV1poZFd4MFgyUmxiR1YwWlVsVFExOUZSVTVUWHpsaGJHeHZZMkYwYjNKSlUwTmZSVVZGUlFCT1UzUXpYMTh5TVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxPTm14aGMzcHBjRGRtYjNKdFlYUnpNalprZVc1aGJXbGpYMlJsWTI5dGNISmxjM052Y2w5bWFXVnNaRWxPVXpGZk9HUmxZMjlrWlhKek1UQmhjbWwwYUcxbGRHbGpTVEV3WW5WbVgzTjBjbVZoYlVWRlRsTXlYelZtYVdWc1pFbGhUbE15WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpZVVZGUlVWRlJVVkZBRTQyYkdGemVtbHdOMlp2Y20xaGRITXlObVI1Ym1GdGFXTmZaR1ZqYjIxd2NtVnpjMjl5WDJacFpXeGtTVTVUWHpoa1pXTnZaR1Z5Y3pFd1lYSnBkR2h0WlhScFkwa3hNR0oxWmw5emRISmxZVzFGUlU1VE1GODFabWxsYkdSSmMwNVRNRjh5TUhOMFlXNWtZWEprWDJScFptWmZiV1YwYUc5a1NYTkZSVVZGUlVVQVRsTjBNMTlmTWpJd1gxOXphR0Z5WldSZmNIUnlYM0J2YVc1MFpYSkpVRTQyYkdGemVtbHdOMlp2Y20xaGRITXlObVI1Ym1GdGFXTmZaR1ZqYjIxd2NtVnpjMjl5WDJacFpXeGtTVTVUTVY4NFpHVmpiMlJsY25NeE1HRnlhWFJvYldWMGFXTkpNVEJpZFdaZmMzUnlaV0Z0UlVWT1V6SmZOV1pwWld4a1NYTk9VekpmTWpCemRHRnVaR0Z5WkY5a2FXWm1YMjFsZEdodlpFbHpSVVZGUlVWRlRsTmZNVFJrWldaaGRXeDBYMlJsYkdWMFpVbFRRMTlGUlU1VFh6bGhiR3h2WTJGMGIzSkpVME5mUlVWRlJRQk9VM1F6WDE4eU1UUmtaV1poZFd4MFgyUmxiR1YwWlVsT05teGhjM3BwY0RkbWIzSnRZWFJ6TWpaa2VXNWhiV2xqWDJSbFkyOXRjSEpsYzNOdmNsOW1hV1ZzWkVsT1V6RmZPR1JsWTI5a1pYSnpNVEJoY21sMGFHMWxkR2xqU1RFd1luVm1YM04wY21WaGJVVkZUbE15WHpWbWFXVnNaRWx6VGxNeVh6SXdjM1JoYm1SaGNtUmZaR2xtWmw5dFpYUm9iMlJKYzBWRlJVVkZSVVZGQUU0MmJHRnplbWx3TjJadmNtMWhkSE15Tm1SNWJtRnRhV05mWkdWamIyMXdjbVZ6YzI5eVgyWnBaV3hrU1U1VFh6aGtaV052WkdWeWN6RXdZWEpwZEdodFpYUnBZMGt4TUdKMVpsOXpkSEpsWVcxRlJVNVRNRjgxWm1sbGJHUkphRTVUTUY4eU1ITjBZVzVrWVhKa1gyUnBabVpmYldWMGFHOWtTV2hGUlVWRlJVVUFUbE4wTTE5Zk1qSXdYMTl6YUdGeVpXUmZjSFJ5WDNCdmFXNTBaWEpKVUU0MmJHRnplbWx3TjJadmNtMWhkSE15Tm1SNWJtRnRhV05mWkdWamIyMXdjbVZ6YzI5eVgyWnBaV3hrU1U1VE1WODRaR1ZqYjJSbGNuTXhNR0Z5YVhSb2JXVjBhV05KTVRCaWRXWmZjM1J5WldGdFJVVk9VekpmTldacFpXeGtTV2hPVXpKZk1qQnpkR0Z1WkdGeVpGOWthV1ptWDIxbGRHaHZaRWxvUlVWRlJVVkZUbE5mTVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxUUTE5RlJVNVRYemxoYkd4dlkyRjBiM0pKVTBOZlJVVkZSUUJPVTNRelgxOHlNVFJrWldaaGRXeDBYMlJsYkdWMFpVbE9ObXhoYzNwcGNEZG1iM0p0WVhSek1qWmtlVzVoYldsalgyUmxZMjl0Y0hKbGMzTnZjbDltYVdWc1pFbE9VekZmT0dSbFkyOWtaWEp6TVRCaGNtbDBhRzFsZEdsalNURXdZblZtWDNOMGNtVmhiVVZGVGxNeVh6Vm1hV1ZzWkVsb1RsTXlYekl3YzNSaGJtUmhjbVJmWkdsbVpsOXRaWFJvYjJSSmFFVkZSVVZGUlVWRkFFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRYemhrWldOdlpHVnljekV3WVhKcGRHaHRaWFJwWTBreE1HSjFabDl6ZEhKbFlXMUZSVTVUTUY4MVptbGxiR1JKZEU1VE1GOHlNSE4wWVc1a1lYSmtYMlJwWm1aZmJXVjBhRzlrU1hSRlJVVkZSVVVBVGxOME0xOWZNakl3WDE5emFHRnlaV1JmY0hSeVgzQnZhVzUwWlhKSlVFNDJiR0Z6ZW1sd04yWnZjbTFoZEhNeU5tUjVibUZ0YVdOZlpHVmpiMjF3Y21WemMyOXlYMlpwWld4a1NVNVRNVjg0WkdWamIyUmxjbk14TUdGeWFYUm9iV1YwYVdOSk1UQmlkV1pmYzNSeVpXRnRSVVZPVXpKZk5XWnBaV3hrU1hST1V6SmZNakJ6ZEdGdVpHRnlaRjlrYVdabVgyMWxkR2h2WkVsMFJVVkZSVVZGVGxOZk1UUmtaV1poZFd4MFgyUmxiR1YwWlVsVFExOUZSVTVUWHpsaGJHeHZZMkYwYjNKSlUwTmZSVVZGUlFCT1UzUXpYMTh5TVRSa1pXWmhkV3gwWDJSbGJHVjBaVWxPTm14aGMzcHBjRGRtYjNKdFlYUnpNalprZVc1aGJXbGpYMlJsWTI5dGNISmxjM052Y2w5bWFXVnNaRWxPVXpGZk9HUmxZMjlrWlhKek1UQmhjbWwwYUcxbGRHbGpTVEV3WW5WbVgzTjBjbVZoYlVWRlRsTXlYelZtYVdWc1pFbDBUbE15WHpJd2MzUmhibVJoY21SZlpHbG1abDl0WlhSb2IyUkpkRVZGUlVWRlJVVkZBRFpNUVZOYWFYQUFVRFpNUVZOYWFYQUFVRXMyVEVGVFdtbHdBR2xwQUhZQWRta0FkbWxwYVdrQWRtbHBhUUJwYVdrQU1UTkVlVzVoYldsalRFRlRXbWx3QUZBeE0wUjVibUZ0YVdOTVFWTmFhWEFBVUVzeE0wUjVibUZ0YVdOTVFWTmFhWEFBZG05cFpBQmliMjlzQUdOb1lYSUFjMmxuYm1Wa0lHTm9ZWElBZFc1emFXZHVaV1FnWTJoaGNnQnphRzl5ZEFCMWJuTnBaMjVsWkNCemFHOXlkQUJwYm5RQWRXNXphV2R1WldRZ2FXNTBBR3h2Ym1jQWRXNXphV2R1WldRZ2JHOXVad0JtYkc5aGRBQmtiM1ZpYkdVQWMzUmtPanB6ZEhKcGJtY0FjM1JrT2pwaVlYTnBZMTl6ZEhKcGJtYzhkVzV6YVdkdVpXUWdZMmhoY2o0QWMzUmtPanAzYzNSeWFXNW5BSE4wWkRvNmRURTJjM1J5YVc1bkFITjBaRG82ZFRNeWMzUnlhVzVuQUdWdGMyTnlhWEIwWlc0Nk9uWmhiQUJsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eGphR0Z5UGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenh6YVdkdVpXUWdZMmhoY2o0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnWTJoaGNqNEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGMyaHZjblErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZ1YzJsbmJtVmtJSE5vYjNKMFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnVjMmxuYm1Wa0lHbHVkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhiRzl1Wno0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnYkc5dVp6NEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGFXNTBPRjkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME9GOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblF4Tmw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWFXNTBNVFpmZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YVc1ME16SmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkV2x1ZERNeVgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHWnNiMkYwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhrYjNWaWJHVStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHeHZibWNnWkc5MVlteGxQZ0JPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxsUlVVQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSlpFVkZBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV1pGUlFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsdFJVVUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpiRVZGQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1dwRlJRQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbHBSVVVBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKZEVWRkFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NYTkZSUUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxvUlVVQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSllVVkZBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV05GUlFCT01UQmxiWE5qY21sd2RHVnVNM1poYkVVQVRsTjBNMTlmTWpFeVltRnphV05mYzNSeWFXNW5TVVJwVGxOZk1URmphR0Z5WDNSeVlXbDBjMGxFYVVWRlRsTmZPV0ZzYkc5allYUnZja2xFYVVWRlJVVUFUbE4wTTE5Zk1qSXhYMTlpWVhOcFkxOXpkSEpwYm1kZlkyOXRiVzl1U1V4aU1VVkZSUUJPVTNRelgxOHlNVEppWVhOcFkxOXpkSEpwYm1kSlJITk9VMTh4TVdOb1lYSmZkSEpoYVhSelNVUnpSVVZPVTE4NVlXeHNiMk5oZEc5eVNVUnpSVVZGUlFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpkMDVUWHpFeFkyaGhjbDkwY21GcGRITkpkMFZGVGxOZk9XRnNiRzlqWVhSdmNrbDNSVVZGUlFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEphRTVUWHpFeFkyaGhjbDkwY21GcGRITkphRVZGVGxOZk9XRnNiRzlqWVhSdmNrbG9SVVZGUlFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpZMDVUWHpFeFkyaGhjbDkwY21GcGRITkpZMFZGVGxOZk9XRnNiRzlqWVhSdmNrbGpSVVZGUlFBdEt5QWdJREJZTUhnQUtHNTFiR3dwQUMwd1dDc3dXQ0F3V0Mwd2VDc3dlQ0F3ZUFCcGJtWUFTVTVHQUc1aGJnQk9RVTRBTGdCMFpYSnRhVzVoZEdsdVp5QjNhWFJvSUNWeklHVjRZMlZ3ZEdsdmJpQnZaaUIwZVhCbElDVnpPaUFsY3dCMFpYSnRhVzVoZEdsdVp5QjNhWFJvSUNWeklHVjRZMlZ3ZEdsdmJpQnZaaUIwZVhCbElDVnpBSFJsY20xcGJtRjBhVzVuSUhkcGRHZ2dKWE1nWm05eVpXbG5iaUJsZUdObGNIUnBiMjRBZEdWeWJXbHVZWFJwYm1jQWRXNWpZWFZuYUhRQVUzUTVaWGhqWlhCMGFXOXVBRTR4TUY5ZlkzaDRZV0pwZGpFeE5sOWZjMmhwYlY5MGVYQmxYMmx1Wm05RkFGTjBPWFI1Y0dWZmFXNW1id0JPTVRCZlgyTjRlR0ZpYVhZeE1qQmZYM05wWDJOc1lYTnpYM1I1Y0dWZmFXNW1iMFVBVGpFd1gxOWplSGhoWW1sMk1URTNYMTlqYkdGemMxOTBlWEJsWDJsdVptOUZBSFJsY20xcGJtRjBaVjlvWVc1a2JHVnlJSFZ1Wlhod1pXTjBaV1JzZVNCeVpYUjFjbTVsWkFCemRHUTZPbUpoWkY5aGJHeHZZd0JUZERsaVlXUmZZV3hzYjJNQVUzUXhNV3h2WjJsalgyVnljbTl5QUZOME1UTnlkVzUwYVcxbFgyVnljbTl5QUZOME1USnNaVzVuZEdoZlpYSnliM0lBVTNReE1tOTFkRjl2Wmw5eVlXNW5aUUJPTVRCZlgyTjRlR0ZpYVhZeE1UZGZYM0JpWVhObFgzUjVjR1ZmYVc1bWIwVUFUakV3WDE5amVIaGhZbWwyTVRFNVgxOXdiMmx1ZEdWeVgzUjVjR1ZmYVc1bWIwVUFUakV3WDE5amVIaGhZbWwyTVRJd1gxOW1kVzVqZEdsdmJsOTBlWEJsWDJsdVptOUZBRTR4TUY5ZlkzaDRZV0pwZGpFeU9WOWZjRzlwYm5SbGNsOTBiMTl0WlcxaVpYSmZkSGx3WlY5cGJtWnZSUUJRZFhKbElIWnBjblIxWVd3Z1puVnVZM1JwYjI0Z1kyRnNiR1ZrSVFCT01UQmZYMk40ZUdGaWFYWXhNak5mWDJaMWJtUmhiV1Z1ZEdGc1gzUjVjR1ZmYVc1bWIwVUFkZ0JFYmdCaUFHTUFhQUJoQUhNQWRBQnBBR29BYkFCdEFHWUFaQUJPTVRCZlgyTjRlR0ZpYVhZeE1qRmZYM1p0YVY5amJHRnpjMTkwZVhCbFgybHVabTlGQUY5ZlkzaGhYMmQxWVhKa1gyRmpjWFZwY21VZ1pHVjBaV04wWldRZ2NtVmpkWEp6YVhabElHbHVhWFJwWVd4cGVtRjBhVzl1QUhOMFpEbzZZbUZrWDJaMWJtTjBhVzl1WDJOaGJHd0FUbE4wTTE5Zk1qRTNZbUZrWDJaMWJtTjBhVzl1WDJOaGJHeEZBRTVUZEROZlh6SXhORjlmYzJoaGNtVmtYMk52ZFc1MFJRQk9VM1F6WDE4eU1UbGZYM05vWVhKbFpGOTNaV0ZyWDJOdmRXNTBSUUJ0ZFhSbGVDQnNiMk5ySUdaaGFXeGxaQUJpWVhOcFkxOXpkSEpwYm1jQWRXNXpjR1ZqYVdacFpXUWdaMlZ1WlhKcFkxOWpZWFJsWjI5eWVTQmxjbkp2Y2dCVmJtdHViM2R1SUdWeWNtOXlJQ1ZrQUdkbGJtVnlhV01BVGxOME0xOWZNakkwWDE5blpXNWxjbWxqWDJWeWNtOXlYMk5oZEdWbmIzSjVSUUJPVTNRelgxOHlNVEpmWDJSdlgyMWxjM05oWjJWRkFFNVRkRE5mWHpJeE5HVnljbTl5WDJOaGRHVm5iM0o1UlFCMWJuTndaV05wWm1sbFpDQnplWE4wWlcxZlkyRjBaV2R2Y25rZ1pYSnliM0lBYzNsemRHVnRBRTVUZEROZlh6SXlNMTlmYzNsemRHVnRYMlZ5Y205eVgyTmhkR1ZuYjNKNVJRQk9VM1F6WDE4eU1USnplWE4wWlcxZlpYSnliM0pGQURvZ0FIWmxZM1J2Y2c9PSI7CiAgICB2YXIgdGVtcERvdWJsZVB0ciA9IDIyMzY4OwogICAgZnVuY3Rpb24gZGVtYW5nbGUoZnVuYykgewogICAgICByZXR1cm4gZnVuYzsKICAgIH0KICAgIGZ1bmN0aW9uIGRlbWFuZ2xlQWxsKHRleHQpIHsKICAgICAgdmFyIHJlZ2V4ID0gL1xiX19aW1x3XGRfXSsvZzsKICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZWdleCwgZnVuY3Rpb24oeCkgewogICAgICAgIHZhciB5ID0gZGVtYW5nbGUoeCk7CiAgICAgICAgcmV0dXJuIHggPT09IHkgPyB4IDogeSArICIgWyIgKyB4ICsgIl0iOwogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIGpzU3RhY2tUcmFjZSgpIHsKICAgICAgdmFyIGVycjIgPSBuZXcgRXJyb3IoKTsKICAgICAgaWYgKCFlcnIyLnN0YWNrKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGVycjIgPSBlOwogICAgICAgIH0KICAgICAgICBpZiAoIWVycjIuc3RhY2spIHsKICAgICAgICAgIHJldHVybiAiKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSkiOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gZXJyMi5zdGFjay50b1N0cmluZygpOwogICAgfQogICAgZnVuY3Rpb24gX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbihzaXplKSB7CiAgICAgIHJldHVybiBfbWFsbG9jKHNpemUpOwogICAgfQogICAgdmFyIF9fX2V4Y2VwdGlvbl9pbmZvcyA9IHt9OwogICAgdmFyIF9fX2V4Y2VwdGlvbl9jYXVnaHQgPSBbXTsKICAgIGZ1bmN0aW9uIF9fX2V4Y2VwdGlvbl9hZGRSZWYocHRyKSB7CiAgICAgIGlmICghcHRyKQogICAgICAgIHJldHVybjsKICAgICAgdmFyIGluZm8gPSBfX19leGNlcHRpb25faW5mb3NbcHRyXTsKICAgICAgaW5mby5yZWZjb3VudCsrOwogICAgfQogICAgZnVuY3Rpb24gX19fZXhjZXB0aW9uX2RlQWRqdXN0KGFkanVzdGVkKSB7CiAgICAgIGlmICghYWRqdXN0ZWQgfHwgX19fZXhjZXB0aW9uX2luZm9zW2FkanVzdGVkXSkKICAgICAgICByZXR1cm4gYWRqdXN0ZWQ7CiAgICAgIGZvciAodmFyIGtleTIgaW4gX19fZXhjZXB0aW9uX2luZm9zKSB7CiAgICAgICAgdmFyIHB0ciA9ICtrZXkyOwogICAgICAgIHZhciBhZGogPSBfX19leGNlcHRpb25faW5mb3NbcHRyXS5hZGp1c3RlZDsKICAgICAgICB2YXIgbGVuID0gYWRqLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBpZiAoYWRqW2ldID09PSBhZGp1c3RlZCkgewogICAgICAgICAgICByZXR1cm4gcHRyOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gYWRqdXN0ZWQ7CiAgICB9CiAgICBmdW5jdGlvbiBfX19jeGFfYmVnaW5fY2F0Y2gocHRyKSB7CiAgICAgIHZhciBpbmZvID0gX19fZXhjZXB0aW9uX2luZm9zW3B0cl07CiAgICAgIGlmIChpbmZvICYmICFpbmZvLmNhdWdodCkgewogICAgICAgIGluZm8uY2F1Z2h0ID0gdHJ1ZTsKICAgICAgICBfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udi51bmNhdWdodF9leGNlcHRpb25zLS07CiAgICAgIH0KICAgICAgaWYgKGluZm8pCiAgICAgICAgaW5mby5yZXRocm93biA9IGZhbHNlOwogICAgICBfX19leGNlcHRpb25fY2F1Z2h0LnB1c2gocHRyKTsKICAgICAgX19fZXhjZXB0aW9uX2FkZFJlZihfX19leGNlcHRpb25fZGVBZGp1c3QocHRyKSk7CiAgICAgIHJldHVybiBwdHI7CiAgICB9CiAgICB2YXIgX19fZXhjZXB0aW9uX2xhc3QgPSAwOwogICAgZnVuY3Rpb24gX19fY3hhX3Rocm93KHB0ciwgdHlwZSwgZGVzdHJ1Y3RvcikgewogICAgICBfX19leGNlcHRpb25faW5mb3NbcHRyXSA9IHsKICAgICAgICBwdHIsCiAgICAgICAgYWRqdXN0ZWQ6IFtwdHJdLAogICAgICAgIHR5cGUsCiAgICAgICAgZGVzdHJ1Y3RvciwKICAgICAgICByZWZjb3VudDogMCwKICAgICAgICBjYXVnaHQ6IGZhbHNlLAogICAgICAgIHJldGhyb3duOiBmYWxzZQogICAgICB9OwogICAgICBfX19leGNlcHRpb25fbGFzdCA9IHB0cjsKICAgICAgaWYgKCEoInVuY2F1Z2h0X2V4Y2VwdGlvbiIgaW4gX19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYpKSB7CiAgICAgICAgX19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYudW5jYXVnaHRfZXhjZXB0aW9ucyA9IDE7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgX19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYudW5jYXVnaHRfZXhjZXB0aW9ucysrOwogICAgICB9CiAgICAgIHRocm93IHB0cjsKICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV91bmNhdWdodF9leGNlcHRpb25zKCkgewogICAgICByZXR1cm4gX19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYudW5jYXVnaHRfZXhjZXB0aW9uczsKICAgIH0KICAgIGZ1bmN0aW9uIF9fX2d4eF9wZXJzb25hbGl0eV92MCgpIHsKICAgIH0KICAgIGZ1bmN0aW9uIGdldFNoaWZ0RnJvbVNpemUoc2l6ZSkgewogICAgICBzd2l0Y2ggKHNpemUpIHsKICAgICAgICBjYXNlIDE6CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICBjYXNlIDQ6CiAgICAgICAgICByZXR1cm4gMjsKICAgICAgICBjYXNlIDg6CiAgICAgICAgICByZXR1cm4gMzsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biB0eXBlIHNpemU6ICIgKyBzaXplKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZW1iaW5kX2luaXRfY2hhckNvZGVzKCkgewogICAgICB2YXIgY29kZXMgPSBuZXcgQXJyYXkoMjU2KTsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgewogICAgICAgIGNvZGVzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTsKICAgICAgfQogICAgICBlbWJpbmRfY2hhckNvZGVzID0gY29kZXM7CiAgICB9CiAgICB2YXIgZW1iaW5kX2NoYXJDb2RlcyA9IHZvaWQgMDsKICAgIGZ1bmN0aW9uIHJlYWRMYXRpbjFTdHJpbmcocHRyKSB7CiAgICAgIHZhciByZXQgPSAiIjsKICAgICAgdmFyIGMgPSBwdHI7CiAgICAgIHdoaWxlIChIRUFQVThbY10pIHsKICAgICAgICByZXQgKz0gZW1iaW5kX2NoYXJDb2Rlc1tIRUFQVThbYysrXV07CiAgICAgIH0KICAgICAgcmV0dXJuIHJldDsKICAgIH0KICAgIHZhciBhd2FpdGluZ0RlcGVuZGVuY2llcyA9IHt9OwogICAgdmFyIHJlZ2lzdGVyZWRUeXBlcyA9IHt9OwogICAgdmFyIHR5cGVEZXBlbmRlbmNpZXMgPSB7fTsKICAgIHZhciBjaGFyXzAgPSA0ODsKICAgIHZhciBjaGFyXzkgPSA1NzsKICAgIGZ1bmN0aW9uIG1ha2VMZWdhbEZ1bmN0aW9uTmFtZShuYW1lKSB7CiAgICAgIGlmICh2b2lkIDAgPT09IG5hbWUpIHsKICAgICAgICByZXR1cm4gIl91bmtub3duIjsKICAgICAgfQogICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csICIkIik7CiAgICAgIHZhciBmID0gbmFtZS5jaGFyQ29kZUF0KDApOwogICAgICBpZiAoZiA+PSBjaGFyXzAgJiYgZiA8PSBjaGFyXzkpIHsKICAgICAgICByZXR1cm4gIl8iICsgbmFtZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gbmFtZTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gY3JlYXRlTmFtZWRGdW5jdGlvbihuYW1lLCBib2R5KSB7CiAgICAgIG5hbWUgPSBtYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSk7CiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oCiAgICAgICAgImJvZHkiLAogICAgICAgICJyZXR1cm4gZnVuY3Rpb24gIiArIG5hbWUgKyAnKCkge1xuICAgICJ1c2Ugc3RyaWN0IjsgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4nCiAgICAgICkoYm9keSk7CiAgICB9CiAgICBmdW5jdGlvbiBleHRlbmRFcnJvcihiYXNlRXJyb3JUeXBlLCBlcnJvck5hbWUpIHsKICAgICAgdmFyIGVycm9yQ2xhc3MgPSBjcmVhdGVOYW1lZEZ1bmN0aW9uKGVycm9yTmFtZSwgZnVuY3Rpb24obWVzc2FnZSkgewogICAgICAgIHRoaXMubmFtZSA9IGVycm9yTmFtZTsKICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjazsKICAgICAgICBpZiAoc3RhY2sgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMudG9TdHJpbmcoKSArICJcbiIgKyBzdGFjay5yZXBsYWNlKC9eRXJyb3IoOlteXG5dKik/XG4vLCAiIik7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgZXJyb3JDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VFcnJvclR5cGUucHJvdG90eXBlKTsKICAgICAgZXJyb3JDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBlcnJvckNsYXNzOwogICAgICBlcnJvckNsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICI6ICIgKyB0aGlzLm1lc3NhZ2U7CiAgICAgICAgfQogICAgICB9OwogICAgICByZXR1cm4gZXJyb3JDbGFzczsKICAgIH0KICAgIHZhciBCaW5kaW5nRXJyb3IgPSB2b2lkIDA7CiAgICBmdW5jdGlvbiB0aHJvd0JpbmRpbmdFcnJvcihtZXNzYWdlKSB7CiAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IobWVzc2FnZSk7CiAgICB9CiAgICB2YXIgSW50ZXJuYWxFcnJvciA9IHZvaWQgMDsKICAgIGZ1bmN0aW9uIHRocm93SW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7CiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKG1lc3NhZ2UpOwogICAgfQogICAgZnVuY3Rpb24gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQobXlUeXBlcywgZGVwZW5kZW50VHlwZXMsIGdldFR5cGVDb252ZXJ0ZXJzKSB7CiAgICAgIG15VHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7CiAgICAgICAgdHlwZURlcGVuZGVuY2llc1t0eXBlXSA9IGRlcGVuZGVudFR5cGVzOwogICAgICB9KTsKICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZSh0eXBlQ29udmVydGVyczIpIHsKICAgICAgICB2YXIgbXlUeXBlQ29udmVydGVycyA9IGdldFR5cGVDb252ZXJ0ZXJzKHR5cGVDb252ZXJ0ZXJzMik7CiAgICAgICAgaWYgKG15VHlwZUNvbnZlcnRlcnMubGVuZ3RoICE9PSBteVR5cGVzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3dJbnRlcm5hbEVycm9yKCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50Iik7CiAgICAgICAgfQogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXlUeXBlcy5sZW5ndGg7ICsraSkgewogICAgICAgICAgcmVnaXN0ZXJUeXBlKG15VHlwZXNbaV0sIG15VHlwZUNvbnZlcnRlcnNbaV0pOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgdHlwZUNvbnZlcnRlcnMgPSBuZXcgQXJyYXkoZGVwZW5kZW50VHlwZXMubGVuZ3RoKTsKICAgICAgdmFyIHVucmVnaXN0ZXJlZFR5cGVzID0gW107CiAgICAgIHZhciByZWdpc3RlcmVkID0gMDsKICAgICAgZGVwZW5kZW50VHlwZXMuZm9yRWFjaChmdW5jdGlvbihkdCwgaSkgewogICAgICAgIGlmIChyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkoZHQpKSB7CiAgICAgICAgICB0eXBlQ29udmVydGVyc1tpXSA9IHJlZ2lzdGVyZWRUeXBlc1tkdF07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHVucmVnaXN0ZXJlZFR5cGVzLnB1c2goZHQpOwogICAgICAgICAgaWYgKCFhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShkdCkpIHsKICAgICAgICAgICAgYXdhaXRpbmdEZXBlbmRlbmNpZXNbZHRdID0gW107CiAgICAgICAgICB9CiAgICAgICAgICBhd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0ucHVzaChmdW5jdGlvbigpIHsKICAgICAgICAgICAgdHlwZUNvbnZlcnRlcnNbaV0gPSByZWdpc3RlcmVkVHlwZXNbZHRdOwogICAgICAgICAgICArK3JlZ2lzdGVyZWQ7CiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkID09PSB1bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpIHsKICAgICAgICAgICAgICBvbkNvbXBsZXRlKHR5cGVDb252ZXJ0ZXJzKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKDAgPT09IHVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCkgewogICAgICAgIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiByZWdpc3RlclR5cGUocmF3VHlwZSwgcmVnaXN0ZXJlZEluc3RhbmNlLCBvcHRpb25zKSB7CiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICBpZiAoISgiYXJnUGFja0FkdmFuY2UiIGluIHJlZ2lzdGVyZWRJbnN0YW5jZSkpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlIik7CiAgICAgIH0KICAgICAgdmFyIG5hbWUgPSByZWdpc3RlcmVkSW5zdGFuY2UubmFtZTsKICAgICAgaWYgKCFyYXdUeXBlKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ3R5cGUgIicgKyBuYW1lICsgJyIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcicpOwogICAgICB9CiAgICAgIGlmIChyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpIHsKICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnIiArIG5hbWUgKyAiJyB0d2ljZSIpOwogICAgICAgIH0KICAgICAgfQogICAgICByZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV0gPSByZWdpc3RlcmVkSW5zdGFuY2U7CiAgICAgIGRlbGV0ZSB0eXBlRGVwZW5kZW5jaWVzW3Jhd1R5cGVdOwogICAgICBpZiAoYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpIHsKICAgICAgICB2YXIgY2FsbGJhY2tzID0gYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07CiAgICAgICAgZGVsZXRlIGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdOwogICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7CiAgICAgICAgICBjYigpOwogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9ib29sKHJhd1R5cGUsIG5hbWUsIHNpemUsIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSkgewogICAgICB2YXIgc2hpZnQgPSBnZXRTaGlmdEZyb21TaXplKHNpemUpOwogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24od3QpIHsKICAgICAgICAgIHJldHVybiAhIXd0OwogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIG8pIHsKICAgICAgICAgIHJldHVybiBvID8gdHJ1ZVZhbHVlIDogZmFsc2VWYWx1ZTsKICAgICAgICB9LAogICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBmdW5jdGlvbihwb2ludGVyKSB7CiAgICAgICAgICB2YXIgaGVhcDsKICAgICAgICAgIGlmIChzaXplID09PSAxKSB7CiAgICAgICAgICAgIGhlYXAgPSBIRUFQODsKICAgICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMikgewogICAgICAgICAgICBoZWFwID0gSEVBUDE2OwogICAgICAgICAgfSBlbHNlIGlmIChzaXplID09PSA0KSB7CiAgICAgICAgICAgIGhlYXAgPSBIRUFQMzI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGJvb2xlYW4gdHlwZSBzaXplOiAiICsgbmFtZSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oaGVhcFtwb2ludGVyID4+IHNoaWZ0XSk7CiAgICAgICAgfSwKICAgICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwKICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBDbGFzc0hhbmRsZV9pc0FsaWFzT2Yob3RoZXIpIHsKICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICB2YXIgbGVmdENsYXNzID0gdGhpcy4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgdmFyIGxlZnQgPSB0aGlzLiQkLnB0cjsKICAgICAgdmFyIHJpZ2h0Q2xhc3MgPSBvdGhlci4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgdmFyIHJpZ2h0ID0gb3RoZXIuJCQucHRyOwogICAgICB3aGlsZSAobGVmdENsYXNzLmJhc2VDbGFzcykgewogICAgICAgIGxlZnQgPSBsZWZ0Q2xhc3MudXBjYXN0KGxlZnQpOwogICAgICAgIGxlZnRDbGFzcyA9IGxlZnRDbGFzcy5iYXNlQ2xhc3M7CiAgICAgIH0KICAgICAgd2hpbGUgKHJpZ2h0Q2xhc3MuYmFzZUNsYXNzKSB7CiAgICAgICAgcmlnaHQgPSByaWdodENsYXNzLnVwY2FzdChyaWdodCk7CiAgICAgICAgcmlnaHRDbGFzcyA9IHJpZ2h0Q2xhc3MuYmFzZUNsYXNzOwogICAgICB9CiAgICAgIHJldHVybiBsZWZ0Q2xhc3MgPT09IHJpZ2h0Q2xhc3MgJiYgbGVmdCA9PT0gcmlnaHQ7CiAgICB9CiAgICBmdW5jdGlvbiBzaGFsbG93Q29weUludGVybmFsUG9pbnRlcihvKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgY291bnQ6IG8uY291bnQsCiAgICAgICAgZGVsZXRlU2NoZWR1bGVkOiBvLmRlbGV0ZVNjaGVkdWxlZCwKICAgICAgICBwcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZTogby5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSwKICAgICAgICBwdHI6IG8ucHRyLAogICAgICAgIHB0clR5cGU6IG8ucHRyVHlwZSwKICAgICAgICBzbWFydFB0cjogby5zbWFydFB0ciwKICAgICAgICBzbWFydFB0clR5cGU6IG8uc21hcnRQdHJUeXBlCiAgICAgIH07CiAgICB9CiAgICBmdW5jdGlvbiB0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQob2JqKSB7CiAgICAgIGZ1bmN0aW9uIGdldEluc3RhbmNlVHlwZU5hbWUoaGFuZGxlKSB7CiAgICAgICAgcmV0dXJuIGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5uYW1lOwogICAgICB9CiAgICAgIHRocm93QmluZGluZ0Vycm9yKGdldEluc3RhbmNlVHlwZU5hbWUob2JqKSArICIgaW5zdGFuY2UgYWxyZWFkeSBkZWxldGVkIik7CiAgICB9CiAgICB2YXIgZmluYWxpemF0aW9uR3JvdXAgPSBmYWxzZTsKICAgIGZ1bmN0aW9uIGRldGFjaEZpbmFsaXplcihoYW5kbGUpIHsKICAgIH0KICAgIGZ1bmN0aW9uIHJ1bkRlc3RydWN0b3IoJCQpIHsKICAgICAgaWYgKCQkLnNtYXJ0UHRyKSB7CiAgICAgICAgJCQuc21hcnRQdHJUeXBlLnJhd0Rlc3RydWN0b3IoJCQuc21hcnRQdHIpOwogICAgICB9IGVsc2UgewogICAgICAgICQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoJCQucHRyKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gcmVsZWFzZUNsYXNzSGFuZGxlKCQkKSB7CiAgICAgICQkLmNvdW50LnZhbHVlIC09IDE7CiAgICAgIHZhciB0b0RlbGV0ZSA9IDAgPT09ICQkLmNvdW50LnZhbHVlOwogICAgICBpZiAodG9EZWxldGUpIHsKICAgICAgICBydW5EZXN0cnVjdG9yKCQkKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gYXR0YWNoRmluYWxpemVyKGhhbmRsZSkgewogICAgICBpZiAoInVuZGVmaW5lZCIgPT09IHR5cGVvZiBGaW5hbGl6YXRpb25Hcm91cCkgewogICAgICAgIGF0dGFjaEZpbmFsaXplciA9IGZ1bmN0aW9uKGhhbmRsZTIpIHsKICAgICAgICAgIHJldHVybiBoYW5kbGUyOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIGhhbmRsZTsKICAgICAgfQogICAgICBmaW5hbGl6YXRpb25Hcm91cCA9IG5ldyBGaW5hbGl6YXRpb25Hcm91cChmdW5jdGlvbihpdGVyKSB7CiAgICAgICAgZm9yICh2YXIgcmVzdWx0ID0gaXRlci5uZXh0KCk7ICFyZXN1bHQuZG9uZTsgcmVzdWx0ID0gaXRlci5uZXh0KCkpIHsKICAgICAgICAgIHZhciAkJCA9IHJlc3VsdC52YWx1ZTsKICAgICAgICAgIGlmICghJCQucHRyKSB7CiAgICAgICAgICAgIGNvbnNvbGUud2Fybigib2JqZWN0IGFscmVhZHkgZGVsZXRlZDogIiArICQkLnB0cik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZWxlYXNlQ2xhc3NIYW5kbGUoJCQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGF0dGFjaEZpbmFsaXplciA9IGZ1bmN0aW9uKGhhbmRsZTIpIHsKICAgICAgICBmaW5hbGl6YXRpb25Hcm91cC5yZWdpc3RlcihoYW5kbGUyLCBoYW5kbGUyLiQkLCBoYW5kbGUyLiQkKTsKICAgICAgICByZXR1cm4gaGFuZGxlMjsKICAgICAgfTsKICAgICAgZGV0YWNoRmluYWxpemVyID0gZnVuY3Rpb24oaGFuZGxlMikgewogICAgICAgIGZpbmFsaXphdGlvbkdyb3VwLnVucmVnaXN0ZXIoaGFuZGxlMi4kJCk7CiAgICAgIH07CiAgICAgIHJldHVybiBhdHRhY2hGaW5hbGl6ZXIoaGFuZGxlKTsKICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2Nsb25lKCkgewogICAgICBpZiAoIXRoaXMuJCQucHRyKSB7CiAgICAgICAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpOwogICAgICB9CiAgICAgIGlmICh0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKSB7CiAgICAgICAgdGhpcy4kJC5jb3VudC52YWx1ZSArPSAxOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9IGVsc2UgewogICAgICAgIHZhciBjbG9uZSA9IGF0dGFjaEZpbmFsaXplcigKICAgICAgICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7CiAgICAgICAgICAgICQkOiB7CiAgICAgICAgICAgICAgdmFsdWU6IHNoYWxsb3dDb3B5SW50ZXJuYWxQb2ludGVyKHRoaXMuJCQpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgKTsKICAgICAgICBjbG9uZS4kJC5jb3VudC52YWx1ZSArPSAxOwogICAgICAgIGNsb25lLiQkLmRlbGV0ZVNjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgIHJldHVybiBjbG9uZTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gQ2xhc3NIYW5kbGVfZGVsZXRlKCkgewogICAgICBpZiAoIXRoaXMuJCQucHRyKSB7CiAgICAgICAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpOwogICAgICB9CiAgICAgIGlmICh0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uIik7CiAgICAgIH0KICAgICAgZGV0YWNoRmluYWxpemVyKHRoaXMpOwogICAgICByZWxlYXNlQ2xhc3NIYW5kbGUodGhpcy4kJCk7CiAgICAgIGlmICghdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRoaXMuJCQuc21hcnRQdHIgPSB2b2lkIDA7CiAgICAgICAgdGhpcy4kJC5wdHIgPSB2b2lkIDA7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2lzRGVsZXRlZCgpIHsKICAgICAgcmV0dXJuICF0aGlzLiQkLnB0cjsKICAgIH0KICAgIHZhciBkZWxheUZ1bmN0aW9uID0gdm9pZCAwOwogICAgdmFyIGRlbGV0aW9uUXVldWUgPSBbXTsKICAgIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0RlbGV0ZXMoKSB7CiAgICAgIHdoaWxlIChkZWxldGlvblF1ZXVlLmxlbmd0aCkgewogICAgICAgIHZhciBvYmogPSBkZWxldGlvblF1ZXVlLnBvcCgpOwogICAgICAgIG9iai4kJC5kZWxldGVTY2hlZHVsZWQgPSBmYWxzZTsKICAgICAgICBvYmpbImRlbGV0ZSJdKCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2RlbGV0ZUxhdGVyKCkgewogICAgICBpZiAoIXRoaXMuJCQucHRyKSB7CiAgICAgICAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpOwogICAgICB9CiAgICAgIGlmICh0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uIik7CiAgICAgIH0KICAgICAgZGVsZXRpb25RdWV1ZS5wdXNoKHRoaXMpOwogICAgICBpZiAoZGVsZXRpb25RdWV1ZS5sZW5ndGggPT09IDEgJiYgZGVsYXlGdW5jdGlvbikgewogICAgICAgIGRlbGF5RnVuY3Rpb24oZmx1c2hQZW5kaW5nRGVsZXRlcyk7CiAgICAgIH0KICAgICAgdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgPSB0cnVlOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIGZ1bmN0aW9uIGluaXRfQ2xhc3NIYW5kbGUoKSB7CiAgICAgIENsYXNzSGFuZGxlLnByb3RvdHlwZVsiaXNBbGlhc09mIl0gPSBDbGFzc0hhbmRsZV9pc0FsaWFzT2Y7CiAgICAgIENsYXNzSGFuZGxlLnByb3RvdHlwZVsiY2xvbmUiXSA9IENsYXNzSGFuZGxlX2Nsb25lOwogICAgICBDbGFzc0hhbmRsZS5wcm90b3R5cGVbImRlbGV0ZSJdID0gQ2xhc3NIYW5kbGVfZGVsZXRlOwogICAgICBDbGFzc0hhbmRsZS5wcm90b3R5cGVbImlzRGVsZXRlZCJdID0gQ2xhc3NIYW5kbGVfaXNEZWxldGVkOwogICAgICBDbGFzc0hhbmRsZS5wcm90b3R5cGVbImRlbGV0ZUxhdGVyIl0gPSBDbGFzc0hhbmRsZV9kZWxldGVMYXRlcjsKICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlKCkgewogICAgfQogICAgdmFyIHJlZ2lzdGVyZWRQb2ludGVycyA9IHt9OwogICAgZnVuY3Rpb24gZW5zdXJlT3ZlcmxvYWRUYWJsZShwcm90bywgbWV0aG9kTmFtZSwgaHVtYW5OYW1lKSB7CiAgICAgIGlmICh2b2lkIDAgPT09IHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpIHsKICAgICAgICB2YXIgcHJldkZ1bmMgPSBwcm90b1ttZXRob2ROYW1lXTsKICAgICAgICBwcm90b1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCFwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpKSB7CiAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgICAgICJGdW5jdGlvbiAnIiArIGh1bWFuTmFtZSArICInIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyAoIiArIGFyZ3VtZW50cy5sZW5ndGggKyAiKSAtIGV4cGVjdHMgb25lIG9mICgiICsgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSArICIpISIKICAgICAgICAgICAgKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgfTsKICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlID0gW107CiAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVtwcmV2RnVuYy5hcmdDb3VudF0gPSBwcmV2RnVuYzsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZXhwb3NlUHVibGljU3ltYm9sKG5hbWUsIHZhbHVlLCBudW1Bcmd1bWVudHMpIHsKICAgICAgaWYgKE1vZHVsZTIuaGFzT3duUHJvcGVydHkobmFtZSkpIHsKICAgICAgICBpZiAodm9pZCAwID09PSBudW1Bcmd1bWVudHMgfHwgdm9pZCAwICE9PSBNb2R1bGUyW25hbWVdLm92ZXJsb2FkVGFibGUgJiYgdm9pZCAwICE9PSBNb2R1bGUyW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSkgewogICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCByZWdpc3RlciBwdWJsaWMgbmFtZSAnIiArIG5hbWUgKyAiJyB0d2ljZSIpOwogICAgICAgIH0KICAgICAgICBlbnN1cmVPdmVybG9hZFRhYmxlKE1vZHVsZTIsIG5hbWUsIG5hbWUpOwogICAgICAgIGlmIChNb2R1bGUyLmhhc093blByb3BlcnR5KG51bUFyZ3VtZW50cykpIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgICAiQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoIiArIG51bUFyZ3VtZW50cyArICIpISIKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICAgIE1vZHVsZTJbbmFtZV0ub3ZlcmxvYWRUYWJsZVtudW1Bcmd1bWVudHNdID0gdmFsdWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgTW9kdWxlMltuYW1lXSA9IHZhbHVlOwogICAgICAgIGlmICh2b2lkIDAgIT09IG51bUFyZ3VtZW50cykgewogICAgICAgICAgTW9kdWxlMltuYW1lXS5udW1Bcmd1bWVudHMgPSBudW1Bcmd1bWVudHM7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkQ2xhc3MobmFtZSwgY29uc3RydWN0b3IsIGluc3RhbmNlUHJvdG90eXBlLCByYXdEZXN0cnVjdG9yLCBiYXNlQ2xhc3MsIGdldEFjdHVhbFR5cGUsIHVwY2FzdCwgZG93bmNhc3QpIHsKICAgICAgdGhpcy5uYW1lID0gbmFtZTsKICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yOwogICAgICB0aGlzLmluc3RhbmNlUHJvdG90eXBlID0gaW5zdGFuY2VQcm90b3R5cGU7CiAgICAgIHRoaXMucmF3RGVzdHJ1Y3RvciA9IHJhd0Rlc3RydWN0b3I7CiAgICAgIHRoaXMuYmFzZUNsYXNzID0gYmFzZUNsYXNzOwogICAgICB0aGlzLmdldEFjdHVhbFR5cGUgPSBnZXRBY3R1YWxUeXBlOwogICAgICB0aGlzLnVwY2FzdCA9IHVwY2FzdDsKICAgICAgdGhpcy5kb3duY2FzdCA9IGRvd25jYXN0OwogICAgICB0aGlzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zID0gW107CiAgICB9CiAgICBmdW5jdGlvbiB1cGNhc3RQb2ludGVyKHB0ciwgcHRyQ2xhc3MsIGRlc2lyZWRDbGFzcykgewogICAgICB3aGlsZSAocHRyQ2xhc3MgIT09IGRlc2lyZWRDbGFzcykgewogICAgICAgIGlmICghcHRyQ2xhc3MudXBjYXN0KSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigKICAgICAgICAgICAgIkV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgIiArIGRlc2lyZWRDbGFzcy5uYW1lICsgIiwgZ290IGFuIGluc3RhbmNlIG9mICIgKyBwdHJDbGFzcy5uYW1lCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBwdHIgPSBwdHJDbGFzcy51cGNhc3QocHRyKTsKICAgICAgICBwdHJDbGFzcyA9IHB0ckNsYXNzLmJhc2VDbGFzczsKICAgICAgfQogICAgICByZXR1cm4gcHRyOwogICAgfQogICAgZnVuY3Rpb24gY29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsIGhhbmRsZSkgewogICAgICBpZiAoaGFuZGxlID09PSBudWxsKSB7CiAgICAgICAgaWYgKHRoaXMuaXNSZWZlcmVuY2UpIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJudWxsIGlzIG5vdCBhIHZhbGlkICIgKyB0aGlzLm5hbWUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJyArIF9lbWJpbmRfcmVwcihoYW5kbGUpICsgJyIgYXMgYSAnICsgdGhpcy5uYW1lKTsKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJC5wdHIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIiArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgdmFyIGhhbmRsZUNsYXNzID0gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzOwogICAgICB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICByZXR1cm4gcHRyOwogICAgfQogICAgZnVuY3Rpb24gZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLCBoYW5kbGUpIHsKICAgICAgdmFyIHB0cjsKICAgICAgaWYgKGhhbmRsZSA9PT0gbnVsbCkgewogICAgICAgIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigibnVsbCBpcyBub3QgYSB2YWxpZCAiICsgdGhpcy5uYW1lKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICAgIHB0ciA9IHRoaXMucmF3Q29uc3RydWN0b3IoKTsKICAgICAgICAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkgewogICAgICAgICAgICBkZXN0cnVjdG9ycy5wdXNoKHRoaXMucmF3RGVzdHJ1Y3RvciwgcHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwdHI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJyArIF9lbWJpbmRfcmVwcihoYW5kbGUpICsgJyIgYXMgYSAnICsgdGhpcy5uYW1lKTsKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJC5wdHIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIiArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKCF0aGlzLmlzQ29uc3QgJiYgaGFuZGxlLiQkLnB0clR5cGUuaXNDb25zdCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIiArIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID8gaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogaGFuZGxlLiQkLnB0clR5cGUubmFtZSkgKyAiIHRvIHBhcmFtZXRlciB0eXBlICIgKyB0aGlzLm5hbWUKICAgICAgICApOwogICAgICB9CiAgICAgIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICBpZiAodGhpcy5pc1NtYXJ0UG9pbnRlcikgewogICAgICAgIGlmICh2b2lkIDAgPT09IGhhbmRsZS4kJC5zbWFydFB0cikgewogICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsIik7CiAgICAgICAgfQogICAgICAgIHN3aXRjaCAodGhpcy5zaGFyaW5nUG9saWN5KSB7CiAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgIGlmIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID09PSB0aGlzKSB7CiAgICAgICAgICAgICAgcHRyID0gaGFuZGxlLiQkLnNtYXJ0UHRyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgICAgICAgIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIiArIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID8gaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogaGFuZGxlLiQkLnB0clR5cGUubmFtZSkgKyAiIHRvIHBhcmFtZXRlciB0eXBlICIgKyB0aGlzLm5hbWUKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBwdHIgPSBoYW5kbGUuJCQuc21hcnRQdHI7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICBpZiAoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZSA9PT0gdGhpcykgewogICAgICAgICAgICAgIHB0ciA9IGhhbmRsZS4kJC5zbWFydFB0cjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgY2xvbmVkSGFuZGxlID0gaGFuZGxlWyJjbG9uZSJdKCk7CiAgICAgICAgICAgICAgcHRyID0gdGhpcy5yYXdTaGFyZSgKICAgICAgICAgICAgICAgIHB0ciwKICAgICAgICAgICAgICAgIF9fZW12YWxfcmVnaXN0ZXIoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIGNsb25lZEhhbmRsZVsiZGVsZXRlIl0oKTsKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHsKICAgICAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLCBwdHIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJVbnN1cHBvcnRpbmcgc2hhcmluZyBwb2xpY3kiKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHB0cjsKICAgIH0KICAgIGZ1bmN0aW9uIG5vbkNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLCBoYW5kbGUpIHsKICAgICAgaWYgKGhhbmRsZSA9PT0gbnVsbCkgewogICAgICAgIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigibnVsbCBpcyBub3QgYSB2YWxpZCAiICsgdGhpcy5uYW1lKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgIicgKyBfZW1iaW5kX3JlcHIoaGFuZGxlKSArICciIGFzIGEgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQucHRyKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICIgKyB0aGlzLm5hbWUpOwogICAgICB9CiAgICAgIGlmIChoYW5kbGUuJCQucHRyVHlwZS5pc0NvbnN0KSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoCiAgICAgICAgICAiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAiICsgaGFuZGxlLiQkLnB0clR5cGUubmFtZSArICIgdG8gcGFyYW1ldGVyIHR5cGUgIiArIHRoaXMubmFtZQogICAgICAgICk7CiAgICAgIH0KICAgICAgdmFyIGhhbmRsZUNsYXNzID0gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzOwogICAgICB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICByZXR1cm4gcHRyOwogICAgfQogICAgZnVuY3Rpb24gc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICByZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUFUzMltwb2ludGVyID4+IDJdKTsKICAgIH0KICAgIGZ1bmN0aW9uIFJlZ2lzdGVyZWRQb2ludGVyX2dldFBvaW50ZWUocHRyKSB7CiAgICAgIGlmICh0aGlzLnJhd0dldFBvaW50ZWUpIHsKICAgICAgICBwdHIgPSB0aGlzLnJhd0dldFBvaW50ZWUocHRyKTsKICAgICAgfQogICAgICByZXR1cm4gcHRyOwogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZGVzdHJ1Y3RvcihwdHIpIHsKICAgICAgaWYgKHRoaXMucmF3RGVzdHJ1Y3RvcikgewogICAgICAgIHRoaXMucmF3RGVzdHJ1Y3RvcihwdHIpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3QoaGFuZGxlKSB7CiAgICAgIGlmIChoYW5kbGUgIT09IG51bGwpIHsKICAgICAgICBoYW5kbGVbImRlbGV0ZSJdKCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGRvd25jYXN0UG9pbnRlcihwdHIsIHB0ckNsYXNzLCBkZXNpcmVkQ2xhc3MpIHsKICAgICAgaWYgKHB0ckNsYXNzID09PSBkZXNpcmVkQ2xhc3MpIHsKICAgICAgICByZXR1cm4gcHRyOwogICAgICB9CiAgICAgIGlmICh2b2lkIDAgPT09IGRlc2lyZWRDbGFzcy5iYXNlQ2xhc3MpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICB2YXIgcnYgPSBkb3duY2FzdFBvaW50ZXIocHRyLCBwdHJDbGFzcywgZGVzaXJlZENsYXNzLmJhc2VDbGFzcyk7CiAgICAgIGlmIChydiA9PT0gbnVsbCkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CiAgICAgIHJldHVybiBkZXNpcmVkQ2xhc3MuZG93bmNhc3QocnYpOwogICAgfQogICAgZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudCgpIHsKICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdGVyZWRJbnN0YW5jZXMpLmxlbmd0aDsKICAgIH0KICAgIGZ1bmN0aW9uIGdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXMoKSB7CiAgICAgIHZhciBydiA9IFtdOwogICAgICBmb3IgKHZhciBrIGluIHJlZ2lzdGVyZWRJbnN0YW5jZXMpIHsKICAgICAgICBpZiAocmVnaXN0ZXJlZEluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrKSkgewogICAgICAgICAgcnYucHVzaChyZWdpc3RlcmVkSW5zdGFuY2VzW2tdKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJ2OwogICAgfQogICAgZnVuY3Rpb24gc2V0RGVsYXlGdW5jdGlvbihmbikgewogICAgICBkZWxheUZ1bmN0aW9uID0gZm47CiAgICAgIGlmIChkZWxldGlvblF1ZXVlLmxlbmd0aCAmJiBkZWxheUZ1bmN0aW9uKSB7CiAgICAgICAgZGVsYXlGdW5jdGlvbihmbHVzaFBlbmRpbmdEZWxldGVzKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW5pdF9lbWJpbmQoKSB7CiAgICAgIE1vZHVsZTJbImdldEluaGVyaXRlZEluc3RhbmNlQ291bnQiXSA9IGdldEluaGVyaXRlZEluc3RhbmNlQ291bnQ7CiAgICAgIE1vZHVsZTJbImdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXMiXSA9IGdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXM7CiAgICAgIE1vZHVsZTJbImZsdXNoUGVuZGluZ0RlbGV0ZXMiXSA9IGZsdXNoUGVuZGluZ0RlbGV0ZXM7CiAgICAgIE1vZHVsZTJbInNldERlbGF5RnVuY3Rpb24iXSA9IHNldERlbGF5RnVuY3Rpb247CiAgICB9CiAgICB2YXIgcmVnaXN0ZXJlZEluc3RhbmNlcyA9IHt9OwogICAgZnVuY3Rpb24gZ2V0QmFzZXN0UG9pbnRlcihjbGFzc18sIHB0cikgewogICAgICBpZiAocHRyID09PSB2b2lkIDApIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkIik7CiAgICAgIH0KICAgICAgd2hpbGUgKGNsYXNzXy5iYXNlQ2xhc3MpIHsKICAgICAgICBwdHIgPSBjbGFzc18udXBjYXN0KHB0cik7CiAgICAgICAgY2xhc3NfID0gY2xhc3NfLmJhc2VDbGFzczsKICAgICAgfQogICAgICByZXR1cm4gcHRyOwogICAgfQogICAgZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2UoY2xhc3NfLCBwdHIpIHsKICAgICAgcHRyID0gZ2V0QmFzZXN0UG9pbnRlcihjbGFzc18sIHB0cik7CiAgICAgIHJldHVybiByZWdpc3RlcmVkSW5zdGFuY2VzW3B0cl07CiAgICB9CiAgICBmdW5jdGlvbiBtYWtlQ2xhc3NIYW5kbGUocHJvdG90eXBlLCByZWNvcmQpIHsKICAgICAgaWYgKCFyZWNvcmQucHRyVHlwZSB8fCAhcmVjb3JkLnB0cikgewogICAgICAgIHRocm93SW50ZXJuYWxFcnJvcigibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZSIpOwogICAgICB9CiAgICAgIHZhciBoYXNTbWFydFB0clR5cGUgPSAhIXJlY29yZC5zbWFydFB0clR5cGU7CiAgICAgIHZhciBoYXNTbWFydFB0ciA9ICEhcmVjb3JkLnNtYXJ0UHRyOwogICAgICBpZiAoaGFzU21hcnRQdHJUeXBlICE9PSBoYXNTbWFydFB0cikgewogICAgICAgIHRocm93SW50ZXJuYWxFcnJvcigiQm90aCBzbWFydFB0clR5cGUgYW5kIHNtYXJ0UHRyIG11c3QgYmUgc3BlY2lmaWVkIik7CiAgICAgIH0KICAgICAgcmVjb3JkLmNvdW50ID0gewogICAgICAgIHZhbHVlOiAxCiAgICAgIH07CiAgICAgIHJldHVybiBhdHRhY2hGaW5hbGl6ZXIoCiAgICAgICAgT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUsIHsKICAgICAgICAgICQkOiB7CiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQKICAgICAgICAgIH0KICAgICAgICB9KQogICAgICApOwogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlKHB0cikgewogICAgICB2YXIgcmF3UG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlZShwdHIpOwogICAgICBpZiAoIXJhd1BvaW50ZXIpIHsKICAgICAgICB0aGlzLmRlc3RydWN0b3IocHRyKTsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICB2YXIgcmVnaXN0ZXJlZEluc3RhbmNlID0gZ2V0SW5oZXJpdGVkSW5zdGFuY2UodGhpcy5yZWdpc3RlcmVkQ2xhc3MsIHJhd1BvaW50ZXIpOwogICAgICBpZiAodm9pZCAwICE9PSByZWdpc3RlcmVkSW5zdGFuY2UpIHsKICAgICAgICBpZiAoMCA9PT0gcmVnaXN0ZXJlZEluc3RhbmNlLiQkLmNvdW50LnZhbHVlKSB7CiAgICAgICAgICByZWdpc3RlcmVkSW5zdGFuY2UuJCQucHRyID0gcmF3UG9pbnRlcjsKICAgICAgICAgIHJlZ2lzdGVyZWRJbnN0YW5jZS4kJC5zbWFydFB0ciA9IHB0cjsKICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkSW5zdGFuY2VbImNsb25lIl0oKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIHJ2ID0gcmVnaXN0ZXJlZEluc3RhbmNlWyJjbG9uZSJdKCk7CiAgICAgICAgICB0aGlzLmRlc3RydWN0b3IocHRyKTsKICAgICAgICAgIHJldHVybiBydjsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbWFrZURlZmF1bHRIYW5kbGUoKSB7CiAgICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICAgIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHsKICAgICAgICAgICAgcHRyVHlwZTogdGhpcy5wb2ludGVlVHlwZSwKICAgICAgICAgICAgcHRyOiByYXdQb2ludGVyLAogICAgICAgICAgICBzbWFydFB0clR5cGU6IHRoaXMsCiAgICAgICAgICAgIHNtYXJ0UHRyOiBwdHIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7CiAgICAgICAgICAgIHB0clR5cGU6IHRoaXMsCiAgICAgICAgICAgIHB0cgogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBhY3R1YWxUeXBlID0gdGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZShyYXdQb2ludGVyKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkID0gcmVnaXN0ZXJlZFBvaW50ZXJzW2FjdHVhbFR5cGVdOwogICAgICBpZiAoIXJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkKSB7CiAgICAgICAgcmV0dXJuIG1ha2VEZWZhdWx0SGFuZGxlLmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgdmFyIHRvVHlwZTsKICAgICAgaWYgKHRoaXMuaXNDb25zdCkgewogICAgICAgIHRvVHlwZSA9IHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkLmNvbnN0UG9pbnRlclR5cGU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdG9UeXBlID0gcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQucG9pbnRlclR5cGU7CiAgICAgIH0KICAgICAgdmFyIGRwID0gZG93bmNhc3RQb2ludGVyKHJhd1BvaW50ZXIsIHRoaXMucmVnaXN0ZXJlZENsYXNzLCB0b1R5cGUucmVnaXN0ZXJlZENsYXNzKTsKICAgICAgaWYgKGRwID09PSBudWxsKSB7CiAgICAgICAgcmV0dXJuIG1ha2VEZWZhdWx0SGFuZGxlLmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICByZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHsKICAgICAgICAgIHB0clR5cGU6IHRvVHlwZSwKICAgICAgICAgIHB0cjogZHAsCiAgICAgICAgICBzbWFydFB0clR5cGU6IHRoaXMsCiAgICAgICAgICBzbWFydFB0cjogcHRyCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0b1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7CiAgICAgICAgICBwdHJUeXBlOiB0b1R5cGUsCiAgICAgICAgICBwdHI6IGRwCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGluaXRfUmVnaXN0ZXJlZFBvaW50ZXIoKSB7CiAgICAgIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZS5nZXRQb2ludGVlID0gUmVnaXN0ZXJlZFBvaW50ZXJfZ2V0UG9pbnRlZTsKICAgICAgUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlLmRlc3RydWN0b3IgPSBSZWdpc3RlcmVkUG9pbnRlcl9kZXN0cnVjdG9yOwogICAgICBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbImFyZ1BhY2tBZHZhbmNlIl0gPSA4OwogICAgICBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbInJlYWRWYWx1ZUZyb21Qb2ludGVyIl0gPSBzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcjsKICAgICAgUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlWyJkZWxldGVPYmplY3QiXSA9IFJlZ2lzdGVyZWRQb2ludGVyX2RlbGV0ZU9iamVjdDsKICAgICAgUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlWyJmcm9tV2lyZVR5cGUiXSA9IFJlZ2lzdGVyZWRQb2ludGVyX2Zyb21XaXJlVHlwZTsKICAgIH0KICAgIGZ1bmN0aW9uIFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUsIHJlZ2lzdGVyZWRDbGFzcywgaXNSZWZlcmVuY2UsIGlzQ29uc3QsIGlzU21hcnRQb2ludGVyLCBwb2ludGVlVHlwZSwgc2hhcmluZ1BvbGljeSwgcmF3R2V0UG9pbnRlZSwgcmF3Q29uc3RydWN0b3IsIHJhd1NoYXJlLCByYXdEZXN0cnVjdG9yKSB7CiAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgIHRoaXMucmVnaXN0ZXJlZENsYXNzID0gcmVnaXN0ZXJlZENsYXNzOwogICAgICB0aGlzLmlzUmVmZXJlbmNlID0gaXNSZWZlcmVuY2U7CiAgICAgIHRoaXMuaXNDb25zdCA9IGlzQ29uc3Q7CiAgICAgIHRoaXMuaXNTbWFydFBvaW50ZXIgPSBpc1NtYXJ0UG9pbnRlcjsKICAgICAgdGhpcy5wb2ludGVlVHlwZSA9IHBvaW50ZWVUeXBlOwogICAgICB0aGlzLnNoYXJpbmdQb2xpY3kgPSBzaGFyaW5nUG9saWN5OwogICAgICB0aGlzLnJhd0dldFBvaW50ZWUgPSByYXdHZXRQb2ludGVlOwogICAgICB0aGlzLnJhd0NvbnN0cnVjdG9yID0gcmF3Q29uc3RydWN0b3I7CiAgICAgIHRoaXMucmF3U2hhcmUgPSByYXdTaGFyZTsKICAgICAgdGhpcy5yYXdEZXN0cnVjdG9yID0gcmF3RGVzdHJ1Y3RvcjsKICAgICAgaWYgKCFpc1NtYXJ0UG9pbnRlciAmJiByZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzID09PSB2b2lkIDApIHsKICAgICAgICBpZiAoaXNDb25zdCkgewogICAgICAgICAgdGhpc1sidG9XaXJlVHlwZSJdID0gY29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGU7CiAgICAgICAgICB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXNbInRvV2lyZVR5cGUiXSA9IG5vbkNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlOwogICAgICAgICAgdGhpcy5kZXN0cnVjdG9yRnVuY3Rpb24gPSBudWxsOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzWyJ0b1dpcmVUeXBlIl0gPSBnZW5lcmljUG9pbnRlclRvV2lyZVR5cGU7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHJlcGxhY2VQdWJsaWNTeW1ib2wobmFtZSwgdmFsdWUsIG51bUFyZ3VtZW50cykgewogICAgICBpZiAoIU1vZHVsZTIuaGFzT3duUHJvcGVydHkobmFtZSkpIHsKICAgICAgICB0aHJvd0ludGVybmFsRXJyb3IoIlJlcGxhY2luZyBub25leGlzdGFudCBwdWJsaWMgc3ltYm9sIik7CiAgICAgIH0KICAgICAgaWYgKHZvaWQgMCAhPT0gTW9kdWxlMltuYW1lXS5vdmVybG9hZFRhYmxlICYmIHZvaWQgMCAhPT0gbnVtQXJndW1lbnRzKSB7CiAgICAgICAgTW9kdWxlMltuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10gPSB2YWx1ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBNb2R1bGUyW25hbWVdID0gdmFsdWU7CiAgICAgICAgTW9kdWxlMltuYW1lXS5hcmdDb3VudCA9IG51bUFyZ3VtZW50czsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oc2lnbmF0dXJlLCByYXdGdW5jdGlvbikgewogICAgICBzaWduYXR1cmUgPSByZWFkTGF0aW4xU3RyaW5nKHNpZ25hdHVyZSk7CiAgICAgIGZ1bmN0aW9uIG1ha2VEeW5DYWxsZXIoZHluQ2FsbDIpIHsKICAgICAgICB2YXIgYXJncyA9IFtdOwogICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBhcmdzLnB1c2goImEiICsgaSk7CiAgICAgICAgfQogICAgICAgIHZhciBuYW1lID0gImR5bkNhbGxfIiArIHNpZ25hdHVyZSArICJfIiArIHJhd0Z1bmN0aW9uOwogICAgICAgIHZhciBib2R5ID0gInJldHVybiBmdW5jdGlvbiAiICsgbmFtZSArICIoIiArIGFyZ3Muam9pbigiLCAiKSArICIpIHtcbiI7CiAgICAgICAgYm9keSArPSAiICAgIHJldHVybiBkeW5DYWxsKHJhd0Z1bmN0aW9uIiArIChhcmdzLmxlbmd0aCA/ICIsICIgOiAiIikgKyBhcmdzLmpvaW4oIiwgIikgKyAiKTtcbiI7CiAgICAgICAgYm9keSArPSAifTtcbiI7CiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigiZHluQ2FsbCIsICJyYXdGdW5jdGlvbiIsIGJvZHkpKGR5bkNhbGwyLCByYXdGdW5jdGlvbik7CiAgICAgIH0KICAgICAgdmFyIGRjID0gTW9kdWxlMlsiZHluQ2FsbF8iICsgc2lnbmF0dXJlXTsKICAgICAgdmFyIGZwID0gbWFrZUR5bkNhbGxlcihkYyk7CiAgICAgIGlmICh0eXBlb2YgZnAgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigKICAgICAgICAgICJ1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgIiArIHNpZ25hdHVyZSArICI6ICIgKyByYXdGdW5jdGlvbgogICAgICAgICk7CiAgICAgIH0KICAgICAgcmV0dXJuIGZwOwogICAgfQogICAgdmFyIFVuYm91bmRUeXBlRXJyb3IgPSB2b2lkIDA7CiAgICBmdW5jdGlvbiBnZXRUeXBlTmFtZSh0eXBlKSB7CiAgICAgIHZhciBwdHIgPSBfX19nZXRUeXBlTmFtZSh0eXBlKTsKICAgICAgdmFyIHJ2ID0gcmVhZExhdGluMVN0cmluZyhwdHIpOwogICAgICBfZnJlZShwdHIpOwogICAgICByZXR1cm4gcnY7CiAgICB9CiAgICBmdW5jdGlvbiB0aHJvd1VuYm91bmRUeXBlRXJyb3IobWVzc2FnZSwgdHlwZXMpIHsKICAgICAgdmFyIHVuYm91bmRUeXBlcyA9IFtdOwogICAgICB2YXIgc2VlbiA9IHt9OwogICAgICBmdW5jdGlvbiB2aXNpdCh0eXBlKSB7CiAgICAgICAgaWYgKHNlZW5bdHlwZV0pIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgaWYgKHJlZ2lzdGVyZWRUeXBlc1t0eXBlXSkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZURlcGVuZGVuY2llc1t0eXBlXSkgewogICAgICAgICAgdHlwZURlcGVuZGVuY2llc1t0eXBlXS5mb3JFYWNoKHZpc2l0KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgdW5ib3VuZFR5cGVzLnB1c2godHlwZSk7CiAgICAgICAgc2Vlblt0eXBlXSA9IHRydWU7CiAgICAgIH0KICAgICAgdHlwZXMuZm9yRWFjaCh2aXNpdCk7CiAgICAgIHRocm93IG5ldyBVbmJvdW5kVHlwZUVycm9yKG1lc3NhZ2UgKyAiOiAiICsgdW5ib3VuZFR5cGVzLm1hcChnZXRUeXBlTmFtZSkuam9pbihbIiwgIl0pKTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzKHJhd1R5cGUsIHJhd1BvaW50ZXJUeXBlLCByYXdDb25zdFBvaW50ZXJUeXBlLCBiYXNlQ2xhc3NSYXdUeXBlLCBnZXRBY3R1YWxUeXBlU2lnbmF0dXJlLCBnZXRBY3R1YWxUeXBlLCB1cGNhc3RTaWduYXR1cmUsIHVwY2FzdCwgZG93bmNhc3RTaWduYXR1cmUsIGRvd25jYXN0LCBuYW1lLCBkZXN0cnVjdG9yU2lnbmF0dXJlLCByYXdEZXN0cnVjdG9yKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICBnZXRBY3R1YWxUeXBlID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSwgZ2V0QWN0dWFsVHlwZSk7CiAgICAgIGlmICh1cGNhc3QpIHsKICAgICAgICB1cGNhc3QgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbih1cGNhc3RTaWduYXR1cmUsIHVwY2FzdCk7CiAgICAgIH0KICAgICAgaWYgKGRvd25jYXN0KSB7CiAgICAgICAgZG93bmNhc3QgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkb3duY2FzdFNpZ25hdHVyZSwgZG93bmNhc3QpOwogICAgICB9CiAgICAgIHJhd0Rlc3RydWN0b3IgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLCByYXdEZXN0cnVjdG9yKTsKICAgICAgdmFyIGxlZ2FsRnVuY3Rpb25OYW1lID0gbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpOwogICAgICBleHBvc2VQdWJsaWNTeW1ib2wobGVnYWxGdW5jdGlvbk5hbWUsIGZ1bmN0aW9uKCkgewogICAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcigiQ2Fubm90IGNvbnN0cnVjdCAiICsgbmFtZSArICIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLCBbCiAgICAgICAgICBiYXNlQ2xhc3NSYXdUeXBlCiAgICAgICAgXSk7CiAgICAgIH0pOwogICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZCgKICAgICAgICBbcmF3VHlwZSwgcmF3UG9pbnRlclR5cGUsIHJhd0NvbnN0UG9pbnRlclR5cGVdLAogICAgICAgIGJhc2VDbGFzc1Jhd1R5cGUgPyBbYmFzZUNsYXNzUmF3VHlwZV0gOiBbXSwKICAgICAgICBmdW5jdGlvbihiYXNlKSB7CiAgICAgICAgICBiYXNlID0gYmFzZVswXTsKICAgICAgICAgIHZhciBiYXNlQ2xhc3M7CiAgICAgICAgICB2YXIgYmFzZVByb3RvdHlwZTsKICAgICAgICAgIGlmIChiYXNlQ2xhc3NSYXdUeXBlKSB7CiAgICAgICAgICAgIGJhc2VDbGFzcyA9IGJhc2UucmVnaXN0ZXJlZENsYXNzOwogICAgICAgICAgICBiYXNlUHJvdG90eXBlID0gYmFzZUNsYXNzLmluc3RhbmNlUHJvdG90eXBlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmFzZVByb3RvdHlwZSA9IENsYXNzSGFuZGxlLnByb3RvdHlwZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGNyZWF0ZU5hbWVkRnVuY3Rpb24obGVnYWxGdW5jdGlvbk5hbWUsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBpbnN0YW5jZVByb3RvdHlwZSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IoIlVzZSAnbmV3JyB0byBjb25zdHJ1Y3QgIiArIG5hbWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcihuYW1lICsgIiBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvciIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBib2R5ID0gcmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJndW1lbnRzLmxlbmd0aF07CiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGJvZHkpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKAogICAgICAgICAgICAgICAgIlRyaWVkIHRvIGludm9rZSBjdG9yIG9mICIgKyBuYW1lICsgIiB3aXRoIGludmFsaWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCIgKyBhcmd1bWVudHMubGVuZ3RoICsgIikgLSBleHBlY3RlZCAoIiArIE9iamVjdC5rZXlzKHJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KS50b1N0cmluZygpICsgIikgcGFyYW1ldGVycyBpbnN0ZWFkISIKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBpbnN0YW5jZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3RvdHlwZSwgewogICAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICAgIHZhbHVlOiBjb25zdHJ1Y3RvcgogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGluc3RhbmNlUHJvdG90eXBlOwogICAgICAgICAgdmFyIHJlZ2lzdGVyZWRDbGFzcyA9IG5ldyBSZWdpc3RlcmVkQ2xhc3MoCiAgICAgICAgICAgIG5hbWUsCiAgICAgICAgICAgIGNvbnN0cnVjdG9yLAogICAgICAgICAgICBpbnN0YW5jZVByb3RvdHlwZSwKICAgICAgICAgICAgcmF3RGVzdHJ1Y3RvciwKICAgICAgICAgICAgYmFzZUNsYXNzLAogICAgICAgICAgICBnZXRBY3R1YWxUeXBlLAogICAgICAgICAgICB1cGNhc3QsCiAgICAgICAgICAgIGRvd25jYXN0CiAgICAgICAgICApOwogICAgICAgICAgdmFyIHJlZmVyZW5jZUNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lLCByZWdpc3RlcmVkQ2xhc3MsIHRydWUsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICB2YXIgcG9pbnRlckNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcigKICAgICAgICAgICAgbmFtZSArICIqIiwKICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzLAogICAgICAgICAgICBmYWxzZSwKICAgICAgICAgICAgZmFsc2UsCiAgICAgICAgICAgIGZhbHNlCiAgICAgICAgICApOwogICAgICAgICAgdmFyIGNvbnN0UG9pbnRlckNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcigKICAgICAgICAgICAgbmFtZSArICIgY29uc3QqIiwKICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzLAogICAgICAgICAgICBmYWxzZSwKICAgICAgICAgICAgdHJ1ZSwKICAgICAgICAgICAgZmFsc2UKICAgICAgICAgICk7CiAgICAgICAgICByZWdpc3RlcmVkUG9pbnRlcnNbcmF3VHlwZV0gPSB7CiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyQ29udmVydGVyLAogICAgICAgICAgICBjb25zdFBvaW50ZXJUeXBlOiBjb25zdFBvaW50ZXJDb252ZXJ0ZXIKICAgICAgICAgIH07CiAgICAgICAgICByZXBsYWNlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLCBjb25zdHJ1Y3Rvcik7CiAgICAgICAgICByZXR1cm4gW3JlZmVyZW5jZUNvbnZlcnRlciwgcG9pbnRlckNvbnZlcnRlciwgY29uc3RQb2ludGVyQ29udmVydGVyXTsKICAgICAgICB9CiAgICAgICk7CiAgICB9CiAgICBmdW5jdGlvbiBoZWFwMzJWZWN0b3JUb0FycmF5KGNvdW50LCBmaXJzdEVsZW1lbnQpIHsKICAgICAgdmFyIGFycmF5ID0gW107CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgewogICAgICAgIGFycmF5LnB1c2goSEVBUDMyWyhmaXJzdEVsZW1lbnQgPj4gMikgKyBpXSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGFycmF5OwogICAgfQogICAgZnVuY3Rpb24gcnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpIHsKICAgICAgd2hpbGUgKGRlc3RydWN0b3JzLmxlbmd0aCkgewogICAgICAgIHZhciBwdHIgPSBkZXN0cnVjdG9ycy5wb3AoKTsKICAgICAgICB2YXIgZGVsID0gZGVzdHJ1Y3RvcnMucG9wKCk7CiAgICAgICAgZGVsKHB0cik7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yKHJhd0NsYXNzVHlwZSwgYXJnQ291bnQsIHJhd0FyZ1R5cGVzQWRkciwgaW52b2tlclNpZ25hdHVyZSwgaW52b2tlciwgcmF3Q29uc3RydWN0b3IpIHsKICAgICAgYXNzZXJ0KGFyZ0NvdW50ID4gMCk7CiAgICAgIHZhciByYXdBcmdUeXBlcyA9IGhlYXAzMlZlY3RvclRvQXJyYXkoYXJnQ291bnQsIHJhd0FyZ1R5cGVzQWRkcik7CiAgICAgIGludm9rZXIgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihpbnZva2VyU2lnbmF0dXJlLCBpbnZva2VyKTsKICAgICAgdmFyIGFyZ3MgPSBbcmF3Q29uc3RydWN0b3JdOwogICAgICB2YXIgZGVzdHJ1Y3RvcnMgPSBbXTsKICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFtyYXdDbGFzc1R5cGVdLCBmdW5jdGlvbihjbGFzc1R5cGUpIHsKICAgICAgICBjbGFzc1R5cGUgPSBjbGFzc1R5cGVbMF07CiAgICAgICAgdmFyIGh1bWFuTmFtZSA9ICJjb25zdHJ1Y3RvciAiICsgY2xhc3NUeXBlLm5hbWU7CiAgICAgICAgaWYgKHZvaWQgMCA9PT0gY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KSB7CiAgICAgICAgICBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkgPSBbXTsKICAgICAgICB9CiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50IC0gMV0pIHsKICAgICAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IoCiAgICAgICAgICAgICJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgiICsgKGFyZ0NvdW50IC0gMSkgKyAiKSBmb3IgY2xhc3MgJyIgKyBjbGFzc1R5cGUubmFtZSArICInISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyEiCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQgLSAxXSA9IGZ1bmN0aW9uIHVuYm91bmRUeXBlSGFuZGxlcigpIHsKICAgICAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcigKICAgICAgICAgICAgIkNhbm5vdCBjb25zdHJ1Y3QgIiArIGNsYXNzVHlwZS5uYW1lICsgIiBkdWUgdG8gdW5ib3VuZCB0eXBlcyIsCiAgICAgICAgICAgIHJhd0FyZ1R5cGVzCiAgICAgICAgICApOwogICAgICAgIH07CiAgICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIHJhd0FyZ1R5cGVzLCBmdW5jdGlvbihhcmdUeXBlcykgewogICAgICAgICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50IC0gMV0gPSBmdW5jdGlvbiBjb25zdHJ1Y3Rvcl9ib2R5KCkgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gYXJnQ291bnQgLSAxKSB7CiAgICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoCiAgICAgICAgICAgICAgICBodW1hbk5hbWUgKyAiIGNhbGxlZCB3aXRoICIgKyBhcmd1bWVudHMubGVuZ3RoICsgIiBhcmd1bWVudHMsIGV4cGVjdGVkICIgKyAoYXJnQ291bnQgLSAxKQogICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGVzdHJ1Y3RvcnMubGVuZ3RoID0gMDsKICAgICAgICAgICAgYXJncy5sZW5ndGggPSBhcmdDb3VudDsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdDb3VudDsgKytpKSB7CiAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ1R5cGVzW2ldWyJ0b1dpcmVUeXBlIl0oZGVzdHJ1Y3RvcnMsIGFyZ3VtZW50c1tpIC0gMV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBwdHIgPSBpbnZva2VyLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgICAgICAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7CiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlc1swXVsiZnJvbVdpcmVUeXBlIl0ocHRyKTsKICAgICAgICAgIH07CiAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIG5ld18oY29uc3RydWN0b3IsIGFyZ3VtZW50TGlzdCkgewogICAgICBpZiAoIShjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAibmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICIgKyB0eXBlb2YgY29uc3RydWN0b3IgKyAiIHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uIgogICAgICAgICk7CiAgICAgIH0KICAgICAgdmFyIGR1bW15ID0gY3JlYXRlTmFtZWRGdW5jdGlvbihjb25zdHJ1Y3Rvci5uYW1lIHx8ICJ1bmtub3duRnVuY3Rpb25OYW1lIiwgZnVuY3Rpb24oKSB7CiAgICAgIH0pOwogICAgICBkdW1teS5wcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7CiAgICAgIHZhciBvYmogPSBuZXcgZHVtbXkoKTsKICAgICAgdmFyIHIgPSBjb25zdHJ1Y3Rvci5hcHBseShvYmosIGFyZ3VtZW50TGlzdCk7CiAgICAgIHJldHVybiByIGluc3RhbmNlb2YgT2JqZWN0ID8gciA6IG9iajsKICAgIH0KICAgIGZ1bmN0aW9uIGNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSwgYXJnVHlwZXMsIGNsYXNzVHlwZSwgY3BwSW52b2tlckZ1bmMsIGNwcFRhcmdldEZ1bmMpIHsKICAgICAgdmFyIGFyZ0NvdW50ID0gYXJnVHlwZXMubGVuZ3RoOwogICAgICBpZiAoYXJnQ291bnQgPCAyKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoCiAgICAgICAgICAiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhIgogICAgICAgICk7CiAgICAgIH0KICAgICAgdmFyIGlzQ2xhc3NNZXRob2RGdW5jID0gYXJnVHlwZXNbMV0gIT09IG51bGwgJiYgY2xhc3NUeXBlICE9PSBudWxsOwogICAgICB2YXIgbmVlZHNEZXN0cnVjdG9yU3RhY2sgPSBmYWxzZTsKICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdUeXBlcy5sZW5ndGg7ICsraSkgewogICAgICAgIGlmIChhcmdUeXBlc1tpXSAhPT0gbnVsbCAmJiBhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24gPT09IHZvaWQgMCkgewogICAgICAgICAgbmVlZHNEZXN0cnVjdG9yU3RhY2sgPSB0cnVlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciByZXR1cm5zID0gYXJnVHlwZXNbMF0ubmFtZSAhPT0gInZvaWQiOwogICAgICB2YXIgYXJnc0xpc3QgPSAiIjsKICAgICAgdmFyIGFyZ3NMaXN0V2lyZWQgPSAiIjsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudCAtIDI7ICsraSkgewogICAgICAgIGFyZ3NMaXN0ICs9IChpICE9PSAwID8gIiwgIiA6ICIiKSArICJhcmciICsgaTsKICAgICAgICBhcmdzTGlzdFdpcmVkICs9IChpICE9PSAwID8gIiwgIiA6ICIiKSArICJhcmciICsgaSArICJXaXJlZCI7CiAgICAgIH0KICAgICAgdmFyIGludm9rZXJGbkJvZHkgPSAicmV0dXJuIGZ1bmN0aW9uICIgKyBtYWtlTGVnYWxGdW5jdGlvbk5hbWUoaHVtYW5OYW1lKSArICIoIiArIGFyZ3NMaXN0ICsgIikge1xuaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09ICIgKyAoYXJnQ291bnQgLSAyKSArICIpIHtcbnRocm93QmluZGluZ0Vycm9yKCdmdW5jdGlvbiAiICsgaHVtYW5OYW1lICsgIiBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCAiICsgKGFyZ0NvdW50IC0gMikgKyAiIGFyZ3MhJyk7XG59XG4iOwogICAgICBpZiAobmVlZHNEZXN0cnVjdG9yU3RhY2spIHsKICAgICAgICBpbnZva2VyRm5Cb2R5ICs9ICJ2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcbiI7CiAgICAgIH0KICAgICAgdmFyIGR0b3JTdGFjayA9IG5lZWRzRGVzdHJ1Y3RvclN0YWNrID8gImRlc3RydWN0b3JzIiA6ICJudWxsIjsKICAgICAgdmFyIGFyZ3MxID0gWyJ0aHJvd0JpbmRpbmdFcnJvciIsICJpbnZva2VyIiwgImZuIiwgInJ1bkRlc3RydWN0b3JzIiwgInJldFR5cGUiLCAiY2xhc3NQYXJhbSJdOwogICAgICB2YXIgYXJnczIgPSBbCiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IsCiAgICAgICAgY3BwSW52b2tlckZ1bmMsCiAgICAgICAgY3BwVGFyZ2V0RnVuYywKICAgICAgICBydW5EZXN0cnVjdG9ycywKICAgICAgICBhcmdUeXBlc1swXSwKICAgICAgICBhcmdUeXBlc1sxXQogICAgICBdOwogICAgICBpZiAoaXNDbGFzc01ldGhvZEZ1bmMpIHsKICAgICAgICBpbnZva2VyRm5Cb2R5ICs9ICJ2YXIgdGhpc1dpcmVkID0gY2xhc3NQYXJhbS50b1dpcmVUeXBlKCIgKyBkdG9yU3RhY2sgKyAiLCB0aGlzKTtcbiI7CiAgICAgIH0KICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudCAtIDI7ICsraSkgewogICAgICAgIGludm9rZXJGbkJvZHkgKz0gInZhciBhcmciICsgaSArICJXaXJlZCA9IGFyZ1R5cGUiICsgaSArICIudG9XaXJlVHlwZSgiICsgZHRvclN0YWNrICsgIiwgYXJnIiArIGkgKyAiKTsgLy8gIiArIGFyZ1R5cGVzW2kgKyAyXS5uYW1lICsgIlxuIjsKICAgICAgICBhcmdzMS5wdXNoKCJhcmdUeXBlIiArIGkpOwogICAgICAgIGFyZ3MyLnB1c2goYXJnVHlwZXNbaSArIDJdKTsKICAgICAgfQogICAgICBpZiAoaXNDbGFzc01ldGhvZEZ1bmMpIHsKICAgICAgICBhcmdzTGlzdFdpcmVkID0gInRoaXNXaXJlZCIgKyAoYXJnc0xpc3RXaXJlZC5sZW5ndGggPiAwID8gIiwgIiA6ICIiKSArIGFyZ3NMaXN0V2lyZWQ7CiAgICAgIH0KICAgICAgaW52b2tlckZuQm9keSArPSAocmV0dXJucyA/ICJ2YXIgcnYgPSAiIDogIiIpICsgImludm9rZXIoZm4iICsgKGFyZ3NMaXN0V2lyZWQubGVuZ3RoID4gMCA/ICIsICIgOiAiIikgKyBhcmdzTGlzdFdpcmVkICsgIik7XG4iOwogICAgICBpZiAobmVlZHNEZXN0cnVjdG9yU3RhY2spIHsKICAgICAgICBpbnZva2VyRm5Cb2R5ICs9ICJydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4iOwogICAgICB9IGVsc2UgewogICAgICAgIGZvciAodmFyIGkgPSBpc0NsYXNzTWV0aG9kRnVuYyA/IDEgOiAyOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBpID09PSAxID8gInRoaXNXaXJlZCIgOiAiYXJnIiArIChpIC0gMikgKyAiV2lyZWQiOwogICAgICAgICAgaWYgKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbiAhPT0gbnVsbCkgewogICAgICAgICAgICBpbnZva2VyRm5Cb2R5ICs9IHBhcmFtTmFtZSArICJfZHRvcigiICsgcGFyYW1OYW1lICsgIik7IC8vICIgKyBhcmdUeXBlc1tpXS5uYW1lICsgIlxuIjsKICAgICAgICAgICAgYXJnczEucHVzaChwYXJhbU5hbWUgKyAiX2R0b3IiKTsKICAgICAgICAgICAgYXJnczIucHVzaChhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocmV0dXJucykgewogICAgICAgIGludm9rZXJGbkJvZHkgKz0gInZhciByZXQgPSByZXRUeXBlLmZyb21XaXJlVHlwZShydik7XG5yZXR1cm4gcmV0O1xuIjsKICAgICAgfSBlbHNlIHsKICAgICAgfQogICAgICBpbnZva2VyRm5Cb2R5ICs9ICJ9XG4iOwogICAgICBhcmdzMS5wdXNoKGludm9rZXJGbkJvZHkpOwogICAgICB2YXIgaW52b2tlckZ1bmN0aW9uID0gbmV3XyhGdW5jdGlvbiwgYXJnczEpLmFwcGx5KG51bGwsIGFyZ3MyKTsKICAgICAgcmV0dXJuIGludm9rZXJGdW5jdGlvbjsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uKHJhd0NsYXNzVHlwZSwgbWV0aG9kTmFtZSwgYXJnQ291bnQsIHJhd0FyZ1R5cGVzQWRkciwgaW52b2tlclNpZ25hdHVyZSwgcmF3SW52b2tlciwgY29udGV4dCwgaXNQdXJlVmlydHVhbCkgewogICAgICB2YXIgcmF3QXJnVHlwZXMgPSBoZWFwMzJWZWN0b3JUb0FycmF5KGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIpOwogICAgICBtZXRob2ROYW1lID0gcmVhZExhdGluMVN0cmluZyhtZXRob2ROYW1lKTsKICAgICAgcmF3SW52b2tlciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGludm9rZXJTaWduYXR1cmUsIHJhd0ludm9rZXIpOwogICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgW3Jhd0NsYXNzVHlwZV0sIGZ1bmN0aW9uKGNsYXNzVHlwZSkgewogICAgICAgIGNsYXNzVHlwZSA9IGNsYXNzVHlwZVswXTsKICAgICAgICB2YXIgaHVtYW5OYW1lID0gY2xhc3NUeXBlLm5hbWUgKyAiLiIgKyBtZXRob2ROYW1lOwogICAgICAgIGlmIChpc1B1cmVWaXJ0dWFsKSB7CiAgICAgICAgICBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zLnB1c2gobWV0aG9kTmFtZSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHVuYm91bmRUeXBlc0hhbmRsZXIoKSB7CiAgICAgICAgICB0aHJvd1VuYm91bmRUeXBlRXJyb3IoIkNhbm5vdCBjYWxsICIgKyBodW1hbk5hbWUgKyAiIGR1ZSB0byB1bmJvdW5kIHR5cGVzIiwgcmF3QXJnVHlwZXMpOwogICAgICAgIH0KICAgICAgICB2YXIgcHJvdG8gPSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlOwogICAgICAgIHZhciBtZXRob2QgPSBwcm90b1ttZXRob2ROYW1lXTsKICAgICAgICBpZiAodm9pZCAwID09PSBtZXRob2QgfHwgdm9pZCAwID09PSBtZXRob2Qub3ZlcmxvYWRUYWJsZSAmJiBtZXRob2QuY2xhc3NOYW1lICE9PSBjbGFzc1R5cGUubmFtZSAmJiBtZXRob2QuYXJnQ291bnQgPT09IGFyZ0NvdW50IC0gMikgewogICAgICAgICAgdW5ib3VuZFR5cGVzSGFuZGxlci5hcmdDb3VudCA9IGFyZ0NvdW50IC0gMjsKICAgICAgICAgIHVuYm91bmRUeXBlc0hhbmRsZXIuY2xhc3NOYW1lID0gY2xhc3NUeXBlLm5hbWU7CiAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXSA9IHVuYm91bmRUeXBlc0hhbmRsZXI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGVuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sIG1ldGhvZE5hbWUsIGh1bWFuTmFtZSk7CiAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50IC0gMl0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyOwogICAgICAgIH0KICAgICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgcmF3QXJnVHlwZXMsIGZ1bmN0aW9uKGFyZ1R5cGVzKSB7CiAgICAgICAgICB2YXIgbWVtYmVyRnVuY3Rpb24gPSBjcmFmdEludm9rZXJGdW5jdGlvbigKICAgICAgICAgICAgaHVtYW5OYW1lLAogICAgICAgICAgICBhcmdUeXBlcywKICAgICAgICAgICAgY2xhc3NUeXBlLAogICAgICAgICAgICByYXdJbnZva2VyLAogICAgICAgICAgICBjb250ZXh0CiAgICAgICAgICApOwogICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSkgewogICAgICAgICAgICBtZW1iZXJGdW5jdGlvbi5hcmdDb3VudCA9IGFyZ0NvdW50IC0gMjsKICAgICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0gPSBtZW1iZXJGdW5jdGlvbjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQgLSAyXSA9IG1lbWJlckZ1bmN0aW9uOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiBbXTsKICAgICAgfSk7CiAgICB9CiAgICB2YXIgZW12YWxfZnJlZV9saXN0ID0gW107CiAgICB2YXIgZW12YWxfaGFuZGxlX2FycmF5ID0gWwogICAgICB7fSwKICAgICAgewogICAgICAgIHZhbHVlOiB2b2lkIDAKICAgICAgfSwKICAgICAgewogICAgICAgIHZhbHVlOiBudWxsCiAgICAgIH0sCiAgICAgIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9LAogICAgICB7CiAgICAgICAgdmFsdWU6IGZhbHNlCiAgICAgIH0KICAgIF07CiAgICBmdW5jdGlvbiBfX2VtdmFsX2RlY3JlZihoYW5kbGUpIHsKICAgICAgaWYgKGhhbmRsZSA+IDQgJiYgMCA9PT0gLS1lbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS5yZWZjb3VudCkgewogICAgICAgIGVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdID0gdm9pZCAwOwogICAgICAgIGVtdmFsX2ZyZWVfbGlzdC5wdXNoKGhhbmRsZSk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGNvdW50X2VtdmFsX2hhbmRsZXMoKSB7CiAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgIGZvciAodmFyIGkgPSA1OyBpIDwgZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgaWYgKGVtdmFsX2hhbmRsZV9hcnJheVtpXSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICArK2NvdW50OwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gY291bnQ7CiAgICB9CiAgICBmdW5jdGlvbiBnZXRfZmlyc3RfZW12YWwoKSB7CiAgICAgIGZvciAodmFyIGkgPSA1OyBpIDwgZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgaWYgKGVtdmFsX2hhbmRsZV9hcnJheVtpXSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gZW12YWxfaGFuZGxlX2FycmF5W2ldOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGZ1bmN0aW9uIGluaXRfZW12YWwoKSB7CiAgICAgIE1vZHVsZTJbImNvdW50X2VtdmFsX2hhbmRsZXMiXSA9IGNvdW50X2VtdmFsX2hhbmRsZXM7CiAgICAgIE1vZHVsZTJbImdldF9maXJzdF9lbXZhbCJdID0gZ2V0X2ZpcnN0X2VtdmFsOwogICAgfQogICAgZnVuY3Rpb24gX19lbXZhbF9yZWdpc3Rlcih2YWx1ZSkgewogICAgICBzd2l0Y2ggKHZhbHVlKSB7CiAgICAgICAgY2FzZSB2b2lkIDA6IHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBjYXNlIG51bGw6IHsKICAgICAgICAgIHJldHVybiAyOwogICAgICAgIH0KICAgICAgICBjYXNlIHRydWU6IHsKICAgICAgICAgIHJldHVybiAzOwogICAgICAgIH0KICAgICAgICBjYXNlIGZhbHNlOiB7CiAgICAgICAgICByZXR1cm4gNDsKICAgICAgICB9CiAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgdmFyIGhhbmRsZSA9IGVtdmFsX2ZyZWVfbGlzdC5sZW5ndGggPyBlbXZhbF9mcmVlX2xpc3QucG9wKCkgOiBlbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoOwogICAgICAgICAgZW12YWxfaGFuZGxlX2FycmF5W2hhbmRsZV0gPSB7CiAgICAgICAgICAgIHJlZmNvdW50OiAxLAogICAgICAgICAgICB2YWx1ZQogICAgICAgICAgfTsKICAgICAgICAgIHJldHVybiBoYW5kbGU7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbChyYXdUeXBlLCBuYW1lKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICByZWdpc3RlclR5cGUocmF3VHlwZSwgewogICAgICAgIG5hbWUsCiAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbihoYW5kbGUpIHsKICAgICAgICAgIHZhciBydiA9IGVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdLnZhbHVlOwogICAgICAgICAgX19lbXZhbF9kZWNyZWYoaGFuZGxlKTsKICAgICAgICAgIHJldHVybiBydjsKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uKGRlc3RydWN0b3JzLCB2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpOwogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9lbWJpbmRfcmVwcih2KSB7CiAgICAgIGlmICh2ID09PSBudWxsKSB7CiAgICAgICAgcmV0dXJuICJudWxsIjsKICAgICAgfQogICAgICB2YXIgdCA9IHR5cGVvZiB2OwogICAgICBpZiAodCA9PT0gIm9iamVjdCIgfHwgdCA9PT0gImFycmF5IiB8fCB0ID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gIiIgKyB2OwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNoaWZ0KSB7CiAgICAgIHN3aXRjaCAoc2hpZnQpIHsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnRlcikgewogICAgICAgICAgICByZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUEYzMltwb2ludGVyID4+IDJdKTsKICAgICAgICAgIH07CiAgICAgICAgY2FzZSAzOgogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50ZXIpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBGNjRbcG9pbnRlciA+PiAzXSk7CiAgICAgICAgICB9OwogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGZsb2F0IHR5cGU6ICIgKyBuYW1lKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQocmF3VHlwZSwgbmFtZSwgc2l6ZSkgewogICAgICB2YXIgc2hpZnQgPSBnZXRTaGlmdEZyb21TaXplKHNpemUpOwogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uKGRlc3RydWN0b3JzLCB2YWx1ZSkgewogICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gIm51bWJlciIgJiYgdHlwZW9mIHZhbHVlICE9PSAiYm9vbGVhbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgIicgKyBfZW1iaW5kX3JlcHIodmFsdWUpICsgJyIgdG8gJyArIHRoaXMubmFtZSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCksCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNoaWZ0LCBzaWduZWQpIHsKICAgICAgc3dpdGNoIChzaGlmdCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIHJldHVybiBzaWduZWQgPyBmdW5jdGlvbiByZWFkUzhGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgICAgICAgIHJldHVybiBIRUFQOFtwb2ludGVyXTsKICAgICAgICAgIH0gOiBmdW5jdGlvbiByZWFkVThGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgICAgICAgIHJldHVybiBIRUFQVThbcG9pbnRlcl07CiAgICAgICAgICB9OwogICAgICAgIGNhc2UgMToKICAgICAgICAgIHJldHVybiBzaWduZWQgPyBmdW5jdGlvbiByZWFkUzE2RnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICAgICAgICByZXR1cm4gSEVBUDE2W3BvaW50ZXIgPj4gMV07CiAgICAgICAgICB9IDogZnVuY3Rpb24gcmVhZFUxNkZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgICAgICAgcmV0dXJuIEhFQVBVMTZbcG9pbnRlciA+PiAxXTsKICAgICAgICAgIH07CiAgICAgICAgY2FzZSAyOgogICAgICAgICAgcmV0dXJuIHNpZ25lZCA/IGZ1bmN0aW9uIHJlYWRTMzJGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgICAgICAgIHJldHVybiBIRUFQMzJbcG9pbnRlciA+PiAyXTsKICAgICAgICAgIH0gOiBmdW5jdGlvbiByZWFkVTMyRnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICAgICAgICByZXR1cm4gSEVBUFUzMltwb2ludGVyID4+IDJdOwogICAgICAgICAgfTsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBpbnRlZ2VyIHR5cGU6ICIgKyBuYW1lKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcihwcmltaXRpdmVUeXBlLCBuYW1lLCBzaXplLCBtaW5SYW5nZSwgbWF4UmFuZ2UpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIGlmIChtYXhSYW5nZSA9PT0gLTEpIHsKICAgICAgICBtYXhSYW5nZSA9IDQyOTQ5NjcyOTU7CiAgICAgIH0KICAgICAgdmFyIHNoaWZ0ID0gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKTsKICAgICAgdmFyIGZyb21XaXJlVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICB9OwogICAgICBpZiAobWluUmFuZ2UgPT09IDApIHsKICAgICAgICB2YXIgYml0c2hpZnQgPSAzMiAtIDggKiBzaXplOwogICAgICAgIGZyb21XaXJlVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPDwgYml0c2hpZnQgPj4+IGJpdHNoaWZ0OwogICAgICAgIH07CiAgICAgIH0KICAgICAgdmFyIGlzVW5zaWduZWRUeXBlID0gbmFtZS5pbmRleE9mKCJ1bnNpZ25lZCIpICE9IC0xOwogICAgICByZWdpc3RlclR5cGUocHJpbWl0aXZlVHlwZSwgewogICAgICAgIG5hbWUsCiAgICAgICAgZnJvbVdpcmVUeXBlLAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uKGRlc3RydWN0b3JzLCB2YWx1ZSkgewogICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gIm51bWJlciIgJiYgdHlwZW9mIHZhbHVlICE9PSAiYm9vbGVhbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgIicgKyBfZW1iaW5kX3JlcHIodmFsdWUpICsgJyIgdG8gJyArIHRoaXMubmFtZSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgPCBtaW5SYW5nZSB8fCB2YWx1ZSA+IG1heFJhbmdlKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgJ1Bhc3NpbmcgYSBudW1iZXIgIicgKyBfZW1iaW5kX3JlcHIodmFsdWUpICsgJyIgZnJvbSBKUyBzaWRlIHRvIEMvQysrIHNpZGUgdG8gYW4gYXJndW1lbnQgb2YgdHlwZSAiJyArIG5hbWUgKyAnIiwgd2hpY2ggaXMgb3V0c2lkZSB0aGUgdmFsaWQgcmFuZ2UgWycgKyBtaW5SYW5nZSArICIsICIgKyBtYXhSYW5nZSArICJdISIKICAgICAgICAgICAgKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBpc1Vuc2lnbmVkVHlwZSA/IHZhbHVlID4+PiAwIDogdmFsdWUgfCAwOwogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCwgbWluUmFuZ2UgIT09IDApLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3KHJhd1R5cGUsIGRhdGFUeXBlSW5kZXgsIG5hbWUpIHsKICAgICAgdmFyIHR5cGVNYXBwaW5nID0gWwogICAgICAgIEludDhBcnJheSwKICAgICAgICBVaW50OEFycmF5LAogICAgICAgIEludDE2QXJyYXksCiAgICAgICAgVWludDE2QXJyYXksCiAgICAgICAgSW50MzJBcnJheSwKICAgICAgICBVaW50MzJBcnJheSwKICAgICAgICBGbG9hdDMyQXJyYXksCiAgICAgICAgRmxvYXQ2NEFycmF5CiAgICAgIF07CiAgICAgIHZhciBUQSA9IHR5cGVNYXBwaW5nW2RhdGFUeXBlSW5kZXhdOwogICAgICBmdW5jdGlvbiBkZWNvZGVNZW1vcnlWaWV3KGhhbmRsZSkgewogICAgICAgIGhhbmRsZSA9IGhhbmRsZSA+PiAyOwogICAgICAgIHZhciBoZWFwID0gSEVBUFUzMjsKICAgICAgICB2YXIgc2l6ZSA9IGhlYXBbaGFuZGxlXTsKICAgICAgICB2YXIgZGF0YTIgPSBoZWFwW2hhbmRsZSArIDFdOwogICAgICAgIHJldHVybiBuZXcgVEEoYnVmZmVyLCBkYXRhMiwgc2l6ZSk7CiAgICAgIH0KICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZSgKICAgICAgICByYXdUeXBlLAogICAgICAgIHsKICAgICAgICAgIG5hbWUsCiAgICAgICAgICBmcm9tV2lyZVR5cGU6IGRlY29kZU1lbW9yeVZpZXcsCiAgICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBkZWNvZGVNZW1vcnlWaWV3CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICBpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zOiB0cnVlCiAgICAgICAgfQogICAgICApOwogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyhyYXdUeXBlLCBuYW1lKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICB2YXIgc3RkU3RyaW5nSXNVVEY4ID0gbmFtZSA9PT0gInN0ZDo6c3RyaW5nIjsKICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgIHZhciBsZW5ndGggPSBIRUFQVTMyW3ZhbHVlID4+IDJdOwogICAgICAgICAgdmFyIHN0cjsKICAgICAgICAgIGlmIChzdGRTdHJpbmdJc1VURjgpIHsKICAgICAgICAgICAgdmFyIGRlY29kZVN0YXJ0UHRyID0gdmFsdWUgKyA0OwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsZW5ndGg7ICsraSkgewogICAgICAgICAgICAgIHZhciBjdXJyZW50Qnl0ZVB0ciA9IHZhbHVlICsgNCArIGk7CiAgICAgICAgICAgICAgaWYgKEhFQVBVOFtjdXJyZW50Qnl0ZVB0cl0gPT0gMCB8fCBpID09IGxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFyIG1heFJlYWQgPSBjdXJyZW50Qnl0ZVB0ciAtIGRlY29kZVN0YXJ0UHRyOwogICAgICAgICAgICAgICAgdmFyIHN0cmluZ1NlZ21lbnQgPSBVVEY4VG9TdHJpbmcoZGVjb2RlU3RhcnRQdHIsIG1heFJlYWQpOwogICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgICAgIHN0ciA9IHN0cmluZ1NlZ21lbnQ7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTsKICAgICAgICAgICAgICAgICAgc3RyICs9IHN0cmluZ1NlZ21lbnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBkZWNvZGVTdGFydFB0ciA9IGN1cnJlbnRCeXRlUHRyICsgMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBhID0gbmV3IEFycmF5KGxlbmd0aCk7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgICBhW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShIRUFQVThbdmFsdWUgKyA0ICsgaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHN0ciA9IGEuam9pbigiIik7CiAgICAgICAgICB9CiAgICAgICAgICBfZnJlZSh2YWx1ZSk7CiAgICAgICAgICByZXR1cm4gc3RyOwogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7CiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgewogICAgICAgICAgICB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBnZXRMZW5ndGg7CiAgICAgICAgICB2YXIgdmFsdWVJc09mVHlwZVN0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyI7CiAgICAgICAgICBpZiAoISh2YWx1ZUlzT2ZUeXBlU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5KSkgewogICAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZyIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0ZFN0cmluZ0lzVVRGOCAmJiB2YWx1ZUlzT2ZUeXBlU3RyaW5nKSB7CiAgICAgICAgICAgIGdldExlbmd0aCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiBsZW5ndGhCeXRlc1VURjgodmFsdWUpOwogICAgICAgICAgICB9OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoKTsKICAgICAgICAgIHZhciBwdHIgPSBfbWFsbG9jKDQgKyBsZW5ndGggKyAxKTsKICAgICAgICAgIEhFQVBVMzJbcHRyID4+IDJdID0gbGVuZ3RoOwogICAgICAgICAgaWYgKHN0ZFN0cmluZ0lzVVRGOCAmJiB2YWx1ZUlzT2ZUeXBlU3RyaW5nKSB7CiAgICAgICAgICAgIHN0cmluZ1RvVVRGOCh2YWx1ZSwgcHRyICsgNCwgbGVuZ3RoICsgMSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpZiAodmFsdWVJc09mVHlwZVN0cmluZykgewogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsKICAgICAgICAgICAgICAgICAgX2ZyZWUocHRyKTsKICAgICAgICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0cyIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgSEVBUFU4W3B0ciArIDQgKyBpXSA9IGNoYXJDb2RlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgICAgICBIRUFQVThbcHRyICsgNCArIGldID0gdmFsdWVbaV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHsKICAgICAgICAgICAgZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSwgcHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwdHI7CiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBmdW5jdGlvbihwdHIpIHsKICAgICAgICAgIF9mcmVlKHB0cik7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nKHJhd1R5cGUsIGNoYXJTaXplLCBuYW1lKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICB2YXIgZGVjb2RlU3RyaW5nLCBlbmNvZGVTdHJpbmcsIGdldEhlYXAsIGxlbmd0aEJ5dGVzVVRGLCBzaGlmdDsKICAgICAgaWYgKGNoYXJTaXplID09PSAyKSB7CiAgICAgICAgZGVjb2RlU3RyaW5nID0gVVRGMTZUb1N0cmluZzsKICAgICAgICBlbmNvZGVTdHJpbmcgPSBzdHJpbmdUb1VURjE2OwogICAgICAgIGxlbmd0aEJ5dGVzVVRGID0gbGVuZ3RoQnl0ZXNVVEYxNjsKICAgICAgICBnZXRIZWFwID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gSEVBUFUxNjsKICAgICAgICB9OwogICAgICAgIHNoaWZ0ID0gMTsKICAgICAgfSBlbHNlIGlmIChjaGFyU2l6ZSA9PT0gNCkgewogICAgICAgIGRlY29kZVN0cmluZyA9IFVURjMyVG9TdHJpbmc7CiAgICAgICAgZW5jb2RlU3RyaW5nID0gc3RyaW5nVG9VVEYzMjsKICAgICAgICBsZW5ndGhCeXRlc1VURiA9IGxlbmd0aEJ5dGVzVVRGMzI7CiAgICAgICAgZ2V0SGVhcCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIEhFQVBVMzI7CiAgICAgICAgfTsKICAgICAgICBzaGlmdCA9IDI7CiAgICAgIH0KICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgIHZhciBsZW5ndGggPSBIRUFQVTMyW3ZhbHVlID4+IDJdOwogICAgICAgICAgdmFyIEhFQVAgPSBnZXRIZWFwKCk7CiAgICAgICAgICB2YXIgc3RyOwogICAgICAgICAgdmFyIGRlY29kZVN0YXJ0UHRyID0gdmFsdWUgKyA0OwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgdmFyIGN1cnJlbnRCeXRlUHRyID0gdmFsdWUgKyA0ICsgaSAqIGNoYXJTaXplOwogICAgICAgICAgICBpZiAoSEVBUFtjdXJyZW50Qnl0ZVB0ciA+PiBzaGlmdF0gPT0gMCB8fCBpID09IGxlbmd0aCkgewogICAgICAgICAgICAgIHZhciBtYXhSZWFkQnl0ZXMgPSBjdXJyZW50Qnl0ZVB0ciAtIGRlY29kZVN0YXJ0UHRyOwogICAgICAgICAgICAgIHZhciBzdHJpbmdTZWdtZW50ID0gZGVjb2RlU3RyaW5nKGRlY29kZVN0YXJ0UHRyLCBtYXhSZWFkQnl0ZXMpOwogICAgICAgICAgICAgIGlmIChzdHIgPT09IHZvaWQgMCkgewogICAgICAgICAgICAgICAgc3RyID0gc3RyaW5nU2VnbWVudDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7CiAgICAgICAgICAgICAgICBzdHIgKz0gc3RyaW5nU2VnbWVudDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZGVjb2RlU3RhcnRQdHIgPSBjdXJyZW50Qnl0ZVB0ciArIGNoYXJTaXplOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBfZnJlZSh2YWx1ZSk7CiAgICAgICAgICByZXR1cm4gc3RyOwogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7CiAgICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciKSkgewogICAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgIiArIG5hbWUpOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGxlbmd0aCA9IGxlbmd0aEJ5dGVzVVRGKHZhbHVlKTsKICAgICAgICAgIHZhciBwdHIgPSBfbWFsbG9jKDQgKyBsZW5ndGggKyBjaGFyU2l6ZSk7CiAgICAgICAgICBIRUFQVTMyW3B0ciA+PiAyXSA9IGxlbmd0aCA+PiBzaGlmdDsKICAgICAgICAgIGVuY29kZVN0cmluZyh2YWx1ZSwgcHRyICsgNCwgbGVuZ3RoICsgY2hhclNpemUpOwogICAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7CiAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2goX2ZyZWUsIHB0cik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHRyOwogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogZnVuY3Rpb24ocHRyKSB7CiAgICAgICAgICBfZnJlZShwdHIpOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl92b2lkKHJhd1R5cGUsIG5hbWUpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7CiAgICAgICAgaXNWb2lkOiB0cnVlLAogICAgICAgIG5hbWUsCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDAsCiAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgfSwKICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbihkZXN0cnVjdG9ycywgbykgewogICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gX2Fib3J0KCkgewogICAgICBhYm9ydCgpOwogICAgfQogICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfc2l6ZSgpIHsKICAgICAgcmV0dXJuIEhFQVBVOC5sZW5ndGg7CiAgICB9CiAgICBmdW5jdGlvbiBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeShyZXF1ZXN0ZWRTaXplKSB7CiAgICAgIGFib3J0KCJPT00iKTsKICAgIH0KICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpIHsKICAgICAgcmVxdWVzdGVkU2l6ZSA9IHJlcXVlc3RlZFNpemUgPj4+IDA7CiAgICAgIGFib3J0T25DYW5ub3RHcm93TWVtb3J5KHJlcXVlc3RlZFNpemUpOwogICAgfQogICAgZnVuY3Rpb24gX2xsdm1fdHJhcCgpIHsKICAgICAgYWJvcnQoInRyYXAhIik7CiAgICB9CiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3QsIHNyYywgbnVtKSB7CiAgICAgIEhFQVBVOC5jb3B5V2l0aGluKGRlc3QsIHNyYywgc3JjICsgbnVtKTsKICAgIH0KICAgIGVtYmluZF9pbml0X2NoYXJDb2RlcygpOwogICAgQmluZGluZ0Vycm9yID0gTW9kdWxlMlsiQmluZGluZ0Vycm9yIl0gPSBleHRlbmRFcnJvcihFcnJvciwgIkJpbmRpbmdFcnJvciIpOwogICAgSW50ZXJuYWxFcnJvciA9IE1vZHVsZTJbIkludGVybmFsRXJyb3IiXSA9IGV4dGVuZEVycm9yKEVycm9yLCAiSW50ZXJuYWxFcnJvciIpOwogICAgaW5pdF9DbGFzc0hhbmRsZSgpOwogICAgaW5pdF9SZWdpc3RlcmVkUG9pbnRlcigpOwogICAgaW5pdF9lbWJpbmQoKTsKICAgIFVuYm91bmRUeXBlRXJyb3IgPSBNb2R1bGUyWyJVbmJvdW5kVHlwZUVycm9yIl0gPSBleHRlbmRFcnJvcihFcnJvciwgIlVuYm91bmRUeXBlRXJyb3IiKTsKICAgIGluaXRfZW12YWwoKTsKICAgIHZhciBBU1NFUlRJT05TID0gZmFsc2U7CiAgICBmdW5jdGlvbiBpbnRBcnJheVRvU3RyaW5nKGFycmF5KSB7CiAgICAgIHZhciByZXQgPSBbXTsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBjaHIgPSBhcnJheVtpXTsKICAgICAgICBpZiAoY2hyID4gMjU1KSB7CiAgICAgICAgICBpZiAoQVNTRVJUSU9OUykgewogICAgICAgICAgICBhc3NlcnQoCiAgICAgICAgICAgICAgZmFsc2UsCiAgICAgICAgICAgICAgIkNoYXJhY3RlciBjb2RlICIgKyBjaHIgKyAiICgiICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgIikgIGF0IG9mZnNldCAiICsgaSArICIgbm90IGluIDB4MDAtMHhGRi4iCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgICBjaHIgJj0gMjU1OwogICAgICAgIH0KICAgICAgICByZXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikpOwogICAgICB9CiAgICAgIHJldHVybiByZXQuam9pbigiIik7CiAgICB9CiAgICB2YXIgZGVjb2RlQmFzZTY0ID0gdHlwZW9mIGF0b2IgPT09ICJmdW5jdGlvbiIgPyBhdG9iIDogZnVuY3Rpb24oaW5wdXQpIHsKICAgICAgdmFyIGtleVN0ciA9ICJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSI7CiAgICAgIHZhciBvdXRwdXQgPSAiIjsKICAgICAgdmFyIGNocjEsIGNocjIsIGNocjM7CiAgICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0OwogICAgICB2YXIgaSA9IDA7CiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcK1wvXD1dL2csICIiKTsKICAgICAgZG8gewogICAgICAgIGVuYzEgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7CiAgICAgICAgZW5jMiA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTsKICAgICAgICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpOwogICAgICAgIGVuYzQgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7CiAgICAgICAgY2hyMSA9IGVuYzEgPDwgMiB8IGVuYzIgPj4gNDsKICAgICAgICBjaHIyID0gKGVuYzIgJiAxNSkgPDwgNCB8IGVuYzMgPj4gMjsKICAgICAgICBjaHIzID0gKGVuYzMgJiAzKSA8PCA2IHwgZW5jNDsKICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpOwogICAgICAgIGlmIChlbmMzICE9PSA2NCkgewogICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7CiAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpOwogICAgICAgIH0KICAgICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCk7CiAgICAgIHJldHVybiBvdXRwdXQ7CiAgICB9OwogICAgZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpIHsKICAgICAgaWYgKHR5cGVvZiBFTlZJUk9OTUVOVF9JU19OT0RFID09PSAiYm9vbGVhbiIgJiYgRU5WSVJPTk1FTlRfSVNfTk9ERSkgewogICAgICAgIHZhciBidWY7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKHMsICJiYXNlNjQiKTsKICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICBidWYgPSBuZXcgQnVmZmVyKHMsICJiYXNlNjQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZlsiYnVmZmVyIl0sIGJ1ZlsiYnl0ZU9mZnNldCJdLCBidWZbImJ5dGVMZW5ndGgiXSk7CiAgICAgIH0KICAgICAgdHJ5IHsKICAgICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZUJhc2U2NChzKTsKICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShkZWNvZGVkLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBieXRlc1tpXSA9IGRlY29kZWQuY2hhckNvZGVBdChpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVzOwogICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb252ZXJ0aW5nIGJhc2U2NCBzdHJpbmcgdG8gYnl0ZXMgZmFpbGVkLiIpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiB0cnlQYXJzZUFzRGF0YVVSSShmaWxlbmFtZSkgewogICAgICBpZiAoIWlzRGF0YVVSSShmaWxlbmFtZSkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgcmV0dXJuIGludEFycmF5RnJvbUJhc2U2NChmaWxlbmFtZS5zbGljZShkYXRhVVJJUHJlZml4Lmxlbmd0aCkpOwogICAgfQogICAgdmFyIGFzbUdsb2JhbEFyZyA9IHsKICAgICAgTWF0aCwKICAgICAgSW50OEFycmF5LAogICAgICBJbnQxNkFycmF5LAogICAgICBJbnQzMkFycmF5LAogICAgICBVaW50OEFycmF5LAogICAgICBVaW50MTZBcnJheSwKICAgICAgRmxvYXQzMkFycmF5LAogICAgICBGbG9hdDY0QXJyYXkKICAgIH07CiAgICB2YXIgYXNtTGlicmFyeUFyZyA9IHsKICAgICAgQTogX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZywKICAgICAgQjogX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsCiAgICAgIEM6IF9sbHZtX3RyYXAsCiAgICAgIEQ6IHRlbXBEb3VibGVQdHIsCiAgICAgIGE6IGFib3J0LAogICAgICBiOiBzZXRUZW1wUmV0MCwKICAgICAgYzogZ2V0VGVtcFJldDAsCiAgICAgIGQ6IF9fX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24sCiAgICAgIGU6IF9fX2N4YV9iZWdpbl9jYXRjaCwKICAgICAgZjogX19fY3hhX3Rocm93LAogICAgICBnOiBfX19jeGFfdW5jYXVnaHRfZXhjZXB0aW9ucywKICAgICAgaDogX19fZXhjZXB0aW9uX2FkZFJlZiwKICAgICAgaTogX19fZXhjZXB0aW9uX2RlQWRqdXN0LAogICAgICBqOiBfX19neHhfcGVyc29uYWxpdHlfdjAsCiAgICAgIGs6IF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wsCiAgICAgIGw6IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzLAogICAgICBtOiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvciwKICAgICAgbjogX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24sCiAgICAgIG86IF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsLAogICAgICBwOiBfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdCwKICAgICAgcTogX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlciwKICAgICAgcjogX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcsCiAgICAgIHM6IF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcsCiAgICAgIHQ6IF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nLAogICAgICB1OiBfX2VtYmluZF9yZWdpc3Rlcl92b2lkLAogICAgICB2OiBfX2VtdmFsX2RlY3JlZiwKICAgICAgdzogX19lbXZhbF9yZWdpc3RlciwKICAgICAgeDogX2Fib3J0LAogICAgICB5OiBfZW1iaW5kX3JlcHIsCiAgICAgIHo6IF9lbXNjcmlwdGVuX2dldF9oZWFwX3NpemUKICAgIH07CiAgICB2YXIgYXNtID0gKAogICAgICAvKiogQHN1cHByZXNzIHt1c2VsZXNzQ29kZX0gKi8KICAgICAgZnVuY3Rpb24oZ2xvYmFsLCBlbnYsIGJ1ZmZlcjIpIHsKICAgICAgICA7CiAgICAgICAgdmFyIGEgPSBuZXcgZ2xvYmFsLkludDhBcnJheShidWZmZXIyKSwgYiA9IG5ldyBnbG9iYWwuSW50MTZBcnJheShidWZmZXIyKSwgYyA9IG5ldyBnbG9iYWwuSW50MzJBcnJheShidWZmZXIyKSwgZCA9IG5ldyBnbG9iYWwuVWludDhBcnJheShidWZmZXIyKSwgZSA9IG5ldyBnbG9iYWwuVWludDE2QXJyYXkoYnVmZmVyMiksIGYgPSBuZXcgZ2xvYmFsLkZsb2F0MzJBcnJheShidWZmZXIyKSwgZyA9IG5ldyBnbG9iYWwuRmxvYXQ2NEFycmF5KGJ1ZmZlcjIpLCBoID0gZW52LkQgfCAwLCBpID0gMCwgaiA9IDAsIGsgPSAwLCBsID0gMCwgbSA9IDAsIG4gPSAwLCBvID0gMCwgcCA9IDAsIHEgPSBnbG9iYWwuTWF0aC5pbXVsLCByID0gZ2xvYmFsLk1hdGguY2x6MzIsIHMgPSBlbnYuYSwgdCA9IGVudi5iLCB1ID0gZW52LmMsIHYgPSBlbnYuZCwgdyA9IGVudi5lLCB4ID0gZW52LmYsIHkgPSBlbnYuZywgeiA9IGVudi5oLCBBID0gZW52LmksIEIgPSBlbnYuaiwgQyA9IGVudi5rLCBEID0gZW52LmwsIEUgPSBlbnYubSwgRiA9IGVudi5uLCBHID0gZW52Lm8sIEggPSBlbnYucCwgSSA9IGVudi5xLCBKID0gZW52LnIsIEsgPSBlbnYucywgTCA9IGVudi50LCBNID0gZW52LnUsIE4gPSBlbnYudiwgTyA9IGVudi53LCBQID0gZW52LngsIFEgPSBlbnYueSwgUiA9IGVudi56LCBTID0gZW52LkEsIFQgPSBlbnYuQiwgVSA9IGVudi5DLCBWID0gMjIzODQsIFcgPSA1MjY1MjY0LCBYID0gMDsKICAgICAgICBmdW5jdGlvbiBpYSgpIHsKICAgICAgICAgIGVtKCk7CiAgICAgICAgICBmbSgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqYSgpIHsKICAgICAgICAgIGthKDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBrYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDA7CiAgICAgICAgICBhMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGIyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGQyID0gYTI7CiAgICAgICAgICB2aygpOwogICAgICAgICAgbTIgPSB4aygpIHwgMDsKICAgICAgICAgIGcyID0geWsoKSB8IDA7CiAgICAgICAgICBmMiA9IEFrKCkgfCAwOwogICAgICAgICAgaDIgPSBCaygpIHwgMDsKICAgICAgICAgIGkyID0gQ2soKSB8IDA7CiAgICAgICAgICBqMiA9IERrKCkgfCAwOwogICAgICAgICAgazIgPSBKaygpIHwgMDsKICAgICAgICAgIGwyID0gS2soKSB8IDA7CiAgICAgICAgICBlMiA9IEtrKCkgfCAwOwogICAgICAgICAgRChmMiB8IDAsIGgyIHwgMCwgaTIgfCAwLCBqMiB8IDAsIGsyIHwgMCwgOSwgbDIgfCAwLCBtMiB8IDAsIGUyIHwgMCwgZzIgfCAwLCA2MjA0LCBMaygpIHwgMCwgMTM4KTsKICAgICAgICAgIE5rKDEpOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDU7CiAgICAgICAgICBjW2QyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gY1tkMiArIDQgPj4gMl07CiAgICAgICAgICBVayg2MjExLCBiMik7CiAgICAgICAgICBjW2QyID4+IDJdID0gMzsKICAgICAgICAgIGNbZDIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBjW2QyICsgNCA+PiAyXTsKICAgICAgICAgIGNsKDYyMTYsIGIyKTsKICAgICAgICAgIGNbZDIgPj4gMl0gPSAxMDsKICAgICAgICAgIGNbZDIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBjW2QyICsgNCA+PiAyXTsKICAgICAgICAgIGtsKDYyMjUsIGIyKTsKICAgICAgICAgIHNsKCk7CiAgICAgICAgICBnMiA9IHVsKCkgfCAwOwogICAgICAgICAgZTIgPSB2bCgpIHwgMDsKICAgICAgICAgIG0yID0geGwoKSB8IDA7CiAgICAgICAgICBsMiA9IHlsKCkgfCAwOwogICAgICAgICAgazIgPSB6bCgpIHwgMDsKICAgICAgICAgIGoyID0gRGsoKSB8IDA7CiAgICAgICAgICBpMiA9IEprKCkgfCAwOwogICAgICAgICAgaDIgPSBLaygpIHwgMDsKICAgICAgICAgIGYyID0gS2soKSB8IDA7CiAgICAgICAgICBEKG0yIHwgMCwgbDIgfCAwLCBrMiB8IDAsIGoyIHwgMCwgaTIgfCAwLCAxMSwgaDIgfCAwLCBnMiB8IDAsIGYyIHwgMCwgZTIgfCAwLCA2MjM0LCBMaygpIHwgMCwgMTM5KTsKICAgICAgICAgIEdsKDIpOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDY7CiAgICAgICAgICBjW2QyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gY1tkMiArIDQgPj4gMl07CiAgICAgICAgICBObCg2MjExLCBiMik7CiAgICAgICAgICBjW2QyID4+IDJdID0gNDsKICAgICAgICAgIGNbZDIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBjW2QyICsgNCA+PiAyXTsKICAgICAgICAgIFVsKDYyNDgsIGIyKTsKICAgICAgICAgIGNbZDIgPj4gMl0gPSA1OwogICAgICAgICAgY1tkMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IGNbZDIgKyA0ID4+IDJdOwogICAgICAgICAgVWwoNjI2NSwgYjIpOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDY7CiAgICAgICAgICBjW2QyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gY1tkMiArIDQgPj4gMl07CiAgICAgICAgICBVbCg2MjgwLCBiMik7CiAgICAgICAgICBjW2QyID4+IDJdID0gNzsKICAgICAgICAgIGNbZDIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBjW2QyICsgNCA+PiAyXTsKICAgICAgICAgIF9sKDYyMTYsIGIyKTsKICAgICAgICAgIFYgPSBhMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGEoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwOwogICAgICAgICAgZTIgPSBWOwogICAgICAgICAgViA9IFYgKyAzMiB8IDA7CiAgICAgICAgICBoMiA9IGUyICsgMTYgfCAwOwogICAgICAgICAgZjIgPSBlMiArIDggfCAwOwogICAgICAgICAgaTIgPSBlMjsKICAgICAgICAgIGcyID0gZXEoMjApIHwgMDsKICAgICAgICAgIHRhKGcyLCBiMiwgZDIpOwogICAgICAgICAgY1tpMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2gyID4+IDJdID0gY1tpMiA+PiAyXTsKICAgICAgICAgIHZhKGYyLCBnMiwgaDIpOwogICAgICAgICAgYjIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSBjW2EyID4+IDJdOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgYjIgPSBmMiArIDQgfCAwOwogICAgICAgICAgZDIgPSBhMiArIDQgfCAwOwogICAgICAgICAgZzIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGcyOwogICAgICAgICAgd2EoZjIpOwogICAgICAgICAgZDIgPSBlcSgzNTIpIHwgMDsKICAgICAgICAgIHVhKGQyLCBjW2EyID4+IDJdIHwgMCk7CiAgICAgICAgICBnMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBjW2kyID4+IDJdID0gMDsKICAgICAgICAgIGNbaDIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgRmEoZjIsIGQyLCBoMik7CiAgICAgICAgICBkMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGNbZzIgPj4gMl07CiAgICAgICAgICBjW2cyID4+IDJdID0gZDI7CiAgICAgICAgICBnMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICBkMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgYjIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgIGNbZzIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGIyOwogICAgICAgICAgR2EoZjIpOwogICAgICAgICAgViA9IGUyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtYShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkZChjW2EyICsgOCA+PiAyXSB8IDAsIGIyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbmEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSAoUWgoY1thMiArIDggPj4gMl0gfCAwKSB8IDApICsgMTA3IHwgMDsKICAgICAgICAgIHJldHVybiBkW2EyID4+IDBdIHwgZFthMiArIDEgPj4gMF0gPDwgOCB8IGRbYTIgKyAyID4+IDBdIDw8IDE2IHwgZFthMiArIDMgPj4gMF0gPDwgMjQgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvYShhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGcyID0gZTIgKyAxNiB8IDA7CiAgICAgICAgICBmMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGUyOwogICAgICAgICAgaTIgPSBlcSgxMikgfCAwOwogICAgICAgICAgUmgoaTIsIGIyLCBkMik7CiAgICAgICAgICBjW2gyID4+IDJdID0gMDsKICAgICAgICAgIGNbZzIgPj4gMl0gPSBjW2gyID4+IDJdOwogICAgICAgICAgVmgoZjIsIGkyLCBnMik7CiAgICAgICAgICBpMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICBjW2EyID4+IDJdID0gaTI7CiAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICBkMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBiMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgY1tpMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBjW2QyID4+IDJdID0gYjI7CiAgICAgICAgICBXaChmMik7CiAgICAgICAgICBkMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBiMiA9IGVxKDEyKSB8IDA7CiAgICAgICAgICBTaChiMiwgY1thMiA+PiAyXSB8IDApOwogICAgICAgICAgY1toMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2cyID4+IDJdID0gY1toMiA+PiAyXTsKICAgICAgICAgIGFpKGYyLCBiMiwgZzIpOwogICAgICAgICAgYjIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGIyOwogICAgICAgICAgYjIgPSBmMiArIDQgfCAwOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGkyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1toMiA+PiAyXTsKICAgICAgICAgIGNbaDIgPj4gMl0gPSBpMjsKICAgICAgICAgIGJpKGYyKTsKICAgICAgICAgIFRoKGYyLCBjW2QyID4+IDJdIHwgMCk7CiAgICAgICAgICBkMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgaDIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gZjIgKyA0IHwgMDsKICAgICAgICAgIGIyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgY1tnMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBjW2QyID4+IDJdID0gaDI7CiAgICAgICAgICBkMiA9IGEyICsgMjAgfCAwOwogICAgICAgICAgY1tnMiArIDQgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGIyOwogICAgICAgICAgVWgoZzIpOwogICAgICAgICAgVWgoZjIpOwogICAgICAgICAgViA9IGUyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwYShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwOwogICAgICAgICAgYTIgPSBhMiArIDE2IHwgMDsKICAgICAgICAgIGQyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBhOgogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmIChkMiB8IDApCiAgICAgICAgICAgICAgICBzd2l0Y2ggKGIyIHwgMCkgewogICAgICAgICAgICAgICAgICBjYXNlIDQ6IHsKICAgICAgICAgICAgICAgICAgICB1aShkMik7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjYXNlIDg6IHsKICAgICAgICAgICAgICAgICAgICB2aShkMik7CiAgICAgICAgICAgICAgICAgICAgdmkoY1thMiA+PiAyXSB8IDApOwogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHFhKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDA7CiAgICAgICAgICBkMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgYTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKGEyIHwgMCkgewogICAgICAgICAgICAgICAgc3dpdGNoIChiMiB8IDApIHsKICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7CiAgICAgICAgICAgICAgICAgICAgaGooYTIpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7CiAgICAgICAgICAgICAgICAgICAgaWooYTIpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSA4OiB7CiAgICAgICAgICAgICAgICAgICAgdWkoYTIpOwogICAgICAgICAgICAgICAgICAgIGEyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB1aShhMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJhKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDA7CiAgICAgICAgICBkMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgYTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKGEyIHwgMCkgewogICAgICAgICAgICAgICAgc3dpdGNoIChiMiB8IDApIHsKICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7CiAgICAgICAgICAgICAgICAgICAgUmooYTIpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7CiAgICAgICAgICAgICAgICAgICAgU2ooYTIpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSA4OiB7CiAgICAgICAgICAgICAgICAgICAgdmkoYTIpOwogICAgICAgICAgICAgICAgICAgIGEyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB2aShhMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHNhKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDE2ID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApCiAgICAgICAgICAgICRbY1tjW2EyID4+IDJdID4+IDJdICYgNjNdKGEyLCBiMikgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0YShiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gZDI7CiAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IGUyOwogICAgICAgICAgY1tiMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgYVtiMiArIDEyID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAxMyA+PiAwXSA9IDA7CiAgICAgICAgICBjW2IyICsgMTYgPj4gMl0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1YShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBWYShhMiArIDQgfCAwLCBiMik7CiAgICAgICAgICBXYShhMiArIDI0NyB8IDApOwogICAgICAgICAgY1thMiArIDI4OCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgMjkyID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyAyOTYgPj4gMl0gPSAwOwogICAgICAgICAgWGEoYTIgKyAzMDAgfCAwKTsKICAgICAgICAgIGIyID0gYTIgKyAzMTIgfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgMTIgPj4gMl0gPSAwOwogICAgICAgICAgWWEoYTIgKyAzMjggfCAwKTsKICAgICAgICAgIFphKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdmEoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQyOTY7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgeGEoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gd2EoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYTIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwID8gKGQyID0gYTIgKyA0IHwgMCwgYjIgPSBjW2QyID4+IDJdIHwgMCwgY1tkMiA+PiAyXSA9IGIyICsgLTEsIChiMiB8IDApID09IDApIDogMCkgewogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA4ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICAgIHFxKGEyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geGEoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5YShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB3KGEyIHwgMCkgfCAwOwogICAgICAgICAgbHAoKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gemEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBBYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJhKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gNjQwNyA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEYShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBFYShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVhKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmEoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQzMjQ7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgSGEoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gR2EoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYTIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwID8gKGQyID0gYTIgKyA0IHwgMCwgYjIgPSBjW2QyID4+IDJdIHwgMCwgY1tkMiA+PiAyXSA9IGIyICsgLTEsIChiMiB8IDApID09IDApIDogMCkgewogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA4ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICAgIHFxKGEyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSGEoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBJYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBwcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEphKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApIHsKICAgICAgICAgICAgTWEoYTIpOwogICAgICAgICAgICBqcChhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEthKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gNjYwNSA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBNYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBOYShhMiArIDMyMCB8IDApOwogICAgICAgICAgT2EoYTIgKyAzMTIgfCAwKTsKICAgICAgICAgIFBhKGEyICsgMzAwIHwgMCk7CiAgICAgICAgICBUYShhMiArIDI4OCB8IDApOwogICAgICAgICAgUWEoYTIgKyAyNDcgfCAwKTsKICAgICAgICAgIFJhKGEyICsgNCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDAgPyAoZDIgPSBhMiArIDQgfCAwLCBiMiA9IGNbZDIgPj4gMl0gfCAwLCBjW2QyID4+IDJdID0gYjIgKyAtMSwgKGIyIHwgMCkgPT0gMCkgOiAwKSB7CiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDggPj4gMl0gJiAyNTVdKGEyKTsKICAgICAgICAgICAgcXEoYTIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBPYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDAgPyAoZDIgPSBhMiArIDQgfCAwLCBiMiA9IGNbZDIgPj4gMl0gfCAwLCBjW2QyID4+IDJdID0gYjIgKyAtMSwgKGIyIHwgMCkgPT0gMCkgOiAwKSB7CiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDggPj4gMl0gJiAyNTVdKGEyKTsKICAgICAgICAgICAgcXEoYTIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBQYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBTYShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFhKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gYTIgKyAzNCB8IDA7CiAgICAgICAgICBhMiA9IGRbYTIgPj4gMF0gfCBkW2EyICsgMSA+PiAwXSA8PCA4IHwgZFthMiArIDIgPj4gMF0gPDwgMTYgfCBkW2EyICsgMyA+PiAwXSA8PCAyNDsKICAgICAgICAgIGlmIChhMiB8IDApCiAgICAgICAgICAgIGdxKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUmEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgVWEoY1thMiArIDEyID4+IDJdIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNhKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGQyOwogICAgICAgICAgICBEYShiMiwgKGNbYTIgKyA4ID4+IDJdIHwgMCkgLSBkMiB8IDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBUYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGlmIChiMiB8IDApIHsKICAgICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgICAgRGEoYjIsIChjW2EyICsgOCA+PiAyXSB8IDApIC0gZDIgfCAwKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVWEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgZXIoY1thMiArIC00ID4+IDJdIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFZhKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyAxMiA+PiAyXSA9IF9hKDEwNDg1NzYpIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2EoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGMyID0gMDsKICAgICAgICAgIGMyID0gYjIgKyAzMiB8IDA7CiAgICAgICAgICBhW2MyID4+IDBdID0gMDsKICAgICAgICAgIGFbYzIgKyAxID4+IDBdID0gMDsKICAgICAgICAgIGIyID0gYjIgKyAzNCB8IDA7CiAgICAgICAgICBhW2IyID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAyID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAzID4+IDBdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWGEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFlhKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDEyID4+IDJdID0gMDsKICAgICAgICAgIGEyID0gYTIgKyAxNiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gLTE7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IC0xOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBaYShiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMDsKICAgICAgICAgIGkyID0gVjsKICAgICAgICAgIFYgPSBWICsgNjQgfCAwOwogICAgICAgICAgZzIgPSBpMiArIDMyIHwgMDsKICAgICAgICAgIGUyID0gaTIgKyA1NiB8IDA7CiAgICAgICAgICBkMiA9IGkyICsgMTYgfCAwOwogICAgICAgICAgaDIgPSBpMjsKICAgICAgICAgICRhKGNbYjIgPj4gMl0gfCAwLCBlMiwgNCk7CiAgICAgICAgICBtYihnMiwgZTIsIGUyICsgNCB8IDApOwogICAgICAgICAgZTIgPSBsYig2NjkzKSB8IDA7CiAgICAgICAgICBmMiA9IGFbZzIgKyAxMSA+PiAwXSB8IDA7CiAgICAgICAgICBpZiAoKGUyIHwgMCkgPT0gKChmMiA8PCAyNCA+PiAyNCA8IDAgPyBjW2cyICsgNCA+PiAyXSB8IDAgOiBmMiAmIDI1NSkgfCAwKSkgewogICAgICAgICAgICBmMiA9IChIcShnMiwgMCwgLTEsIDY2OTMsIGUyKSB8IDApID09IDA7CiAgICAgICAgICAgIENxKGcyKTsKICAgICAgICAgICAgaWYgKGYyKSB7CiAgICAgICAgICAgICAgZTIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2QyID4+IDJdID0gMDsKICAgICAgICAgICAgICBjW2QyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tkMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbZDIgKyAxMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgY1tnMiArIDQgPj4gMl0gPSBjW2QyICsgNCA+PiAyXTsKICAgICAgICAgICAgICBjW2cyICsgOCA+PiAyXSA9IGNbZDIgKyA4ID4+IDJdOwogICAgICAgICAgICAgIGNbZzIgKyAxMiA+PiAyXSA9IGNbZDIgKyAxMiA+PiAyXTsKICAgICAgICAgICAgICBiYihlMiwgZzIpOwogICAgICAgICAgICAgIGUyID0gYjIgKyAyMCB8IDA7CiAgICAgICAgICAgICAgJGEoY1tiMiA+PiAyXSB8IDAsIGUyLCAyMjcpOwogICAgICAgICAgICAgIGNiKGIyLCBlMik7CiAgICAgICAgICAgICAgZjIgPSBkYigpIHwgMDsKICAgICAgICAgICAgICBkMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGYyID0gY1tmMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGlmICgoZDIgfCAwKSAhPSAoZjIgfCAwKSkKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgZWIoZzIsIGQyKTsKICAgICAgICAgICAgICAgICAgZmIoZzIsIGUyKTsKICAgICAgICAgICAgICAgICAgZ2IoZzIpOwogICAgICAgICAgICAgICAgICBkMiA9IGQyICsgMjQgfCAwOwogICAgICAgICAgICAgICAgfSB3aGlsZSAoKGQyIHwgMCkgIT0gKGYyIHwgMCkpOwogICAgICAgICAgICAgIGhiKGIyKTsKICAgICAgICAgICAgICBpYihiMik7CiAgICAgICAgICAgICAgamIoY1tiMiA+PiAyXSB8IDApOwogICAgICAgICAgICAgIGYyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgZDIgPSAoY1tiMiArIDExNiA+PiAyXSB8IDApICsgOCB8IDA7CiAgICAgICAgICAgICAgZTIgPSBoMjsKICAgICAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgZTIgPSBoMiArIDggfCAwOwogICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGNbaDIgPj4gMl07CiAgICAgICAgICAgICAgY1tnMiArIDQgPj4gMl0gPSBjW2gyICsgNCA+PiAyXTsKICAgICAgICAgICAgICBjW2cyICsgOCA+PiAyXSA9IGNbaDIgKyA4ID4+IDJdOwogICAgICAgICAgICAgIGNbZzIgKyAxMiA+PiAyXSA9IGNbaDIgKyAxMiA+PiAyXTsKICAgICAgICAgICAgICBiYihmMiwgZzIpOwogICAgICAgICAgICAgIGtiKGIyICsgNCB8IDApOwogICAgICAgICAgICAgIFYgPSBpMjsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICBDcShnMik7CiAgICAgICAgICBpMiA9IHYoOCkgfCAwOwogICAgICAgICAgYWIoaTIpOwogICAgICAgICAgeChpMiB8IDAsIDI1OTIsIDgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfYShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwOwogICAgICAgICAgYjIgPSBkcihhMiArIDY4IHwgMCkgfCAwOwogICAgICAgICAgYTIgPSBiMiArIDY4ICYgLTY0OwogICAgICAgICAgY1thMiArIC00ID4+IDJdID0gYjI7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiAkYShiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMDsKICAgICAgICAgIGkyID0gYjIgKyAxMyB8IDA7CiAgICAgICAgICBpZiAoIShhW2kyID4+IDBdIHwgMCkpIHsKICAgICAgICAgICAgaDIgPSBiMiArIDQgfCAwOwogICAgICAgICAgICBmMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICBqMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICAgIGcyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGsyID0gZjIgLSBnMiB8IDA7CiAgICAgICAgICAgIGUyID0gKGsyIHwgMCkgPCAoZTIgfCAwKSA/IGsyIDogZTI7CiAgICAgICAgICAgIGlmIChlMikgewogICAgICAgICAgICAgIHZyKGQyIHwgMCwgKGNbYjIgPj4gMl0gfCAwKSArIGcyIHwgMCwgZTIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgZzIgPSBjW2oyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBmMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGsyID0gZzIgKyBlMiB8IDA7CiAgICAgICAgICAgIGNbajIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgY1tiMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICAgIGlmICgoazIgfCAwKSA+PSAoZjIgfCAwKSkKICAgICAgICAgICAgICBhW2kyID4+IDBdID0gMTsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICBhW2IyICsgMTIgPj4gMF0gPSAxOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBhYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB4cShhMiwgNjc5MSk7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDM1MjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYmIoYjIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwLCBnMiA9IDA7CiAgICAgICAgICBnMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICBkMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgZzIgPSBjW2cyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGYyID0gKChlMiB8IDApIDwgMCkgPDwgMzEgPj4gMzE7CiAgICAgICAgICBpZiAoKGcyIHwgMCkgPCAoZjIgfCAwKSB8IChnMiB8IDApID09IChmMiB8IDApICYgZDIgPj4+IDAgPCBlMiA+Pj4gMCkKICAgICAgICAgICAgY1tiMiArIDggPj4gMl0gPSBkMjsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYVtiMiArIDEyID4+IDBdID0gMTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2IoYjIsIGMyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMDsKICAgICAgICAgIG4yID0gYzIgKyAxNzkgfCAwOwogICAgICAgICAgYVtoID4+IDBdID0gYVtuMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDEgPj4gMF0gPSBhW24yICsgMSA+PiAwXTsKICAgICAgICAgIGFbaCArIDIgPj4gMF0gPSBhW24yICsgMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDMgPj4gMF0gPSBhW24yICsgMyA+PiAwXTsKICAgICAgICAgIGFbaCArIDQgPj4gMF0gPSBhW24yICsgNCA+PiAwXTsKICAgICAgICAgIGFbaCArIDUgPj4gMF0gPSBhW24yICsgNSA+PiAwXTsKICAgICAgICAgIGFbaCArIDYgPj4gMF0gPSBhW24yICsgNiA+PiAwXTsKICAgICAgICAgIGFbaCArIDcgPj4gMF0gPSBhW24yICsgNyA+PiAwXTsKICAgICAgICAgIG0yID0gK2dbaCA+PiAzXTsKICAgICAgICAgIGoyID0gYzIgKyAxODcgfCAwOwogICAgICAgICAgYVtoID4+IDBdID0gYVtqMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDEgPj4gMF0gPSBhW2oyICsgMSA+PiAwXTsKICAgICAgICAgIGFbaCArIDIgPj4gMF0gPSBhW2oyICsgMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDMgPj4gMF0gPSBhW2oyICsgMyA+PiAwXTsKICAgICAgICAgIGFbaCArIDQgPj4gMF0gPSBhW2oyICsgNCA+PiAwXTsKICAgICAgICAgIGFbaCArIDUgPj4gMF0gPSBhW2oyICsgNSA+PiAwXTsKICAgICAgICAgIGFbaCArIDYgPj4gMF0gPSBhW2oyICsgNiA+PiAwXTsKICAgICAgICAgIGFbaCArIDcgPj4gMF0gPSBhW2oyICsgNyA+PiAwXTsKICAgICAgICAgIG8yID0gK2dbaCA+PiAzXTsKICAgICAgICAgIGIyID0gYzIgKyAxOTUgfCAwOwogICAgICAgICAgYVtoID4+IDBdID0gYVtiMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDEgPj4gMF0gPSBhW2IyICsgMSA+PiAwXTsKICAgICAgICAgIGFbaCArIDIgPj4gMF0gPSBhW2IyICsgMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDMgPj4gMF0gPSBhW2IyICsgMyA+PiAwXTsKICAgICAgICAgIGFbaCArIDQgPj4gMF0gPSBhW2IyICsgNCA+PiAwXTsKICAgICAgICAgIGFbaCArIDUgPj4gMF0gPSBhW2IyICsgNSA+PiAwXTsKICAgICAgICAgIGFbaCArIDYgPj4gMF0gPSBhW2IyICsgNiA+PiAwXTsKICAgICAgICAgIGFbaCArIDcgPj4gMF0gPSBhW2IyICsgNyA+PiAwXTsKICAgICAgICAgIGkyID0gK2dbaCA+PiAzXTsKICAgICAgICAgIGwyID0gYzIgKyAyMDMgfCAwOwogICAgICAgICAgYVtoID4+IDBdID0gYVtsMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDEgPj4gMF0gPSBhW2wyICsgMSA+PiAwXTsKICAgICAgICAgIGFbaCArIDIgPj4gMF0gPSBhW2wyICsgMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDMgPj4gMF0gPSBhW2wyICsgMyA+PiAwXTsKICAgICAgICAgIGFbaCArIDQgPj4gMF0gPSBhW2wyICsgNCA+PiAwXTsKICAgICAgICAgIGFbaCArIDUgPj4gMF0gPSBhW2wyICsgNSA+PiAwXTsKICAgICAgICAgIGFbaCArIDYgPj4gMF0gPSBhW2wyICsgNiA+PiAwXTsKICAgICAgICAgIGFbaCArIDcgPj4gMF0gPSBhW2wyICsgNyA+PiAwXTsKICAgICAgICAgIGsyID0gK2dbaCA+PiAzXTsKICAgICAgICAgIGYyID0gYzIgKyAyMTEgfCAwOwogICAgICAgICAgYVtoID4+IDBdID0gYVtmMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDEgPj4gMF0gPSBhW2YyICsgMSA+PiAwXTsKICAgICAgICAgIGFbaCArIDIgPj4gMF0gPSBhW2YyICsgMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDMgPj4gMF0gPSBhW2YyICsgMyA+PiAwXTsKICAgICAgICAgIGFbaCArIDQgPj4gMF0gPSBhW2YyICsgNCA+PiAwXTsKICAgICAgICAgIGFbaCArIDUgPj4gMF0gPSBhW2YyICsgNSA+PiAwXTsKICAgICAgICAgIGFbaCArIDYgPj4gMF0gPSBhW2YyICsgNiA+PiAwXTsKICAgICAgICAgIGFbaCArIDcgPj4gMF0gPSBhW2YyICsgNyA+PiAwXTsKICAgICAgICAgIGQyID0gK2dbaCA+PiAzXTsKICAgICAgICAgIGMyID0gYzIgKyAyMTkgfCAwOwogICAgICAgICAgYVtoID4+IDBdID0gYVtjMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDEgPj4gMF0gPSBhW2MyICsgMSA+PiAwXTsKICAgICAgICAgIGFbaCArIDIgPj4gMF0gPSBhW2MyICsgMiA+PiAwXTsKICAgICAgICAgIGFbaCArIDMgPj4gMF0gPSBhW2MyICsgMyA+PiAwXTsKICAgICAgICAgIGFbaCArIDQgPj4gMF0gPSBhW2MyICsgNCA+PiAwXTsKICAgICAgICAgIGFbaCArIDUgPj4gMF0gPSBhW2MyICsgNSA+PiAwXTsKICAgICAgICAgIGFbaCArIDYgPj4gMF0gPSBhW2MyICsgNiA+PiAwXTsKICAgICAgICAgIGFbaCArIDcgPj4gMF0gPSBhW2MyICsgNyA+PiAwXTsKICAgICAgICAgIGUyID0gK2dbaCA+PiAzXTsKICAgICAgICAgIGdbaCA+PiAzXSA9IG8yOwogICAgICAgICAgYVtuMiA+PiAwXSA9IGFbaCA+PiAwXTsKICAgICAgICAgIGFbbjIgKyAxID4+IDBdID0gYVtoICsgMSA+PiAwXTsKICAgICAgICAgIGFbbjIgKyAyID4+IDBdID0gYVtoICsgMiA+PiAwXTsKICAgICAgICAgIGFbbjIgKyAzID4+IDBdID0gYVtoICsgMyA+PiAwXTsKICAgICAgICAgIGFbbjIgKyA0ID4+IDBdID0gYVtoICsgNCA+PiAwXTsKICAgICAgICAgIGFbbjIgKyA1ID4+IDBdID0gYVtoICsgNSA+PiAwXTsKICAgICAgICAgIGFbbjIgKyA2ID4+IDBdID0gYVtoICsgNiA+PiAwXTsKICAgICAgICAgIGFbbjIgKyA3ID4+IDBdID0gYVtoICsgNyA+PiAwXTsKICAgICAgICAgIGdbaCA+PiAzXSA9IG0yOwogICAgICAgICAgYVtsMiA+PiAwXSA9IGFbaCA+PiAwXTsKICAgICAgICAgIGFbbDIgKyAxID4+IDBdID0gYVtoICsgMSA+PiAwXTsKICAgICAgICAgIGFbbDIgKyAyID4+IDBdID0gYVtoICsgMiA+PiAwXTsKICAgICAgICAgIGFbbDIgKyAzID4+IDBdID0gYVtoICsgMyA+PiAwXTsKICAgICAgICAgIGFbbDIgKyA0ID4+IDBdID0gYVtoICsgNCA+PiAwXTsKICAgICAgICAgIGFbbDIgKyA1ID4+IDBdID0gYVtoICsgNSA+PiAwXTsKICAgICAgICAgIGFbbDIgKyA2ID4+IDBdID0gYVtoICsgNiA+PiAwXTsKICAgICAgICAgIGFbbDIgKyA3ID4+IDBdID0gYVtoICsgNyA+PiAwXTsKICAgICAgICAgIGdbaCA+PiAzXSA9IGsyOwogICAgICAgICAgYVtqMiA+PiAwXSA9IGFbaCA+PiAwXTsKICAgICAgICAgIGFbajIgKyAxID4+IDBdID0gYVtoICsgMSA+PiAwXTsKICAgICAgICAgIGFbajIgKyAyID4+IDBdID0gYVtoICsgMiA+PiAwXTsKICAgICAgICAgIGFbajIgKyAzID4+IDBdID0gYVtoICsgMyA+PiAwXTsKICAgICAgICAgIGFbajIgKyA0ID4+IDBdID0gYVtoICsgNCA+PiAwXTsKICAgICAgICAgIGFbajIgKyA1ID4+IDBdID0gYVtoICsgNSA+PiAwXTsKICAgICAgICAgIGFbajIgKyA2ID4+IDBdID0gYVtoICsgNiA+PiAwXTsKICAgICAgICAgIGFbajIgKyA3ID4+IDBdID0gYVtoICsgNyA+PiAwXTsKICAgICAgICAgIGdbaCA+PiAzXSA9IGkyOwogICAgICAgICAgYVtmMiA+PiAwXSA9IGFbaCA+PiAwXTsKICAgICAgICAgIGFbZjIgKyAxID4+IDBdID0gYVtoICsgMSA+PiAwXTsKICAgICAgICAgIGFbZjIgKyAyID4+IDBdID0gYVtoICsgMiA+PiAwXTsKICAgICAgICAgIGFbZjIgKyAzID4+IDBdID0gYVtoICsgMyA+PiAwXTsKICAgICAgICAgIGFbZjIgKyA0ID4+IDBdID0gYVtoICsgNCA+PiAwXTsKICAgICAgICAgIGFbZjIgKyA1ID4+IDBdID0gYVtoICsgNSA+PiAwXTsKICAgICAgICAgIGFbZjIgKyA2ID4+IDBdID0gYVtoICsgNiA+PiAwXTsKICAgICAgICAgIGFbZjIgKyA3ID4+IDBdID0gYVtoICsgNyA+PiAwXTsKICAgICAgICAgIGdbaCA+PiAzXSA9IGUyOwogICAgICAgICAgYVtiMiA+PiAwXSA9IGFbaCA+PiAwXTsKICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gYVtoICsgMSA+PiAwXTsKICAgICAgICAgIGFbYjIgKyAyID4+IDBdID0gYVtoICsgMiA+PiAwXTsKICAgICAgICAgIGFbYjIgKyAzID4+IDBdID0gYVtoICsgMyA+PiAwXTsKICAgICAgICAgIGFbYjIgKyA0ID4+IDBdID0gYVtoICsgNCA+PiAwXTsKICAgICAgICAgIGFbYjIgKyA1ID4+IDBdID0gYVtoICsgNSA+PiAwXTsKICAgICAgICAgIGFbYjIgKyA2ID4+IDBdID0gYVtoICsgNiA+PiAwXTsKICAgICAgICAgIGFbYjIgKyA3ID4+IDBdID0gYVtoICsgNyA+PiAwXTsKICAgICAgICAgIGdbaCA+PiAzXSA9IGQyOwogICAgICAgICAgYVtjMiA+PiAwXSA9IGFbaCA+PiAwXTsKICAgICAgICAgIGFbYzIgKyAxID4+IDBdID0gYVtoICsgMSA+PiAwXTsKICAgICAgICAgIGFbYzIgKyAyID4+IDBdID0gYVtoICsgMiA+PiAwXTsKICAgICAgICAgIGFbYzIgKyAzID4+IDBdID0gYVtoICsgMyA+PiAwXTsKICAgICAgICAgIGFbYzIgKyA0ID4+IDBdID0gYVtoICsgNCA+PiAwXTsKICAgICAgICAgIGFbYzIgKyA1ID4+IDBdID0gYVtoICsgNSA+PiAwXTsKICAgICAgICAgIGFbYzIgKyA2ID4+IDBdID0gYVtoICsgNiA+PiAwXTsKICAgICAgICAgIGFbYzIgKyA3ID4+IDBdID0gYVtoICsgNyA+PiAwXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGIoKSB7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDA7CiAgICAgICAgICBnMiA9IFY7CiAgICAgICAgICBWID0gViArIDQ4IHwgMDsKICAgICAgICAgIGUyID0gZzIgKyAyNCB8IDA7CiAgICAgICAgICBmMiA9IGcyOwogICAgICAgICAgYjIgPSBnMiArIDQ0IHwgMDsKICAgICAgICAgIGlmICgoYVsyMTQ0MF0gfCAwKSA9PSAwID8gVHAoMjE0NDApIHwgMCA6IDApIHsKICAgICAgICAgICAgY1s1Mzc0XSA9IDA7CiAgICAgICAgICAgIGNbNTM3NV0gPSAwOwogICAgICAgICAgICBjWzUzNzZdID0gMDsKICAgICAgICAgICAgJHAoMjE0NDApOwogICAgICAgICAgfQogICAgICAgICAgaWYgKChhWzIxNDQ4XSB8IDApID09IDAgPyBUcCgyMTQ0OCkgfCAwIDogMCkKICAgICAgICAgICAgJHAoMjE0NDgpOwogICAgICAgICAgaWYgKChjWzUzNzRdIHwgMCkgPT0gKGNbNTM3NV0gfCAwKSkgewogICAgICAgICAgICBycSgyMTUwOCk7CiAgICAgICAgICAgIGlmICgoY1s1Mzc0XSB8IDApID09IChjWzUzNzVdIHwgMCkpIHsKICAgICAgICAgICAgICBhW2UyID4+IDBdID0gYVtiMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgcGIoZjIsIGUyKTsKICAgICAgICAgICAgICBiMiA9IGNbNTM3NV0gfCAwOwogICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICBpZiAoYjIgPj4+IDAgPj0gKGNbNTM3Nl0gfCAwKSA+Pj4gMCkgewogICAgICAgICAgICAgICAgICBiMiA9ICgoYjIgLSAoY1s1Mzc0XSB8IDApIHwgMCkgLyAyNCB8IDApICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIGQyID0geGIoMjE0OTYpIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICAgICAgY3IoMjE0OTYpOwogICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBoMiA9IGNbNTM3NF0gfCAwOwogICAgICAgICAgICAgICAgICAgIGoyID0gKChjWzUzNzZdIHwgMCkgLSBoMiB8IDApIC8gMjQgfCAwOwogICAgICAgICAgICAgICAgICAgIGkyID0gajIgPDwgMTsKICAgICAgICAgICAgICAgICAgICB1YigKICAgICAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICAgICAgajIgPj4+IDAgPCBkMiA+Pj4gMSA+Pj4gMCA/IGkyID4+PiAwIDwgYjIgPj4+IDAgPyBiMiA6IGkyIDogZDIsCiAgICAgICAgICAgICAgICAgICAgICAoKGNbNTM3NV0gfCAwKSAtIGgyIHwgMCkgLyAyNCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICAyMTUwNAogICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgICAgZDIgPSBlMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgIHNiKGNbZDIgPj4gMl0gfCAwLCBmMik7CiAgICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IChjW2QyID4+IDJdIHwgMCkgKyAyNDsKICAgICAgICAgICAgICAgICAgICB2YigyMTQ5NiwgZTIpOwogICAgICAgICAgICAgICAgICAgIHdiKGUyKTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcWIoZTIsIDIxNDk2LCAxKTsKICAgICAgICAgICAgICAgICAgajIgPSBlMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICBzYihjW2oyID4+IDJdIHwgMCwgZjIpOwogICAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gKGNbajIgPj4gMl0gfCAwKSArIDI0OwogICAgICAgICAgICAgICAgICByYihlMik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgIGdiKGYyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzcSgyMTUwOCk7CiAgICAgICAgICB9CiAgICAgICAgICBWID0gZzI7CiAgICAgICAgICByZXR1cm4gMjE0OTY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGViKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGQyID0gYjIgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGUyKQogICAgICAgICAgICAgIGlmICgoYjIgfCAwKSA9PSAoZTIgfCAwKSkgewogICAgICAgICAgICAgICAgZTIgPSB0YihhMikgfCAwOwogICAgICAgICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICBkMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgZGFbY1soY1tkMiA+PiAyXSB8IDApICsgMTIgPj4gMl0gJiAxNV0oZDIsIGUyKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBaW2NbKGNbZTIgPj4gMl0gfCAwKSArIDggPj4gMl0gJiAxNV0oZTIpIHwgMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGNbYTIgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZiKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDE2ID4+IDJdIHwgMDsKICAgICAgICAgIGlmICghYTIpIHsKICAgICAgICAgICAgYjIgPSB2KDQpIHwgMDsKICAgICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICAgIE5iKGIyKTsKICAgICAgICAgICAgeChiMiB8IDAsIDQxNjgsIDEzMSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBkYVtjWyhjW2EyID4+IDJdIHwgMCkgKyAyNCA+PiAyXSAmIDE1XShhMiwgYjIpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdiKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDA7CiAgICAgICAgICBiMiA9IGNbYTIgKyAxNiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoKGEyIHwgMCkgIT0gKGIyIHwgMCkpIHsKICAgICAgICAgICAgaWYgKGIyIHwgMCkKICAgICAgICAgICAgICBjYVtjWyhjW2IyID4+IDJdIHwgMCkgKyAyMCA+PiAyXSAmIDI1NV0oYjIpOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIGNhW2NbKGNbYjIgPj4gMl0gfCAwKSArIDE2ID4+IDJdICYgMjU1XShiMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGhiKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwOwogICAgICAgICAgcTIgPSBWOwogICAgICAgICAgViA9IFYgKyA5NiB8IDA7CiAgICAgICAgICBpMiA9IHEyICsgMTYgfCAwOwogICAgICAgICAgbzIgPSBxMjsKICAgICAgICAgIGwyID0gcTIgKyA3MiB8IDA7CiAgICAgICAgICBqMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgbTIgPSBlW2IyICsgMTE0ID4+IDFdIHwgMDsKICAgICAgICAgIG4yID0gbzI7CiAgICAgICAgICBjW24yID4+IDJdID0gMDsKICAgICAgICAgIGNbbjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIG4yID0gbzIgKyA4IHwgMDsKICAgICAgICAgIGNbbjIgPj4gMl0gPSBtMjsKICAgICAgICAgIGNbbjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbaTIgPj4gMl0gPSBjW28yID4+IDJdOwogICAgICAgICAgY1tpMiArIDQgPj4gMl0gPSBjW28yICsgNCA+PiAyXTsKICAgICAgICAgIGNbaTIgKyA4ID4+IDJdID0gY1tvMiArIDggPj4gMl07CiAgICAgICAgICBjW2kyICsgMTIgPj4gMl0gPSBjW28yICsgMTIgPj4gMl07CiAgICAgICAgICBiYihqMiwgaTIpOwogICAgICAgICAgajIgPSBiMiArIDEyMCB8IDA7CiAgICAgICAgICBhOgogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmIChjW2oyID4+IDJdIHwgMCkgewogICAgICAgICAgICAgICAgazIgPSBpMiArIDIgfCAwOwogICAgICAgICAgICAgICAgbTIgPSBpMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgIG4yID0gaTIgKyAyMCB8IDA7CiAgICAgICAgICAgICAgICBvMiA9IGkyICsgMTggfCAwOwogICAgICAgICAgICAgICAgZzIgPSAwOwogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgaWYgKCEoT2IoY1tiMiA+PiAyXSB8IDApIHwgMCkpCiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgaWYgKFBiKGNbYjIgPj4gMl0gfCAwKSB8IDApCiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgJGEoY1tiMiA+PiAyXSB8IDAsIGkyLCA1NCk7CiAgICAgICAgICAgICAgICAgIGYyID0gNzI3NzsKICAgICAgICAgICAgICAgICAgaDIgPSBrMjsKICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoKGFbaDIgPj4gMF0gfCAwKSAhPSAoYVtmMiA+PiAwXSB8IDApKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgaDIgPSBoMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgIGlmICgoaDIgfCAwKSA9PSAobTIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgcDIgPSA4OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICBmMiA9IGYyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKChwMiB8IDApID09IDggPyAocDIgPSAwLCAoZFtvMiA+PiAwXSB8IGRbbzIgKyAxID4+IDBdIDw8IDgpIDw8IDE2ID4+IDE2ID09IDIyMjA0KSA6IDApCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIFJiKGNbYjIgPj4gMl0gfCAwLCAoZFtuMiA+PiAwXSB8IGRbbjIgKyAxID4+IDBdIDw8IDgpICYgNjU1MzUsIDAsIDEpOwogICAgICAgICAgICAgICAgICBnMiA9IGcyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIGlmIChnMiA+Pj4gMCA+PSAoY1tqMiA+PiAyXSB8IDApID4+PiAwKQogICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvMiA9IChkW24yID4+IDBdIHwgZFtuMiArIDEgPj4gMF0gPDwgOCkgJiA2NTUzNTsKICAgICAgICAgICAgICAgIHAyID0gZnEobzIpIHwgMDsKICAgICAgICAgICAgICAgICRhKGNbYjIgPj4gMl0gfCAwLCBwMiwgbzIpOwogICAgICAgICAgICAgICAgUWIoYjIsIHAyKTsKICAgICAgICAgICAgICAgIGpwKHAyKTsKICAgICAgICAgICAgICAgIHAyID0gYjIgKyAxMjUgfCAwOwogICAgICAgICAgICAgICAgVGIobDIsIGIyICsgMjQ3IHwgMCwgKGRbcDIgPj4gMF0gfCBkW3AyICsgMSA+PiAwXSA8PCA4KSAmIDY1NTM1KTsKICAgICAgICAgICAgICAgIFViKGIyICsgMzAwIHwgMCwgbDIpIHwgMDsKICAgICAgICAgICAgICAgIFBhKGwyKTsKICAgICAgICAgICAgICAgIFYgPSBxMjsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHEyID0gdig4KSB8IDA7CiAgICAgICAgICBTYihxMik7CiAgICAgICAgICB4KHEyIHwgMCwgMjY3MiwgOCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGliKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwOwogICAgICAgICAgbjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNzYgfCAwOwogICAgICAgICAgZzIgPSBuMiArIDQwIHwgMDsKICAgICAgICAgIGgyID0gbjIgKyAyNCB8IDA7CiAgICAgICAgICBiMiA9IG4yICsgMTYgfCAwOwogICAgICAgICAgZjIgPSBuMjsKICAgICAgICAgIGsyID0gbjIgKyAxNTIgfCAwOwogICAgICAgICAgbDIgPSBuMiArIDEzNiB8IDA7CiAgICAgICAgICBtMiA9IG4yICsgNTYgfCAwOwogICAgICAgICAgajIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gYTIgKyAxMTYgfCAwOwogICAgICAgICAgbzIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgIGUyID0gaDI7CiAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGUyID0gaDIgKyA4IHwgMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBvMjsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZzIgPj4gMl0gPSBjW2gyID4+IDJdOwogICAgICAgICAgY1tnMiArIDQgPj4gMl0gPSBjW2gyICsgNCA+PiAyXTsKICAgICAgICAgIGNbZzIgKyA4ID4+IDJdID0gY1toMiArIDggPj4gMl07CiAgICAgICAgICBjW2cyICsgMTIgPj4gMl0gPSBjW2gyICsgMTIgPj4gMl07CiAgICAgICAgICBiYihqMiwgZzIpOwogICAgICAgICAgajIgPSBiMjsKICAgICAgICAgIGNbajIgPj4gMl0gPSAwOwogICAgICAgICAgY1tqMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgJGEoY1thMiA+PiAyXSB8IDAsIGIyLCA4KTsKICAgICAgICAgIGlmICghKE9iKGNbYTIgPj4gMl0gfCAwKSB8IDApKSB7CiAgICAgICAgICAgIG8yID0gdig4KSB8IDA7CiAgICAgICAgICAgIGhjKG8yKTsKICAgICAgICAgICAgeChvMiB8IDAsIDI3MDQsIDgpOwogICAgICAgICAgfQogICAgICAgICAgZTIgPSBiMjsKICAgICAgICAgIGIyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGNbZTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoYjIgfCAwKSA9PSAtMSAmIChlMiB8IDApID09IC0xKSB7CiAgICAgICAgICAgIG8yID0gdig4KSB8IDA7CiAgICAgICAgICAgIGljKG8yLCA3NDg4KTsKICAgICAgICAgICAgeChvMiB8IDAsIDI3MjAsIDgpOwogICAgICAgICAgfQogICAgICAgICAgbzIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGoyID0gZjI7CiAgICAgICAgICBjW2oyID4+IDJdID0gMDsKICAgICAgICAgIGNbajIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGoyID0gZjIgKyA4IHwgMDsKICAgICAgICAgIGNbajIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbajIgKyA0ID4+IDJdID0gZTI7CiAgICAgICAgICBjW2cyID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgIGNbZzIgKyA0ID4+IDJdID0gY1tmMiArIDQgPj4gMl07CiAgICAgICAgICBjW2cyICsgOCA+PiAyXSA9IGNbZjIgKyA4ID4+IDJdOwogICAgICAgICAgY1tnMiArIDEyID4+IDJdID0gY1tmMiArIDEyID4+IDJdOwogICAgICAgICAgYmIobzIsIGcyKTsKICAgICAgICAgIGlmICghKE9iKGNbYTIgPj4gMl0gfCAwKSB8IDApKSB7CiAgICAgICAgICAgIG8yID0gdig4KSB8IDA7CiAgICAgICAgICAgIGhjKG8yKTsKICAgICAgICAgICAgeChvMiB8IDAsIDI3MDQsIDgpOwogICAgICAgICAgfQogICAgICAgICAgJGEoY1thMiA+PiAyXSB8IDAsIGcyLCA4KTsKICAgICAgICAgIGlmICghKE9iKGNbYTIgPj4gMl0gfCAwKSB8IDApKSB7CiAgICAgICAgICAgIG8yID0gdig4KSB8IDA7CiAgICAgICAgICAgIGhjKG8yKTsKICAgICAgICAgICAgeChvMiB8IDAsIDI3MDQsIDgpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNbZzIgPj4gMl0gfCAwKSB7CiAgICAgICAgICAgIG8yID0gdig4KSB8IDA7CiAgICAgICAgICAgIGpjKG8yKTsKICAgICAgICAgICAgeChvMiB8IDAsIDI3MzYsIDgpOwogICAgICAgICAgfQogICAgICAgICAgaDIgPSBhMiArIDI4OCB8IDA7CiAgICAgICAgICBqMiA9IGEyICsgMjkyIHwgMDsKICAgICAgICAgIGNbajIgPj4gMl0gPSBjW2gyID4+IDJdOwogICAgICAgICAgbzIgPSBhMiArIDI1OSB8IDA7CiAgICAgICAgICBpZiAoKGRbbzIgPj4gMF0gfCBkW28yICsgMSA+PiAwXSA8PCA4IHwgZFtvMiArIDIgPj4gMF0gPDwgMTYgfCBkW28yICsgMyA+PiAwXSA8PCAyNCB8IDApID09IC0xKSB7CiAgICAgICAgICAgIG8yID0gdig4KSB8IDA7CiAgICAgICAgICAgIGljKG8yLCA3NjA2KTsKICAgICAgICAgICAgeChvMiB8IDAsIDI3MjAsIDgpOwogICAgICAgICAgfQogICAgICAgICAgZjIgPSBnMiArIDQgfCAwOwogICAgICAgICAga2MoaDIsIChjW2YyID4+IDJdIHwgMCkgKyAxIHwgMCk7CiAgICAgICAgICBvMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgY1tvMiA+PiAyXSA9IChjW2kyID4+IDJdIHwgMCkgKyA4OwogICAgICAgICAgY1tvMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgaWYgKChjW2YyID4+IDJdIHwgMCkgPj4+IDAgPiAxKSB7CiAgICAgICAgICAgIFZhKGsyLCBjW2EyID4+IDJdIHwgMCk7CiAgICAgICAgICAgIGxjKGwyLCBrMik7CiAgICAgICAgICAgIG1jKG0yLCAzMiwgMiwgOCwgMCk7CiAgICAgICAgICAgIG5jKGwyKTsKICAgICAgICAgICAgb2MobTIpOwogICAgICAgICAgICBpZiAoIShjW2YyID4+IDJdIHwgMCkpIHsKICAgICAgICAgICAgICBoMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGUyID0gaDI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZTIgPSAxOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGlmIChlMiA+Pj4gMCA+IDEpCiAgICAgICAgICAgICAgICAgIGIyID0gY1soY1toMiA+PiAyXSB8IDApICsgKGUyICsgLTEgPDwgMykgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICBiMiA9IDA7CiAgICAgICAgICAgICAgICBpMiA9IHBjKG0yLCBsMiwgYjIsIDEpIHwgMDsKICAgICAgICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBvMiA9IGIyICsgKGUyIDw8IDMpIHwgMDsKICAgICAgICAgICAgICAgIGNbbzIgPj4gMl0gPSBpMjsKICAgICAgICAgICAgICAgIGNbbzIgKyA0ID4+IDJdID0gKChpMiB8IDApIDwgMCkgPDwgMzEgPj4gMzE7CiAgICAgICAgICAgICAgICBlMiA9IGUyICsgMSB8IDA7CiAgICAgICAgICAgICAgfSB3aGlsZSAoZTIgPj4+IDAgPD0gKGNbZjIgPj4gMl0gfCAwKSA+Pj4gMCk7CiAgICAgICAgICAgICAgZTIgPSBiMjsKICAgICAgICAgICAgICBoMiA9IGIyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGIyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGlmIChiMiAtIGUyID4+IDMgPj4+IDAgPiAxKSB7CiAgICAgICAgICAgICAgZzIgPSBiMiAtIGgyID4+IDM7CiAgICAgICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgICAgICBiMiA9IDE7CiAgICAgICAgICAgICAgZTIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBmMiA9IGNbZjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBvMiA9IGgyICsgKGIyIDw8IDMpIHwgMDsKICAgICAgICAgICAgICAgIGoyID0gbzI7CiAgICAgICAgICAgICAgICBlMiA9IGxyKGNbajIgPj4gMl0gfCAwLCBjW2oyICsgNCA+PiAyXSB8IDAsIGUyIHwgMCwgZjIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICBmMiA9IHUoKSB8IDA7CiAgICAgICAgICAgICAgICBjW28yID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICBjW28yICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgICAgIH0gd2hpbGUgKGIyID4+PiAwIDwgZzIgPj4+IDApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHFjKG0yKTsKICAgICAgICAgICAgcmMobDIpOwogICAgICAgICAgICBSYShrMik7CiAgICAgICAgICB9CiAgICAgICAgICBWID0gbjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGpiKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGFbYjIgKyAxMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMTMgPj4gMF0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBrYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGxiKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBmbyhhMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtYihiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMDsKICAgICAgICAgIGkyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZzIgPSBkMjsKICAgICAgICAgIGgyID0gaTI7CiAgICAgICAgICBmMiA9IGUyIC0gZzIgfCAwOwogICAgICAgICAgaWYgKGYyID4+PiAwID4gNDI5NDk2NzI3OSkKICAgICAgICAgICAgeXEoYjIpOwogICAgICAgICAgaWYgKGYyID4+PiAwIDwgMTEpCiAgICAgICAgICAgIGFbYjIgKyAxMSA+PiAwXSA9IGYyOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGsyID0gZjIgKyAxNiAmIC0xNjsKICAgICAgICAgICAgajIgPSBlcShrMikgfCAwOwogICAgICAgICAgICBjW2IyID4+IDJdID0gajI7CiAgICAgICAgICAgIGNbYjIgKyA4ID4+IDJdID0gazIgfCAtMjE0NzQ4MzY0ODsKICAgICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgICAgYjIgPSBqMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoZDIgfCAwKSAhPSAoZTIgfCAwKSkgewogICAgICAgICAgICBnMiA9IGUyIC0gZzIgfCAwOwogICAgICAgICAgICBmMiA9IGIyOwogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIG5iKGYyLCBkMik7CiAgICAgICAgICAgICAgZDIgPSBkMiArIDEgfCAwOwogICAgICAgICAgICAgIGlmICgoZDIgfCAwKSA9PSAoZTIgfCAwKSkKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIGYyID0gZjIgKyAxIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBiMiA9IGIyICsgZzIgfCAwOwogICAgICAgICAgfQogICAgICAgICAgYVtoMiA+PiAwXSA9IDA7CiAgICAgICAgICBuYihiMiwgaDIpOwogICAgICAgICAgViA9IGkyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuYihiMiwgYzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBhW2IyID4+IDBdID0gYVtjMiA+PiAwXSB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9iKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHlwKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGIoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQzNzI7CiAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBhMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcWIoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgYjIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBiMiArIChkMiAqIDI0IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJiKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbKGNbYTIgPj4gMl0gfCAwKSArIDQgPj4gMl0gPSBjW2EyICsgNCA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc2IoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgZDIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgIGUyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoZTIpCiAgICAgICAgICAgICAgaWYgKChiMiB8IDApID09IChlMiB8IDApKSB7CiAgICAgICAgICAgICAgICBlMiA9IHRiKGEyKSB8IDA7CiAgICAgICAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBlMjsKICAgICAgICAgICAgICAgIGQyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBkYVtjWyhjW2QyID4+IDJdIHwgMCkgKyAxMiA+PiAyXSAmIDE1XShkMiwgZTIpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNbYTIgKyAxNiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSAwOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0YihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1YihhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwOwogICAgICAgICAgZjIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgaWYgKGIyID4+PiAwID4gMTc4OTU2OTcwKSB7CiAgICAgICAgICAgICAgICBmMiA9IHYoOCkgfCAwOwogICAgICAgICAgICAgICAgdnEoZjIsIDY3MjMpOwogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDU5NTY7CiAgICAgICAgICAgICAgICB4KGYyIHwgMCwgMzkyOCwgMTIzKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZTIgPSBlcShiMiAqIDI0IHwgMCkgfCAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgY1thMiA+PiAyXSA9IGUyOwogICAgICAgICAgZDIgPSBlMiArIChkMiAqIDI0IHwgMCkgfCAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBkMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2YyID4+IDJdID0gZTIgKyAoYjIgKiAyNCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB2YihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwOwogICAgICAgICAgaTIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGoyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGQyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICBoMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBpZiAoKGQyIHwgMCkgPT0gKGkyIHwgMCkpIHsKICAgICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgICAgZzIgPSBhMjsKICAgICAgICAgICAgZTIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgICAgZDIgPSBpMjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGUyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBkMiA9IGQyICsgLTI0IHwgMDsKICAgICAgICAgICAgICBzYihlMiArIC0yNCB8IDAsIGQyKTsKICAgICAgICAgICAgICBlMiA9IChjW2gyID4+IDJdIHwgMCkgKyAtMjQgfCAwOwogICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgfSB3aGlsZSAoKGQyIHwgMCkgIT0gKGkyIHwgMCkpOwogICAgICAgICAgICBmMiA9IGgyOwogICAgICAgICAgICBnMiA9IGEyOwogICAgICAgICAgICBkMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgfQogICAgICAgICAgY1tnMiA+PiAyXSA9IGUyOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGQyOwogICAgICAgICAgaTIgPSBiMiArIDggfCAwOwogICAgICAgICAgaDIgPSBjW2oyID4+IDJdIHwgMDsKICAgICAgICAgIGNbajIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgY1tpMiA+PiAyXSA9IGgyOwogICAgICAgICAgaTIgPSBhMiArIDggfCAwOwogICAgICAgICAgajIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgIGEyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2kyID4+IDJdID0gY1tqMiA+PiAyXTsKICAgICAgICAgIGNbajIgPj4gMl0gPSBhMjsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3YihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBiMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChiMiB8IDApICE9IChkMiB8IDApKQogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgZjIgPSBiMiArIC0yNCB8IDA7CiAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGYyOwogICAgICAgICAgICAgIGdiKGYyKTsKICAgICAgICAgICAgICBiMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICB9IHdoaWxlICgoYjIgfCAwKSAhPSAoZDIgfCAwKSk7CiAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGIyIHwgMCkKICAgICAgICAgICAgRGEoYjIsIChjW2EyICsgMTIgPj4gMl0gfCAwKSAtIGIyIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHhiKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAxNzg5NTY5NzA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHliKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gemIoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSBlcSg4KSB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDM3MjsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFiKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSA0MzcyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBCYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENiKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCA4KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRGIoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgSGIoYTIgKyA0IHwgMCwgYjIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFYihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDcxODMgPyBhMiArIDQgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gMjY2NDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gR2IoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBIYihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBJYihhMiwgYjIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBJYihiMiwgYzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBiMiA9IGMyICsgMTA0IHwgMDsKICAgICAgICAgIGMyID0gZFtiMiA+PiAwXSB8IDA7CiAgICAgICAgICBlMiA9IGMyID4+PiA3OwogICAgICAgICAgZjIgPSBjMiA+Pj4gNiAmIDE7CiAgICAgICAgICBpZiAoKGUyIHwgMCkgPT0gMSAmIChmMiB8IDApICE9IDApIHsKICAgICAgICAgICAgZjIgPSB2KDgpIHwgMDsKICAgICAgICAgICAgSmIoZjIpOwogICAgICAgICAgICB4KGYyIHwgMCwgMjYzMiwgOCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKGUyIHwgMCkgPT0gKGYyIHwgMCkpIHsKICAgICAgICAgICAgZjIgPSB2KDgpIHwgMDsKICAgICAgICAgICAgS2IoZjIpOwogICAgICAgICAgICB4KGYyIHwgMCwgMjY0OCwgOCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBhW2IyID4+IDBdID0gYzIgJiA2MzsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB4cShhMiwgNzA3Nik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDQxNjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gS2IoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeHEoYTIsIDcxNDQpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ0MzY7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIExiKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHlwKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTWIoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeXAoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNjA5MjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT2IoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGMyID0gMDsKICAgICAgICAgIGMyID0gYjIgKyAxMiB8IDA7CiAgICAgICAgICBiMiA9IChhW2MyID4+IDBdIHwgMCkgPT0gMDsKICAgICAgICAgIGFbYzIgPj4gMF0gPSAwOwogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUGIoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChhW2IyICsgMTMgPj4gMF0gfCAwKSAhPSAwIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUWIoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYTIgPSBhMiArIDI0NyB8IDA7CiAgICAgICAgICBWYihhMiwgYjIpOwogICAgICAgICAgaWYgKChkW2EyID4+IDBdIHwgZFthMiArIDEgPj4gMF0gPDwgOCkgPDwgMTYgPj4gMTYgPT0gMikKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGIyID0gdig4KSB8IDA7CiAgICAgICAgICAgIFdiKGIyKTsKICAgICAgICAgICAgeChiMiB8IDAsIDI2ODgsIDgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBSYihiMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICB2YXIgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBzd2l0Y2ggKGYyIHwgMCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjogewogICAgICAgICAgICAgIGYyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGQyID0gbHIobHIoZDIgfCAwLCBlMiB8IDAsIC0xLCAtMSkgfCAwLCB1KCkgfCAwLCBmMiB8IDAsICgoZjIgfCAwKSA8IDApIDw8IDMxID4+IDMxIHwgMCkgfCAwOwogICAgICAgICAgICAgIGUyID0gdSgpIHwgMDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIDE6IHsKICAgICAgICAgICAgICBmMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICBkMiA9IGxyKGYyIHwgMCwgKChmMiB8IDApIDwgMCkgPDwgMzEgPj4gMzEgfCAwLCBkMiB8IDAsIGUyIHwgMCkgfCAwOwogICAgICAgICAgICAgIGUyID0gdSgpIHwgMDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZzIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBoMiA9ICgoZzIgfCAwKSA8IDApIDw8IDMxID4+IDMxOwogICAgICAgICAgZjIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgIGlmICgoZTIgfCAwKSA8IDAgfCAoKGUyIHwgMCkgPiAoaDIgfCAwKSB8IChlMiB8IDApID09IChoMiB8IDApICYgZDIgPj4+IDAgPj0gZzIgPj4+IDApKQogICAgICAgICAgICBhW2YyID4+IDBdID0gMTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBhW2YyID4+IDBdID0gMDsKICAgICAgICAgICAgY1tiMiArIDggPj4gMl0gPSBkMjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2IoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeHEoYTIsIDc0MTApOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ0NzY7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRiKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDA7CiAgICAgICAgICBoMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGcyID0gaDI7CiAgICAgICAgICBYYShhMik7CiAgICAgICAgICBmMiA9IGIyICsgMzIgfCAwOwogICAgICAgICAgaWYgKChkW2YyID4+IDBdIHwgZFtmMiArIDEgPj4gMF0gPDwgOCkgPDwgMTYgPj4gMTYpIHsKICAgICAgICAgICAgZTIgPSBiMiArIDM0IHwgMDsKICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgajIgPSBkW2UyID4+IDBdIHwgZFtlMiArIDEgPj4gMF0gPDwgOCB8IGRbZTIgKyAyID4+IDBdIDw8IDE2IHwgZFtlMiArIDMgPj4gMF0gPDwgMjQ7CiAgICAgICAgICAgICAgazIgPSBqMiArIChiMiAqIDYgfCAwKSB8IDA7CiAgICAgICAgICAgICAgaTIgPSBqMiArIChiMiAqIDYgfCAwKSArIDIgfCAwOwogICAgICAgICAgICAgIGoyID0gajIgKyAoYjIgKiA2IHwgMCkgKyA0IHwgMDsKICAgICAgICAgICAgICBfYigKICAgICAgICAgICAgICAgIGcyLAogICAgICAgICAgICAgICAgKGRbazIgPj4gMF0gfCBkW2syICsgMSA+PiAwXSA8PCA4KSAmIDY1NTM1LAogICAgICAgICAgICAgICAgKGRbaTIgPj4gMF0gfCBkW2kyICsgMSA+PiAwXSA8PCA4KSAmIDY1NTM1LAogICAgICAgICAgICAgICAgKGRbajIgPj4gMF0gfCBkW2oyICsgMSA+PiAwXSA8PCA4KSAmIDY1NTM1CiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICBaYihhMiwgZzIpOwogICAgICAgICAgICAgIGMyID0gYzIgLSAoKGRbaTIgPj4gMF0gfCBkW2kyICsgMSA+PiAwXSA8PCA4KSAmIDY1NTM1KSB8IDA7CiAgICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgICB9IHdoaWxlIChiMiA+Pj4gMCA8ICgoZFtmMiA+PiAwXSB8IGRbZjIgKyAxID4+IDBdIDw8IDgpICYgNjU1MzUpID4+PiAwKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoYzIgfCAwKSA8IDApIHsKICAgICAgICAgICAgazIgPSB2KDgpIHwgMDsKICAgICAgICAgICAgV2IoazIpOwogICAgICAgICAgICB4KGsyIHwgMCwgMjY4OCwgOCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYzIgfCAwKSB7CiAgICAgICAgICAgIF9iKGcyLCAwLCBjMiwgMik7CiAgICAgICAgICAgIFpiKGEyLCBnMik7CiAgICAgICAgICB9CiAgICAgICAgICBWID0gaDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFViKGIyLCBjMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMiArIDEgfCAwOwogICAgICAgICAgYVtlMiA+PiAwXSA9IGFbZDIgPj4gMF0gfCAwOwogICAgICAgICAgZmMoYjIsIGMyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWYihiMiwgYzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwOwogICAgICAgICAgZjIgPSBjMiArIDIgfCAwOwogICAgICAgICAgaDIgPSBkW2MyID4+IDBdIHwgZFtjMiArIDEgPj4gMF0gPDwgODsKICAgICAgICAgIGFbYjIgPj4gMF0gPSBoMjsKICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gaDIgPj4gODsKICAgICAgICAgIGgyID0gYjIgKyAyIHwgMDsKICAgICAgICAgIGYyID0gZFtmMiA+PiAwXSB8IGRbZjIgKyAxID4+IDBdIDw8IDg7CiAgICAgICAgICBhW2gyID4+IDBdID0gZjI7CiAgICAgICAgICBhW2gyICsgMSA+PiAwXSA9IGYyID4+IDg7CiAgICAgICAgICBhW2IyICsgNCA+PiAwXSA9IGFbYzIgKyA0ID4+IDBdIHwgMDsKICAgICAgICAgIGgyID0gYzIgKyA2IHwgMDsKICAgICAgICAgIGFbYjIgKyA1ID4+IDBdID0gYVtjMiArIDUgPj4gMF0gfCAwOwogICAgICAgICAgZjIgPSBjMiArIDggfCAwOwogICAgICAgICAgZTIgPSBiMiArIDYgfCAwOwogICAgICAgICAgaDIgPSBkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgODsKICAgICAgICAgIGFbZTIgPj4gMF0gPSBoMjsKICAgICAgICAgIGFbZTIgKyAxID4+IDBdID0gaDIgPj4gODsKICAgICAgICAgIGUyID0gYzIgKyAxMiB8IDA7CiAgICAgICAgICBoMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICBmMiA9IGRbZjIgPj4gMF0gfCBkW2YyICsgMSA+PiAwXSA8PCA4IHwgZFtmMiArIDIgPj4gMF0gPDwgMTYgfCBkW2YyICsgMyA+PiAwXSA8PCAyNDsKICAgICAgICAgIGFbaDIgPj4gMF0gPSBmMjsKICAgICAgICAgIGFbaDIgKyAxID4+IDBdID0gZjIgPj4gODsKICAgICAgICAgIGFbaDIgKyAyID4+IDBdID0gZjIgPj4gMTY7CiAgICAgICAgICBhW2gyICsgMyA+PiAwXSA9IGYyID4+IDI0OwogICAgICAgICAgaDIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgIGUyID0gZFtlMiA+PiAwXSB8IGRbZTIgKyAxID4+IDBdIDw8IDggfCBkW2UyICsgMiA+PiAwXSA8PCAxNiB8IGRbZTIgKyAzID4+IDBdIDw8IDI0OwogICAgICAgICAgYVtoMiA+PiAwXSA9IGUyOwogICAgICAgICAgYVtoMiArIDEgPj4gMF0gPSBlMiA+PiA4OwogICAgICAgICAgYVtoMiArIDIgPj4gMF0gPSBlMiA+PiAxNjsKICAgICAgICAgIGFbaDIgKyAzID4+IDBdID0gZTIgPj4gMjQ7CiAgICAgICAgICBoMiA9IGMyICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBoMjsKICAgICAgICAgIGUyID0gZFtlMiA+PiAwXSB8IGRbZTIgKyAxID4+IDBdIDw8IDggfCBkW2UyICsgMiA+PiAwXSA8PCAxNiB8IGRbZTIgKyAzID4+IDBdIDw8IDI0OwogICAgICAgICAgaDIgPSBoMiArIDQgfCAwOwogICAgICAgICAgaDIgPSBkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCB8IGRbaDIgKyAyID4+IDBdIDw8IDE2IHwgZFtoMiArIDMgPj4gMF0gPDwgMjQ7CiAgICAgICAgICBmMiA9IGIyICsgMTYgfCAwOwogICAgICAgICAgaTIgPSBmMjsKICAgICAgICAgIGFbaTIgPj4gMF0gPSBlMjsKICAgICAgICAgIGFbaTIgKyAxID4+IDBdID0gZTIgPj4gODsKICAgICAgICAgIGFbaTIgKyAyID4+IDBdID0gZTIgPj4gMTY7CiAgICAgICAgICBhW2kyICsgMyA+PiAwXSA9IGUyID4+IDI0OwogICAgICAgICAgZjIgPSBmMiArIDQgfCAwOwogICAgICAgICAgYVtmMiA+PiAwXSA9IGgyOwogICAgICAgICAgYVtmMiArIDEgPj4gMF0gPSBoMiA+PiA4OwogICAgICAgICAgYVtmMiArIDIgPj4gMF0gPSBoMiA+PiAxNjsKICAgICAgICAgIGFbZjIgKyAzID4+IDBdID0gaDIgPj4gMjQ7CiAgICAgICAgICBmMiA9IGMyICsgMzIgfCAwOwogICAgICAgICAgaDIgPSBjMiArIDI0IHwgMDsKICAgICAgICAgIGkyID0gaDI7CiAgICAgICAgICBpMiA9IGRbaTIgPj4gMF0gfCBkW2kyICsgMSA+PiAwXSA8PCA4IHwgZFtpMiArIDIgPj4gMF0gPDwgMTYgfCBkW2kyICsgMyA+PiAwXSA8PCAyNDsKICAgICAgICAgIGgyID0gaDIgKyA0IHwgMDsKICAgICAgICAgIGgyID0gZFtoMiA+PiAwXSB8IGRbaDIgKyAxID4+IDBdIDw8IDggfCBkW2gyICsgMiA+PiAwXSA8PCAxNiB8IGRbaDIgKyAzID4+IDBdIDw8IDI0OwogICAgICAgICAgZTIgPSBiMiArIDI0IHwgMDsKICAgICAgICAgIGcyID0gZTI7CiAgICAgICAgICBhW2cyID4+IDBdID0gaTI7CiAgICAgICAgICBhW2cyICsgMSA+PiAwXSA9IGkyID4+IDg7CiAgICAgICAgICBhW2cyICsgMiA+PiAwXSA9IGkyID4+IDE2OwogICAgICAgICAgYVtnMiArIDMgPj4gMF0gPSBpMiA+PiAyNDsKICAgICAgICAgIGUyID0gZTIgKyA0IHwgMDsKICAgICAgICAgIGFbZTIgPj4gMF0gPSBoMjsKICAgICAgICAgIGFbZTIgKyAxID4+IDBdID0gaDIgPj4gODsKICAgICAgICAgIGFbZTIgKyAyID4+IDBdID0gaDIgPj4gMTY7CiAgICAgICAgICBhW2UyICsgMyA+PiAwXSA9IGgyID4+IDI0OwogICAgICAgICAgZTIgPSBjMiArIDM0IHwgMDsKICAgICAgICAgIGgyID0gYjIgKyAzMiB8IDA7CiAgICAgICAgICBmMiA9IGRbZjIgPj4gMF0gfCBkW2YyICsgMSA+PiAwXSA8PCA4OwogICAgICAgICAgYVtoMiA+PiAwXSA9IGYyOwogICAgICAgICAgYVtoMiArIDEgPj4gMF0gPSBmMiA+PiA4OwogICAgICAgICAgZzIgPSBiMiArIDM0IHwgMDsKICAgICAgICAgIGIyID0gZFtnMiA+PiAwXSB8IGRbZzIgKyAxID4+IDBdIDw8IDggfCBkW2cyICsgMiA+PiAwXSA8PCAxNiB8IGRbZzIgKyAzID4+IDBdIDw8IDI0OwogICAgICAgICAgaWYgKCFiMikKICAgICAgICAgICAgYjIgPSBmMjsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBncShiMik7CiAgICAgICAgICAgIGIyID0gZFtoMiA+PiAwXSB8IGRbaDIgKyAxID4+IDBdIDw8IDg7CiAgICAgICAgICB9CiAgICAgICAgICBmMiA9IGZxKChiMiAmIDY1NTM1KSAqIDYgfCAwKSB8IDA7CiAgICAgICAgICBhW2cyID4+IDBdID0gZjI7CiAgICAgICAgICBhW2cyICsgMSA+PiAwXSA9IGYyID4+IDg7CiAgICAgICAgICBhW2cyICsgMiA+PiAwXSA9IGYyID4+IDE2OwogICAgICAgICAgYVtnMiArIDMgPj4gMF0gPSBmMiA+PiAyNDsKICAgICAgICAgIGlmIChiMiA8PCAxNiA+PiAxNiA/IChiMiA9IGMyICsgMzYgfCAwLCBpMiA9IGRbZTIgPj4gMF0gfCBkW2UyICsgMSA+PiAwXSA8PCA4LCBhW2YyID4+IDBdID0gaTIsIGFbZjIgKyAxID4+IDBdID0gaTIgPj4gOCwgYzIgPSBjMiArIDM4IHwgMCwgaTIgPSBmMiArIDIgfCAwLCBiMiA9IGRbYjIgPj4gMF0gfCBkW2IyICsgMSA+PiAwXSA8PCA4LCBhW2kyID4+IDBdID0gYjIsIGFbaTIgKyAxID4+IDBdID0gYjIgPj4gOCwgaTIgPSBmMiArIDQgfCAwLCBjMiA9IGRbYzIgPj4gMF0gfCBkW2MyICsgMSA+PiAwXSA8PCA4LCBhW2kyID4+IDBdID0gYzIsIGFbaTIgKyAxID4+IDBdID0gYzIgPj4gOCwgKChkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCkgJiA2NTUzNSkgPiAxKSA6IDApIHsKICAgICAgICAgICAgYjIgPSAxOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgYzIgPSBlMjsKICAgICAgICAgICAgICBlMiA9IGUyICsgNiB8IDA7CiAgICAgICAgICAgICAgaTIgPSBkW2cyID4+IDBdIHwgZFtnMiArIDEgPj4gMF0gPDwgOCB8IGRbZzIgKyAyID4+IDBdIDw8IDE2IHwgZFtnMiArIDMgPj4gMF0gPDwgMjQ7CiAgICAgICAgICAgICAgajIgPSBjMiArIDggfCAwOwogICAgICAgICAgICAgIGYyID0gaTIgKyAoYjIgKiA2IHwgMCkgfCAwOwogICAgICAgICAgICAgIGsyID0gZFtlMiA+PiAwXSB8IGRbZTIgKyAxID4+IDBdIDw8IDg7CiAgICAgICAgICAgICAgYVtmMiA+PiAwXSA9IGsyOwogICAgICAgICAgICAgIGFbZjIgKyAxID4+IDBdID0gazIgPj4gODsKICAgICAgICAgICAgICBjMiA9IGMyICsgMTAgfCAwOwogICAgICAgICAgICAgIGYyID0gaTIgKyAoYjIgKiA2IHwgMCkgKyAyIHwgMDsKICAgICAgICAgICAgICBqMiA9IGRbajIgPj4gMF0gfCBkW2oyICsgMSA+PiAwXSA8PCA4OwogICAgICAgICAgICAgIGFbZjIgPj4gMF0gPSBqMjsKICAgICAgICAgICAgICBhW2YyICsgMSA+PiAwXSA9IGoyID4+IDg7CiAgICAgICAgICAgICAgaTIgPSBpMiArIChiMiAqIDYgfCAwKSArIDQgfCAwOwogICAgICAgICAgICAgIGMyID0gZFtjMiA+PiAwXSB8IGRbYzIgKyAxID4+IDBdIDw8IDg7CiAgICAgICAgICAgICAgYVtpMiA+PiAwXSA9IGMyOwogICAgICAgICAgICAgIGFbaTIgKyAxID4+IDBdID0gYzIgPj4gODsKICAgICAgICAgICAgICBiMiA9IGIyICsgMSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKGIyID4+PiAwIDwgKChkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCkgJiA2NTUzNSkgPj4+IDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBXYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB4cShhMiwgNzM1NCk7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDQ1NjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWGIoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeXAoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBZYihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB5cChhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFpiKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMDsKICAgICAgICAgIGkyID0gVjsKICAgICAgICAgIFYgPSBWICsgMzIgfCAwOwogICAgICAgICAgZjIgPSBpMjsKICAgICAgICAgIGcyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGQyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICBoMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoKGQyIHwgMCkgPT0gKGNbaDIgPj4gMl0gfCAwKSkgewogICAgICAgICAgICAgIGQyID0gKChkMiAtIChjW2EyID4+IDJdIHwgMCkgfCAwKSAvIDEyIHwgMCkgKyAxIHwgMDsKICAgICAgICAgICAgICBlMiA9IGVjKGEyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGUyID4+PiAwIDwgZDIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihhMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBqMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgazIgPSAoKGNbaDIgPj4gMl0gfCAwKSAtIGoyIHwgMCkgLyAxMiB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGsyIDw8IDE7CiAgICAgICAgICAgICAgICBiYygKICAgICAgICAgICAgICAgICAgZjIsCiAgICAgICAgICAgICAgICAgIGsyID4+PiAwIDwgZTIgPj4+IDEgPj4+IDAgPyBoMiA+Pj4gMCA8IGQyID4+PiAwID8gZDIgOiBoMiA6IGUyLAogICAgICAgICAgICAgICAgICAoKGNbZzIgPj4gMl0gfCAwKSAtIGoyIHwgMCkgLyAxMiB8IDAsCiAgICAgICAgICAgICAgICAgIGEyICsgOCB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBoMiA9IGYyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBnMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2cyICsgNCA+PiAyXSA9IGNbYjIgKyA0ID4+IDJdOwogICAgICAgICAgICAgICAgY1tnMiArIDggPj4gMl0gPSBjW2IyICsgOCA+PiAyXTsKICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAoY1toMiA+PiAyXSB8IDApICsgMTI7CiAgICAgICAgICAgICAgICBjYyhhMiwgZjIpOwogICAgICAgICAgICAgICAgZGMoZjIpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICRiKGYyLCBhMiwgMSk7CiAgICAgICAgICAgICAgazIgPSBmMiArIDQgfCAwOwogICAgICAgICAgICAgIGoyID0gY1trMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgY1tqMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICAgICAgY1tqMiArIDQgPj4gMl0gPSBjW2IyICsgNCA+PiAyXTsKICAgICAgICAgICAgICBjW2oyICsgOCA+PiAyXSA9IGNbYjIgKyA4ID4+IDJdOwogICAgICAgICAgICAgIGNbazIgPj4gMl0gPSAoY1trMiA+PiAyXSB8IDApICsgMTI7CiAgICAgICAgICAgICAgYWMoZjIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBWID0gaTI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9iKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGUyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiAkYihhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBiMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGIyICsgKGQyICogMTIgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1soY1thMiA+PiAyXSB8IDApICsgNCA+PiAyXSA9IGNbYTIgKyA0ID4+IDJdOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBiYyhhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwOwogICAgICAgICAgZjIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgaWYgKGIyID4+PiAwID4gMzU3OTEzOTQxKSB7CiAgICAgICAgICAgICAgICBmMiA9IHYoOCkgfCAwOwogICAgICAgICAgICAgICAgdnEoZjIsIDY3MjMpOwogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDU5NTY7CiAgICAgICAgICAgICAgICB4KGYyIHwgMCwgMzkyOCwgMTIzKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZTIgPSBlcShiMiAqIDEyIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgY1thMiA+PiAyXSA9IGUyOwogICAgICAgICAgZDIgPSBlMiArIChkMiAqIDEyIHwgMCkgfCAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBkMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2YyID4+IDJdID0gZTIgKyAoYjIgKiAxMiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBjYyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgaDIgPSBhMiArIDQgfCAwOwogICAgICAgICAgZzIgPSBiMiArIDQgfCAwOwogICAgICAgICAgZjIgPSAoY1toMiA+PiAyXSB8IDApIC0gZTIgfCAwOwogICAgICAgICAgZDIgPSAoY1tnMiA+PiAyXSB8IDApICsgKCgoZjIgfCAwKSAvIC0xMiB8IDApICogMTIgfCAwKSB8IDA7CiAgICAgICAgICBjW2cyID4+IDJdID0gZDI7CiAgICAgICAgICBpZiAoKGYyIHwgMCkgPiAwKSB7CiAgICAgICAgICAgIHVyKGQyIHwgMCwgZTIgfCAwLCBmMiB8IDApIHwgMDsKICAgICAgICAgICAgZTIgPSBnMjsKICAgICAgICAgICAgZDIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICBlMiA9IGcyOwogICAgICAgICAgZzIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBkMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBnMjsKICAgICAgICAgIGcyID0gYjIgKyA4IHwgMDsKICAgICAgICAgIGYyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2gyID4+IDJdID0gY1tnMiA+PiAyXTsKICAgICAgICAgIGNbZzIgPj4gMl0gPSBmMjsKICAgICAgICAgIGcyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGgyID0gYjIgKyAxMiB8IDA7CiAgICAgICAgICBhMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgY1tnMiA+PiAyXSA9IGNbaDIgPj4gMl07CiAgICAgICAgICBjW2gyID4+IDJdID0gYTI7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBiMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGUyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoKGUyIHwgMCkgIT0gKGIyIHwgMCkpCiAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBlMiArICh+KCgoZTIgKyAtMTIgLSBiMiB8IDApID4+PiAwKSAvIDEyIHwgMCkgKiAxMiB8IDApOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChiMiB8IDApCiAgICAgICAgICAgIERhKGIyLCAoY1thMiArIDEyID4+IDJdIHwgMCkgLSBiMiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gMzU3OTEzOTQxOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBmYyhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwOwogICAgICAgICAgZ2MoYTIpOwogICAgICAgICAgY1thMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICBkMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBlMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGNbZTIgPj4gMl07CiAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgIGNbZDIgPj4gMl0gPSAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdjKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGlmIChiMiB8IDApIHsKICAgICAgICAgICAgZTIgPSBhMiArIDQgfCAwOwogICAgICAgICAgICBjW2UyID4+IDJdID0gZDI7CiAgICAgICAgICAgIGYyID0gYTIgKyA4IHwgMDsKICAgICAgICAgICAgRGEoYjIsIChjW2YyID4+IDJdIHwgMCkgLSBkMiB8IDApOwogICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgY1tlMiA+PiAyXSA9IDA7CiAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBoYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB4cShhMiwgNzY2MCk7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDQ5NjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaWMoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgeHEoYTIsIGIyKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0NTE2OwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB4cShhMiwgNzcwNCk7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDUzNjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga2MoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBmMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSAoY1tkMiA+PiAyXSB8IDApIC0gZjIgPj4gMzsKICAgICAgICAgIGlmIChlMiA+Pj4gMCA+PSBiMiA+Pj4gMCkgewogICAgICAgICAgICBpZiAoZTIgPj4+IDAgPiBiMiA+Pj4gMCkKICAgICAgICAgICAgICBjW2QyID4+IDJdID0gZjIgKyAoYjIgPDwgMyk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgdmMoYTIsIGIyIC0gZTIgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGMoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSAtMTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbWMoYTIsIGIyLCBkMiwgZTIsIGYyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgdmFyIGcyID0gMDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGQyOwogICAgICAgICAgY1thMiArIDEyID4+IDJdID0gZTI7CiAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBmMjsKICAgICAgICAgIGNbYTIgKyAzNiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNDAgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDQ0ID4+IDJdID0gMDsKICAgICAgICAgIEdjKGEyICsgNDggfCAwKTsKICAgICAgICAgIGNbYTIgKyA2OCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNzIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDc2ID4+IDJdID0gMDsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmICghZjIpIHsKICAgICAgICAgICAgICBkMiA9IGEyICsgMjAgfCAwOwogICAgICAgICAgICAgIGlmICgoYjIgKyAtMSB8IDApID4+PiAwIDwgMzEpIHsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgIGYyID0gMSA8PCBiMjsKICAgICAgICAgICAgICAgIGNbYTIgKyAyNCA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgZDIgPSBmMiA+Pj4gMTsKICAgICAgICAgICAgICAgIGNbYTIgKyAyOCA+PiAyXSA9IDAgLSBkMjsKICAgICAgICAgICAgICAgIGQyID0gZjIgKyAtMSAtIGQyIHwgMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gMzI7CiAgICAgICAgICAgICAgICBjW2EyICsgMjQgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1thMiArIDI4ID4+IDJdID0gLTIxNDc0ODM2NDg7CiAgICAgICAgICAgICAgICBkMiA9IDIxNDc0ODM2NDc7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZTIgPSBhMiArIDIwIHwgMDsKICAgICAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgICAgICBjW2EyICsgMjQgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICBkMiA9IGYyOwogICAgICAgICAgICAgIGcyID0gMDsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgZDIgPSBkMiA+Pj4gMTsKICAgICAgICAgICAgICAgIGIyID0gZzIgKyAxIHwgMDsKICAgICAgICAgICAgICAgIGlmICghZDIpCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICBnMiA9IGIyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjW2UyID4+IDJdID0gKDEgPDwgZzIgfCAwKSA9PSAoZjIgfCAwKSA/IGcyIDogYjI7CiAgICAgICAgICAgICAgZDIgPSBmMiA+Pj4gMTsKICAgICAgICAgICAgICBjW2EyICsgMjggPj4gMl0gPSAwIC0gZDI7CiAgICAgICAgICAgICAgZDIgPSBmMiArIC0xIC0gZDIgfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBjW2EyICsgMzIgPj4gMl0gPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwOwogICAgICAgICAgYjIgPSAoKEpjKGNbYTIgPj4gMl0gfCAwKSB8IDApICYgMjU1KSA8PCAyNDsKICAgICAgICAgIGIyID0gKChKYyhjW2EyID4+IDJdIHwgMCkgfCAwKSAmIDI1NSkgPDwgMTYgfCBiMjsKICAgICAgICAgIGIyID0gYjIgfCAoKEpjKGNbYTIgPj4gMl0gfCAwKSB8IDApICYgMjU1KSA8PCA4OwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMiB8IChKYyhjW2EyID4+IDJdIHwgMCkgfCAwKSAmIDI1NTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb2MoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMCwgcDIgPSAwLCBxMiA9IDAsIHIyID0gMCwgczIgPSAwLCB0MiA9IDA7CiAgICAgICAgICBxMiA9IFY7CiAgICAgICAgICBWID0gViArIDY0IHwgMDsKICAgICAgICAgIG8yID0gcTIgKyA0NCB8IDA7CiAgICAgICAgICBwMiA9IHEyOwogICAgICAgICAgazIgPSBhMiArIDM2IHwgMDsKICAgICAgICAgIGwyID0gYTIgKyA0MCB8IDA7CiAgICAgICAgICBhOgogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmICgoY1trMiA+PiAyXSB8IDApID09IChjW2wyID4+IDJdIHwgMCkpIHsKICAgICAgICAgICAgICAgIG0yID0gYTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgIGI6CiAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY1ttMiA+PiAyXSB8IDApKQogICAgICAgICAgICAgICAgICAgICAgbjIgPSBhMiArIDIwIHwgMDsKICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGYyID0gYTIgKyAyMCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBnMiA9IGEyICsgNDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaDIgPSBvMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBhMiArIDQ0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGoyID0gbzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIE9jKHAyLCAoY1tmMiA+PiAyXSB8IDApICsgMSB8IDAsIDAsIDApOwogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNbbDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYjIgPj4+IDAgPCAoY1tnMiA+PiAyXSB8IDApID4+PiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgUGMobzIsIGsyLCAxKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBSYyhjW2gyID4+IDJdIHwgMCwgcDIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAoY1toMiA+PiAyXSB8IDApICsgNDQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgUWMobzIpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gKChiMiAtIChjW2syID4+IDJdIHwgMCkgfCAwKSAvIDQ0IHwgMCkgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IFZjKGsyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICByMiA9IGNbazIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gKChjW2cyID4+IDJdIHwgMCkgLSByMiB8IDApIC8gNDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gdDIgPDwgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICBTYygKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8yLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdDIgPj4+IDAgPCBkMiA+Pj4gMSA+Pj4gMCA/IHMyID4+PiAwIDwgYjIgPj4+IDAgPyBiMiA6IHMyIDogZDIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGNbbDIgPj4gMl0gfCAwKSAtIHIyIHwgMCkgLyA0NCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMgogICAgICAgICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgUmMoY1tqMiA+PiAyXSB8IDAsIHAyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gKGNbajIgPj4gMl0gfCAwKSArIDQ0OwogICAgICAgICAgICAgICAgICAgICAgICAgIFRjKGsyLCBvMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgVWMobzIpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIEljKHAyKTsKICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBlMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZTIgPj4+IDAgPj0gKGNbbTIgPj4gMl0gfCAwKSA+Pj4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gZjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY3IoazIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgaWYgKGNbbjIgPj4gMl0gfCAwKSB7CiAgICAgICAgICAgICAgICAgIGgyID0gYTIgKyAxMiB8IDA7CiAgICAgICAgICAgICAgICAgIGkyID0gYTIgKyA2OCB8IDA7CiAgICAgICAgICAgICAgICAgIGoyID0gYTIgKyA3MiB8IDA7CiAgICAgICAgICAgICAgICAgIGsyID0gYTIgKyA3NiB8IDA7CiAgICAgICAgICAgICAgICAgIGwyID0gbzIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgZjIgPSBhMiArIDc2IHwgMDsKICAgICAgICAgICAgICAgICAgZzIgPSBvMiArIDggfCAwOwogICAgICAgICAgICAgICAgICBlMiA9IDE7CiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBPYyhwMiwgMSA8PCAoZTIgPj4+IDAgPiBiMiA+Pj4gMCA/IGIyIDogZTIpLCAwLCAwKTsKICAgICAgICAgICAgICAgICAgICBiMiA9IGNbajIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGlmIChiMiA+Pj4gMCA8IChjW2syID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICAgIFBjKG8yLCBpMiwgMSk7CiAgICAgICAgICAgICAgICAgICAgICBSYyhjW2wyID4+IDJdIHwgMCwgcDIpOwogICAgICAgICAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IChjW2wyID4+IDJdIHwgMCkgKyA0NDsKICAgICAgICAgICAgICAgICAgICAgIFFjKG8yKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgYjIgPSAoKGIyIC0gKGNbaTIgPj4gMl0gfCAwKSB8IDApIC8gNDQgfCAwKSArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgZDIgPSBWYyhpMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgdDIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIHIyID0gKChjW2syID4+IDJdIHwgMCkgLSB0MiB8IDApIC8gNDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgczIgPSByMiA8PCAxOwogICAgICAgICAgICAgICAgICAgICAgU2MoCiAgICAgICAgICAgICAgICAgICAgICAgIG8yLAogICAgICAgICAgICAgICAgICAgICAgICByMiA+Pj4gMCA8IGQyID4+PiAxID4+PiAwID8gczIgPj4+IDAgPCBiMiA+Pj4gMCA/IGIyIDogczIgOiBkMiwKICAgICAgICAgICAgICAgICAgICAgICAgKChjW2oyID4+IDJdIHwgMCkgLSB0MiB8IDApIC8gNDQgfCAwLAogICAgICAgICAgICAgICAgICAgICAgICBmMgogICAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgICAgICAgIFJjKGNbZzIgPj4gMl0gfCAwLCBwMik7CiAgICAgICAgICAgICAgICAgICAgICBjW2cyID4+IDJdID0gKGNbZzIgPj4gMl0gfCAwKSArIDQ0OwogICAgICAgICAgICAgICAgICAgICAgVGMoaTIsIG8yKTsKICAgICAgICAgICAgICAgICAgICAgIFVjKG8yKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgSWMocDIpOwogICAgICAgICAgICAgICAgICAgIGUyID0gZTIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoZTIgPj4+IDAgPiAoY1tuMiA+PiAyXSB8IDApID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjcihpMik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBWID0gcTI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBjKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGQyID0gKFljKGEyLCBiMiwgKGNbYTIgKyAzNiA+PiAyXSB8IDApICsgKGUyICogNDQgfCAwKSB8IDApIHwgMCkgKyBkMiB8IDA7CiAgICAgICAgICBiMiA9IGNbYTIgKyAyNCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoKGQyIHwgMCkgPCAwKQogICAgICAgICAgICByZXR1cm4gZDIgKyBiMiB8IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBkMiAtIChkMiA+Pj4gMCA8IGIyID4+PiAwID8gMCA6IGIyKSB8IDA7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcWMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgSGMoYTIgKyA2OCB8IDApOwogICAgICAgICAgSGMoYTIgKyAzNiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiByYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHNjKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHlwKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdGMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeXAoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1YyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB5cChhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZjKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMDsKICAgICAgICAgIGkyID0gVjsKICAgICAgICAgIFYgPSBWICsgMzIgfCAwOwogICAgICAgICAgZjIgPSBpMjsKICAgICAgICAgIGcyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGgyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGQyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoKGNbZzIgPj4gMl0gfCAwKSAtIGQyID4+IDMgPj4+IDAgPCBiMiA+Pj4gMCkgewogICAgICAgICAgICAgIGQyID0gKGQyIC0gKGNbYTIgPj4gMl0gfCAwKSA+PiAzKSArIGIyIHwgMDsKICAgICAgICAgICAgICBlMiA9IERjKGEyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGUyID4+PiAwIDwgZDIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihhMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBqMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgazIgPSAoY1tnMiA+PiAyXSB8IDApIC0gajIgfCAwOwogICAgICAgICAgICAgICAgZzIgPSBrMiA+PiAyOwogICAgICAgICAgICAgICAgeGMoCiAgICAgICAgICAgICAgICAgIGYyLAogICAgICAgICAgICAgICAgICBrMiA+PiAzID4+PiAwIDwgZTIgPj4+IDEgPj4+IDAgPyBnMiA+Pj4gMCA8IGQyID4+PiAwID8gZDIgOiBnMiA6IGUyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gajIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyA4IHwgMAogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIHljKGYyLCBiMik7CiAgICAgICAgICAgICAgICB6YyhhMiwgZjIpOwogICAgICAgICAgICAgICAgQWMoZjIpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICB3YyhhMiwgYjIpOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgViA9IGkyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3YyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGYyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBmMjsKICAgICAgICAgIEJjKGUyLCBhMiwgYjIpOwogICAgICAgICAgYTIgPSBlMiArIDQgfCAwOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gY1tlMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChiMiB8IDApICE9IChkMiB8IDApKSB7CiAgICAgICAgICAgIGQyID0gZDIgKyAtOCAtIGIyIHwgMDsKICAgICAgICAgICAgd3IoYjIgfCAwLCAwLCBkMiArIDggJiAtOCB8IDApIHwgMDsKICAgICAgICAgICAgY1thMiA+PiAyXSA9IGIyICsgKChkMiA+Pj4gMykgKyAxIDw8IDMpOwogICAgICAgICAgfQogICAgICAgICAgQ2MoZTIpOwogICAgICAgICAgViA9IGYyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4YyhhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwOwogICAgICAgICAgZjIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgaWYgKGIyID4+PiAwID4gNTM2ODcwOTExKSB7CiAgICAgICAgICAgICAgICBmMiA9IHYoOCkgfCAwOwogICAgICAgICAgICAgICAgdnEoZjIsIDY3MjMpOwogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDU5NTY7CiAgICAgICAgICAgICAgICB4KGYyIHwgMCwgMzkyOCwgMTIzKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZTIgPSBlcShiMiA8PCAzKSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBjW2EyID4+IDJdID0gZTI7CiAgICAgICAgICBkMiA9IGUyICsgKGQyIDw8IDMpIHwgMDsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGQyOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGUyICsgKGIyIDw8IDMpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5YyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gZTI7CiAgICAgICAgICBFYyhkMiwgYTIgKyA4IHwgMCwgYjIpOwogICAgICAgICAgYTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGIyID0gY1tkMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChhMiB8IDApICE9IChiMiB8IDApKSB7CiAgICAgICAgICAgIGIyID0gYjIgKyAtOCAtIGEyIHwgMDsKICAgICAgICAgICAgd3IoYTIgfCAwLCAwLCBiMiArIDggJiAtOCB8IDApIHwgMDsKICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGEyICsgKChiMiA+Pj4gMykgKyAxIDw8IDMpOwogICAgICAgICAgfQogICAgICAgICAgRmMoZDIpOwogICAgICAgICAgViA9IGUyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6YyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgaDIgPSBhMiArIDQgfCAwOwogICAgICAgICAgZzIgPSBiMiArIDQgfCAwOwogICAgICAgICAgZjIgPSAoY1toMiA+PiAyXSB8IDApIC0gZTIgfCAwOwogICAgICAgICAgZDIgPSAoY1tnMiA+PiAyXSB8IDApICsgKDAgLSAoZjIgPj4gMykgPDwgMykgfCAwOwogICAgICAgICAgY1tnMiA+PiAyXSA9IGQyOwogICAgICAgICAgaWYgKChmMiB8IDApID4gMCkgewogICAgICAgICAgICB1cihkMiB8IDAsIGUyIHwgMCwgZjIgfCAwKSB8IDA7CiAgICAgICAgICAgIGUyID0gZzI7CiAgICAgICAgICAgIGQyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgZTIgPSBnMjsKICAgICAgICAgIGcyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gZDI7CiAgICAgICAgICBjW2UyID4+IDJdID0gZzI7CiAgICAgICAgICBnMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICBmMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgY1toMiA+PiAyXSA9IGNbZzIgPj4gMl07CiAgICAgICAgICBjW2cyID4+IDJdID0gZjI7CiAgICAgICAgICBnMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGIyICsgMTIgfCAwOwogICAgICAgICAgYTIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgIGNbZzIgPj4gMl0gPSBjW2gyID4+IDJdOwogICAgICAgICAgY1toMiA+PiAyXSA9IGEyOwogICAgICAgICAgY1tiMiA+PiAyXSA9IGNbZTIgPj4gMl07CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFjKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgYjIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBkMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBlMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChlMiB8IDApICE9IChiMiB8IDApKQogICAgICAgICAgICBjW2QyID4+IDJdID0gZTIgKyAofigoZTIgKyAtOCAtIGIyIHwgMCkgPj4+IDMpIDw8IDMpOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChiMiB8IDApCiAgICAgICAgICAgIERhKGIyLCAoY1thMiArIDEyID4+IDJdIHwgMCkgLSBiMiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBCYyhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBiMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGIyICsgKGQyIDw8IDMpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdID0gY1thMiArIDQgPj4gMl07CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIERjKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiA1MzY4NzA5MTE7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVjKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAoY1tiMiA+PiAyXSB8IDApICsgKGQyIDw8IDMpOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1tjW2EyICsgOCA+PiAyXSA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdjKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgKyAxMiA+PiAyXSA9IDE7CiAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSAyOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSA0MDk2OwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSA0OwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhjKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChkMiB8IDApIHsKICAgICAgICAgICAgZTIgPSBhMiArIDQgfCAwOwogICAgICAgICAgICBiMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gKGQyIHwgMCkpCiAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgYjIgPSBiMiArIC00NCB8IDA7CiAgICAgICAgICAgICAgICBJYyhiMik7CiAgICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gKGQyIHwgMCkpOwogICAgICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGQyOwogICAgICAgICAgICBEYShiMiwgKGNbYTIgKyA4ID4+IDJdIHwgMCkgLSBiMiB8IDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBJYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwOwogICAgICAgICAgYjIgPSBjW2EyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKQogICAgICAgICAgICBVYShiMik7CiAgICAgICAgICBiMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKQogICAgICAgICAgICBVYShiMik7CiAgICAgICAgICBiMiA9IGNbYTIgKyAxNiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKQogICAgICAgICAgICBVYShiMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEpjKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGUyID0gYjIgKyA0IHwgMDsKICAgICAgICAgIGQyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoKGQyIHwgMCkgPj0gKGNbYjIgKyA4ID4+IDJdIHwgMCkpIHsKICAgICAgICAgICAgS2MoYjIpOwogICAgICAgICAgICBkMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgfQogICAgICAgICAgYjIgPSBjW2IyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGQyICsgMTsKICAgICAgICAgIHJldHVybiBhW2IyICsgZDIgPj4gMF0gfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBLYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgJGEoY1thMiA+PiAyXSB8IDAsIGNbYTIgKyAxMiA+PiAyXSB8IDAsIDEwNDg1NzYpOwogICAgICAgICAgYjIgPSBMYyhjW2EyID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBiMjsKICAgICAgICAgIGlmICghYjIpIHsKICAgICAgICAgICAgYjIgPSB2KDgpIHwgMDsKICAgICAgICAgICAgTWMoYjIpOwogICAgICAgICAgICB4KGIyIHwgMCwgMjc1MiwgOCk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gY1thMiArIDE2ID4+IDJdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTWMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeHEoYTIsIDc3NjkpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ1NTY7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5jKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHlwKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT2MoYjIsIGQyLCBlMiwgZjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgdmFyIGcyID0gMCwgaDIgPSAwLCBpMiA9IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gZDI7CiAgICAgICAgICBhW2IyICsgNCA+PiAwXSA9IGUyICYgMTsKICAgICAgICAgIGgyID0gYjIgKyA4IHwgMDsKICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgaTIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgZzIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgIGNbZzIgPj4gMl0gPSAwOwogICAgICAgICAgaWYgKChkMiArIC0yIHwgMCkgPj4+IDAgPiAyMDQ2KSB7CiAgICAgICAgICAgIGIyID0gdig4KSB8IDA7CiAgICAgICAgICAgIHhxKGIyLCA3Nzg5KTsKICAgICAgICAgICAgeChiMiB8IDAsIDM5MTIsIDgpOwogICAgICAgICAgfQogICAgICAgICAgY1tiMiArIDMyID4+IDJdID0gZDIgKyAtMTsKICAgICAgICAgIGlmIChkMiA+Pj4gMCA+IDE2ICYgKGUyIF4gMSkpIHsKICAgICAgICAgICAgZTIgPSAzOwogICAgICAgICAgICB3aGlsZSAoMSkKICAgICAgICAgICAgICBpZiAoMSA8PCBlMiArIDIgPj4+IDAgPCBkMiA+Pj4gMCkKICAgICAgICAgICAgICAgIGUyID0gZTIgKyAxIHwgMDsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZDIgPSAxIDw8IGUyOwogICAgICAgICAgICBjW2IyICsgMzYgPj4gMl0gPSBkMjsKICAgICAgICAgICAgY1tiMiArIDQwID4+IDJdID0gMTUgLSBlMjsKICAgICAgICAgICAgY1tnMiA+PiAyXSA9IF9hKChkMiA8PCAyKSArIDggfCAwKSB8IDA7CiAgICAgICAgICAgIGQyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjW2cyID4+IDJdID0gMDsKICAgICAgICAgICAgY1tiMiArIDQwID4+IDJdID0gMDsKICAgICAgICAgICAgY1tiMiArIDM2ID4+IDJdID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGNbaDIgPj4gMl0gPSBfYShkMiA8PCAyKSB8IDA7CiAgICAgICAgICBnMiA9IF9hKGNbYjIgPj4gMl0gPDwgMikgfCAwOwogICAgICAgICAgY1tpMiA+PiAyXSA9IGcyOwogICAgICAgICAgY1tiMiArIDIwID4+IDJdID0gMDsKICAgICAgICAgIGQyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGIyICsgMjQgfCAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGQyOwogICAgICAgICAgZDIgPSAoZDIgfCAwKSAhPSAwOwogICAgICAgICAgaWYgKCFmMikgewogICAgICAgICAgICBpZiAoZDIpIHsKICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgY1tnMiArIChkMiA8PCAyKSA+PiAyXSA9IDE7CiAgICAgICAgICAgICAgICBkMiA9IGQyICsgMSB8IDA7CiAgICAgICAgICAgICAgfSB3aGlsZSAoZDIgPj4+IDAgPCAoY1tiMiA+PiAyXSB8IDApID4+PiAwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChkMikgewogICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBjW2cyICsgKGQyIDw8IDIpID4+IDJdID0gY1tmMiArIChkMiA8PCAyKSA+PiAyXTsKICAgICAgICAgICAgICBkMiA9IGQyICsgMSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKGQyID4+PiAwIDwgKGNbYjIgPj4gMl0gfCAwKSA+Pj4gMCk7CiAgICAgICAgICB9CiAgICAgICAgICBYYyhiMik7CiAgICAgICAgICBmMiA9ICgoY1tiMiA+PiAyXSB8IDApICsgNiB8IDApID4+PiAxOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGYyOwogICAgICAgICAgY1tiMiArIDI4ID4+IDJdID0gZjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBjKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGIyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gYjIgKyAoZDIgKiA0NCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBRYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdID0gY1thMiArIDQgPj4gMl07CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFJjKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgIGFbYjIgKyA0ID4+IDBdID0gYVtkMiArIDQgPj4gMF0gfCAwOwogICAgICAgICAgZTIgPSBkMiArIDggfCAwOwogICAgICAgICAgY1tiMiArIDggPj4gMl0gPSBjW2UyID4+IDJdOwogICAgICAgICAgY1tiMiArIDEyID4+IDJdID0gY1tkMiArIDEyID4+IDJdOwogICAgICAgICAgY1tiMiArIDE2ID4+IDJdID0gY1tkMiArIDE2ID4+IDJdOwogICAgICAgICAgY1tiMiArIDIwID4+IDJdID0gY1tkMiArIDIwID4+IDJdOwogICAgICAgICAgY1tiMiArIDI0ID4+IDJdID0gY1tkMiArIDI0ID4+IDJdOwogICAgICAgICAgY1tiMiArIDI4ID4+IDJdID0gY1tkMiArIDI4ID4+IDJdOwogICAgICAgICAgY1tiMiArIDMyID4+IDJdID0gY1tkMiArIDMyID4+IDJdOwogICAgICAgICAgY1tiMiArIDM2ID4+IDJdID0gY1tkMiArIDM2ID4+IDJdOwogICAgICAgICAgY1tiMiArIDQwID4+IDJdID0gY1tkMiArIDQwID4+IDJdOwogICAgICAgICAgY1tlMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNjKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDA7CiAgICAgICAgICBmMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBlMjsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmIChiMikKICAgICAgICAgICAgICBpZiAoYjIgPj4+IDAgPiA5NzYxMjg5MykgewogICAgICAgICAgICAgICAgZjIgPSB2KDgpIHwgMDsKICAgICAgICAgICAgICAgIHZxKGYyLCA2NzIzKTsKICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSA1OTU2OwogICAgICAgICAgICAgICAgeChmMiB8IDAsIDM5MjgsIDEyMyk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGUyID0gZXEoYjIgKiA0NCB8IDApIHwgMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBlMjsKICAgICAgICAgIGQyID0gZTIgKyAoZDIgKiA0NCB8IDApIHwgMDsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGQyOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGUyICsgKGIyICogNDQgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVGMoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMDsKICAgICAgICAgIGkyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBqMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBkMiA9IGNbajIgPj4gMl0gfCAwOwogICAgICAgICAgaDIgPSBiMiArIDQgfCAwOwogICAgICAgICAgaWYgKChkMiB8IDApID09IChpMiB8IDApKSB7CiAgICAgICAgICAgIGYyID0gaDI7CiAgICAgICAgICAgIGcyID0gYTI7CiAgICAgICAgICAgIGUyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGQyID0gaTI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgZDIgPSBkMiArIC00NCB8IDA7CiAgICAgICAgICAgICAgV2MoZTIgKyAtNDQgfCAwLCBkMik7CiAgICAgICAgICAgICAgZTIgPSAoY1toMiA+PiAyXSB8IDApICsgLTQ0IHwgMDsKICAgICAgICAgICAgICBjW2gyID4+IDJdID0gZTI7CiAgICAgICAgICAgIH0gd2hpbGUgKChkMiB8IDApICE9IChpMiB8IDApKTsKICAgICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgICAgZzIgPSBhMjsKICAgICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIGNbZzIgPj4gMl0gPSBlMjsKICAgICAgICAgIGNbZjIgPj4gMl0gPSBkMjsKICAgICAgICAgIGkyID0gYjIgKyA4IHwgMDsKICAgICAgICAgIGgyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2oyID4+IDJdID0gY1tpMiA+PiAyXTsKICAgICAgICAgIGNbaTIgPj4gMl0gPSBoMjsKICAgICAgICAgIGkyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGoyID0gYjIgKyAxMiB8IDA7CiAgICAgICAgICBhMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgY1tpMiA+PiAyXSA9IGNbajIgPj4gMl07CiAgICAgICAgICBjW2oyID4+IDJdID0gYTI7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVWMoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSBhMiArIDggfCAwOwogICAgICAgICAgYjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoYjIgfCAwKSAhPSAoZDIgfCAwKSkKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGYyID0gYjIgKyAtNDQgfCAwOwogICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICBJYyhmMik7CiAgICAgICAgICAgICAgYjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gKGQyIHwgMCkpOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChiMiB8IDApCiAgICAgICAgICAgIERhKGIyLCAoY1thMiArIDEyID4+IDJdIHwgMCkgLSBiMiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWYyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gOTc2MTI4OTM7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFdjKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IGUyOwogICAgICAgICAgYVtiMiArIDQgPj4gMF0gPSBhW2QyICsgNCA+PiAwXSB8IDA7CiAgICAgICAgICBjW2IyICsgMjAgPj4gMl0gPSBjW2QyICsgMjAgPj4gMl07CiAgICAgICAgICBjW2IyICsgMjQgPj4gMl0gPSBjW2QyICsgMjQgPj4gMl07CiAgICAgICAgICBjW2IyICsgMjggPj4gMl0gPSBjW2QyICsgMjggPj4gMl07CiAgICAgICAgICBjW2IyICsgMzIgPj4gMl0gPSBjW2QyICsgMzIgPj4gMl07CiAgICAgICAgICBoMiA9IGIyICsgMzYgfCAwOwogICAgICAgICAgY1toMiA+PiAyXSA9IGNbZDIgKyAzNiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0MCA+PiAyXSA9IGNbZDIgKyA0MCA+PiAyXTsKICAgICAgICAgIGUyID0gZTIgPDwgMjsKICAgICAgICAgIGYyID0gX2EoZTIpIHwgMDsKICAgICAgICAgIGNbYjIgKyA4ID4+IDJdID0gZjI7CiAgICAgICAgICBnMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGcyIHwgMCkKICAgICAgICAgICAgdnIoZjIgfCAwLCBjW2QyICsgOCA+PiAyXSB8IDAsIGcyIDw8IDIgfCAwKSB8IDA7CiAgICAgICAgICBlMiA9IF9hKGUyKSB8IDA7CiAgICAgICAgICBjW2IyICsgMTIgPj4gMl0gPSBlMjsKICAgICAgICAgIGYyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoZjIgfCAwKQogICAgICAgICAgICB2cihlMiB8IDAsIGNbZDIgKyAxMiA+PiAyXSB8IDAsIGYyIDw8IDIgfCAwKSB8IDA7CiAgICAgICAgICBlMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGUyKSB7CiAgICAgICAgICAgIGYyID0gX2EoKGUyIDw8IDIpICsgOCB8IDApIHwgMDsKICAgICAgICAgICAgY1tiMiArIDE2ID4+IDJdID0gZjI7CiAgICAgICAgICAgIGUyID0gKGNbaDIgPj4gMl0gPDwgMikgKyA4IHwgMDsKICAgICAgICAgICAgaWYgKGUyIHwgMCkKICAgICAgICAgICAgICB2cihmMiB8IDAsIGNbZDIgKyAxNiA+PiAyXSB8IDAsIGUyIHwgMCkgfCAwOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIGNbYjIgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFhjKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwLCBwMiA9IDAsIHIyID0gMDsKICAgICAgICAgIHIyID0gYjIgKyAyNCB8IDA7CiAgICAgICAgICBnMiA9IGIyICsgMjAgfCAwOwogICAgICAgICAgZDIgPSAoY1tnMiA+PiAyXSB8IDApICsgKGNbcjIgPj4gMl0gfCAwKSB8IDA7CiAgICAgICAgICBjW2cyID4+IDJdID0gZDI7CiAgICAgICAgICBpZiAoZDIgPj4+IDAgPiAzMjc2OCkgewogICAgICAgICAgICBjW2cyID4+IDJdID0gMDsKICAgICAgICAgICAgaWYgKCEoY1tiMiA+PiAyXSB8IDApKQogICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgZjIgPSBjW2IyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBuMiA9IGYyICsgKGUyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgIGQyID0gKChjW24yID4+IDJdIHwgMCkgKyAxIHwgMCkgPj4+IDE7CiAgICAgICAgICAgICAgICBjW24yID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICBkMiA9IChjW2cyID4+IDJdIHwgMCkgKyBkMiB8IDA7CiAgICAgICAgICAgICAgICBjW2cyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICBlMiA9IGUyICsgMSB8IDA7CiAgICAgICAgICAgICAgfSB3aGlsZSAoZTIgPj4+IDAgPCAoY1tiMiA+PiAyXSB8IDApID4+PiAwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbjIgPSAyMTQ3NDgzNjQ4IC8gKGQyID4+PiAwKSB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoKGFbYjIgKyA0ID4+IDBdIHwgMCkgPT0gMCA/IChvMiA9IGIyICsgMzYgfCAwLCAoY1tvMiA+PiAyXSB8IDApICE9IDApIDogMCkgewogICAgICAgICAgICAgIGlmIChjW2IyID4+IDJdIHwgMCkgewogICAgICAgICAgICAgICAgajIgPSBjW2IyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBrMiA9IGNbYjIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBsMiA9IGIyICsgNDAgfCAwOwogICAgICAgICAgICAgICAgbTIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgICAgICAgIGgyID0gMDsKICAgICAgICAgICAgICAgIGkyID0gMDsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgZTIgPSAocShoMiwgbjIpIHwgMCkgPj4+IDE2OwogICAgICAgICAgICAgICAgICBjW2oyICsgKGkyIDw8IDIpID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgIGgyID0gKGNbazIgKyAoaTIgPDwgMikgPj4gMl0gfCAwKSArIGgyIHwgMDsKICAgICAgICAgICAgICAgICAgZTIgPSBlMiA+Pj4gKGNbbDIgPj4gMl0gfCAwKTsKICAgICAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgZTIgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICBmMiA9IGkyICsgLTEgfCAwOwogICAgICAgICAgICAgICAgICAgIGcyID0gY1ttMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgZDIgPSBkMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1tnMiArIChkMiA8PCAyKSA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKChkMiB8IDApICE9IChlMiB8IDApKTsKICAgICAgICAgICAgICAgICAgICBkMiA9IGUyOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGkyID0gaTIgKyAxIHwgMDsKICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkyID4+PiAwIDwgKGNbYjIgPj4gMl0gfCAwKSA+Pj4gMCk7CiAgICAgICAgICAgICAgICBlMiA9IGNbbTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICBpZiAoZDIgPj4+IDAgPiAoY1tvMiA+PiAyXSB8IDApID4+PiAwKSB7CiAgICAgICAgICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBlMiA9IGNbYjIgKyAxNiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgZDIgPSBkMiArIDEgfCAwOwogICAgICAgICAgICAgICAgY1tlMiArIChkMiA8PCAyKSA+PiAyXSA9IChjW2IyID4+IDJdIHwgMCkgKyAtMTsKICAgICAgICAgICAgICB9IHdoaWxlIChkMiA+Pj4gMCA8PSAoY1tvMiA+PiAyXSB8IDApID4+PiAwKTsKICAgICAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBwMiA9IDc7CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBpZiAoKHAyIHwgMCkgPT0gNykKICAgICAgICAgICAgaWYgKCEoY1tiMiA+PiAyXSB8IDApKQogICAgICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGYyID0gY1tiMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgIGcyID0gY1tiMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGNbZjIgKyAoZDIgPDwgMikgPj4gMl0gPSAocShlMiwgbjIpIHwgMCkgPj4+IDE2OwogICAgICAgICAgICAgICAgZTIgPSAoY1tnMiArIChkMiA8PCAyKSA+PiAyXSB8IDApICsgZTIgfCAwOwogICAgICAgICAgICAgICAgZDIgPSBkMiArIDEgfCAwOwogICAgICAgICAgICAgIH0gd2hpbGUgKGQyID4+PiAwIDwgKGNbYjIgPj4gMl0gfCAwKSA+Pj4gMCk7CiAgICAgICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgICAgfQogICAgICAgICAgcDIgPSAoKGNbcjIgPj4gMl0gfCAwKSAqIDUgfCAwKSA+Pj4gMjsKICAgICAgICAgIG8yID0gKGNbZDIgPj4gMl0gPDwgMykgKyA0OCB8IDA7CiAgICAgICAgICBwMiA9IHAyID4+PiAwID4gbzIgPj4+IDAgPyBvMiA6IHAyOwogICAgICAgICAgY1tyMiA+PiAyXSA9IHAyOwogICAgICAgICAgY1tiMiArIDI4ID4+IDJdID0gcDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFljKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDA7CiAgICAgICAgICBkMiA9IFpjKGIyLCBkMikgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGQyOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGQyKSB7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwID49IDMyKSB7CiAgICAgICAgICAgICAgICBkMiA9IGNbYTIgKyAyOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZTIgPSBjW2EyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGlmIChkMiA+Pj4gMCA+IGUyID4+PiAwKSB7CiAgICAgICAgICAgICAgICBlMiA9IGQyIC0gZTIgfCAwOwogICAgICAgICAgICAgICAgZDIgPSBaYyhiMiwgKGNbYTIgKyA2OCA+PiAyXSB8IDApICsgKChkMiArIC0xIHwgMCkgKiA0NCB8IDApIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgZTIgPSBkMiA8PCBlMiB8IChfYyhiMiwgZTIpIHwgMCk7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBlMiA9IFpjKGIyLCAoY1thMiArIDY4ID4+IDJdIHwgMCkgKyAoKGQyICsgLTEgfCAwKSAqIDQ0IHwgMCkgfCAwKSB8IDA7CiAgICAgICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoKGUyIHwgMCkgPCAoMSA8PCBkMiArIC0xIHwgMCkpIHsKICAgICAgICAgICAgICAgIGQyID0gZTIgKyAxICsgKC0xIDw8IGQyKSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZDIgPSBlMiArIDEgfCAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBkMiA9ICRjKGIyLCBhMiArIDQ4IHwgMCkgfCAwOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgcmV0dXJuIGQyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWmMoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDA7CiAgICAgICAgICBuMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBtMiA9IGNbbjIgPj4gMl0gfCAwOwogICAgICAgICAgZjIgPSBjW2IyICsgMTYgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGYyKSB7CiAgICAgICAgICAgIGUyID0gYTIgKyA0IHwgMDsKICAgICAgICAgICAgZDIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgbDIgPSBtMiA+Pj4gMTU7CiAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBsMjsKICAgICAgICAgICAgajIgPSAoZDIgPj4+IDApIC8gKGwyID4+PiAwKSB8IDA7CiAgICAgICAgICAgIGkyID0gajIgPj4+IChjW2IyICsgNDAgPj4gMl0gfCAwKTsKICAgICAgICAgICAgZzIgPSBjW2YyICsgKGkyIDw8IDIpID4+IDJdIHwgMDsKICAgICAgICAgICAgaTIgPSAoY1tmMiArIChpMiArIDEgPDwgMikgPj4gMl0gfCAwKSArIDEgfCAwOwogICAgICAgICAgICBoMiA9IGcyICsgMSB8IDA7CiAgICAgICAgICAgIGsyID0gY1tiMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICBpZiAoaTIgPj4+IDAgPiBoMiA+Pj4gMCkgewogICAgICAgICAgICAgIGYyID0gZzI7CiAgICAgICAgICAgICAgZzIgPSBpMjsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBoMiA9IChnMiArIGYyIHwgMCkgPj4+IDE7CiAgICAgICAgICAgICAgICBpMiA9IChjW2syICsgKGgyIDw8IDIpID4+IDJdIHwgMCkgPj4+IDAgPiBqMiA+Pj4gMDsKICAgICAgICAgICAgICAgIGYyID0gaTIgPyBmMiA6IGgyOwogICAgICAgICAgICAgICAgZzIgPSBpMiA/IGgyIDogZzI7CiAgICAgICAgICAgICAgICBoMiA9IGYyICsgMSB8IDA7CiAgICAgICAgICAgICAgfSB3aGlsZSAoZzIgPj4+IDAgPiBoMiA+Pj4gMCk7CiAgICAgICAgICAgICAgZzIgPSBmMjsKICAgICAgICAgICAgfQogICAgICAgICAgICBmMiA9IHEoY1trMiArIChnMiA8PCAyKSA+PiAyXSB8IDAsIGwyKSB8IDA7CiAgICAgICAgICAgIGlmICgoZzIgfCAwKSA9PSAoY1tiMiArIDMyID4+IDJdIHwgMCkpCiAgICAgICAgICAgICAgaDIgPSBtMjsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGgyID0gcShjW2syICsgKGgyIDw8IDIpID4+IDJdIHwgMCwgbDIpIHwgMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGsyID0gbTIgPj4+IDE1OwogICAgICAgICAgICBjW24yID4+IDJdID0gazI7CiAgICAgICAgICAgIGkyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGwyID0gY1tiMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICBlMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICAgIGQyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGoyID0gaTIgPj4+IDE7CiAgICAgICAgICAgIGYyID0gMDsKICAgICAgICAgICAgaDIgPSBtMjsKICAgICAgICAgICAgZzIgPSAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgbzIgPSBxKGNbbDIgKyAoajIgPDwgMikgPj4gMl0gfCAwLCBrMikgfCAwOwogICAgICAgICAgICAgIG0yID0gbzIgPj4+IDAgPiBkMiA+Pj4gMDsKICAgICAgICAgICAgICBoMiA9IG0yID8gbzIgOiBoMjsKICAgICAgICAgICAgICBmMiA9IG0yID8gZjIgOiBvMjsKICAgICAgICAgICAgICBnMiA9IG0yID8gZzIgOiBqMjsKICAgICAgICAgICAgICBpMiA9IG0yID8gajIgOiBpMjsKICAgICAgICAgICAgICBqMiA9IChnMiArIGkyIHwgMCkgPj4+IDE7CiAgICAgICAgICAgIH0gd2hpbGUgKChqMiB8IDApICE9IChnMiB8IDApKTsKICAgICAgICAgIH0KICAgICAgICAgIGNbZTIgPj4gMl0gPSBkMiAtIGYyOwogICAgICAgICAgbzIgPSBoMiAtIGYyIHwgMDsKICAgICAgICAgIGNbbjIgPj4gMl0gPSBvMjsKICAgICAgICAgIGlmIChvMiA+Pj4gMCA8IDE2Nzc3MjE2KQogICAgICAgICAgICBhZChhMik7CiAgICAgICAgICBuMiA9IChjW2IyICsgMTIgPj4gMl0gfCAwKSArIChnMiA8PCAyKSB8IDA7CiAgICAgICAgICBjW24yID4+IDJdID0gKGNbbjIgPj4gMl0gfCAwKSArIDE7CiAgICAgICAgICBuMiA9IGIyICsgMjggfCAwOwogICAgICAgICAgbzIgPSAoY1tuMiA+PiAyXSB8IDApICsgLTEgfCAwOwogICAgICAgICAgY1tuMiA+PiAyXSA9IG8yOwogICAgICAgICAgaWYgKCFvMikKICAgICAgICAgICAgWGMoYjIpOwogICAgICAgICAgcmV0dXJuIGcyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX2MoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGlmIChiMiA+Pj4gMCA+IDE5KSB7CiAgICAgICAgICAgIGQyID0gKGJkKGEyKSB8IDApICYgNjU1MzU7CiAgICAgICAgICAgIHJldHVybiAoX2MoYTIsIGIyICsgLTE2IHwgMCkgfCAwKSA8PCAxNiB8IGQyIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIGUyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGYyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICBnMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBkMiA9IChjW2cyID4+IDJdIHwgMCkgPj4+IGIyOwogICAgICAgICAgY1tnMiA+PiAyXSA9IGQyOwogICAgICAgICAgYjIgPSAoZjIgPj4+IDApIC8gKGQyID4+PiAwKSB8IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gZjIgLSAocShiMiwgZDIpIHwgMCk7CiAgICAgICAgICBpZiAoZDIgPj4+IDAgPCAxNjc3NzIxNikKICAgICAgICAgICAgYWQoYTIpOwogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJGMoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDA7CiAgICAgICAgICBlMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBmMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBxKGYyID4+PiAxMywgY1tiMiArIDggPj4gMl0gfCAwKSB8IDA7CiAgICAgICAgICBnMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBoMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgaTIgPSBoMiA+Pj4gMCA+PSBkMiA+Pj4gMDsKICAgICAgICAgIGlmIChpMikgewogICAgICAgICAgICBjW2cyID4+IDJdID0gaDIgLSBkMjsKICAgICAgICAgICAgZDIgPSBmMiAtIGQyIHwgMDsKICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGQyOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGQyOwogICAgICAgICAgICBoMiA9IGIyICsgMTIgfCAwOwogICAgICAgICAgICBjW2gyID4+IDJdID0gKGNbaDIgPj4gMl0gfCAwKSArIDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZDIgPj4+IDAgPCAxNjc3NzIxNikKICAgICAgICAgICAgYWQoYTIpOwogICAgICAgICAgaDIgPSBiMiArIDQgfCAwOwogICAgICAgICAgYTIgPSAoY1toMiA+PiAyXSB8IDApICsgLTEgfCAwOwogICAgICAgICAgY1toMiA+PiAyXSA9IGEyOwogICAgICAgICAgaWYgKCFhMikKICAgICAgICAgICAgY2QoYjIpOwogICAgICAgICAgcmV0dXJuIGkyICYgMSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBiMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBkMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBlMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgZG8gewogICAgICAgICAgICBlMiA9IGUyIDw8IDggfCAoSmMoY1thMiA+PiAyXSB8IDApIHwgMCkgJiAyNTU7CiAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgZjIgPSBjW2QyID4+IDJdIDw8IDg7CiAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBmMjsKICAgICAgICAgIH0gd2hpbGUgKGYyID4+PiAwIDwgMTY3NzcyMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBiZChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBhMiArIDQgfCAwOwogICAgICAgICAgZjIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGIyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGUyID0gKGNbYjIgPj4gMl0gfCAwKSA+Pj4gMTY7CiAgICAgICAgICBjW2IyID4+IDJdID0gZTI7CiAgICAgICAgICBiMiA9IChmMiA+Pj4gMCkgLyAoZTIgPj4+IDApIHwgMDsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBmMiAtIChxKGIyLCBlMikgfCAwKTsKICAgICAgICAgIGFkKGEyKTsKICAgICAgICAgIHJldHVybiBiMiAmIDY1NTM1IHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2QoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gYTIgKyAxNiB8IDA7CiAgICAgICAgICBiMiA9IChjW2QyID4+IDJdIHwgMCkgKyBmMiB8IDA7CiAgICAgICAgICBjW2QyID4+IDJdID0gYjI7CiAgICAgICAgICBpZiAoYjIgPj4+IDAgPiA4MTkyKSB7CiAgICAgICAgICAgIGUyID0gKGIyICsgMSB8IDApID4+PiAxOwogICAgICAgICAgICBjW2QyID4+IDJdID0gZTI7CiAgICAgICAgICAgIGcyID0gYTIgKyAxMiB8IDA7CiAgICAgICAgICAgIGIyID0gKChjW2cyID4+IDJdIHwgMCkgKyAxIHwgMCkgPj4+IDE7CiAgICAgICAgICAgIGNbZzIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgaWYgKChiMiB8IDApID09IChlMiB8IDApKSB7CiAgICAgICAgICAgICAgYjIgPSBlMiArIDEgfCAwOwogICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgICAgIGIyID0gZTI7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIGQyID0gZTI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgICBiMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IChxKGIyLCAyMTQ3NDgzNjQ4IC8gKGQyID4+PiAwKSB8IDApIHwgMCkgPj4+IDE4OwogICAgICAgICAgZzIgPSBmMiAqIDUgfCAwOwogICAgICAgICAgZzIgPSBnMiA+Pj4gMCA+IDI1OSA/IDY0IDogZzIgPj4+IDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gZzI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGcyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkZChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDA7CiAgICAgICAgICBtMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGgyID0gbTIgKyAxNiB8IDA7CiAgICAgICAgICBpMiA9IG0yICsgOCB8IDA7CiAgICAgICAgICBqMiA9IG0yOwogICAgICAgICAgazIgPSBhMiArIDMzNiB8IDA7CiAgICAgICAgICBmMiA9IGsyOwogICAgICAgICAgZzIgPSBhMiArIDI1OSB8IDA7CiAgICAgICAgICBpZiAoISgoY1tmMiArIDQgPj4gMl0gfCAwKSA9PSAwID8gKGNbZjIgPj4gMl0gfCAwKSA9PSAoZFtnMiA+PiAwXSB8IGRbZzIgKyAxID4+IDBdIDw8IDggfCBkW2cyICsgMiA+PiAwXSA8PCAxNiB8IGRbZzIgKyAzID4+IDBdIDw8IDI0IHwgMCkgOiAwKSkgewogICAgICAgICAgICBmMiA9IGEyICsgMzIwIHwgMDsKICAgICAgICAgICAgZTIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgZzIgPSBlMjsKICAgICAgICAgICAgaWYgKCEoKGUyIHwgMCkgIT0gMCA/IChjW2EyICsgMzEyID4+IDJdIHwgMCkgIT0gMCA6IDApKSB7CiAgICAgICAgICAgICAgZTIgPSBnMjsKICAgICAgICAgICAgICBsMiA9IDU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGYyID0gYTIgKyAzMjAgfCAwOwogICAgICAgICAgICBlMiA9IGNbYTIgKyAzMjAgPj4gMl0gfCAwOwogICAgICAgICAgICBsMiA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKGwyIHwgMCkgPT0gNSkgewogICAgICAgICAgICBsMiA9IGEyICsgMzIwIHwgMDsKICAgICAgICAgICAgY1toMiA+PiAyXSA9IGUyOwogICAgICAgICAgICBjW2wyID4+IDJdID0gMDsKICAgICAgICAgICAgZTIgPSBhMiArIDMyNCB8IDA7CiAgICAgICAgICAgIGNbaDIgKyA0ID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgICAgY1tlMiA+PiAyXSA9IDA7CiAgICAgICAgICAgIE5hKGgyKTsKICAgICAgICAgICAgZzIgPSBhMiArIDMxMiB8IDA7CiAgICAgICAgICAgIGNbaDIgPj4gMl0gPSBjW2cyID4+IDJdOwogICAgICAgICAgICBjW2cyID4+IDJdID0gMDsKICAgICAgICAgICAgbjIgPSBhMiArIDMxNiB8IDA7CiAgICAgICAgICAgIGNbaDIgKyA0ID4+IDJdID0gY1tuMiA+PiAyXTsKICAgICAgICAgICAgY1tuMiA+PiAyXSA9IDA7CiAgICAgICAgICAgIE9hKGgyKTsKICAgICAgICAgICAgbzIgPSBlcSgxMikgfCAwOwogICAgICAgICAgICBsYyhvMiwgYTIgKyA0IHwgMCk7CiAgICAgICAgICAgIGNbajIgPj4gMl0gPSAwOwogICAgICAgICAgICBjW2gyID4+IDJdID0gY1tqMiA+PiAyXTsKICAgICAgICAgICAgZmQoaTIsIG8yLCBoMik7CiAgICAgICAgICAgIG8yID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGNbaTIgPj4gMl0gPSBjW2cyID4+IDJdOwogICAgICAgICAgICBjW2cyID4+IDJdID0gbzI7CiAgICAgICAgICAgIG8yID0gaTIgKyA0IHwgMDsKICAgICAgICAgICAgajIgPSBjW28yID4+IDJdIHwgMDsKICAgICAgICAgICAgY1tvMiA+PiAyXSA9IGNbbjIgPj4gMl07CiAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBqMjsKICAgICAgICAgICAgT2EoaTIpOwogICAgICAgICAgICBlZChpMiwgY1tnMiA+PiAyXSB8IDAsIGEyICsgMzAwIHwgMCk7CiAgICAgICAgICAgIGcyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIG4yID0gaTIgKyA0IHwgMDsKICAgICAgICAgICAgajIgPSBjW24yID4+IDJdIHwgMDsKICAgICAgICAgICAgY1tpMiA+PiAyXSA9IDA7CiAgICAgICAgICAgIGNbbjIgPj4gMl0gPSAwOwogICAgICAgICAgICBjW2gyID4+IDJdID0gY1tsMiA+PiAyXTsKICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGcyOwogICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbZTIgPj4gMl07CiAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBqMjsKICAgICAgICAgICAgTmEoaDIpOwogICAgICAgICAgICBOYShpMik7CiAgICAgICAgICAgIGUyID0gYTIgKyAzMjggfCAwOwogICAgICAgICAgICBqMiA9IGUyOwogICAgICAgICAgICBqMiA9IGxyKGNbajIgPj4gMl0gfCAwLCBjW2oyICsgNCA+PiAyXSB8IDAsIDEsIDApIHwgMDsKICAgICAgICAgICAgbDIgPSB1KCkgfCAwOwogICAgICAgICAgICBjW2UyID4+IDJdID0gajI7CiAgICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gbDI7CiAgICAgICAgICAgIGUyID0gazI7CiAgICAgICAgICAgIGNbZTIgPj4gMl0gPSAwOwogICAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgIGUyID0gY1tmMiA+PiAyXSB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICAkW2NbY1tlMiA+PiAyXSA+PiAyXSAmIDYzXShlMiwgYjIpIHwgMDsKICAgICAgICAgIGwyID0gazI7CiAgICAgICAgICBsMiA9IGxyKGNbbDIgPj4gMl0gfCAwLCBjW2wyICsgNCA+PiAyXSB8IDAsIDEsIDApIHwgMDsKICAgICAgICAgIG4yID0gdSgpIHwgMDsKICAgICAgICAgIG8yID0gazI7CiAgICAgICAgICBjW28yID4+IDJdID0gbDI7CiAgICAgICAgICBjW28yICsgNCA+PiAyXSA9IG4yOwogICAgICAgICAgViA9IG0yOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlZChhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgaDIgPSBWOwogICAgICAgICAgViA9IFYgKyA2NCB8IDA7CiAgICAgICAgICBlMiA9IGgyICsgNTYgfCAwOwogICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgIGcyID0gbGQoZDIpIHwgMDsKICAgICAgICAgIGlmICgoZzIgfCAwKSA9PSAtMSkgewogICAgICAgICAgICBoMiA9IHYoOCkgfCAwOwogICAgICAgICAgICBtZChoMik7CiAgICAgICAgICAgIHgoaDIgfCAwLCAyNzg0LCA4KTsKICAgICAgICAgIH0KICAgICAgICAgIGQyID0gbmQoZDIpIHwgMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKCFkMikKICAgICAgICAgICAgICAgIHN3aXRjaCAoZzIgfCAwKSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDogewogICAgICAgICAgICAgICAgICAgIGcyID0gZXEoNDc4OCkgfCAwOwogICAgICAgICAgICAgICAgICAgIHhkKGcyKTsKICAgICAgICAgICAgICAgICAgICB3ZChhMiwgYjIsIGcyKTsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNhc2UgMTogewogICAgICAgICAgICAgICAgICAgIGcyID0gZXEoNTExNikgfCAwOwogICAgICAgICAgICAgICAgICAgIHpkKGcyKTsKICAgICAgICAgICAgICAgICAgICB5ZChhMiwgYjIsIGcyKTsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNhc2UgMjogewogICAgICAgICAgICAgICAgICAgIGcyID0gZXEoNTEwNCkgfCAwOwogICAgICAgICAgICAgICAgICAgIEJkKGcyKTsKICAgICAgICAgICAgICAgICAgICBBZChhMiwgYjIsIGcyKTsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNhc2UgMzogewogICAgICAgICAgICAgICAgICAgIGcyID0gZXEoNTQzMikgfCAwOwogICAgICAgICAgICAgICAgICAgIERkKGcyKTsKICAgICAgICAgICAgICAgICAgICBDZChhMiwgYjIsIGcyKTsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgb2QoZTIsIGIyKTsKICAgICAgICAgICAgICAgIHBkKGNbZTIgPj4gMl0gfCAwKTsKICAgICAgICAgICAgICAgIGlmICgoZzIgfCAyIHwgMCkgPT0gMykKICAgICAgICAgICAgICAgICAgcWQoY1tlMiA+PiAyXSB8IDApOwogICAgICAgICAgICAgICAgaWYgKChnMiB8IDEgfCAwKSA9PSAzKQogICAgICAgICAgICAgICAgICByZChjW2UyID4+IDJdIHwgMCk7CiAgICAgICAgICAgICAgICBnMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgdGQoZjIsIGQyKTsKICAgICAgICAgICAgICAgIHNkKGcyLCBmMik7CiAgICAgICAgICAgICAgICB1ZChmMik7CiAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgICAgICAgIGcyID0gZTIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gY1tnMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICB2ZChlMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBWID0gaDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZkKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA0NTc2OwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIGdkKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdkKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaGQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpZChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKSB7CiAgICAgICAgICAgIHJjKGEyKTsKICAgICAgICAgICAganAoYTIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqZChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDc5ODMgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga2QoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSAoY1thMiArIDQgPj4gMl0gfCAwKSAtIChjW2EyID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoKChiMiB8IDApICE9IDAgPyAoZDIgPSAoKGIyIHwgMCkgLyAxMiB8IDApICsgKCgobmQoYTIpIHwgMCkgIT0gMCkgPDwgMzEgPj4gMzEpIHwgMCwgKGQyIHwgMCkgIT0gMCkgOiAwKSA/IChiMiA9IGNbYTIgPj4gMl0gfCAwLCAhKEVkKGIyLCBGZCgpIHwgMCkgfCAwKSkgOiAwKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKGQyIHwgMCkgewogICAgICAgICAgICAgICAgICBjYXNlIDE6IHsKICAgICAgICAgICAgICAgICAgICBhMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjYXNlIDI6IHsKICAgICAgICAgICAgICAgICAgICBpZiAoR2QoKGNbYTIgPj4gMl0gfCAwKSArIDEyIHwgMCwgSGQoKSB8IDApIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgYTIgPSAxOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKEdkKChjW2EyID4+IDJdIHwgMCkgKyAxMiB8IDAsIElkKCkgfCAwKSB8IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGEyID0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNhc2UgMzogewogICAgICAgICAgICAgICAgICAgIGlmIChHZCgoY1thMiA+PiAyXSB8IDApICsgMTIgfCAwLCBIZCgpIHwgMCkgfCAwID8gKGQyID0gKGNbYTIgPj4gMl0gfCAwKSArIDI0IHwgMCwgR2QoZDIsIElkKCkgfCAwKSB8IDApIDogMCkgewogICAgICAgICAgICAgICAgICAgICAgYTIgPSAzOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBhMiA9IC0xOwogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgYTIgPSAtMTsKICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbWQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeHEoYTIsIDgxMzEpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ2MDQ7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG5kKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKCgoYjIgfCAwKSAhPSAoY1thMiA+PiAyXSB8IDApID8gKGQyID0gYjIsIChjW2QyICsgLTEyID4+IDJdIHwgMCkgPT0gMCkgOiAwKSA/IChjW2QyICsgLTQgPj4gMl0gfCAwKSA9PSAyIDogMCkKICAgICAgICAgICAgYTIgPSBjW2QyICsgLTggPj4gMl0gfCAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBhMiA9IDA7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvZChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyICsgNCB8IDA7CiAgICAgICAgICBnMiA9IGQyOwogICAgICAgICAgZjIgPSBlcSgyNCkgfCAwOwogICAgICAgICAgS2QoZjIsIGIyKTsKICAgICAgICAgIGNbZzIgPj4gMl0gPSAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGNbZzIgPj4gMl07CiAgICAgICAgICBMZChhMiwgZjIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMDsKICAgICAgICAgIGoyID0gVjsKICAgICAgICAgIFYgPSBWICsgMzIgfCAwOwogICAgICAgICAgZTIgPSBqMiArIDEyIHwgMDsKICAgICAgICAgIGYyID0gajI7CiAgICAgICAgICBiMiA9IGoyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGVxKDQ3OTIpIHwgMDsKICAgICAgICAgIFpkKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIF9kKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHFkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDA7CiAgICAgICAgICBqMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gajIgKyAxMiB8IDA7CiAgICAgICAgICBmMiA9IGoyOwogICAgICAgICAgYjIgPSBqMiArIDggfCAwOwogICAgICAgICAgaDIgPSBlcSgzMzYpIHwgMDsKICAgICAgICAgIGFmKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIGJmKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDA7CiAgICAgICAgICBqMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gajIgKyAxMiB8IDA7CiAgICAgICAgICBmMiA9IGoyOwogICAgICAgICAgYjIgPSBqMiArIDggfCAwOwogICAgICAgICAgaDIgPSBlcSgzMjQpIHwgMDsKICAgICAgICAgIEFmKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIEJmKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHNkKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwOwogICAgICAgICAgajIgPSBWOwogICAgICAgICAgViA9IFYgKyAzMiB8IDA7CiAgICAgICAgICBoMiA9IGoyICsgMTIgfCAwOwogICAgICAgICAgaTIgPSBqMjsKICAgICAgICAgIGUyID0gajIgKyA4IHwgMDsKICAgICAgICAgIGcyID0gZXEoNjQpIHwgMDsKICAgICAgICAgIFFmKGcyLCBjW2EyICsgNCA+PiAyXSB8IDAsIGIyKTsKICAgICAgICAgIGYyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSAwOwogICAgICAgICAgY1toMiA+PiAyXSA9IGNbZTIgPj4gMl07CiAgICAgICAgICBSZihpMiwgZzIsIGgyKTsKICAgICAgICAgIGcyID0gYTIgKyAxMiB8IDA7CiAgICAgICAgICBiMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSBhMiArIDE2IHwgMDsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmIChiMiA+Pj4gMCA+PSAoY1tlMiA+PiAyXSB8IDApID4+PiAwKSB7CiAgICAgICAgICAgICAgYjIgPSAoYjIgLSAoY1tmMiA+PiAyXSB8IDApID4+IDMpICsgMSB8IDA7CiAgICAgICAgICAgICAgZDIgPSBlZShmMikgfCAwOwogICAgICAgICAgICAgIGlmIChkMiA+Pj4gMCA8IGIyID4+PiAwKQogICAgICAgICAgICAgICAgY3IoZjIpOwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgazIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGwyID0gKGNbZTIgPj4gMl0gfCAwKSAtIGsyIHwgMDsKICAgICAgICAgICAgICAgIGUyID0gbDIgPj4gMjsKICAgICAgICAgICAgICAgIGJlKAogICAgICAgICAgICAgICAgICBoMiwKICAgICAgICAgICAgICAgICAgbDIgPj4gMyA+Pj4gMCA8IGQyID4+PiAxID4+PiAwID8gZTIgPj4+IDAgPCBiMiA+Pj4gMCA/IGIyIDogZTIgOiBkMiwKICAgICAgICAgICAgICAgICAgKGNbZzIgPj4gMl0gfCAwKSAtIGsyID4+IDMsCiAgICAgICAgICAgICAgICAgIGEyICsgMTYgfCAwCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgYTIgPSBoMiArIDggfCAwOwogICAgICAgICAgICAgICAgZzIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbZzIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgICAgZTIgPSBpMiArIDQgfCAwOwogICAgICAgICAgICAgICAgY1tnMiArIDQgPj4gMl0gPSBjW2UyID4+IDJdOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSBnMiArIDg7CiAgICAgICAgICAgICAgICBjZShmMiwgaDIpOwogICAgICAgICAgICAgICAgZGUoaDIpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICRkKGgyLCBmMiwgMSk7CiAgICAgICAgICAgICAgbDIgPSBoMiArIDQgfCAwOwogICAgICAgICAgICAgIGsyID0gY1tsMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgY1trMiA+PiAyXSA9IGNbaTIgPj4gMl07CiAgICAgICAgICAgICAgYTIgPSBpMiArIDQgfCAwOwogICAgICAgICAgICAgIGNbazIgKyA0ID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgICAgICBjW2kyID4+IDJdID0gMDsKICAgICAgICAgICAgICBjW2EyID4+IDJdID0gMDsKICAgICAgICAgICAgICBjW2wyID4+IDJdID0gazIgKyA4OwogICAgICAgICAgICAgIGFlKGgyKTsKICAgICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgU2QoaTIpOwogICAgICAgICAgViA9IGoyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0ZChiMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDQ4IHwgMDsKICAgICAgICAgIGYyID0gZTI7CiAgICAgICAgICBjW2IyID4+IDJdID0gZDI7CiAgICAgICAgICBhW2IyICsgNCA+PiAwXSA9IDA7CiAgICAgICAgICBKZyhiMiArIDggfCAwLCBkMik7CiAgICAgICAgICBKZyhiMiArIDIwIHwgMCwgZDIpOwogICAgICAgICAgT2MoZjIsIDI1NiwgMCwgMCk7CiAgICAgICAgICBLZyhiMiArIDMyIHwgMCwgZDIsIGYyKTsKICAgICAgICAgIEljKGYyKTsKICAgICAgICAgIFYgPSBlMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgTmcoYTIgKyAzMiB8IDApOwogICAgICAgICAgX2YoYTIgKyAyMCB8IDApOwogICAgICAgICAgX2YoYTIgKyA4IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGEyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCA/IChkMiA9IGEyICsgNCB8IDAsIGIyID0gY1tkMiA+PiAyXSB8IDAsIGNbZDIgPj4gMl0gPSBiMiArIC0xLCAoYjIgfCAwKSA9PSAwKSA6IDApIHsKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgICBxcShhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdkKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGYyID0gZTIgKyA0IHwgMDsKICAgICAgICAgIGgyID0gZTI7CiAgICAgICAgICBnMiA9IGVxKDEyKSB8IDA7CiAgICAgICAgICBPZyhnMiwgYjIsIGQyKTsKICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGNbaDIgPj4gMl07CiAgICAgICAgICBQZyhhMiwgZzIsIGYyKTsKICAgICAgICAgIFYgPSBlMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geGQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgZ2UoYTIpOwogICAgICAgICAgJGcoYTIgKyA0Nzg0IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHlkKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGYyID0gZTIgKyA0IHwgMDsKICAgICAgICAgIGgyID0gZTI7CiAgICAgICAgICBnMiA9IGVxKDEyKSB8IDA7CiAgICAgICAgICBhaChnMiwgYjIsIGQyKTsKICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGNbaDIgPj4gMl07CiAgICAgICAgICBiaChhMiwgZzIsIGYyKTsKICAgICAgICAgIFYgPSBlMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gemQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgZ2UoYTIpOwogICAgICAgICAgbmgoYTIgKyA0Nzg0IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFkKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGYyID0gZTIgKyA0IHwgMDsKICAgICAgICAgIGgyID0gZTI7CiAgICAgICAgICBnMiA9IGVxKDEyKSB8IDA7CiAgICAgICAgICBvaChnMiwgYjIsIGQyKTsKICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGNbaDIgPj4gMl07CiAgICAgICAgICBwaChhMiwgZzIsIGYyKTsKICAgICAgICAgIFYgPSBlMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQmQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgZ2UoYTIpOwogICAgICAgICAgQmgoYTIgKyA0Nzg0IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENkKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBlMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGYyID0gZTIgKyA0IHwgMDsKICAgICAgICAgIGgyID0gZTI7CiAgICAgICAgICBnMiA9IGVxKDEyKSB8IDA7CiAgICAgICAgICBDaChnMiwgYjIsIGQyKTsKICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGNbaDIgPj4gMl07CiAgICAgICAgICBEaChhMiwgZzIsIGYyKTsKICAgICAgICAgIFYgPSBlMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRGQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgZ2UoYTIpOwogICAgICAgICAgUGgoYTIgKyA0Nzg0IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVkKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoR2QoYTIsIGIyKSB8IDApIF4gMSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEZkKCkgewogICAgICAgICAgaWYgKChhWzIxNDU2XSB8IDApID09IDAgPyBUcCgyMTQ1NikgfCAwIDogMCkgewogICAgICAgICAgICBfYigyMTUzNiwgNiwgMjAsIDIpOwogICAgICAgICAgICAkcCgyMTQ1Nik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gMjE1MzY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdkKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGlmICgoY1thMiA+PiAyXSB8IDApID09IChjW2IyID4+IDJdIHwgMCkgPyAoY1thMiArIDggPj4gMl0gfCAwKSA9PSAoY1tiMiArIDggPj4gMl0gfCAwKSA6IDApCiAgICAgICAgICAgIGEyID0gKGNbYTIgKyA0ID4+IDJdIHwgMCkgPT0gKGNbYjIgKyA0ID4+IDJdIHwgMCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhkKCkgewogICAgICAgICAgaWYgKChhWzIxNDY0XSB8IDApID09IDAgPyBUcCgyMTQ2NCkgfCAwIDogMCkgewogICAgICAgICAgICBfYigyMTU0OCwgNywgOCwgMik7CiAgICAgICAgICAgICRwKDIxNDY0KTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAyMTU0ODsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSWQoKSB7CiAgICAgICAgICBpZiAoKGFbMjE0NzJdIHwgMCkgPT0gMCA/IFRwKDIxNDcyKSB8IDAgOiAwKSB7CiAgICAgICAgICAgIF9iKDIxNTYwLCA4LCA2LCAyKTsKICAgICAgICAgICAgJHAoMjE0NzIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDIxNTYwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKZChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB5cChhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtkKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIE1kKGIyKTsKICAgICAgICAgIGNbYjIgPj4gMl0gPSA0NjI0OwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIGNbYjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbYjIgKyAxMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgMTYgPj4gMl0gPSAwOwogICAgICAgICAgYVtiMiArIDIwID4+IDBdID0gMTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTGQoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQ2NjQ7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgVWQoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTWQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ2NDQ7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5kKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDA7CiAgICAgICAgICBrMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGgyID0gazI7CiAgICAgICAgICBlMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gY1tiMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoZTIgfCAwKSAhPSAoaTIgfCAwKSkgewogICAgICAgICAgICBqMiA9IGgyICsgNCB8IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBmMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICBnMiA9IGNbZTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2oyID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgaWYgKGcyIHwgMCkgewogICAgICAgICAgICAgICAgZzIgPSBnMiArIDQgfCAwOwogICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IChjW2cyID4+IDJdIHwgMCkgKyAxOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkMiA9ICRbY1soY1tmMiA+PiAyXSB8IDApICsgMTIgPj4gMl0gJiA2M10oZjIsIGQyKSB8IDA7CiAgICAgICAgICAgICAgU2QoaDIpOwogICAgICAgICAgICAgIGUyID0gZTIgKyA4IHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoKGUyIHwgMCkgIT0gKGkyIHwgMCkpOwogICAgICAgICAgfQogICAgICAgICAgZTIgPSBiMiArIDIwIHwgMDsKICAgICAgICAgIGlmIChhW2UyID4+IDBdIHwgMCkgewogICAgICAgICAgICBhW2UyID4+IDBdID0gMDsKICAgICAgICAgICAgbmMoY1tiMiArIDQgPj4gMl0gfCAwKTsKICAgICAgICAgIH0KICAgICAgICAgIFYgPSBrMjsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE9kKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0NjI0OwogICAgICAgICAgVGQoYTIgKyA4IHwgMCk7CiAgICAgICAgICBRZChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIE9kKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUWQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBSZChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBVKCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGEyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCA/IChkMiA9IGEyICsgNCB8IDAsIGIyID0gY1tkMiA+PiAyXSB8IDAsIGNbZDIgPj4gMl0gPSBiMiArIC0xLCAoYjIgfCAwKSA9PSAwKSA6IDApIHsKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgICBxcShhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRkKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChkMiB8IDApIHsKICAgICAgICAgICAgZTIgPSBhMiArIDQgfCAwOwogICAgICAgICAgICBiMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gKGQyIHwgMCkpCiAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgYjIgPSBiMiArIC04IHwgMDsKICAgICAgICAgICAgICAgIFNkKGIyKTsKICAgICAgICAgICAgICB9IHdoaWxlICgoYjIgfCAwKSAhPSAoZDIgfCAwKSk7CiAgICAgICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBjW2UyID4+IDJdID0gZDI7CiAgICAgICAgICAgIERhKGIyLCAoY1thMiArIDggPj4gMl0gfCAwKSAtIGIyIHwgMCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFVkKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVmQoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBXZChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA4ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFhkKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gODU0NiA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBZZChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBaZChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBmZShhMik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDY5MjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBnZShhMiArIDggfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX2QoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQ3NDA7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgWGUoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJGQoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgYjIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBiMiArIChkMiA8PCAzKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1soY1thMiA+PiAyXSB8IDApICsgNCA+PiAyXSA9IGNbYTIgKyA0ID4+IDJdOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBiZShhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwOwogICAgICAgICAgZjIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgaWYgKGIyID4+PiAwID4gNTM2ODcwOTExKSB7CiAgICAgICAgICAgICAgICBmMiA9IHYoOCkgfCAwOwogICAgICAgICAgICAgICAgdnEoZjIsIDY3MjMpOwogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDU5NTY7CiAgICAgICAgICAgICAgICB4KGYyIHwgMCwgMzkyOCwgMTIzKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZTIgPSBlcShiMiA8PCAzKSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBjW2EyID4+IDJdID0gZTI7CiAgICAgICAgICBkMiA9IGUyICsgKGQyIDw8IDMpIHwgMDsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGQyOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGUyICsgKGIyIDw8IDMpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBjZShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwOwogICAgICAgICAgaTIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGoyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGQyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICBoMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBpZiAoKGQyIHwgMCkgPT0gKGkyIHwgMCkpIHsKICAgICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgICAgZzIgPSBhMjsKICAgICAgICAgICAgZTIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgICAgZDIgPSBpMjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGUyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBnMiA9IGQyOwogICAgICAgICAgICAgIGQyID0gZDIgKyAtOCB8IDA7CiAgICAgICAgICAgICAgY1tlMiArIC04ID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICBnMiA9IGcyICsgLTQgfCAwOwogICAgICAgICAgICAgIGNbZTIgKyAtNCA+PiAyXSA9IGNbZzIgPj4gMl07CiAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgZTIgPSAoY1toMiA+PiAyXSB8IDApICsgLTggfCAwOwogICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgfSB3aGlsZSAoKGQyIHwgMCkgIT0gKGkyIHwgMCkpOwogICAgICAgICAgICBmMiA9IGgyOwogICAgICAgICAgICBnMiA9IGEyOwogICAgICAgICAgICBkMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgfQogICAgICAgICAgY1tnMiA+PiAyXSA9IGUyOwogICAgICAgICAgY1tmMiA+PiAyXSA9IGQyOwogICAgICAgICAgaTIgPSBiMiArIDggfCAwOwogICAgICAgICAgaDIgPSBjW2oyID4+IDJdIHwgMDsKICAgICAgICAgIGNbajIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgY1tpMiA+PiAyXSA9IGgyOwogICAgICAgICAgaTIgPSBhMiArIDggfCAwOwogICAgICAgICAgajIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgIGEyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2kyID4+IDJdID0gY1tqMiA+PiAyXTsKICAgICAgICAgIGNbajIgPj4gMl0gPSBhMjsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBiMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChiMiB8IDApICE9IChkMiB8IDApKQogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgZjIgPSBiMiArIC04IHwgMDsKICAgICAgICAgICAgICBjW2UyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgU2QoZjIpOwogICAgICAgICAgICAgIGIyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKChiMiB8IDApICE9IChkMiB8IDApKTsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKQogICAgICAgICAgICBEYShiMiwgKGNbYTIgKyAxMiA+PiAyXSB8IDApIC0gYjIgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZWUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZmUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ3MTY7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdlKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIG9lKGIyKTsKICAgICAgICAgIHBlKGIyICsgMzk4MCB8IDApOwogICAgICAgICAgcWUoYjIgKyA0MzgwIHwgMCk7CiAgICAgICAgICBhW2IyICsgNDc4MCA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgNDc4MSA+PiAwXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGhlKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0NjkyOwogICAgICAgICAgemUoYTIgKyA4IHwgMCk7CiAgICAgICAgICBsZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGllKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGhlKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gamUoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga2UoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIEJlKGEyICsgOCB8IDAsIGNbYTIgKyA0ID4+IDJdIHwgMCwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBsZShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG5lKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9lKGQyKSB7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIHRlKGQyKTsKICAgICAgICAgIHVlKGQyICsgNTIgfCAwKTsKICAgICAgICAgIHVlKGQyICsgNDM2IHwgMCk7CiAgICAgICAgICBPYyhkMiArIDg1MiB8IDAsIDY0LCAwLCAwKTsKICAgICAgICAgIGFbZDIgKyAzOTc2ID4+IDBdID0gMDsKICAgICAgICAgIGUyID0gZDIgKyAyMCB8IDA7CiAgICAgICAgICBmMiA9IGUyICsgMzIgfCAwOwogICAgICAgICAgZG8gewogICAgICAgICAgICBiW2UyID4+IDFdID0gMDsKICAgICAgICAgICAgZTIgPSBlMiArIDIgfCAwOwogICAgICAgICAgfSB3aGlsZSAoKGUyIHwgMCkgPCAoZjIgfCAwKSk7CiAgICAgICAgICBlMiA9IGVxKDQ0KSB8IDA7CiAgICAgICAgICBPYyhlMiwgMjU2LCAwLCAwKTsKICAgICAgICAgIGNbZDIgKyA4OTYgPj4gMl0gPSBlMjsKICAgICAgICAgIGUyID0gZXEoNDQpIHwgMDsKICAgICAgICAgIE9jKGUyLCAyNTYsIDAsIDApOwogICAgICAgICAgY1tkMiArIDkwMCA+PiAyXSA9IGUyOwogICAgICAgICAgZTIgPSBkMiArIDgyMCB8IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgKyAxMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyICsgMTYgPj4gMl0gPSAwOwogICAgICAgICAgY1tlMiArIDIwID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgKyAyNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyICsgMjggPj4gMl0gPSAwOwogICAgICAgICAgZTIgPSAwOwogICAgICAgICAgZG8gewogICAgICAgICAgICBmMiA9IGVxKDQ0KSB8IDA7CiAgICAgICAgICAgIE9jKGYyLCAyNTYsIDAsIDApOwogICAgICAgICAgICBjW2QyICsgOTA0ICsgKGUyIDw8IDIpID4+IDJdID0gZjI7CiAgICAgICAgICAgIGYyID0gZXEoNDQpIHwgMDsKICAgICAgICAgICAgT2MoZjIsIDI1NiwgMCwgMCk7CiAgICAgICAgICAgIGNbZDIgKyAxOTI4ICsgKGUyIDw8IDIpID4+IDJdID0gZjI7CiAgICAgICAgICAgIGYyID0gZXEoNDQpIHwgMDsKICAgICAgICAgICAgT2MoZjIsIDI1NiwgMCwgMCk7CiAgICAgICAgICAgIGNbZDIgKyAyOTUyICsgKGUyIDw8IDIpID4+IDJdID0gZjI7CiAgICAgICAgICAgIGUyID0gZTIgKyAxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKGUyID4+PiAwIDwgMjU2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeGUoYTIsIDE2LCA0LCA4LCAwKTsKICAgICAgICAgIHhlKGEyICsgODAgfCAwLCAxNiwgMSwgOCwgMCk7CiAgICAgICAgICB4ZShhMiArIDE2MCB8IDAsIDMyLCAyLCA4LCAwKTsKICAgICAgICAgIHhlKGEyICsgMjQwIHwgMCwgMzIsIDIyLCA4LCAwKTsKICAgICAgICAgIHhlKGEyICsgMzIwIHwgMCwgMzIsIDIwLCA4LCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcWUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgbWMoYTIsIDE2LCA0LCA4LCAwKTsKICAgICAgICAgIG1jKGEyICsgODAgfCAwLCAxNiwgMSwgOCwgMCk7CiAgICAgICAgICBtYyhhMiArIDE2MCB8IDAsIDMyLCAyLCA4LCAwKTsKICAgICAgICAgIG1jKGEyICsgMjQwIHwgMCwgMzIsIDIyLCA4LCAwKTsKICAgICAgICAgIG1jKGEyICsgMzIwIHwgMCwgMzIsIDIwLCA4LCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeWUoYTIgKyAzMjAgfCAwKTsKICAgICAgICAgIHllKGEyICsgMjQwIHwgMCk7CiAgICAgICAgICB5ZShhMiArIDE2MCB8IDApOwogICAgICAgICAgeWUoYTIgKyA4MCB8IDApOwogICAgICAgICAgeWUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IGNbYTIgKyA4OTYgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICBJYyhiMik7CiAgICAgICAgICAgIGpwKGIyKTsKICAgICAgICAgIH0KICAgICAgICAgIGIyID0gY1thMiArIDkwMCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKSB7CiAgICAgICAgICAgIEljKGIyKTsKICAgICAgICAgICAganAoYjIpOwogICAgICAgICAgfQogICAgICAgICAgZDIgPSAwOwogICAgICAgICAgZG8gewogICAgICAgICAgICBiMiA9IGNbYTIgKyA5MDQgKyAoZDIgPDwgMikgPj4gMl0gfCAwOwogICAgICAgICAgICBpZiAoYjIgfCAwKSB7CiAgICAgICAgICAgICAgSWMoYjIpOwogICAgICAgICAgICAgIGpwKGIyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBiMiA9IGNbYTIgKyAxOTI4ICsgKGQyIDw8IDIpID4+IDJdIHwgMDsKICAgICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICAgIEljKGIyKTsKICAgICAgICAgICAgICBqcChiMik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYjIgPSBjW2EyICsgMjk1MiArIChkMiA8PCAyKSA+PiAyXSB8IDA7CiAgICAgICAgICAgIGlmIChiMiB8IDApIHsKICAgICAgICAgICAgICBJYyhiMik7CiAgICAgICAgICAgICAganAoYjIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGQyID0gZDIgKyAxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKChkMiB8IDApICE9IDI1Nik7CiAgICAgICAgICBJYyhhMiArIDg1MiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0ZShiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgYzIgPSAwOwogICAgICAgICAgYVtiMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMyA+PiAwXSA9IDA7CiAgICAgICAgICBjMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBhW2MyID4+IDBdID0gMDsKICAgICAgICAgIGFbYzIgKyAxID4+IDBdID0gMDsKICAgICAgICAgIGFbYzIgKyAyID4+IDBdID0gMDsKICAgICAgICAgIGFbYzIgKyAzID4+IDBdID0gMDsKICAgICAgICAgIGIyID0gYjIgKyAxMiB8IDA7CiAgICAgICAgICBjMiA9IGIyOwogICAgICAgICAgYVtjMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2MyICsgMSA+PiAwXSA9IDA7CiAgICAgICAgICBhW2MyICsgMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2MyICsgMyA+PiAwXSA9IDA7CiAgICAgICAgICBiMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBhW2IyID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAyID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAzID4+IDBdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMDsKICAgICAgICAgIGIyID0gYTIgKyAzODQgfCAwOwogICAgICAgICAgZG8gewogICAgICAgICAgICB2ZShhMik7CiAgICAgICAgICAgIGEyID0gYTIgKyAyNCB8IDA7CiAgICAgICAgICB9IHdoaWxlICgoYTIgfCAwKSAhPSAoYjIgfCAwKSk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZlKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHdlKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gd2UoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgMTIgPj4gMl0gPSAwOwogICAgICAgICAgY1tiMiArIDE2ID4+IDJdID0gMDsKICAgICAgICAgIGFbYjIgKyAyMCA+PiAwXSA9IDE7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHhlKGEyLCBiMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIHZhciBnMiA9IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBkMjsKICAgICAgICAgIGNbYTIgKyAxMiA+PiAyXSA9IGUyOwogICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2EyICsgMzYgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDQwID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyA0NCA+PiAyXSA9IDA7CiAgICAgICAgICBHYyhhMiArIDQ4IHwgMCk7CiAgICAgICAgICBjW2EyICsgNjggPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDcyID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyA3NiA+PiAyXSA9IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoIWYyKSB7CiAgICAgICAgICAgICAgZDIgPSBhMiArIDIwIHwgMDsKICAgICAgICAgICAgICBpZiAoKGIyICsgLTEgfCAwKSA+Pj4gMCA8IDMxKSB7CiAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICBmMiA9IDEgPDwgYjI7CiAgICAgICAgICAgICAgICBjW2EyICsgMjQgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICAgIGQyID0gZjIgPj4+IDE7CiAgICAgICAgICAgICAgICBjW2EyICsgMjggPj4gMl0gPSAwIC0gZDI7CiAgICAgICAgICAgICAgICBkMiA9IGYyICsgLTEgLSBkMiB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IDMyOwogICAgICAgICAgICAgICAgY1thMiArIDI0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgKyAyOCA+PiAyXSA9IC0yMTQ3NDgzNjQ4OwogICAgICAgICAgICAgICAgZDIgPSAyMTQ3NDgzNjQ3OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGUyID0gYTIgKyAyMCB8IDA7CiAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1thMiArIDI0ID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgZDIgPSBmMjsKICAgICAgICAgICAgICBnMiA9IDA7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIGQyID0gZDIgPj4+IDE7CiAgICAgICAgICAgICAgICBiMiA9IGcyICsgMSB8IDA7CiAgICAgICAgICAgICAgICBpZiAoIWQyKQogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgZzIgPSBiMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9ICgxIDw8IGcyIHwgMCkgPT0gKGYyIHwgMCkgPyBnMiA6IGIyOwogICAgICAgICAgICAgIGQyID0gZjIgPj4+IDE7CiAgICAgICAgICAgICAgY1thMiArIDI4ID4+IDJdID0gMCAtIGQyOwogICAgICAgICAgICAgIGQyID0gZjIgKyAtMSAtIGQyIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgY1thMiArIDMyID4+IDJdID0gZDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geWUoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZzIgPSBhMiArIDM2IHwgMDsKICAgICAgICAgIGQyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGEyICsgNDAgfCAwOwogICAgICAgICAgYjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoYjIgfCAwKSAhPSAoZDIgfCAwKSkKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGIyID0gYjIgKyAtNDQgfCAwOwogICAgICAgICAgICAgIEljKGIyKTsKICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gKGQyIHwgMCkpOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGQyOwogICAgICAgICAgZTIgPSBhMiArIDY4IHwgMDsKICAgICAgICAgIGYyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICBkMiA9IGEyICsgNzIgfCAwOwogICAgICAgICAgYjIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoYjIgfCAwKSAhPSAoZjIgfCAwKSkKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGIyID0gYjIgKyAtNDQgfCAwOwogICAgICAgICAgICAgIEljKGIyKTsKICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gKGYyIHwgMCkpOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGYyOwogICAgICAgICAgSGMoZTIpOwogICAgICAgICAgSGMoZzIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6ZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBBZShhMiArIDQzODAgfCAwKTsKICAgICAgICAgIHJlKGEyICsgMzk4MCB8IDApOwogICAgICAgICAgc2UoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBBZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBxYyhhMiArIDMyMCB8IDApOwogICAgICAgICAgcWMoYTIgKyAyNDAgfCAwKTsKICAgICAgICAgIHFjKGEyICsgMTYwIHwgMCk7CiAgICAgICAgICBxYyhhMiArIDgwIHwgMCk7CiAgICAgICAgICBxYyhhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJlKGYyLCBnMiwgaDIpIHsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgZzIgPSBnMiB8IDA7CiAgICAgICAgICBoMiA9IGgyIHwgMDsKICAgICAgICAgIHZhciBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwOwogICAgICAgICAgcDIgPSBWOwogICAgICAgICAgViA9IFYgKyAzMiB8IDA7CiAgICAgICAgICBvMiA9IHAyOwogICAgICAgICAgaTIgPSBmMiArIDQ3ODEgfCAwOwogICAgICAgICAgaWYgKCEoYVtpMiA+PiAwXSB8IDApKSB7CiAgICAgICAgICAgIENlKGYyICsgNDM4MCB8IDApOwogICAgICAgICAgICBhW2kyID4+IDBdID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIGkyID0gZjIgKyAzOTc2IHwgMDsKICAgICAgICAgIGlmICghKGFbaTIgPj4gMF0gfCAwKSkgewogICAgICAgICAgICBhW2kyID4+IDBdID0gMTsKICAgICAgICAgICAgRWUoRGUoZzIpIHwgMCwgaDIsIDIwKTsKICAgICAgICAgICAgRmUobzIsIGgyKTsKICAgICAgICAgICAgazIgPSBmMjsKICAgICAgICAgICAgaTIgPSBvMjsKICAgICAgICAgICAgajIgPSBrMiArIDIwIHwgMDsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGFbazIgPj4gMF0gPSBhW2kyID4+IDBdIHwgMDsKICAgICAgICAgICAgICBrMiA9IGsyICsgMSB8IDA7CiAgICAgICAgICAgICAgaTIgPSBpMiArIDEgfCAwOwogICAgICAgICAgICB9IHdoaWxlICgoazIgfCAwKSA8IChqMiB8IDApKTsKICAgICAgICAgICAgYltmMiArIDEyID4+IDFdID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG0yID0gWmMoZzIsIGYyICsgODUyIHwgMCkgfCAwOwogICAgICAgICAgICBpZiAobTIpIHsKICAgICAgICAgICAgICBpZiAobTIgJiAzMiB8IDApCiAgICAgICAgICAgICAgICBIZSgoWmMoZzIsIGNbZjIgKyA5MDQgKyAoKChHZShmMikgfCAwKSAmIDI1NSkgPDwgMikgPj4gMl0gfCAwKSB8IDApICYgMjU1LCBmMik7CiAgICAgICAgICAgICAgbjIgPSBmMiArIDE0IHwgMDsKICAgICAgICAgICAgICBrMiA9IGFbbjIgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGkyID0gazIgJiA3OwogICAgICAgICAgICAgIGsyID0gKGsyICYgMjU1KSA+Pj4gMyAmIDc7CiAgICAgICAgICAgICAgajIgPSBkWzE2ICsgKGsyIDw8IDMpICsgaTIgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGkyID0gZFs4MCArIChrMiA8PCAzKSArIGkyID4+IDBdIHwgMDsKICAgICAgICAgICAgICBpZiAoIShtMiAmIDE2KSkKICAgICAgICAgICAgICAgIGwyID0gYltmMiArIDIwICsgKGoyIDw8IDEpID4+IDFdIHwgMDsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHEyID0gZjIgKyAyMCArIChqMiA8PCAxKSB8IDA7CiAgICAgICAgICAgICAgICBsMiA9IChwYyhmMiArIDQzODAgfCAwLCBnMiwgZVtxMiA+PiAxXSB8IDAsIGoyID4+PiAwIDwgMyA/IGoyIDogMykgfCAwKSAmIDY1NTM1OwogICAgICAgICAgICAgICAgYltxMiA+PiAxXSA9IGwyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBiW2YyICsgMTIgPj4gMV0gPSBsMjsKICAgICAgICAgICAgICBpZiAobTIgJiA4IHwgMCkgewogICAgICAgICAgICAgICAgcTIgPSBmMiArIDE1IHwgMDsKICAgICAgICAgICAgICAgIGFbcTIgPj4gMF0gPSBaYyhnMiwgY1tmMiArIDE5MjggKyAoZFtxMiA+PiAwXSA8PCAyKSA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKG0yICYgNCB8IDApIHsKICAgICAgICAgICAgICAgIG4yID0gWmMoZzIsIGNbZjIgKyA4OTYgKyAoKChkW24yID4+IDBdIHwgMCkgPj4+IDYgJiAxKSA8PCAyKSA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgICAgICAgIHEyID0gZjIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICBhW3EyID4+IDBdID0gSWUobjIgKyAoYVtxMiA+PiAwXSB8IDApIHwgMCkgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAobTIgJiAyIHwgMCkgewogICAgICAgICAgICAgICAgcTIgPSBmMiArIDE3IHwgMDsKICAgICAgICAgICAgICAgIGFbcTIgPj4gMF0gPSBaYyhnMiwgY1tmMiArIDI5NTIgKyAoZFtxMiA+PiAwXSA8PCAyKSA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKG0yICYgMSkgewogICAgICAgICAgICAgICAgcTIgPSBmMiArIDE4IHwgMDsKICAgICAgICAgICAgICAgIGJbcTIgPj4gMV0gPSBwYyhmMiArIDQ0NjAgfCAwLCBnMiwgZVtxMiA+PiAxXSB8IDAsIDApIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcTIgPSBhW2YyICsgMTQgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGkyID0gcTIgJiA3OwogICAgICAgICAgICAgIHEyID0gKHEyICYgMjU1KSA+Pj4gMyAmIDc7CiAgICAgICAgICAgICAgazIgPSBxMjsKICAgICAgICAgICAgICBqMiA9IGRbMTYgKyAocTIgPDwgMykgKyBpMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgaTIgPSBkWzgwICsgKHEyIDw8IDMpICsgaTIgPj4gMF0gfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGwyID0gZjIgKyA1MiArIChqMiAqIDI0IHwgMCkgfCAwOwogICAgICAgICAgICBtMiA9IGYyICsgNDU0MCB8IDA7CiAgICAgICAgICAgIG4yID0gKGsyIHwgMCkgPT0gMSAmIDE7CiAgICAgICAgICAgIGsyID0gcGMobTIsIGcyLCBKZShsMikgfCAwLCBuMikgfCAwOwogICAgICAgICAgICBjW28yID4+IDJdID0gazI7CiAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAoY1tmMiA+PiAyXSB8IDApICsgazI7CiAgICAgICAgICAgIEtlKGwyLCBvMik7CiAgICAgICAgICAgIGwyID0gZjIgKyA0MzYgKyAoajIgKiAyNCB8IDApIHwgMDsKICAgICAgICAgICAgazIgPSBKZShsMikgfCAwOwogICAgICAgICAgICBqMiA9IExlKG0yKSB8IDA7CiAgICAgICAgICAgIHEyID0gZjIgKyA0NjIwIHwgMDsKICAgICAgICAgICAgajIgPSBwYyhxMiwgZzIsIGsyLCAoajIgPj4+IDAgPCAyMCA/IGoyICYgLTIgOiAyMCkgfCBuMikgfCAwOwogICAgICAgICAgICBjW28yID4+IDJdID0gajI7CiAgICAgICAgICAgIGsyID0gZjIgKyA0IHwgMDsKICAgICAgICAgICAgY1trMiA+PiAyXSA9IChjW2syID4+IDJdIHwgMCkgKyBqMjsKICAgICAgICAgICAgS2UobDIsIG8yKTsKICAgICAgICAgICAgbzIgPSBMZShtMikgfCAwOwogICAgICAgICAgICBvMiA9IChMZShxMikgfCAwKSArIG8yIHwgMDsKICAgICAgICAgICAgcTIgPSBmMiArIDgyMCArIChpMiA8PCAyKSB8IDA7CiAgICAgICAgICAgIG8yID0gcGMoZjIgKyA0NzAwIHwgMCwgZzIsIGNbcTIgPj4gMl0gfCAwLCAobzIgPj4+IDAgPCAzNiA/IG8yID4+PiAxICYgMjE0NzQ4MzY0NiA6IDE4KSB8IG4yKSB8IDA7CiAgICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gbzI7CiAgICAgICAgICAgIGNbcTIgPj4gMl0gPSBvMjsKICAgICAgICAgICAgTWUoZjIsIGgyKTsKICAgICAgICAgIH0KICAgICAgICAgIFYgPSBwMjsKICAgICAgICAgIHJldHVybiBoMiArIDIwIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQ2UoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgb2MoYTIpOwogICAgICAgICAgb2MoYTIgKyA4MCB8IDApOwogICAgICAgICAgb2MoYTIgKyAxNjAgfCAwKTsKICAgICAgICAgIG9jKGEyICsgMjQwIHwgMCk7CiAgICAgICAgICBvYyhhMiArIDMyMCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVlKGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwOwogICAgICAgICAgazIgPSBiMiArIDQgfCAwOwogICAgICAgICAgZjIgPSBjW2syID4+IDJdIHwgMDsKICAgICAgICAgIGoyID0gKGNbYjIgKyA4ID4+IDJdIHwgMCkgLSBmMiB8IDA7CiAgICAgICAgICBqMiA9IGoyID4+PiAwID4gZTIgPj4+IDAgPyBlMiA6IGoyOwogICAgICAgICAgaTIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgIGcyID0gKGNbaTIgPj4gMl0gfCAwKSArIGYyIHwgMDsKICAgICAgICAgIGgyID0gZzIgKyBqMiB8IDA7CiAgICAgICAgICBpZiAoajIpIHsKICAgICAgICAgICAgZjIgPSBnMjsKICAgICAgICAgICAgZzIgPSBkMjsKICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICBhW2cyID4+IDBdID0gYVtmMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgZjIgPSBmMiArIDEgfCAwOwogICAgICAgICAgICAgIGlmICgoZjIgfCAwKSA9PSAoaDIgfCAwKSkKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIGcyID0gZzIgKyAxIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBmMiA9IGNbazIgPj4gMl0gfCAwOwogICAgICAgICAgfQogICAgICAgICAgY1trMiA+PiAyXSA9IGYyICsgajI7CiAgICAgICAgICBlMiA9IGUyIC0gajIgfCAwOwogICAgICAgICAgaWYgKGUyIHwgMCkgewogICAgICAgICAgICBLYyhiMik7CiAgICAgICAgICAgIGcyID0gKGNbaTIgPj4gMl0gfCAwKSArIChjW2syID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgICBoMiA9IGcyICsgZTIgfCAwOwogICAgICAgICAgICBmMiA9IGQyICsgajIgfCAwOwogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIGFbZjIgPj4gMF0gPSBhW2cyID4+IDBdIHwgMDsKICAgICAgICAgICAgICBnMiA9IGcyICsgMSB8IDA7CiAgICAgICAgICAgICAgaWYgKChnMiB8IDApID09IChoMiB8IDApKQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgZjIgPSBmMiArIDEgfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNbazIgPj4gMl0gPSAoY1trMiA+PiAyXSB8IDApICsgZTI7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEZlKGQyLCBlMikgewogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHRlKGQyKTsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBOZShlMikgfCAwOwogICAgICAgICAgY1tkMiArIDQgPj4gMl0gPSBOZShlMiArIDQgfCAwKSB8IDA7CiAgICAgICAgICBjW2QyICsgOCA+PiAyXSA9IE5lKGUyICsgOCB8IDApIHwgMDsKICAgICAgICAgIGJbZDIgKyAxMiA+PiAxXSA9IE9lKGUyICsgMTIgfCAwKSB8IDA7CiAgICAgICAgICBIZShQZShlMiArIDE0IHwgMCkgfCAwLCBkMik7CiAgICAgICAgICBhW2QyICsgMTUgPj4gMF0gPSBQZShlMiArIDE1IHwgMCkgfCAwOwogICAgICAgICAgYVtkMiArIDE2ID4+IDBdID0gUWUoZTIgKyAxNiB8IDApIHwgMDsKICAgICAgICAgIGFbZDIgKyAxNyA+PiAwXSA9IFFlKGUyICsgMTcgfCAwKSB8IDA7CiAgICAgICAgICBiW2QyICsgMTggPj4gMV0gPSBPZShlMiArIDE4IHwgMCkgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHZShiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gYVtiMiArIDE0ID4+IDBdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSGUoYjIsIGMyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgYVtjMiArIDE0ID4+IDBdID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEllKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiAmIDI1NSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEplKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBjW2EyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtlKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDA7CiAgICAgICAgICBrMiA9IGIyICsgMjAgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKCEoYVtrMiA+PiAwXSB8IDApKSB7CiAgICAgICAgICAgICAgajIgPSBiMiArIDggfCAwOwogICAgICAgICAgICAgIGUyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgZjIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBnMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgICAgaDIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoKGUyIHwgMCkgPj0gKGYyIHwgMCkpIHsKICAgICAgICAgICAgICAgIGlmICgoaDIgfCAwKSA8IChmMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBoMjsKICAgICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgYVtrMiA+PiAwXSA9IDE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGgyOwogICAgICAgICAgICAgIGNbZzIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgICBnMiA9IGIyICsgMTYgfCAwOwogICAgICAgICAgICAgIGgyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgaTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBlMiA9IGIyICsgMTIgfCAwOwogICAgICAgICAgICAgIGYyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgaWYgKChoMiB8IDApIDwgKGkyIHwgMCkpIHsKICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBoMjsKICAgICAgICAgICAgICAgIGNbZzIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgoZjIgfCAwKSA8IChpMiB8IDApKSB7CiAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICBjW2UyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZzIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICAgICAgZTIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBoMiA9IGIyICsgMTIgfCAwOwogICAgICAgICAgICAgIGYyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgaWYgKChnMiB8IDApID49IChlMiB8IDApKSB7CiAgICAgICAgICAgICAgICBlMiA9IGIyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgaWYgKChnMiB8IDApIDwgKGYyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICBjW2UyID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICBhW2syID4+IDBdID0gMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjW2IyICsgMTYgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICBjW2gyID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgZTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBmMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGcyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgICBoMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGlmICgoZTIgfCAwKSA8IChmMiB8IDApKSB7CiAgICAgICAgICAgICAgICBjW2kyID4+IDJdID0gaDI7CiAgICAgICAgICAgICAgICBjW2cyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoKGUyIHwgMCkgPCAoaDIgfCAwKSkgewogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyOwogICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIExlKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBjW2EyID4+IDJdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTWUoYjIsIGMyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIFNlKGRbYjIgPj4gMF0gfCBkW2IyICsgMSA+PiAwXSA8PCA4IHwgZFtiMiArIDIgPj4gMF0gPDwgMTYgfCBkW2IyICsgMyA+PiAwXSA8PCAyNCwgYzIpOwogICAgICAgICAgZTIgPSBiMiArIDQgfCAwOwogICAgICAgICAgU2UoCiAgICAgICAgICAgIGRbZTIgPj4gMF0gfCBkW2UyICsgMSA+PiAwXSA8PCA4IHwgZFtlMiArIDIgPj4gMF0gPDwgMTYgfCBkW2UyICsgMyA+PiAwXSA8PCAyNCwKICAgICAgICAgICAgYzIgKyA0IHwgMAogICAgICAgICAgKTsKICAgICAgICAgIGUyID0gYjIgKyA4IHwgMDsKICAgICAgICAgIFNlKAogICAgICAgICAgICBkW2UyID4+IDBdIHwgZFtlMiArIDEgPj4gMF0gPDwgOCB8IGRbZTIgKyAyID4+IDBdIDw8IDE2IHwgZFtlMiArIDMgPj4gMF0gPDwgMjQsCiAgICAgICAgICAgIGMyICsgOCB8IDAKICAgICAgICAgICk7CiAgICAgICAgICBlMiA9IGIyICsgMTIgfCAwOwogICAgICAgICAgVGUoZFtlMiA+PiAwXSB8IGRbZTIgKyAxID4+IDBdIDw8IDgsIGMyICsgMTIgfCAwKTsKICAgICAgICAgIFVlKEdlKGIyKSB8IDAsIGMyICsgMTQgfCAwKTsKICAgICAgICAgIFVlKGFbYjIgKyAxNSA+PiAwXSB8IDAsIGMyICsgMTUgfCAwKTsKICAgICAgICAgIFZlKGFbYjIgKyAxNiA+PiAwXSB8IDAsIGMyICsgMTYgfCAwKTsKICAgICAgICAgIFZlKGFbYjIgKyAxNyA+PiAwXSB8IDAsIGMyICsgMTcgfCAwKTsKICAgICAgICAgIGIyID0gYjIgKyAxOCB8IDA7CiAgICAgICAgICBUZShkW2IyID4+IDBdIHwgZFtiMiArIDEgPj4gMF0gPDwgOCwgYzIgKyAxOCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gUmUoYTIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT2UoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChhW2IyICsgMSA+PiAwXSA8PCA4IHwgZFtiMiA+PiAwXSkgJiA2NTUzNSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBlKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiBhW2IyID4+IDBdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUWUoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIGFbYjIgPj4gMF0gfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBSZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gKGRbYTIgKyAxID4+IDBdIHwgMCkgPDwgOCB8IChkW2EyID4+IDBdIHwgMCkgfCAoZFthMiArIDIgPj4gMF0gfCAwKSA8PCAxNiB8IChkW2EyICsgMyA+PiAwXSB8IDApIDw8IDI0IHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2UoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgV2UoYTIsIGIyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVGUoYjIsIGMyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgYVtjMiArIDEgPj4gMF0gPSAoYjIgJiA2NTUzNSkgPj4+IDg7CiAgICAgICAgICBhW2MyID4+IDBdID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFVlKGIyLCBjMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGFbYzIgPj4gMF0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVmUoYjIsIGMyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgYVtjMiA+PiAwXSA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBXZShiMiwgYzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBhW2MyICsgMyA+PiAwXSA9IGIyID4+PiAyNDsKICAgICAgICAgIGFbYzIgKyAyID4+IDBdID0gYjIgPj4+IDE2OwogICAgICAgICAgYVtjMiArIDEgPj4gMF0gPSBiMiA+Pj4gODsKICAgICAgICAgIGFbYzIgPj4gMF0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWGUoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBZZShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBwcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFplKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApCiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDQgPj4gMl0gJiAyNTVdKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX2UoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuICgoY1tiMiArIDQgPj4gMl0gfCAwKSA9PSA5MjAyID8gYTIgKyAxMiB8IDAgOiAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uICRlKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCAxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFmKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGZlKGEyKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0NzY4OwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIGNmKGEyICsgOCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBiZihhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBmMiA9IGVxKDE2KSB8IDA7CiAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gNDc5MjsKICAgICAgICAgIGNbZjIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBYZShhMiwgZTIpOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBjZihiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBnZihiMik7CiAgICAgICAgICBoZihiMiArIDE2NCB8IDApOwogICAgICAgICAgamYoYjIgKyAyNDQgfCAwKTsKICAgICAgICAgIGFbYjIgKyAzMjQgPj4gMF0gPSAwOwogICAgICAgICAgYVtiMiArIDMyNSA+PiAwXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0NzY4OwogICAgICAgICAgb2YoYTIgKyA4IHwgMCk7CiAgICAgICAgICBsZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGRmKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZmYoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIHFmKGEyICsgOCB8IDAsIGNbYTIgKyA0ID4+IDJdIHwgMCwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ2YoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMDsKICAgICAgICAgIGgyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgIGFbYjIgPj4gMF0gPSAwOwogICAgICAgICAgT2MoYjIgKyA0IHwgMCwgNTE2LCAwLCAwKTsKICAgICAgICAgIE9jKGIyICsgNDggfCAwLCA2LCAwLCAwKTsKICAgICAgICAgIGNbYjIgKyA5MiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgOTYgPj4gMl0gPSAwOwogICAgICAgICAgZTIgPSBiMiArIDEwMCB8IDA7CiAgICAgICAgICBtZihlMik7CiAgICAgICAgICBuZihmMik7CiAgICAgICAgICBnMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgZjIgPSBjW2YyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBkMiA9IDQ7CiAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICBpMiA9IGUyOwogICAgICAgICAgICBqMiA9IGkyOwogICAgICAgICAgICBhW2oyID4+IDBdID0gZzI7CiAgICAgICAgICAgIGFbajIgKyAxID4+IDBdID0gZzIgPj4gODsKICAgICAgICAgICAgYVtqMiArIDIgPj4gMF0gPSBnMiA+PiAxNjsKICAgICAgICAgICAgYVtqMiArIDMgPj4gMF0gPSBnMiA+PiAyNDsKICAgICAgICAgICAgaTIgPSBpMiArIDQgfCAwOwogICAgICAgICAgICBhW2kyID4+IDBdID0gZjI7CiAgICAgICAgICAgIGFbaTIgKyAxID4+IDBdID0gZjIgPj4gODsKICAgICAgICAgICAgYVtpMiArIDIgPj4gMF0gPSBmMiA+PiAxNjsKICAgICAgICAgICAgYVtpMiArIDMgPj4gMF0gPSBmMiA+PiAyNDsKICAgICAgICAgICAgZDIgPSBkMiArIC0xIHwgMDsKICAgICAgICAgICAgaWYgKCFkMikKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGUyID0gZTIgKyA4IHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIGoyID0gYjIgKyAxMzIgfCAwOwogICAgICAgICAgY1tqMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2oyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2oyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2oyICsgMTIgPj4gMl0gPSAwOwogICAgICAgICAgY1tqMiArIDE2ID4+IDJdID0gMDsKICAgICAgICAgIGNbajIgKyAyMCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2oyICsgMjQgPj4gMl0gPSAwOwogICAgICAgICAgY1tqMiArIDI4ID4+IDJdID0gMDsKICAgICAgICAgIFYgPSBoMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaGYoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeGUoYTIsIDMyLCA5LCA4LCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gamYoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgbWMoYTIsIDMyLCA5LCA4LCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga2YoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgeWUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsZihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBJYyhhMiArIDQ4IHwgMCk7CiAgICAgICAgICBJYyhhMiArIDQgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbWYoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMDsKICAgICAgICAgIGIyID0gYTIgKyAzMiB8IDA7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIG5mKGEyKTsKICAgICAgICAgICAgYTIgPSBhMiArIDggfCAwOwogICAgICAgICAgfSB3aGlsZSAoKGEyIHwgMCkgIT0gKGIyIHwgMCkpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuZihiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgYzIgPSAwOwogICAgICAgICAgYzIgPSBiMjsKICAgICAgICAgIGFbYzIgPj4gMF0gPSAwOwogICAgICAgICAgYVtjMiArIDEgPj4gMF0gPSAwOwogICAgICAgICAgYVtjMiArIDIgPj4gMF0gPSAwOwogICAgICAgICAgYVtjMiArIDMgPj4gMF0gPSAwOwogICAgICAgICAgYjIgPSBiMiArIDQgfCAwOwogICAgICAgICAgYVtiMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMyA+PiAwXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9mKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHBmKGEyICsgMjQ0IHwgMCk7CiAgICAgICAgICBrZihhMiArIDE2NCB8IDApOwogICAgICAgICAgbGYoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwZihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBxYyhhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHFmKGIyLCBlMiwgZjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIHZhciBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMDsKICAgICAgICAgIGcyID0gYjIgKyAzMjUgfCAwOwogICAgICAgICAgaWYgKCEoYVtnMiA+PiAwXSB8IDApKSB7CiAgICAgICAgICAgIHJmKGIyICsgMjQ0IHwgMCk7CiAgICAgICAgICAgIGFbZzIgPj4gMF0gPSAxOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCEoYVtiMiA+PiAwXSB8IDApKSB7CiAgICAgICAgICAgIGFbYjIgPj4gMF0gPSAxOwogICAgICAgICAgICBFZShEZShlMikgfCAwLCBmMiwgOCk7CiAgICAgICAgICAgIGkyID0gc2YoZjIpIHwgMDsKICAgICAgICAgICAgajIgPSB1KCkgfCAwOwogICAgICAgICAgICBiMiA9IGIyICsgMTAwIHwgMDsKICAgICAgICAgICAgZTIgPSBiMjsKICAgICAgICAgICAgYVtlMiA+PiAwXSA9IGkyOwogICAgICAgICAgICBhW2UyICsgMSA+PiAwXSA9IGkyID4+IDg7CiAgICAgICAgICAgIGFbZTIgKyAyID4+IDBdID0gaTIgPj4gMTY7CiAgICAgICAgICAgIGFbZTIgKyAzID4+IDBdID0gaTIgPj4gMjQ7CiAgICAgICAgICAgIGIyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgYVtiMiA+PiAwXSA9IGoyOwogICAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IGoyID4+IDg7CiAgICAgICAgICAgIGFbYjIgKyAyID4+IDBdID0gajIgPj4gMTY7CiAgICAgICAgICAgIGFbYjIgKyAzID4+IDBdID0gajIgPj4gMjQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBqMiA9IGIyICsgOTIgfCAwOwogICAgICAgICAgICBhOgogICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICBpZiAoIShjW2IyICsgMTMyICsgKGNbajIgPj4gMl0gPDwgMikgPj4gMl0gfCAwKSkgewogICAgICAgICAgICAgICAgICBnMiA9IFpjKGUyLCBiMiArIDQ4IHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICBzd2l0Y2ggKGcyIHwgMCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMTogewogICAgICAgICAgICAgICAgICAgICAgZTIgPSBwYyhiMiArIDI0NCB8IDAsIGUyLCAwLCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTMyICsgKGNbajIgPj4gMl0gPDwgMikgPj4gMl0gPSBlMjsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBrMiA9IGNbYjIgKyAxMzIgKyAoZTIgPDwgMikgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBiMiArIDEwMCArIChlMiA8PCAzKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBoMiA9IGkyOwogICAgICAgICAgICAgICAgICAgICAgZzIgPSBoMjsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gaDIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGsyID0gbHIoCiAgICAgICAgICAgICAgICAgICAgICAgIGRbZzIgPj4gMF0gfCBkW2cyICsgMSA+PiAwXSA8PCA4IHwgZFtnMiArIDIgPj4gMF0gPDwgMTYgfCBkW2cyICsgMyA+PiAwXSA8PCAyNCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICAgIGRbaDIgPj4gMF0gfCBkW2gyICsgMSA+PiAwXSA8PCA4IHwgZFtoMiArIDIgPj4gMF0gPDwgMTYgfCBkW2gyICsgMyA+PiAwXSA8PCAyNCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICAgIGsyIHwgMCwKICAgICAgICAgICAgICAgICAgICAgICAgKChrMiB8IDApIDwgMCkgPDwgMzEgPj4gMzEgfCAwCiAgICAgICAgICAgICAgICAgICAgICApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gdSgpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gaTI7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyID4+IDBdID0gazI7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyICsgMSA+PiAwXSA9IGsyID4+IDg7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyICsgMiA+PiAwXSA9IGsyID4+IDE2OwogICAgICAgICAgICAgICAgICAgICAgYVtnMiArIDMgPj4gMF0gPSBrMiA+PiAyNDsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gaTIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGFbaTIgPj4gMF0gPSBoMjsKICAgICAgICAgICAgICAgICAgICAgIGFbaTIgKyAxID4+IDBdID0gaDIgPj4gODsKICAgICAgICAgICAgICAgICAgICAgIGFbaTIgKyAyID4+IDBdID0gaDIgPj4gMTY7CiAgICAgICAgICAgICAgICAgICAgICBhW2kyICsgMyA+PiAwXSA9IGgyID4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDE0OCArIChlMiA8PCAyKSA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHsKICAgICAgICAgICAgICAgICAgICAgIGsyID0gYjIgKyA5NiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2syID4+IDJdID0gKGNbazIgPj4gMl0gfCAwKSArIDEgJiAzOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBiMiArIDEwMCArIChjW2oyID4+IDJdIDw8IDMpICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpMiA9IHBjKAogICAgICAgICAgICAgICAgICAgICAgICBiMiArIDI0NCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICAgICAgICBkW2kyID4+IDBdIHwgZFtpMiArIDEgPj4gMF0gPDwgOCB8IGRbaTIgKyAyID4+IDBdIDw8IDE2IHwgZFtpMiArIDMgPj4gMF0gPDwgMjQsCiAgICAgICAgICAgICAgICAgICAgICAgIDgKICAgICAgICAgICAgICAgICAgICAgICkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgZzIgPSBiMiArIDEwMCArIChjW2syID4+IDJdIDw8IDMpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICBhW2gyID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgKyAxID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgKyAyID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgKyAzID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gZzIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGFbZzIgPj4gMF0gPSBpMjsKICAgICAgICAgICAgICAgICAgICAgIGFbZzIgKyAxID4+IDBdID0gaTIgPj4gODsKICAgICAgICAgICAgICAgICAgICAgIGFbZzIgKyAyID4+IDBdID0gaTIgPj4gMTY7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyICsgMyA+PiAwXSA9IGkyID4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgZzIgPSB0ZihlMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgazIgPSBjW2syID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gYjIgKyAxMDAgKyAoazIgPDwgMykgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gaTI7CiAgICAgICAgICAgICAgICAgICAgICBpMiA9IGkyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpMiA9IGRbaTIgPj4gMF0gfCBkW2kyICsgMSA+PiAwXSA8PCA4IHwgZFtpMiArIDIgPj4gMF0gPDwgMTYgfCBkW2kyICsgMyA+PiAwXSA8PCAyNDsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gZFtoMiA+PiAwXSB8IGRbaDIgKyAxID4+IDBdIDw8IDggfCBkW2gyICsgMiA+PiAwXSA8PCAxNiB8IGRbaDIgKyAzID4+IDBdIDw8IDI0IHwgZzI7CiAgICAgICAgICAgICAgICAgICAgICBoMiA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgYVtoMiA+PiAwXSA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgYVtoMiArIDEgPj4gMF0gPSBnMiA+PiA4OwogICAgICAgICAgICAgICAgICAgICAgYVtoMiArIDIgPj4gMF0gPSBnMiA+PiAxNjsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgKyAzID4+IDBdID0gZzIgPj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBhW2UyID4+IDBdID0gaTI7CiAgICAgICAgICAgICAgICAgICAgICBhW2UyICsgMSA+PiAwXSA9IGkyID4+IDg7CiAgICAgICAgICAgICAgICAgICAgICBhW2UyICsgMiA+PiAwXSA9IGkyID4+IDE2OwogICAgICAgICAgICAgICAgICAgICAgYVtlMiArIDMgPj4gMF0gPSBpMiA+PiAyNDsKICAgICAgICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyAxMzIgKyAoazIgPDwgMikgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDE0OCArIChjW2oyID4+IDJdIDw8IDIpID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgoZzIgfCAwKSA8PSAyKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgICAgY1tqMiA+PiAyXSA9IGcyICsgMiArIChjW2oyID4+IDJdIHwgMCkgJiAzOwogICAgICAgICAgICAgICAgICAgICAgcWYoYjIsIGUyLCBmMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGkyID0gWmMoZTIsIGIyICsgNCB8IDApIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKChpMiB8IDApID09IDEpIHsKICAgICAgICAgICAgICAgICAgICBnMiA9IHBjKGIyICsgMjQ0IHwgMCwgZTIsIGNbYjIgKyAxMzIgKyAoY1tqMiA+PiAyXSA8PCAyKSA+PiAyXSB8IDAsIDEpIHwgMDsKICAgICAgICAgICAgICAgICAgICBrMiA9IGNbajIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGUyID0gYjIgKyAxMDAgKyAoazIgPDwgMykgfCAwOwogICAgICAgICAgICAgICAgICAgIGkyID0gZTI7CiAgICAgICAgICAgICAgICAgICAgaDIgPSBpMjsKICAgICAgICAgICAgICAgICAgICBpMiA9IGkyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgZzIgPSBscigKICAgICAgICAgICAgICAgICAgICAgIGRbaDIgPj4gMF0gfCBkW2gyICsgMSA+PiAwXSA8PCA4IHwgZFtoMiArIDIgPj4gMF0gPDwgMTYgfCBkW2gyICsgMyA+PiAwXSA8PCAyNCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICBkW2kyID4+IDBdIHwgZFtpMiArIDEgPj4gMF0gPDwgOCB8IGRbaTIgKyAyID4+IDBdIDw8IDE2IHwgZFtpMiArIDMgPj4gMF0gPDwgMjQgfCAwLAogICAgICAgICAgICAgICAgICAgICAgZzIgfCAwLAogICAgICAgICAgICAgICAgICAgICAgKChnMiB8IDApIDwgMCkgPDwgMzEgPj4gMzEgfCAwCiAgICAgICAgICAgICAgICAgICAgKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaTIgPSB1KCkgfCAwOwogICAgICAgICAgICAgICAgICAgIGgyID0gZTI7CiAgICAgICAgICAgICAgICAgICAgYVtoMiA+PiAwXSA9IGcyOwogICAgICAgICAgICAgICAgICAgIGFbaDIgKyAxID4+IDBdID0gZzIgPj4gODsKICAgICAgICAgICAgICAgICAgICBhW2gyICsgMiA+PiAwXSA9IGcyID4+IDE2OwogICAgICAgICAgICAgICAgICAgIGFbaDIgKyAzID4+IDBdID0gZzIgPj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgZTIgPSBlMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgIGFbZTIgPj4gMF0gPSBpMjsKICAgICAgICAgICAgICAgICAgICBhW2UyICsgMSA+PiAwXSA9IGkyID4+IDg7CiAgICAgICAgICAgICAgICAgICAgYVtlMiArIDIgPj4gMF0gPSBpMiA+PiAxNjsKICAgICAgICAgICAgICAgICAgICBhW2UyICsgMyA+PiAwXSA9IGkyID4+IDI0OwogICAgICAgICAgICAgICAgICAgIGNbYjIgKyAxNDggKyAoazIgPDwgMikgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICgoaTIgfCAwKSA+PSA1MTEpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoKGkyIHwgMCkgPT0gNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgICBrMiA9IGIyICsgOTYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1trMiA+PiAyXSA9IChjW2syID4+IDJdIHwgMCkgKyAxICYgMzsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gYjIgKyAxMDAgKyAoY1tqMiA+PiAyXSA8PCAzKSArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBwYygKICAgICAgICAgICAgICAgICAgICAgICAgYjIgKyAyNDQgfCAwLAogICAgICAgICAgICAgICAgICAgICAgICBlMiwKICAgICAgICAgICAgICAgICAgICAgICAgZFtpMiA+PiAwXSB8IGRbaTIgKyAxID4+IDBdIDw8IDggfCBkW2kyICsgMiA+PiAwXSA8PCAxNiB8IGRbaTIgKyAzID4+IDBdIDw8IDI0LAogICAgICAgICAgICAgICAgICAgICAgICA4CiAgICAgICAgICAgICAgICAgICAgICApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gYjIgKyAxMDAgKyAoY1trMiA+PiAyXSA8PCAzKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBoMiA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgYVtoMiA+PiAwXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBhW2gyICsgMSA+PiAwXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBhW2gyICsgMiA+PiAwXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBhW2gyICsgMyA+PiAwXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBnMiA9IGcyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyID4+IDBdID0gaTI7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyICsgMSA+PiAwXSA9IGkyID4+IDg7CiAgICAgICAgICAgICAgICAgICAgICBhW2cyICsgMiA+PiAwXSA9IGkyID4+IDE2OwogICAgICAgICAgICAgICAgICAgICAgYVtnMiArIDMgPj4gMF0gPSBpMiA+PiAyNDsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gdGYoZTIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGsyID0gY1trMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGIyICsgMTAwICsgKGsyIDw8IDMpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICBoMiA9IGkyOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBpMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSBkW2kyID4+IDBdIHwgZFtpMiArIDEgPj4gMF0gPDwgOCB8IGRbaTIgKyAyID4+IDBdIDw8IDE2IHwgZFtpMiArIDMgPj4gMF0gPDwgMjQ7CiAgICAgICAgICAgICAgICAgICAgICBnMiA9IGRbaDIgPj4gMF0gfCBkW2gyICsgMSA+PiAwXSA8PCA4IHwgZFtoMiArIDIgPj4gMF0gPDwgMTYgfCBkW2gyICsgMyA+PiAwXSA8PCAyNCB8IGcyOwogICAgICAgICAgICAgICAgICAgICAgaDIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgPj4gMF0gPSBnMjsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgKyAxID4+IDBdID0gZzIgPj4gODsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgKyAyID4+IDBdID0gZzIgPj4gMTY7CiAgICAgICAgICAgICAgICAgICAgICBhW2gyICsgMyA+PiAwXSA9IGcyID4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgZTIgPSBlMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgYVtlMiA+PiAwXSA9IGkyOwogICAgICAgICAgICAgICAgICAgICAgYVtlMiArIDEgPj4gMF0gPSBpMiA+PiA4OwogICAgICAgICAgICAgICAgICAgICAgYVtlMiArIDIgPj4gMF0gPSBpMiA+PiAxNjsKICAgICAgICAgICAgICAgICAgICAgIGFbZTIgKyAzID4+IDBdID0gaTIgPj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gazI7CiAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTMyICsgKGsyIDw8IDIpID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyAxNDggKyAoY1tqMiA+PiAyXSA8PCAyKSA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKChpMiB8IDApIDw9IDUxMSkKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSAoY1tqMiA+PiAyXSB8IDApICsgaTIgJiAzOwogICAgICAgICAgICAgICAgICAgIHFmKGIyLCBlMiwgZjIpIHwgMDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmICghaTIpIHsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gcGMoYjIgKyAyNDQgfCAwLCBlMiwgMCwgNykgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaDIgPSBiMiArIDE0OCArIChjW2oyID4+IDJdIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAoY1toMiA+PiAyXSB8IDApICsgMTsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYjIgKyAxNDggKyAoaDIgPDwgMikgPj4gMl0gfCAwKSA+IDMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDEzMiArIChoMiA8PCAyKSA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTQ4ICsgKGNbajIgPj4gMl0gPDwgMikgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkyIHwgMCkgPCA1MDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgZzIgPSBiMiArIDI0NCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gcShjW2IyICsgMTMyICsgKGNbajIgPj4gMl0gPDwgMikgPj4gMl0gfCAwLCBpMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkyIHwgMCkgPCAxMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gcGMoZzIsIGUyLCBoMiwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gcGMoZzIsIGUyLCBoMiwgMykgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkyIHwgMCkgPT0gNTAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gcGMoCiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgKyAyNDQgfCAwLAogICAgICAgICAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICAgICAgICAgIChjW2IyICsgMTMyICsgKGNbajIgPj4gMl0gPDwgMikgPj4gMl0gfCAwKSAqIDUwMCB8IDAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgNAogICAgICAgICAgICAgICAgICAgICAgICApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBiMiArIDE0OCArIChjW2oyID4+IDJdIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IChjW2gyID4+IDJdIHwgMCkgKyAxOwogICAgICAgICAgICAgICAgICAgICAgICBoMiA9IGNbajIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYjIgKyAxNDggKyAoaDIgPDwgMikgPj4gMl0gfCAwKSA8PSAzKQogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTMyICsgKGgyIDw8IDIpID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyAxNDggKyAoY1tqMiA+PiAyXSA8PCAyKSA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZzIgPSA1MDAgLSBpMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBoMiA9IGIyICsgMjQ0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gY1tiMiArIDEzMiArIChjW2oyID4+IDJdIDw8IDIpID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmICgoZzIgfCAwKSA+IC0xMCkgewogICAgICAgICAgICAgICAgICAgICAgICBnMiA9IHBjKGgyLCBlMiwgcShpMiwgZzIpIHwgMCwgNSkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGcyID0gcGMoaDIsIGUyLCBxKGkyLCAtMTApIHwgMCwgNikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaDIgPSBiMiArIDE0OCArIChjW2oyID4+IDJdIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAoY1toMiA+PiAyXSB8IDApICsgMTsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYjIgKyAxNDggKyAoaDIgPDwgMikgPj4gMl0gfCAwKSA+IDMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDEzMiArIChoMiA8PCAyKSA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTQ4ICsgKGNbajIgPj4gMl0gPDwgMikgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICBrMiA9IGIyICsgMTAwICsgKGNbajIgPj4gMl0gPDwgMykgfCAwOwogICAgICAgICAgICAgICAgICBoMiA9IGsyOwogICAgICAgICAgICAgICAgICBlMiA9IGgyOwogICAgICAgICAgICAgICAgICBoMiA9IGgyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgIGgyID0gbHIoCiAgICAgICAgICAgICAgICAgICAgZFtlMiA+PiAwXSB8IGRbZTIgKyAxID4+IDBdIDw8IDggfCBkW2UyICsgMiA+PiAwXSA8PCAxNiB8IGRbZTIgKyAzID4+IDBdIDw8IDI0IHwgMCwKICAgICAgICAgICAgICAgICAgICBkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCB8IGRbaDIgKyAyID4+IDBdIDw8IDE2IHwgZFtoMiArIDMgPj4gMF0gPDwgMjQgfCAwLAogICAgICAgICAgICAgICAgICAgIGcyIHwgMCwKICAgICAgICAgICAgICAgICAgICAoKGcyIHwgMCkgPCAwKSA8PCAzMSA+PiAzMSB8IDAKICAgICAgICAgICAgICAgICAgKSB8IDA7CiAgICAgICAgICAgICAgICAgIGUyID0gdSgpIHwgMDsKICAgICAgICAgICAgICAgICAgaTIgPSBrMjsKICAgICAgICAgICAgICAgICAgYVtpMiA+PiAwXSA9IGgyOwogICAgICAgICAgICAgICAgICBhW2kyICsgMSA+PiAwXSA9IGgyID4+IDg7CiAgICAgICAgICAgICAgICAgIGFbaTIgKyAyID4+IDBdID0gaDIgPj4gMTY7CiAgICAgICAgICAgICAgICAgIGFbaTIgKyAzID4+IDBdID0gaDIgPj4gMjQ7CiAgICAgICAgICAgICAgICAgIGsyID0gazIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgYVtrMiA+PiAwXSA9IGUyOwogICAgICAgICAgICAgICAgICBhW2syICsgMSA+PiAwXSA9IGUyID4+IDg7CiAgICAgICAgICAgICAgICAgIGFbazIgKyAyID4+IDBdID0gZTIgPj4gMTY7CiAgICAgICAgICAgICAgICAgIGFbazIgKyAzID4+IDBdID0gZTIgPj4gMjQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICB1ZihiMiArIDEwMCArIChjW2oyID4+IDJdIDw8IDMpIHwgMCwgZjIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGYyICsgOCB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIG9jKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc2YoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICBlMiA9IFJlKGEyKSB8IDA7CiAgICAgICAgICB2ZihkMiwgZTIsIFJlKGEyICsgNCB8IDApIHwgMCk7CiAgICAgICAgICBhMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgdChjW2QyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdGYoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMDsKICAgICAgICAgIGIyID0gKGJkKGEyKSB8IDApICYgNjU1MzU7CiAgICAgICAgICByZXR1cm4gKChiZChhMikgfCAwKSAmIDY1NTM1KSA8PCAxNiB8IGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWYoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGMyID0gMDsKICAgICAgICAgIGMyID0gYTI7CiAgICAgICAgICBXZShkW2MyID4+IDBdIHwgZFtjMiArIDEgPj4gMF0gPDwgOCB8IGRbYzIgKyAyID4+IDBdIDw8IDE2IHwgZFtjMiArIDMgPj4gMF0gPDwgMjQsIGIyKTsKICAgICAgICAgIGEyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIFdlKAogICAgICAgICAgICBkW2EyID4+IDBdIHwgZFthMiArIDEgPj4gMF0gPDwgOCB8IGRbYTIgKyAyID4+IDBdIDw8IDE2IHwgZFthMiArIDMgPj4gMF0gPDwgMjQsCiAgICAgICAgICAgIGIyICsgNCB8IDAKICAgICAgICAgICk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZmKGIyLCBjMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDA7CiAgICAgICAgICBlMiA9IGIyOwogICAgICAgICAgYVtlMiA+PiAwXSA9IGMyOwogICAgICAgICAgYVtlMiArIDEgPj4gMF0gPSBjMiA+PiA4OwogICAgICAgICAgYVtlMiArIDIgPj4gMF0gPSBjMiA+PiAxNjsKICAgICAgICAgIGFbZTIgKyAzID4+IDBdID0gYzIgPj4gMjQ7CiAgICAgICAgICBjMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBhW2MyID4+IDBdID0gZDI7CiAgICAgICAgICBhW2MyICsgMSA+PiAwXSA9IGQyID4+IDg7CiAgICAgICAgICBhW2MyICsgMiA+PiAwXSA9IGQyID4+IDE2OwogICAgICAgICAgYVtjMiArIDMgPj4gMF0gPSBkMiA+PiAyNDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gd2YoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4ZihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHlmKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gOTg5MCA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6ZihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBBZihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBmZShhMik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDgyMDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBDZihhMiArIDggfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQmYoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQ4NDQ7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgWGUoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQ2YoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYVtiMiA+PiAwXSA9IDA7CiAgICAgICAgICBHZihiMiArIDEgfCAwKTsKICAgICAgICAgIE9jKGIyICsgOCB8IDAsIDEyOCwgMCwgMCk7CiAgICAgICAgICBPYyhiMiArIDUyIHwgMCwgMjU2LCAwLCAwKTsKICAgICAgICAgIE9jKGIyICsgOTYgfCAwLCAyNTYsIDAsIDApOwogICAgICAgICAgT2MoYjIgKyAxNDAgfCAwLCAyNTYsIDAsIDApOwogICAgICAgICAgT2MoYjIgKyAxODQgfCAwLCAyNTYsIDAsIDApOwogICAgICAgICAgT2MoYjIgKyAyMjggfCAwLCAyNTYsIDAsIDApOwogICAgICAgICAgT2MoYjIgKyAyNzIgfCAwLCAyNTYsIDAsIDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEZihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDgyMDsKICAgICAgICAgIEhmKGEyICsgOCB8IDApOwogICAgICAgICAgbGUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFZihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEZihhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEZmKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiBJZihhMiArIDggfCAwLCBjW2EyICsgNCA+PiAyXSB8IDAsIGIyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdmKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBjMiA9IDA7CiAgICAgICAgICBhW2IyID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gMDsKICAgICAgICAgIGMyID0gYjIgKyAyIHwgMDsKICAgICAgICAgIGFbYzIgPj4gMF0gPSAwOwogICAgICAgICAgYVtjMiArIDEgPj4gMF0gPSAwOwogICAgICAgICAgYjIgPSBiMiArIDQgfCAwOwogICAgICAgICAgYVtiMiA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIEljKGEyICsgMjcyIHwgMCk7CiAgICAgICAgICBJYyhhMiArIDIyOCB8IDApOwogICAgICAgICAgSWMoYTIgKyAxODQgfCAwKTsKICAgICAgICAgIEljKGEyICsgMTQwIHwgMCk7CiAgICAgICAgICBJYyhhMiArIDk2IHwgMCk7CiAgICAgICAgICBJYyhhMiArIDUyIHwgMCk7CiAgICAgICAgICBJYyhhMiArIDggfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSWYoYzIsIGYyLCBnMikgewogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgdmFyIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwLCBwMiA9IDA7CiAgICAgICAgICBvMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIG0yID0gbzI7CiAgICAgICAgICBpZiAoIShhW2MyID4+IDBdIHwgMCkpIHsKICAgICAgICAgICAgYVtjMiA+PiAwXSA9IDE7CiAgICAgICAgICAgIEVlKERlKGYyKSB8IDAsIGcyLCA2KTsKICAgICAgICAgICAgSmYobTIsIGcyKTsKICAgICAgICAgICAgbjIgPSBjMiArIDEgfCAwOwogICAgICAgICAgICBhW24yID4+IDBdID0gYVttMiA+PiAwXSB8IDA7CiAgICAgICAgICAgIGFbbjIgKyAxID4+IDBdID0gYVttMiArIDEgPj4gMF0gfCAwOwogICAgICAgICAgICBhW24yICsgMiA+PiAwXSA9IGFbbTIgKyAyID4+IDBdIHwgMDsKICAgICAgICAgICAgYVtuMiArIDMgPj4gMF0gPSBhW20yICsgMyA+PiAwXSB8IDA7CiAgICAgICAgICAgIGFbbjIgKyA0ID4+IDBdID0gYVttMiArIDQgPj4gMF0gfCAwOwogICAgICAgICAgICBhW24yICsgNSA+PiAwXSA9IGFbbTIgKyA1ID4+IDBdIHwgMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG4yID0gWmMoZjIsIGMyICsgOCB8IDApIHwgMDsKICAgICAgICAgICAgR2YobTIpOwogICAgICAgICAgICBpZiAoIShuMiAmIDEpKSB7CiAgICAgICAgICAgICAgaDIgPSBjMiArIDEgfCAwOwogICAgICAgICAgICAgIGgyID0gKGRbaDIgPj4gMF0gfCBkW2gyICsgMSA+PiAwXSA8PCA4KSAmIDI1NTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBsMiA9IChaYyhmMiwgYzIgKyA1MiB8IDApIHwgMCkgJiAyNTU7CiAgICAgICAgICAgICAgaDIgPSBjMiArIDEgfCAwOwogICAgICAgICAgICAgIGgyID0gKEllKGwyICsgKChkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCkgJiAyNTUpIHwgMCkgfCAwKSAmIDI1NTsKICAgICAgICAgICAgfQogICAgICAgICAgICBiW20yID4+IDFdID0gaDI7CiAgICAgICAgICAgIGlmICghKG4yICYgMikpIHsKICAgICAgICAgICAgICBsMiA9IGMyICsgMSB8IDA7CiAgICAgICAgICAgICAgaDIgPSBoMiB8IChkW2wyID4+IDBdIHwgZFtsMiArIDEgPj4gMF0gPDwgOCkgJiAtMjU2OwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGgyID0gKFpjKGYyLCBjMiArIDk2IHwgMCkgfCAwKSAmIDI1NTsKICAgICAgICAgICAgICBsMiA9IGMyICsgMSB8IDA7CiAgICAgICAgICAgICAgaDIgPSAoKEllKCgoKGRbbDIgPj4gMF0gfCBkW2wyICsgMSA+PiAwXSA8PCA4KSAmIDY1NTM1KSA+Pj4gOCkgKyBoMiB8IDApIHwgMCkgJiAyNTUpIDw8IDg7CiAgICAgICAgICAgICAgaDIgPSAoaDIgfCBlW20yID4+IDFdKSAmIDY1NTM1OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJbbTIgPj4gMV0gPSBoMjsKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAobjIgJiA2NCkgewogICAgICAgICAgICAgICAgazIgPSBjMiArIDEgfCAwOwogICAgICAgICAgICAgICAgaTIgPSAoaDIgJiAyNTUpIC0gKChkW2syID4+IDBdIHwgZFtrMiArIDEgPj4gMF0gPDwgOCkgJiAyNTUpIHwgMDsKICAgICAgICAgICAgICAgIGlmICghKG4yICYgNCkpIHsKICAgICAgICAgICAgICAgICAgaDIgPSBjMiArIDMgfCAwOwogICAgICAgICAgICAgICAgICBoMiA9IChkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCkgJiAyNTU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBoMiA9IChaYyhmMiwgYzIgKyAxNDAgfCAwKSB8IDApICYgMjU1OwogICAgICAgICAgICAgICAgICBsMiA9IGMyICsgMyB8IDA7CiAgICAgICAgICAgICAgICAgIGwyID0gaTIgKyAoKGRbbDIgPj4gMF0gfCBkW2wyICsgMSA+PiAwXSA8PCA4KSAmIDI1NSkgfCAwOwogICAgICAgICAgICAgICAgICBoMiA9IChJZSgoKGwyIHwgMCkgPCAxID8gMCA6IChsMiB8IDApID4gMjU0ID8gMjU1IDogbDIgJiAyNTUpICsgaDIgfCAwKSB8IDApICYgMjU1OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbDIgPSBtMiArIDIgfCAwOwogICAgICAgICAgICAgICAgYltsMiA+PiAxXSA9IGgyOwogICAgICAgICAgICAgICAgaWYgKCEobjIgJiAxNikpIHsKICAgICAgICAgICAgICAgICAgaDIgPSBjMiArIDUgfCAwOwogICAgICAgICAgICAgICAgICBoMiA9IChkW2gyID4+IDBdIHwgZFtoMiArIDEgPj4gMF0gPDwgOCkgJiAyNTU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBoMiA9IFpjKGYyLCBjMiArIDIyOCB8IDApIHwgMDsKICAgICAgICAgICAgICAgICAgcDIgPSBjMiArIDMgfCAwOwogICAgICAgICAgICAgICAgICBqMiA9IGMyICsgNSB8IDA7CiAgICAgICAgICAgICAgICAgIGoyID0gKChpMiArIChiW2wyID4+IDFdICYgMjU1KSAtICgoZFtwMiA+PiAwXSB8IGRbcDIgKyAxID4+IDBdIDw8IDgpICYgMjU1KSB8IDApIC8gMiB8IDApICsgKChkW2oyID4+IDBdIHwgZFtqMiArIDEgPj4gMF0gPDwgOCkgJiAyNTUpIHwgMDsKICAgICAgICAgICAgICAgICAgaDIgPSAoSWUoKChqMiB8IDApIDwgMSA/IDAgOiAoajIgfCAwKSA+IDI1NCA/IDI1NSA6IGoyICYgMjU1KSArIChoMiAmIDI1NSkgfCAwKSB8IDApICYgMjU1OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgajIgPSBtMiArIDQgfCAwOwogICAgICAgICAgICAgICAgYltqMiA+PiAxXSA9IGgyOwogICAgICAgICAgICAgICAgaDIgPSAoKGVbbTIgPj4gMV0gfCAwKSA+Pj4gOCkgLSAoKChkW2syID4+IDBdIHwgZFtrMiArIDEgPj4gMF0gPDwgOCkgJiA2NTUzNSkgPj4+IDgpIHwgMDsKICAgICAgICAgICAgICAgIGlmICghKG4yICYgOCkpIHsKICAgICAgICAgICAgICAgICAgaTIgPSBjMiArIDMgfCAwOwogICAgICAgICAgICAgICAgICBpMiA9IGJbbDIgPj4gMV0gfCAoZFtpMiA+PiAwXSB8IGRbaTIgKyAxID4+IDBdIDw8IDgpICYgLTI1NjsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGkyID0gKFpjKGYyLCBjMiArIDE4NCB8IDApIHwgMCkgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHAyID0gYzIgKyAzIHwgMDsKICAgICAgICAgICAgICAgICAgcDIgPSAoKChkW3AyID4+IDBdIHwgZFtwMiArIDEgPj4gMF0gPDwgOCkgJiA2NTUzNSkgPj4+IDgpICsgaDIgfCAwOwogICAgICAgICAgICAgICAgICBpMiA9ICgoSWUoKChwMiB8IDApIDwgMSA/IDAgOiAocDIgfCAwKSA+IDI1NCA/IDI1NSA6IHAyICYgMjU1KSArIGkyIHwgMCkgfCAwKSAmIDI1NSkgPDwgODsKICAgICAgICAgICAgICAgICAgaTIgPSAoaTIgfCBlW2wyID4+IDFdKSAmIDY1NTM1OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYltsMiA+PiAxXSA9IGkyOwogICAgICAgICAgICAgICAgaWYgKCEobjIgJiAzMikpIHsKICAgICAgICAgICAgICAgICAgcDIgPSBjMiArIDUgfCAwOwogICAgICAgICAgICAgICAgICBiW2oyID4+IDFdID0gYltqMiA+PiAxXSB8IChkW3AyID4+IDBdIHwgZFtwMiArIDEgPj4gMF0gPDwgOCkgJiAtMjU2OwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHAyID0gWmMoZjIsIGMyICsgMjcyIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICBmMiA9IGMyICsgMyB8IDA7CiAgICAgICAgICAgICAgICAgIG4yID0gYzIgKyA1IHwgMDsKICAgICAgICAgICAgICAgICAgbjIgPSAoKCgoZVtsMiA+PiAxXSB8IDApID4+PiA4KSArIGgyIC0gKCgoZFtmMiA+PiAwXSB8IGRbZjIgKyAxID4+IDBdIDw8IDgpICYgNjU1MzUpID4+PiA4KSB8IDApIC8gMiB8IDApICsgKCgoZFtuMiA+PiAwXSB8IGRbbjIgKyAxID4+IDBdIDw8IDgpICYgNjU1MzUpID4+PiA4KSB8IDA7CiAgICAgICAgICAgICAgICAgIHAyID0gKChJZSgoKG4yIHwgMCkgPCAxID8gMCA6IChuMiB8IDApID4gMjU0ID8gMjU1IDogbjIgJiAyNTUpICsgKHAyICYgMjU1KSB8IDApIHwgMCkgJiAyNTUpIDw8IDg7CiAgICAgICAgICAgICAgICAgIGJbajIgPj4gMV0gPSBwMiB8IGVbajIgPj4gMV07CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBiW20yICsgMiA+PiAxXSA9IGgyOwogICAgICAgICAgICAgICAgYlttMiArIDQgPj4gMV0gPSBoMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgcDIgPSBjMiArIDEgfCAwOwogICAgICAgICAgICBhW3AyID4+IDBdID0gYVttMiA+PiAwXSB8IDA7CiAgICAgICAgICAgIGFbcDIgKyAxID4+IDBdID0gYVttMiArIDEgPj4gMF0gfCAwOwogICAgICAgICAgICBhW3AyICsgMiA+PiAwXSA9IGFbbTIgKyAyID4+IDBdIHwgMDsKICAgICAgICAgICAgYVtwMiArIDMgPj4gMF0gPSBhW20yICsgMyA+PiAwXSB8IDA7CiAgICAgICAgICAgIGFbcDIgKyA0ID4+IDBdID0gYVttMiArIDQgPj4gMF0gfCAwOwogICAgICAgICAgICBhW3AyICsgNSA+PiAwXSA9IGFbbTIgKyA1ID4+IDBdIHwgMDsKICAgICAgICAgICAgS2YocDIsIGcyKTsKICAgICAgICAgIH0KICAgICAgICAgIFYgPSBvMjsKICAgICAgICAgIHJldHVybiBnMiArIDYgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKZihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgYzIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBkMiA9IE9lKGIyKSB8IDA7CiAgICAgICAgICBjMiA9IE9lKGIyICsgMiB8IDApIHwgMDsKICAgICAgICAgIExmKGEyLCBkMiwgYzIsIE9lKGIyICsgNCB8IDApIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtmKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBjMiA9IDA7CiAgICAgICAgICBUZShkW2EyID4+IDBdIHwgZFthMiArIDEgPj4gMF0gPDwgOCwgYjIpOwogICAgICAgICAgYzIgPSBhMiArIDIgfCAwOwogICAgICAgICAgVGUoZFtjMiA+PiAwXSB8IGRbYzIgKyAxID4+IDBdIDw8IDgsIGIyICsgMiB8IDApOwogICAgICAgICAgYTIgPSBhMiArIDQgfCAwOwogICAgICAgICAgVGUoZFthMiA+PiAwXSB8IGRbYTIgKyAxID4+IDBdIDw8IDgsIGIyICsgNCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMZihiMiwgYzIsIGQyLCBlMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBhW2IyID4+IDBdID0gYzI7CiAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IGMyID4+IDg7CiAgICAgICAgICBjMiA9IGIyICsgMiB8IDA7CiAgICAgICAgICBhW2MyID4+IDBdID0gZDI7CiAgICAgICAgICBhW2MyICsgMSA+PiAwXSA9IGQyID4+IDg7CiAgICAgICAgICBkMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBhW2QyID4+IDBdID0gZTI7CiAgICAgICAgICBhW2QyICsgMSA+PiAwXSA9IGUyID4+IDg7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE1mKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHBxKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTmYoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSBjW2EyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCkKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgNCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBPZihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDEwNTcwID8gYTIgKyAxMiB8IDAgOiAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCAxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFmKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGZlKGEyKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0ODcyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFNmKGEyICsgOCB8IDAsIGQyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUmYoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQ4OTY7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgWGUoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2YoYjIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBhW2IyICsgNCA+PiAwXSA9IGFbZDIgKyA0ID4+IDBdIHwgMDsKICAgICAgICAgIFdmKGIyICsgOCB8IDAsIGQyICsgOCB8IDApOwogICAgICAgICAgV2YoYjIgKyAyMCB8IDAsIGQyICsgMjAgfCAwKTsKICAgICAgICAgIFhmKGIyICsgMzIgfCAwLCBkMiArIDMyIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0ODcyOwogICAgICAgICAgdWQoYTIgKyA4IHwgMCk7CiAgICAgICAgICBsZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFVmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIFRmKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVmYoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIERnKGEyICsgOCB8IDAsIGNbYTIgKyA0ID4+IDJdIHwgMCwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2YoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBkMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBlMiA9IChjW2QyID4+IDJdIHwgMCkgLSAoY1tiMiA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgIGlmIChlMiB8IDApIHsKICAgICAgICAgICAgWWYoYTIsIGUyKTsKICAgICAgICAgICAgWmYoYTIsIGNbYjIgPj4gMl0gfCAwLCBjW2QyID4+IDJdIHwgMCwgZTIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBYZihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gZDIgKyAyNCB8IDA7CiAgICAgICAgICBmMiA9IGQyICsgMTYgfCAwOwogICAgICAgICAgaDIgPSBkMiArIDggfCAwOwogICAgICAgICAgZzIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDEyID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgMjAgPj4gMl0gPSAwOwogICAgICAgICAgemcoaDIsIGIyKTsKICAgICAgICAgIEFnKGcyLCBiMik7CiAgICAgICAgICBjW2YyID4+IDJdID0gY1toMiA+PiAyXTsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gY1toMiArIDQgPj4gMl07CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tnMiA+PiAyXTsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gY1tnMiArIDQgPj4gMl07CiAgICAgICAgICBjZyhhMiwgZjIsIGUyLCAwKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWWYoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMDsKICAgICAgICAgIGlmICgoJGYoYTIpIHwgMCkgPj4+IDAgPCBiMiA+Pj4gMCkKICAgICAgICAgICAgY3IoYTIpOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGQyID0gZXEoYjIpIHwgMDsKICAgICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgICAgY1thMiA+PiAyXSA9IGQyOwogICAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGQyICsgYjI7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWmYoYTIsIGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZzIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBmMiA9IGcyOwogICAgICAgICAgYWcoZjIsIGEyLCBlMik7CiAgICAgICAgICBlMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICBhMiA9IGQyIC0gYjIgfCAwOwogICAgICAgICAgaWYgKChhMiB8IDApID4gMCkgewogICAgICAgICAgICB1cihjW2UyID4+IDJdIHwgMCwgYjIgfCAwLCBhMiB8IDApIHwgMDsKICAgICAgICAgICAgY1tlMiA+PiAyXSA9IChjW2UyID4+IDJdIHwgMCkgKyBhMjsKICAgICAgICAgIH0KICAgICAgICAgIGJnKGYyKTsKICAgICAgICAgIFYgPSBnMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX2YoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICBpZiAoYjIgfCAwKSB7CiAgICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICAgIERhKGIyLCAoY1thMiArIDggPj4gMl0gfCAwKSAtIGQyIHwgMCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uICRmKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAyMTQ3NDgzNjQ3OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBhZyhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBiMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGIyICsgZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGJnKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbKGNbYTIgPj4gMl0gfCAwKSArIDQgPj4gMl0gPSBjW2EyICsgNCA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2coYTIsIGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMCwgcDIgPSAwLCBxMiA9IDA7CiAgICAgICAgICBxMiA9IFY7CiAgICAgICAgICBWID0gViArIDk2IHwgMDsKICAgICAgICAgIHAyID0gcTIgKyA4MCB8IDA7CiAgICAgICAgICBtMiA9IHEyICsgNjQgfCAwOwogICAgICAgICAgajIgPSBxMiArIDQ4IHwgMDsKICAgICAgICAgIGsyID0gcTIgKyA0MCB8IDA7CiAgICAgICAgICBsMiA9IHEyICsgOCB8IDA7CiAgICAgICAgICBpMiA9IHEyOwogICAgICAgICAgbjIgPSBxMiArIDMyIHwgMDsKICAgICAgICAgIG8yID0gcTIgKyAxNiB8IDA7CiAgICAgICAgICBoMiA9IGIyOwogICAgICAgICAgZzIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgIGgyID0gY1toMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZjIgPSBkMjsKICAgICAgICAgIGQyID0gY1tmMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IGNbZjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGUyID0gZzI7CiAgICAgICAgICBpZiAoKGYyIHwgMCkgPT0gKGgyIHwgMCkpCiAgICAgICAgICAgIGgyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgaDIgPSAoKGYyIC0gKGNbZDIgPj4gMl0gfCAwKSB8IDApIC8gNDQgfCAwKSArICgoZDIgLSBnMiA+PiAyKSAqIDkzIHwgMCkgKyAoKGgyIC0gKGNbZzIgPj4gMl0gfCAwKSB8IDApIC8gLTQ0IHwgMCkgfCAwOwogICAgICAgICAgZDIgPSAoY1thMiArIDggPj4gMl0gfCAwKSAtIChjW2EyICsgNCA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgIGQyID0gKChkMiB8IDApID09IDAgPyAwIDogKChkMiA+PiAyKSAqIDkzIHwgMCkgKyAtMSB8IDApIC0gKChjW2EyICsgMjAgPj4gMl0gfCAwKSArIChjW2EyICsgMTYgPj4gMl0gfCAwKSkgfCAwOwogICAgICAgICAgaWYgKGgyID4+PiAwID4gZDIgPj4+IDApCiAgICAgICAgICAgIGVnKGEyLCBoMiAtIGQyIHwgMCk7CiAgICAgICAgICBmZyhrMiwgYTIpOwogICAgICAgICAgZmcoaTIsIGEyKTsKICAgICAgICAgIGYyID0gaTI7CiAgICAgICAgICBkMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgZjIgPSBjW2YyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBnMiA9IGwyOwogICAgICAgICAgY1tnMiA+PiAyXSA9IGQyOwogICAgICAgICAgY1tnMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgIGcyID0gZDI7CiAgICAgICAgICBpZiAoaDIgfCAwKSB7CiAgICAgICAgICAgIGQyID0gKChmMiAtIChjW2QyID4+IDJdIHwgMCkgfCAwKSAvIDQ0IHwgMCkgKyBoMiB8IDA7CiAgICAgICAgICAgIGlmICgoZDIgfCAwKSA+IDApIHsKICAgICAgICAgICAgICBpMiA9IChkMiA+Pj4gMCkgLyA5MyB8IDA7CiAgICAgICAgICAgICAgaDIgPSBnMiArIChpMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGgyOwogICAgICAgICAgICAgIGQyID0gKGNbaDIgPj4gMl0gfCAwKSArICgoZDIgLSAoaTIgKiA5MyB8IDApIHwgMCkgKiA0NCB8IDApIHwgMDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBkMiA9IDkyIC0gZDIgfCAwOwogICAgICAgICAgICAgIGkyID0gZzIgKyAoKChkMiB8IDApIC8gLTkzIHwgMCkgPDwgMikgfCAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBpMjsKICAgICAgICAgICAgICBkMiA9IChjW2kyID4+IDJdIHwgMCkgKyAoKDkyIC0gKChkMiB8IDApICUgOTMgfCAwKSB8IDApICogNDQgfCAwKSB8IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY1tsMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIH0KICAgICAgICAgIGNbbTIgPj4gMl0gPSBjW2syID4+IDJdOwogICAgICAgICAgY1ttMiArIDQgPj4gMl0gPSBjW2syICsgNCA+PiAyXTsKICAgICAgICAgIGNbcDIgPj4gMl0gPSBjW2wyID4+IDJdOwogICAgICAgICAgY1twMiArIDQgPj4gMl0gPSBjW2wyICsgNCA+PiAyXTsKICAgICAgICAgIGdnKGoyLCBtMiwgcDIpOwogICAgICAgICAgaGcocDIsIGoyKTsKICAgICAgICAgIGlnKG0yLCBqMik7CiAgICAgICAgICBpZiAoamcocDIsIG0yKSB8IDApIHsKICAgICAgICAgICAgZzIgPSBvMiArIDQgfCAwOwogICAgICAgICAgICBoMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBrZyhuMiwgcDIpOwogICAgICAgICAgICAgIGxnKG8yLCBhMiwgbjIpOwogICAgICAgICAgICAgIGQyID0gY1tvMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgaWYgKChkMiB8IDApICE9IChjW2cyID4+IDJdIHwgMCkpIHsKICAgICAgICAgICAgICAgIGYyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgIFdjKGQyLCBmMik7CiAgICAgICAgICAgICAgICAgIGQyID0gKGNbbzIgPj4gMl0gfCAwKSArIDQ0IHwgMDsKICAgICAgICAgICAgICAgICAgY1tvMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICBmMiA9IGYyICsgNDQgfCAwOwogICAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICAgIGlmICgoZjIgLSAoY1tlMiA+PiAyXSB8IDApIHwgMCkgPT0gNDA5MikgewogICAgICAgICAgICAgICAgICAgIGUyID0gZTIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgZjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gd2hpbGUgKChkMiB8IDApICE9IChjW2cyID4+IDJdIHwgMCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBtZyhvMik7CiAgICAgICAgICAgICAgbmcocDIpIHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoamcocDIsIG0yKSB8IDApOwogICAgICAgICAgfQogICAgICAgICAgViA9IHEyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBhMiArIDggfCAwOwogICAgICAgICAgZTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoZTIgfCAwKSAhPSAoYjIgfCAwKSkKICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGUyICsgKH4oKGUyICsgLTQgLSBiMiB8IDApID4+PiAyKSA8PCAyKTsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKQogICAgICAgICAgICBEYShiMiwgKGNbYTIgKyAxMiA+PiAyXSB8IDApIC0gYjIgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZWcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcjIgPSAwLCBzMiA9IDAsIHQyID0gMCwgdTIgPSAwLCB2MiA9IDAsIHcyID0gMCwgeDIgPSAwLCB5MiA9IDAsIHoyID0gMCwgQTIgPSAwLCBCMiA9IDAsIEMyID0gMDsKICAgICAgICAgIEIyID0gVjsKICAgICAgICAgIFYgPSBWICsgNjQgfCAwOwogICAgICAgICAgdjIgPSBCMiArIDUyIHwgMDsKICAgICAgICAgIHUyID0gQjIgKyA0OCB8IDA7CiAgICAgICAgICB3MiA9IEIyICsgMjggfCAwOwogICAgICAgICAgeDIgPSBCMiArIDI0IHwgMDsKICAgICAgICAgIHkyID0gQjIgKyAyMCB8IDA7CiAgICAgICAgICBwMiA9IEIyOwogICAgICAgICAgejIgPSBhMiArIDggfCAwOwogICAgICAgICAgZDIgPSBjW3oyID4+IDJdIHwgMDsKICAgICAgICAgIEEyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGoyID0gY1tBMiA+PiAyXSB8IDA7CiAgICAgICAgICBzMiA9ICgoZDIgfCAwKSA9PSAoajIgfCAwKSAmIDEpICsgYjIgfCAwOwogICAgICAgICAgaDIgPSAoczIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgaDIgPSBoMiArICgoczIgLSAoaDIgKiA5MyB8IDApIHwgMCkgIT0gMCAmIDEpIHwgMDsKICAgICAgICAgIHMyID0gYTIgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGNbczIgPj4gMl0gfCAwOwogICAgICAgICAgaTIgPSAoZTIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgcjIgPSBoMiA+Pj4gMCA8IGkyID4+PiAwID8gaDIgOiBpMjsKICAgICAgICAgIGIyID0gaDIgLSByMiB8IDA7CiAgICAgICAgICBnMiA9IGQyOwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoIWIyKSB7CiAgICAgICAgICAgICAgICBjW3MyID4+IDJdID0gKHEocjIsIC05MykgfCAwKSArIGUyOwogICAgICAgICAgICAgICAgaWYgKHIyIHwgMCkgewogICAgICAgICAgICAgICAgICBpMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgICBrMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgICBsMiA9IHcyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgIG0yID0gdzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgbjIgPSB3MiArIDEyIHwgMDsKICAgICAgICAgICAgICAgICAgYjIgPSByMjsKICAgICAgICAgICAgICAgICAgZTIgPSBqMjsKICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICBoMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGcyID0gZTIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICBjW0EyID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICAgICAgdDIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBlMiA9IHQyOwogICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGQyIHwgMCkgPT0gKHQyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSB0MjsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcyID4+PiAwIDw9IHQyID4+PiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBlMiAtIGQyIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IChkMiB8IDApID09IDAgPyAxIDogZDIgPj4gMTsKICAgICAgICAgICAgICAgICAgICAgICAgICBxZyh3MiwgZDIsIGQyID4+PiAyLCBrMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t4MiA+PiAyXSA9IGNbQTIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t5MiA+PiAyXSA9IGNbejIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t1MiA+PiAyXSA9IGNbeDIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t2MiA+PiAyXSA9IGNbeTIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgdWcodzIsIHUyLCB2Mik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gY1t3MiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW3cyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBjW0EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW0EyID4+IDJdID0gY1tsMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBjW3oyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW3oyID4+IDJdID0gY1ttMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW20yID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2kyID4+IDJdID0gY1tuMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW24yID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdGcodzIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1t6MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBnMjsKICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSAoKHQyIC0gZDIgPj4gMikgKyAxIHwgMCkgLyAtMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gZzIgKyAoZDIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGUyIC0gdDIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUyKQogICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gZjI7CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZyKGYyIHwgMCwgZzIgfCAwLCBlMiB8IDApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IChjW0EyID4+IDJdIHwgMCkgKyAoZDIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gZjIgKyAoZTIgPj4gMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbejIgPj4gMl0gPSB0MjsKICAgICAgICAgICAgICAgICAgICAgICAgY1tBMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICBkMiA9IHQyOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gaDI7CiAgICAgICAgICAgICAgICAgICAgZDIgPSAoY1t6MiA+PiAyXSB8IDApICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1t6MiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgIGIyID0gYjIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFiMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgZTIgPSBjW0EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0MiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgZTIgPSBjW3QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGYyID0gZTIgLSAoY1thMiA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgICAgICAgIGQyID0gZzIgLSBqMiA+PiAyOwogICAgICAgICAgICAgICAgaWYgKGIyID4+PiAwID4gKChmMiA+PiAyKSAtIGQyIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgbzIgPSBmMiA+PiAxOwogICAgICAgICAgICAgICAgICBuMiA9IGQyICsgYjIgfCAwOwogICAgICAgICAgICAgICAgICBxZyhwMiwgbzIgPj4+IDAgPCBuMiA+Pj4gMCA/IG4yIDogbzIsIGQyIC0gcjIgfCAwLCBhMiArIDEyIHwgMCk7CiAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICBjW3YyID4+IDJdID0gZXEoNDA5MikgfCAwOwogICAgICAgICAgICAgICAgICAgIHJnKHAyLCB2Mik7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBiMiArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gMCk7CiAgICAgICAgICAgICAgICAgIGlmICghcjIpCiAgICAgICAgICAgICAgICAgICAgZDIgPSBjW0EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaTIgPSBwMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgIGoyID0gcDIgKyAxMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgazIgPSBwMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgIGwyID0gcDIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgbTIgPSB3MiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgIG4yID0gdzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgICBvMiA9IHcyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgICAgIGgyID0gcjI7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBkMiA9IGNbQTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgIGcyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChiMiB8IDApID09IChnMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSBjW2syID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBnMiA9IGNbcDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYyID4+PiAwIDw9IGcyID4+PiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGUyIC0gYjIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAoYjIgfCAwKSA9PSAwID8gMSA6IGIyID4+IDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxZyh3MiwgYjIsIGIyID4+PiAyLCBjW2wyID4+IDJdIHwgMCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW3gyID4+IDJdID0gY1trMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbeTIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1t1MiA+PiAyXSA9IGNbeDIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW3YyID4+IDJdID0gY1t5MiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVnKHcyLCB1MiwgdjIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW3AyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbcDIgPj4gMl0gPSBjW3cyID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1t3MiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2syID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgPj4gMl0gPSBjW20yID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1ttMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSBjW24yID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tuMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2oyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSBjW28yID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tvMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGcodzIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBDMiA9IGYyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gKChDMiAtIGIyID4+IDIpICsgMSB8IDApIC8gLTIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gZjIgKyAoYjIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZTIgLSBDMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2cihnMiB8IDAsIGYyIHwgMCwgZTIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IChjW2syID4+IDJdIHwgMCkgKyAoYjIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBDMiA9IGcyICsgKGUyID4+IDIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSBDMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBDMjsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICBiMiA9IChjW2kyID4+IDJdIHwgMCkgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgIGQyID0gKGNbQTIgPj4gMl0gfCAwKSArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1tBMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgaDIgPSBoMiArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoaDIgfCAwKSAhPSAwKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBiMiA9IGNbejIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBpZiAoKGIyIHwgMCkgIT0gKGQyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICBiMiA9IGIyICsgLTQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgc2cocDIsIGIyKTsKICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tBMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gKGQyIHwgMCkpOwogICAgICAgICAgICAgICAgICAgIGIyID0gY1t6MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgQzIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGNbcDIgPj4gMl07CiAgICAgICAgICAgICAgICAgIGNbcDIgPj4gMl0gPSBDMjsKICAgICAgICAgICAgICAgICAgQzIgPSBwMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICBjW0EyID4+IDJdID0gY1tDMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgY1tDMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICBDMiA9IHAyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgIGNbejIgPj4gMl0gPSBjW0MyID4+IDJdOwogICAgICAgICAgICAgICAgICBjW0MyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgIEMyID0gcDIgKyAxMiB8IDA7CiAgICAgICAgICAgICAgICAgIEEyID0gY1t0MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIGNbdDIgPj4gMl0gPSBjW0MyID4+IDJdOwogICAgICAgICAgICAgICAgICBjW0MyID4+IDJdID0gQTI7CiAgICAgICAgICAgICAgICAgIGNbczIgPj4gMl0gPSAoY1tzMiA+PiAyXSB8IDApICsgKHEocjIsIC05MykgfCAwKTsKICAgICAgICAgICAgICAgICAgdGcocDIpOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGI6CiAgICAgICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgICAgIGlmICgoZTIgfCAwKSA9PSAoZzIgfCAwKSkKICAgICAgICAgICAgICAgICAgICAgICAgazIgPSAxODsKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGNbdjIgPj4gMl0gPSBlcSg0MDkyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb2coYTIsIHYyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGIyICsgLTEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYjIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbdDIgPj4gMl0gfCAwKSA9PSAoY1t6MiA+PiAyXSB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrMiA9IDE4OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSByMjsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW3MyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgIGlmICgoazIgfCAwKSA9PSAxOCkgewogICAgICAgICAgICAgICAgICAgIGUyID0gfihoMiA+Pj4gMCA+IGkyID4+PiAwID8gaTIgOiBoMik7CiAgICAgICAgICAgICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICBjW3YyID4+IDJdID0gZXEoNDA5MikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgcGcoYTIsIHYyKTsKICAgICAgICAgICAgICAgICAgICAgIGQyID0gZDIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBmMiA9ICgoKGNbejIgPj4gMl0gfCAwKSAtIChjW0EyID4+IDJdIHwgMCkgfCAwKSA9PSA0ID8gOTIgOiA5MykgKyAoY1tzMiA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbczIgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoZDIgfCAwKSAhPSAwKTsKICAgICAgICAgICAgICAgICAgICBkMiA9IGIyICsgLTEgLSBlMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBmMjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjW3MyID4+IDJdID0gYjIgKyAocShkMiwgLTkzKSB8IDApOwogICAgICAgICAgICAgICAgICBpZiAoIWQyKQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBpMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgICBqMiA9IHcyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgIGsyID0gdzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgbDIgPSB3MiArIDEyIHwgMDsKICAgICAgICAgICAgICAgICAgYjIgPSBjW3oyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGcyID0gY1tBMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaDIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBnMiA9IGcyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tBMiA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgICAgIEMyID0gY1t0MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgZTIgPSBDMjsKICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgaWYgKChiMiB8IDApID09IChDMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIEMyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gQzI7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnMiA+Pj4gMCA8PSBDMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gZTIgLSBiMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAoYjIgfCAwKSA9PSAwID8gMSA6IGIyID4+IDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcWcodzIsIGIyLCBiMiA+Pj4gMiwgaTIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbeDIgPj4gMl0gPSBjW0EyID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbeTIgPj4gMl0gPSBjW3oyID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbdTIgPj4gMl0gPSBjW3gyID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbdjIgPj4gMl0gPSBjW3kyID4+IDJdOwogICAgICAgICAgICAgICAgICAgICAgICAgIHVnKHcyLCB1MiwgdjIpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGNbdzIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t3MiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1tBMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tBMiA+PiAyXSA9IGNbajIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tqMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1t6MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t6MiA+PiAyXSA9IGNbazIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1trMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1t0MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1t0MiA+PiAyXSA9IGNbbDIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgIHRnKHcyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNbejIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIEMyID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gKChDMiAtIGIyID4+IDIpICsgMSB8IDApIC8gLTIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBmMiA9IGcyICsgKGIyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBlMiAtIEMyIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlMikKICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGYyOwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2cihmMiB8IDAsIGcyIHwgMCwgZTIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAoY1tBMiA+PiAyXSB8IDApICsgKGIyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBDMiA9IGYyICsgKGUyID4+IDIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjW3oyID4+IDJdID0gQzI7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbQTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBDMjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGgyOwogICAgICAgICAgICAgICAgICAgIGIyID0gKGNbejIgPj4gMl0gfCAwKSArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgIGNbejIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICBkMiA9IGQyICsgLTEgfCAwOwogICAgICAgICAgICAgICAgICB9IHdoaWxlICgoZDIgfCAwKSAhPSAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIFYgPSBCMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZmcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGQyID0gKGNbYjIgKyAxNiA+PiAyXSB8IDApICsgKGNbYjIgKyAyMCA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgIGcyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSAoZDIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgZjIgPSBnMiArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICBpZiAoKGNbYjIgKyA4ID4+IDJdIHwgMCkgPT0gKGcyIHwgMCkpCiAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYjIgPSAoY1tmMiA+PiAyXSB8IDApICsgKChkMiAtIChlMiAqIDkzIHwgMCkgfCAwKSAqIDQ0IHwgMCkgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGYyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ2coYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZjIgPSBiMjsKICAgICAgICAgIGIyID0gY1tmMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSBhMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBiMiA9IGNbZTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBjW2UyID4+IDJdOwogICAgICAgICAgY1tkMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaGcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGNbYjIgKyA0ID4+IDJdOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBjW2IyICsgOCA+PiAyXTsKICAgICAgICAgIGNbYTIgKyAxMiA+PiAyXSA9IGNbYjIgKyAxMiA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaWcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMzIgfCAwOwogICAgICAgICAgZTIgPSBkMiArIDI0IHwgMDsKICAgICAgICAgIGYyID0gZDIgKyAxNiB8IDA7CiAgICAgICAgICBoMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICBnMiA9IGQyOwogICAgICAgICAgaTIgPSBiMiArIDggfCAwOwogICAgICAgICAgajIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gY1tpMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgYjIgPSBoMjsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBqMjsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gaTI7CiAgICAgICAgICBiMiA9IGcyOwogICAgICAgICAgY1tiMiA+PiAyXSA9IGoyOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBpMjsKICAgICAgICAgIGNbZjIgPj4gMl0gPSBjW2gyID4+IDJdOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSBjW2gyICsgNCA+PiAyXTsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2cyID4+IDJdOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBjW2cyICsgNCA+PiAyXTsKICAgICAgICAgIGdnKGEyLCBmMiwgZTIpOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqZyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKHhnKGEyLCBiMikgfCAwKSBeIDEgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBrZyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBkMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoKGQyIHwgMCkgPT0gKGNbYjIgKyA4ID4+IDJdIHwgMCkpCiAgICAgICAgICAgIHlnKGEyLCBlMiwgY1tiMiArIDEyID4+IDJdIHwgMCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHlnKGEyLCBlMiwgKGNbZDIgPj4gMl0gfCAwKSArIDQwOTIgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGcoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIGUyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gZTI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGNbZDIgKyA0ID4+IDJdOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBlMjsKICAgICAgICAgIGNbYTIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwOwogICAgICAgICAgYjIgPSAoY1thMiArIDEyID4+IDJdIHwgMCkgKyAyMCB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gKGNbYjIgPj4gMl0gfCAwKSArICgoKGNbYTIgPj4gMl0gfCAwKSAtIChjW2EyICsgOCA+PiAyXSB8IDApIHwgMCkgLyA0NCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBkMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gKGNbZDIgPj4gMl0gfCAwKSkgewogICAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgICBiMiA9IGNbZTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgICAgZDIgPSBhMjsKICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGNbZTIgPj4gMl07CiAgICAgICAgICAgIGNbZDIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgIGNbYTIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBjW2UyID4+IDJdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb2coYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwOwogICAgICAgICAgcDIgPSBWOwogICAgICAgICAgViA9IFYgKyA0OCB8IDA7CiAgICAgICAgICBmMiA9IHAyICsgMzIgfCAwOwogICAgICAgICAgZTIgPSBwMiArIDI4IHwgMDsKICAgICAgICAgIGkyID0gcDIgKyA4IHwgMDsKICAgICAgICAgIGoyID0gcDIgKyA0IHwgMDsKICAgICAgICAgIGsyID0gcDI7CiAgICAgICAgICBvMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBkMiA9IGNbbzIgPj4gMl0gfCAwOwogICAgICAgICAgbDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIG4yID0gY1tsMiA+PiAyXSB8IDA7CiAgICAgICAgICBnMiA9IG4yOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKChkMiB8IDApID09IChuMiB8IDApKSB7CiAgICAgICAgICAgICAgbjIgPSBhMiArIDQgfCAwOwogICAgICAgICAgICAgIG0yID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgcTIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBoMiA9IHEyOwogICAgICAgICAgICAgIGlmIChtMiA+Pj4gMCA8PSBxMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgZDIgPSBnMiAtIGgyIHwgMDsKICAgICAgICAgICAgICAgIGQyID0gKGQyIHwgMCkgPT0gMCA/IDEgOiBkMiA+PiAxOwogICAgICAgICAgICAgICAgcWcoaTIsIGQyLCBkMiA+Pj4gMiwgYTIgKyAxMiB8IDApOwogICAgICAgICAgICAgICAgY1tqMiA+PiAyXSA9IGNbbjIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tvMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2oyID4+IDJdOwogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IGNbazIgPj4gMl07CiAgICAgICAgICAgICAgICB1ZyhpMiwgZTIsIGYyKTsKICAgICAgICAgICAgICAgIGQyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gY1tpMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgIGQyID0gaTIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIHEyID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW24yID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBxMjsKICAgICAgICAgICAgICAgIGQyID0gaTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgIHEyID0gY1tvMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW28yID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBxMjsKICAgICAgICAgICAgICAgIGQyID0gaTIgKyAxMiB8IDA7CiAgICAgICAgICAgICAgICBxMiA9IGNbbDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gcTI7CiAgICAgICAgICAgICAgICB0ZyhpMik7CiAgICAgICAgICAgICAgICBkMiA9IGNbbzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGYyID0gbTI7CiAgICAgICAgICAgICAgZTIgPSAoKGYyIC0gaDIgPj4gMikgKyAxIHwgMCkgLyAtMiB8IDA7CiAgICAgICAgICAgICAgYTIgPSBtMiArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgZjIgPSBkMiAtIGYyIHwgMDsKICAgICAgICAgICAgICBpZiAoIWYyKQogICAgICAgICAgICAgICAgZDIgPSBhMjsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHZyKGEyIHwgMCwgbTIgfCAwLCBmMiB8IDApIHwgMDsKICAgICAgICAgICAgICAgIGQyID0gKGNbbjIgPj4gMl0gfCAwKSArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHEyID0gYTIgKyAoZjIgPj4gMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgY1tvMiA+PiAyXSA9IHEyOwogICAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICBkMiA9IHEyOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBjW2QyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIGNbbzIgPj4gMl0gPSAoY1tvMiA+PiAyXSB8IDApICsgNDsKICAgICAgICAgIFYgPSBwMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwOwogICAgICAgICAgcDIgPSBWOwogICAgICAgICAgViA9IFYgKyA0OCB8IDA7CiAgICAgICAgICBlMiA9IHAyICsgMzIgfCAwOwogICAgICAgICAgZDIgPSBwMiArIDI4IHwgMDsKICAgICAgICAgIGgyID0gcDIgKyA4IHwgMDsKICAgICAgICAgIGkyID0gcDIgKyA0IHwgMDsKICAgICAgICAgIGoyID0gcDI7CiAgICAgICAgICBvMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBtMiA9IGNbbzIgPj4gMl0gfCAwOwogICAgICAgICAgbjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGsyID0gbjI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoKG0yIHwgMCkgPT0gKG4yIHwgMCkpIHsKICAgICAgICAgICAgICBuMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICAgICAgbDIgPSBjW24yID4+IDJdIHwgMDsKICAgICAgICAgICAgICBnMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgICAgIHEyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgZjIgPSBxMjsKICAgICAgICAgICAgICBpZiAobDIgPj4+IDAgPj0gcTIgPj4+IDApIHsKICAgICAgICAgICAgICAgIHEyID0gZjIgLSBrMiB8IDA7CiAgICAgICAgICAgICAgICBxMiA9IChxMiB8IDApID09IDAgPyAxIDogcTIgPj4gMTsKICAgICAgICAgICAgICAgIHFnKGgyLCBxMiwgKHEyICsgMyB8IDApID4+PiAyLCBhMiArIDEyIHwgMCk7CiAgICAgICAgICAgICAgICBjW2kyID4+IDJdID0gY1tvMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSBjW24yID4+IDJdOwogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGNbaTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2UyID4+IDJdID0gY1tqMiA+PiAyXTsKICAgICAgICAgICAgICAgIHVnKGgyLCBkMiwgZTIpOwogICAgICAgICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSBjW2gyID4+IDJdOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgZDIgPSBoMiArIDQgfCAwOwogICAgICAgICAgICAgICAgcTIgPSBjW28yID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbbzIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IHEyOwogICAgICAgICAgICAgICAgZDIgPSBoMiArIDggfCAwOwogICAgICAgICAgICAgICAgcTIgPSBjW24yID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IHEyOwogICAgICAgICAgICAgICAgZDIgPSBoMiArIDEyIHwgMDsKICAgICAgICAgICAgICAgIHEyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2cyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBxMjsKICAgICAgICAgICAgICAgIHRnKGgyKTsKICAgICAgICAgICAgICAgIGQyID0gY1tvMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZTIgPSBsMjsKICAgICAgICAgICAgICBhMiA9ICgoZjIgLSBlMiA+PiAyKSArIDEgfCAwKSAvIDIgfCAwOwogICAgICAgICAgICAgIGYyID0gbDIgKyAoYTIgPDwgMikgfCAwOwogICAgICAgICAgICAgIGUyID0gZTIgLSBtMiB8IDA7CiAgICAgICAgICAgICAgZDIgPSBmMiArICgwIC0gKGUyID4+IDIpIDw8IDIpIHwgMDsKICAgICAgICAgICAgICBpZiAoIWUyKSB7CiAgICAgICAgICAgICAgICBkMiA9IGYyOwogICAgICAgICAgICAgICAgZTIgPSBmMjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdnIoZDIgfCAwLCBtMiB8IDAsIGUyIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgZTIgPSAoY1tuMiA+PiAyXSB8IDApICsgKGEyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY1tvMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgZDIgPSBtMjsKICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIGNbZDIgKyAtNCA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICBjW28yID4+IDJdID0gKGNbbzIgPj4gMl0gfCAwKSArIC00OwogICAgICAgICAgViA9IHAyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBxZyhhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwOwogICAgICAgICAgZjIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDE2ID4+IDJdID0gZTI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgaWYgKGIyID4+PiAwID4gMTA3Mzc0MTgyMykgewogICAgICAgICAgICAgICAgZjIgPSB2KDgpIHwgMDsKICAgICAgICAgICAgICAgIHZxKGYyLCA2NzIzKTsKICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSA1OTU2OwogICAgICAgICAgICAgICAgeChmMiB8IDAsIDM5MjgsIDEyMyk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGUyID0gZXEoYjIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgY1thMiA+PiAyXSA9IGUyOwogICAgICAgICAgZDIgPSBlMiArIChkMiA8PCAyKSB8IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGQyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIGNbZjIgPj4gMl0gPSBlMiArIChiMiA8PCAyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwOwogICAgICAgICAgcDIgPSBWOwogICAgICAgICAgViA9IFYgKyA0OCB8IDA7CiAgICAgICAgICBmMiA9IHAyICsgMzIgfCAwOwogICAgICAgICAgZTIgPSBwMiArIDI4IHwgMDsKICAgICAgICAgIGkyID0gcDIgKyA4IHwgMDsKICAgICAgICAgIGoyID0gcDIgKyA0IHwgMDsKICAgICAgICAgIGsyID0gcDI7CiAgICAgICAgICBvMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBkMiA9IGNbbzIgPj4gMl0gfCAwOwogICAgICAgICAgbDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIG4yID0gY1tsMiA+PiAyXSB8IDA7CiAgICAgICAgICBnMiA9IG4yOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKChkMiB8IDApID09IChuMiB8IDApKSB7CiAgICAgICAgICAgICAgbjIgPSBhMiArIDQgfCAwOwogICAgICAgICAgICAgIG0yID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgcTIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBoMiA9IHEyOwogICAgICAgICAgICAgIGlmIChtMiA+Pj4gMCA8PSBxMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgZDIgPSBnMiAtIGgyIHwgMDsKICAgICAgICAgICAgICAgIGQyID0gKGQyIHwgMCkgPT0gMCA/IDEgOiBkMiA+PiAxOwogICAgICAgICAgICAgICAgcWcoaTIsIGQyLCBkMiA+Pj4gMiwgY1thMiArIDE2ID4+IDJdIHwgMCk7CiAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gY1tuMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbazIgPj4gMl0gPSBjW28yID4+IDJdOwogICAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGNbajIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gY1trMiA+PiAyXTsKICAgICAgICAgICAgICAgIHVnKGkyLCBlMiwgZjIpOwogICAgICAgICAgICAgICAgZDIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgZDIgPSBpMiArIDQgfCAwOwogICAgICAgICAgICAgICAgcTIgPSBjW24yID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IHEyOwogICAgICAgICAgICAgICAgZDIgPSBpMiArIDggfCAwOwogICAgICAgICAgICAgICAgcTIgPSBjW28yID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGNbbzIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IHEyOwogICAgICAgICAgICAgICAgZDIgPSBpMiArIDEyIHwgMDsKICAgICAgICAgICAgICAgIHEyID0gY1tsMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBxMjsKICAgICAgICAgICAgICAgIHRnKGkyKTsKICAgICAgICAgICAgICAgIGQyID0gY1tvMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZjIgPSBtMjsKICAgICAgICAgICAgICBlMiA9ICgoZjIgLSBoMiA+PiAyKSArIDEgfCAwKSAvIC0yIHwgMDsKICAgICAgICAgICAgICBhMiA9IG0yICsgKGUyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICBmMiA9IGQyIC0gZjIgfCAwOwogICAgICAgICAgICAgIGlmICghZjIpCiAgICAgICAgICAgICAgICBkMiA9IGEyOwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdnIoYTIgfCAwLCBtMiB8IDAsIGYyIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgZDIgPSAoY1tuMiA+PiAyXSB8IDApICsgKGUyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcTIgPSBhMiArIChmMiA+PiAyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICBjW28yID4+IDJdID0gcTI7CiAgICAgICAgICAgICAgY1tuMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgIGQyID0gcTI7CiAgICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAgY1tvMiA+PiAyXSA9IChjW28yID4+IDJdIHwgMCkgKyA0OwogICAgICAgICAgViA9IHAyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzZyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMCwgcDIgPSAwLCBxMiA9IDA7CiAgICAgICAgICBwMiA9IFY7CiAgICAgICAgICBWID0gViArIDQ4IHwgMDsKICAgICAgICAgIGUyID0gcDIgKyAzMiB8IDA7CiAgICAgICAgICBkMiA9IHAyICsgMjggfCAwOwogICAgICAgICAgaDIgPSBwMiArIDggfCAwOwogICAgICAgICAgaTIgPSBwMiArIDQgfCAwOwogICAgICAgICAgajIgPSBwMjsKICAgICAgICAgIG8yID0gYTIgKyA0IHwgMDsKICAgICAgICAgIG0yID0gY1tvMiA+PiAyXSB8IDA7CiAgICAgICAgICBuMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgazIgPSBuMjsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmICgobTIgfCAwKSA9PSAobjIgfCAwKSkgewogICAgICAgICAgICAgIG4yID0gYTIgKyA4IHwgMDsKICAgICAgICAgICAgICBsMiA9IGNbbjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGcyID0gYTIgKyAxMiB8IDA7CiAgICAgICAgICAgICAgcTIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBmMiA9IHEyOwogICAgICAgICAgICAgIGlmIChsMiA+Pj4gMCA+PSBxMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgcTIgPSBmMiAtIGsyIHwgMDsKICAgICAgICAgICAgICAgIHEyID0gKHEyIHwgMCkgPT0gMCA/IDEgOiBxMiA+PiAxOwogICAgICAgICAgICAgICAgcWcoaDIsIHEyLCAocTIgKyAzIHwgMCkgPj4+IDIsIGNbYTIgKyAxNiA+PiAyXSB8IDApOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGNbbzIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gY1tuMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGNbajIgPj4gMl07CiAgICAgICAgICAgICAgICB1ZyhoMiwgZDIsIGUyKTsKICAgICAgICAgICAgICAgIGQyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gY1toMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgIGQyID0gaDIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIHEyID0gY1tvMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW28yID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBxMjsKICAgICAgICAgICAgICAgIGQyID0gaDIgKyA4IHwgMDsKICAgICAgICAgICAgICAgIHEyID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW24yID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBxMjsKICAgICAgICAgICAgICAgIGQyID0gaDIgKyAxMiB8IDA7CiAgICAgICAgICAgICAgICBxMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gcTI7CiAgICAgICAgICAgICAgICB0ZyhoMik7CiAgICAgICAgICAgICAgICBkMiA9IGNbbzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGUyID0gbDI7CiAgICAgICAgICAgICAgYTIgPSAoKGYyIC0gZTIgPj4gMikgKyAxIHwgMCkgLyAyIHwgMDsKICAgICAgICAgICAgICBmMiA9IGwyICsgKGEyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICBlMiA9IGUyIC0gbTIgfCAwOwogICAgICAgICAgICAgIGQyID0gZjIgKyAoMCAtIChlMiA+PiAyKSA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKCFlMikgewogICAgICAgICAgICAgICAgZDIgPSBmMjsKICAgICAgICAgICAgICAgIGUyID0gZjI7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZyKGQyIHwgMCwgbTIgfCAwLCBlMiB8IDApIHwgMDsKICAgICAgICAgICAgICAgIGUyID0gKGNbbjIgPj4gMl0gfCAwKSArIChhMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNbbzIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICBjW24yID4+IDJdID0gZTI7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIGQyID0gbTI7CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBjW2QyICsgLTQgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAgY1tvMiA+PiAyXSA9IChjW28yID4+IDJdIHwgMCkgKyAtNDsKICAgICAgICAgIFYgPSBwMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdGcoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBiMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGUyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoKGUyIHwgMCkgIT0gKGIyIHwgMCkpCiAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBlMiArICh+KChlMiArIC00IC0gYjIgfCAwKSA+Pj4gMikgPDwgMik7CiAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGIyIHwgMCkKICAgICAgICAgICAgRGEoYjIsIChjW2EyICsgMTIgPj4gMl0gfCAwKSAtIGIyIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHVnKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBoMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGcyID0gaDI7CiAgICAgICAgICBmMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgdmcoZzIsIGEyICsgOCB8IDAsIChjW2QyID4+IDJdIHwgMCkgLSBmMiA+PiAyKTsKICAgICAgICAgIGEyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGcyICsgNCB8IDA7CiAgICAgICAgICBpZiAoKGEyIHwgMCkgIT0gKGNbZTIgPj4gMl0gfCAwKSkgewogICAgICAgICAgICBkMiA9IGYyOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgYTIgPSAoY1tnMiA+PiAyXSB8IDApICsgNCB8IDA7CiAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGEyOwogICAgICAgICAgICAgIGQyID0gZDIgKyA0IHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoKGEyIHwgMCkgIT0gKGNbZTIgPj4gMl0gfCAwKSk7CiAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBkMjsKICAgICAgICAgIH0KICAgICAgICAgIHdnKGcyKTsKICAgICAgICAgIFYgPSBoMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdmcoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IChjW2IyID4+IDJdIHwgMCkgKyAoZDIgPDwgMik7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3ZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2NbYTIgKyA4ID4+IDJdID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geGcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChjW2EyICsgNCA+PiAyXSB8IDApID09IChjW2IyICsgNCA+PiAyXSB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geWcoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gemcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBjW2IyICsgMTYgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSAoZDIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgZjIgPSBnMiArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICBpZiAoKGNbYjIgKyA4ID4+IDJdIHwgMCkgPT0gKGcyIHwgMCkpCiAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYjIgPSAoY1tmMiA+PiAyXSB8IDApICsgKChkMiAtIChlMiAqIDkzIHwgMCkgfCAwKSAqIDQ0IHwgMCkgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGYyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQWcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGQyID0gKGNbYjIgKyAxNiA+PiAyXSB8IDApICsgKGNbYjIgKyAyMCA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgIGcyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSAoZDIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgZjIgPSBnMiArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICBpZiAoKGNbYjIgKyA4ID4+IDJdIHwgMCkgPT0gKGcyIHwgMCkpCiAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYjIgPSAoY1tmMiA+PiAyXSB8IDApICsgKChkMiAtIChlMiAqIDkzIHwgMCkgfCAwKSAqIDQ0IHwgMCkgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGYyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQmcoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMDsKICAgICAgICAgIGkyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBpMiArIDggfCAwOwogICAgICAgICAgZzIgPSBpMjsKICAgICAgICAgIENnKGUyLCBhMik7CiAgICAgICAgICBmZyhnMiwgYTIpOwogICAgICAgICAgZjIgPSBlMiArIDQgfCAwOwogICAgICAgICAgYjIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgIGcyID0gZzIgKyA0IHwgMDsKICAgICAgICAgIGlmICgoYjIgfCAwKSAhPSAoY1tnMiA+PiAyXSB8IDApKQogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgSWMoYjIpOwogICAgICAgICAgICAgIGIyID0gKGNbZjIgPj4gMl0gfCAwKSArIDQ0IHwgMDsKICAgICAgICAgICAgICBjW2YyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgZDIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoKGIyIC0gKGNbZDIgPj4gMl0gfCAwKSB8IDApID09IDQwOTIpIHsKICAgICAgICAgICAgICAgIGIyID0gZDIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgIGIyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlICgoYjIgfCAwKSAhPSAoY1tnMiA+PiAyXSB8IDApKTsKICAgICAgICAgIGNbYTIgKyAyMCA+PiAyXSA9IDA7CiAgICAgICAgICBmMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBlMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBkMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgYjIgPSAoY1tmMiA+PiAyXSB8IDApIC0gZDIgPj4gMjsKICAgICAgICAgIGlmIChiMiA+Pj4gMCA+IDIpCiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBEYShjW2QyID4+IDJdIHwgMCwgNDA5Mik7CiAgICAgICAgICAgICAgZDIgPSAoY1tlMiA+PiAyXSB8IDApICsgNCB8IDA7CiAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgIGIyID0gKGNbZjIgPj4gMl0gfCAwKSAtIGQyID4+IDI7CiAgICAgICAgICAgIH0gd2hpbGUgKGIyID4+PiAwID4gMik7CiAgICAgICAgICBzd2l0Y2ggKGIyIHwgMCkgewogICAgICAgICAgICBjYXNlIDE6IHsKICAgICAgICAgICAgICBiMiA9IDQ2OwogICAgICAgICAgICAgIGgyID0gMTE7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSAyOiB7CiAgICAgICAgICAgICAgYjIgPSA5MzsKICAgICAgICAgICAgICBoMiA9IDExOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKChoMiB8IDApID09IDExKQogICAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBiMjsKICAgICAgICAgIFYgPSBpMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQ2coYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBjW2IyICsgMTYgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSAoZDIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgZjIgPSBnMiArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICBpZiAoKGNbYjIgKyA4ID4+IDJdIHwgMCkgPT0gKGcyIHwgMCkpCiAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYjIgPSAoY1tmMiA+PiAyXSB8IDApICsgKChkMiAtIChlMiAqIDkzIHwgMCkgfCAwKSAqIDQ0IHwgMCkgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGYyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRGcoYjIsIGUyLCBmMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgdmFyIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMDsKICAgICAgICAgIG0yID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgbDIgPSBtMjsKICAgICAgICAgIGoyID0gYjIgKyA0IHwgMDsKICAgICAgICAgIGlmICghKGFbajIgPj4gMF0gfCAwKSkgewogICAgICAgICAgICBsMiA9IERlKGUyKSB8IDA7CiAgICAgICAgICAgIEVlKGwyLCBmMiwgY1tiMiA+PiAyXSB8IDApOwogICAgICAgICAgICBsMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICBpMiA9IGYyICsgbDIgfCAwOwogICAgICAgICAgICBpZiAoIWwyKQogICAgICAgICAgICAgIGcyID0gMDsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgZzIgPSBmMjsKICAgICAgICAgICAgICBoMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgYVtoMiA+PiAwXSA9IGFbZzIgPj4gMF0gfCAwOwogICAgICAgICAgICAgICAgZzIgPSBnMiArIDEgfCAwOwogICAgICAgICAgICAgICAgaWYgKChnMiB8IDApID09IChpMiB8IDApKQogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgaDIgPSBoMiArIDEgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBnMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGFbajIgPj4gMF0gPSAxOwogICAgICAgICAgICBmMiA9IGYyICsgZzIgfCAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaDIgPSBjW2IyICsgMjAgPj4gMl0gfCAwOwogICAgICAgICAgICBnMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgQ2cobDIsIGIyICsgMzIgfCAwKTsKICAgICAgICAgICAgYjIgPSBiMiArIDEyIHwgMDsKICAgICAgICAgICAgaWYgKChnMiB8IDApICE9IChjW2IyID4+IDJdIHwgMCkpIHsKICAgICAgICAgICAgICBrMiA9IGwyICsgNCB8IDA7CiAgICAgICAgICAgICAgajIgPSBnMjsKICAgICAgICAgICAgICBpMiA9IGgyOwogICAgICAgICAgICAgIGcyID0gY1trMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIGgyID0gZFtqMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IEVnKChaYyhlMiwgZzIpIHwgMCkgKyBoMiB8IDApIHwgMDsKICAgICAgICAgICAgICAgIGFbaTIgPj4gMF0gPSBoMjsKICAgICAgICAgICAgICAgIGFbZjIgPj4gMF0gPSBoMjsKICAgICAgICAgICAgICAgIGFbajIgPj4gMF0gPSBoMjsKICAgICAgICAgICAgICAgIGoyID0gajIgKyAxIHwgMDsKICAgICAgICAgICAgICAgIGYyID0gZjIgKyAxIHwgMDsKICAgICAgICAgICAgICAgIGgyID0gY1tsMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBnMiA9IChjW2syID4+IDJdIHwgMCkgKyA0NCB8IDA7CiAgICAgICAgICAgICAgICBjW2syID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICBpZiAoKGcyIC0gKGNbaDIgPj4gMl0gfCAwKSB8IDApID09IDQwOTIpIHsKICAgICAgICAgICAgICAgICAgZzIgPSBoMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICAgIGcyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIGNbazIgPj4gMl0gPSBnMjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoajIgfCAwKSA9PSAoY1tiMiA+PiAyXSB8IDApKQogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgaTIgPSBpMiArIDEgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgViA9IG0yOwogICAgICAgICAgcmV0dXJuIGYyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRWcoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIGEyICYgMjU1IHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmcoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhnKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTEyNjIgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSWcoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSmcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKSB7CiAgICAgICAgICAgIFlmKGEyLCBiMik7CiAgICAgICAgICAgIExnKGEyLCBiMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtnKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDEyID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgMjAgPj4gMl0gPSAwOwogICAgICAgICAgaWYgKGIyIHwgMCkKICAgICAgICAgICAgTWcoYTIsIGIyLCBkMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIExnKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZzIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBmMiA9IGcyOwogICAgICAgICAgYWcoZjIsIGIyLCBkMik7CiAgICAgICAgICBkMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICBiMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSBmMiArIDggfCAwOwogICAgICAgICAgaWYgKChiMiB8IDApICE9IChjW2UyID4+IDJdIHwgMCkpCiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBhW2IyID4+IDBdID0gMDsKICAgICAgICAgICAgICBiMiA9IChjW2QyID4+IDJdIHwgMCkgKyAxIHwgMDsKICAgICAgICAgICAgICBjW2QyID4+IDJdID0gYjI7CiAgICAgICAgICAgIH0gd2hpbGUgKChiMiB8IDApICE9IChjW2UyID4+IDJdIHwgMCkpOwogICAgICAgICAgYmcoZjIpOwogICAgICAgICAgViA9IGcyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBNZyhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDA7CiAgICAgICAgICBvMiA9IFY7CiAgICAgICAgICBWID0gViArIDk2IHwgMDsKICAgICAgICAgIG4yID0gbzIgKyA4MCB8IDA7CiAgICAgICAgICBrMiA9IG8yICsgNjQgfCAwOwogICAgICAgICAgaDIgPSBvMiArIDQ4IHwgMDsKICAgICAgICAgIGkyID0gbzIgKyA0MCB8IDA7CiAgICAgICAgICBqMiA9IG8yICsgOCB8IDA7CiAgICAgICAgICBmMiA9IG8yOwogICAgICAgICAgbDIgPSBvMiArIDMyIHwgMDsKICAgICAgICAgIG0yID0gbzIgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IChjW2EyICsgOCA+PiAyXSB8IDApIC0gKGNbYTIgKyA0ID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgZTIgPSAoKGUyIHwgMCkgPT0gMCA/IDAgOiAoKGUyID4+IDIpICogOTMgfCAwKSArIC0xIHwgMCkgLSAoKGNbYTIgKyAyMCA+PiAyXSB8IDApICsgKGNbYTIgKyAxNiA+PiAyXSB8IDApKSB8IDA7CiAgICAgICAgICBpZiAoZTIgPj4+IDAgPCBiMiA+Pj4gMCkKICAgICAgICAgICAgZWcoYTIsIGIyIC0gZTIgfCAwKTsKICAgICAgICAgIGZnKGkyLCBhMik7CiAgICAgICAgICBmZyhmMiwgYTIpOwogICAgICAgICAgZTIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgIGYyID0gY1tmMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgZzIgPSBqMjsKICAgICAgICAgIGNbZzIgPj4gMl0gPSBlMjsKICAgICAgICAgIGNbZzIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBnMiA9IGUyOwogICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICBlMiA9ICgoZjIgLSAoY1tlMiA+PiAyXSB8IDApIHwgMCkgLyA0NCB8IDApICsgYjIgfCAwOwogICAgICAgICAgICBpZiAoKGUyIHwgMCkgPiAwKSB7CiAgICAgICAgICAgICAgYjIgPSAoZTIgPj4+IDApIC8gOTMgfCAwOwogICAgICAgICAgICAgIGcyID0gZzIgKyAoYjIgPDwgMikgfCAwOwogICAgICAgICAgICAgIGNbajIgPj4gMl0gPSBnMjsKICAgICAgICAgICAgICBlMiA9IChjW2cyID4+IDJdIHwgMCkgKyAoKGUyIC0gKGIyICogOTMgfCAwKSB8IDApICogNDQgfCAwKSB8IDA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZTIgPSA5MiAtIGUyIHwgMDsKICAgICAgICAgICAgICBiMiA9IGcyICsgKCgoZTIgfCAwKSAvIC05MyB8IDApIDw8IDIpIHwgMDsKICAgICAgICAgICAgICBjW2oyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgZTIgPSAoY1tiMiA+PiAyXSB8IDApICsgKCg5MiAtICgoZTIgfCAwKSAlIDkzIHwgMCkgfCAwKSAqIDQ0IHwgMCkgfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNbajIgKyA0ID4+IDJdID0gZTI7CiAgICAgICAgICB9CiAgICAgICAgICBjW2syID4+IDJdID0gY1tpMiA+PiAyXTsKICAgICAgICAgIGNbazIgKyA0ID4+IDJdID0gY1tpMiArIDQgPj4gMl07CiAgICAgICAgICBjW24yID4+IDJdID0gY1tqMiA+PiAyXTsKICAgICAgICAgIGNbbjIgKyA0ID4+IDJdID0gY1tqMiArIDQgPj4gMl07CiAgICAgICAgICBnZyhoMiwgazIsIG4yKTsKICAgICAgICAgIGhnKG4yLCBoMik7CiAgICAgICAgICBpZyhrMiwgaDIpOwogICAgICAgICAgaWYgKGpnKG4yLCBrMikgfCAwKSB7CiAgICAgICAgICAgIGYyID0gbTIgKyA0IHwgMDsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGtnKGwyLCBuMik7CiAgICAgICAgICAgICAgbGcobTIsIGEyLCBsMik7CiAgICAgICAgICAgICAgZTIgPSBjW20yID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoKGUyIHwgMCkgIT0gKGNbZjIgPj4gMl0gfCAwKSkKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgV2MoZTIsIGQyKTsKICAgICAgICAgICAgICAgICAgZTIgPSAoY1ttMiA+PiAyXSB8IDApICsgNDQgfCAwOwogICAgICAgICAgICAgICAgICBjW20yID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICB9IHdoaWxlICgoZTIgfCAwKSAhPSAoY1tmMiA+PiAyXSB8IDApKTsKICAgICAgICAgICAgICBtZyhtMik7CiAgICAgICAgICAgICAgbmcobjIpIHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoamcobjIsIGsyKSB8IDApOwogICAgICAgICAgfQogICAgICAgICAgViA9IG8yOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBCZyhhMik7CiAgICAgICAgICBiMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gY1thMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChiMiB8IDApICE9IChkMiB8IDApKQogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgRGEoY1tiMiA+PiAyXSB8IDAsIDQwOTIpOwogICAgICAgICAgICAgIGIyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoKGIyIHwgMCkgIT0gKGQyIHwgMCkpOwogICAgICAgICAgZGcoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBPZyhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBNZChhMik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDkyNDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBQZyhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBmMiA9IGVxKDE2KSB8IDA7CiAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gNDk0NDsKICAgICAgICAgIGNbZjIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBXZyhhMiwgZTIpOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBRZyhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gVGcoY1thMiArIDggPj4gMl0gfCAwLCBjW2EyICsgNCA+PiAyXSB8IDAsIGIyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFJnKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA0OTI0OwogICAgICAgICAgZDIgPSBhMiArIDggfCAwOwogICAgICAgICAgYjIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGNbZDIgPj4gMl0gPSAwOwogICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICBWZyhiMik7CiAgICAgICAgICAgIGpwKGIyKTsKICAgICAgICAgIH0KICAgICAgICAgIFFkKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2coYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgUmcoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBUZyhhMiwgYjIsIGMyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICByZXR1cm4gVWcoYTIgKyA0Nzg0IHwgMCwgYjIsIEJlKGEyLCBiMiwgYzIpIHwgMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVZyhiMiwgYzIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBpZiAoYVtiMiA+PiAwXSB8IDApIHsKICAgICAgICAgICAgbmMoYzIpOwogICAgICAgICAgICBhW2IyID4+IDBdID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFZnKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHplKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2coYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBYZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBwcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFlnKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApCiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDggPj4gMl0gJiAyNTVdKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWmcoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuICgoY1tiMiArIDQgPj4gMl0gfCAwKSA9PSAxMjAwNCA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfZyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiAkZyhiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBhW2IyID4+IDBdID0gMTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWgoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgTWQoYTIpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDQ5NzI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYmgoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDQ5OTI7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgV2coYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2goYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIGZoKGNbYTIgKyA4ID4+IDJdIHwgMCwgY1thMiArIDQgPj4gMl0gfCAwLCBiMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNDk3MjsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGIyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2QyID4+IDJdID0gMDsKICAgICAgICAgIGlmIChiMiB8IDApIHsKICAgICAgICAgICAgaGgoYjIpOwogICAgICAgICAgICBqcChiMik7CiAgICAgICAgICB9CiAgICAgICAgICBRZChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGRoKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZmgoYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgcmV0dXJuIGdoKGEyICsgNDc4NCB8IDAsIGIyLCBCZShhMiwgYjIsIGMyKSB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ2goYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgcmV0dXJuIFVnKGEyICsgMzI4IHwgMCwgYjIsIHFmKGEyLCBiMiwgYzIpIHwgMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBoaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBpaChhMiArIDQ3ODQgfCAwKTsKICAgICAgICAgIHplKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaWgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgb2YoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBwcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApCiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDggPj4gMl0gJiAyNTVdKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGgoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuICgoY1tiMiArIDQgPj4gMl0gfCAwKSA9PSAxMjgyNyA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjZihhMik7CiAgICAgICAgICAkZyhhMiArIDMyOCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvaChhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBNZChhMik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNTAyMDsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwaChhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBmMiA9IGVxKDE2KSB8IDA7CiAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gNTA0MDsKICAgICAgICAgIGNbZjIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBXZyhhMiwgZTIpOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBxaChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gdGgoY1thMiArIDggPj4gMl0gfCAwLCBjW2EyICsgNCA+PiAyXSB8IDAsIGIyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1MDIwOwogICAgICAgICAgZDIgPSBhMiArIDggfCAwOwogICAgICAgICAgYjIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIGNbZDIgPj4gMl0gPSAwOwogICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICB2aChiMik7CiAgICAgICAgICAgIGpwKGIyKTsKICAgICAgICAgIH0KICAgICAgICAgIFFkKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc2goYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmgoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0aChhMiwgYjIsIGMyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICByZXR1cm4gdWgoYTIgKyA0Nzg0IHwgMCwgYjIsIEJlKGEyLCBiMiwgYzIpIHwgMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1aChhMiwgYjIsIGMyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICByZXR1cm4gVWcoYTIgKyAzMTYgfCAwLCBiMiwgSWYoYTIsIGIyLCBjMikgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHdoKGEyICsgNDc4NCB8IDApOwogICAgICAgICAgemUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3aChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBIZihhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHhoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHBxKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geWgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSBjW2EyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCkKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6aChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDEzNjcyID8gYTIgKyAxMiB8IDAgOiAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCAxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIENmKGEyKTsKICAgICAgICAgICRnKGEyICsgMzE2IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENoKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIE1kKGEyKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1MDY4OwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIERoKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA1MDg4OwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFdnKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVoKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiBIaChjW2EyICsgOCA+PiAyXSB8IDAsIGNbYTIgKyA0ID4+IDJdIHwgMCwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDUwNjg7CiAgICAgICAgICBkMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBiMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDA7CiAgICAgICAgICBpZiAoYjIgfCAwKSB7CiAgICAgICAgICAgIEpoKGIyKTsKICAgICAgICAgICAganAoYjIpOwogICAgICAgICAgfQogICAgICAgICAgUWQoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBGaChhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhoKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHJldHVybiBJaChhMiArIDQ3ODQgfCAwLCBiMiwgQmUoYTIsIGIyLCBjMikgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEloKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHJldHVybiB1aChhMiArIDMyOCB8IDAsIGIyLCBxZihhMiwgYjIsIGMyKSB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSmgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgS2goYTIgKyA0Nzg0IHwgMCk7CiAgICAgICAgICB6ZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHdoKGEyICsgMzI4IHwgMCk7CiAgICAgICAgICBvZihhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIExoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHBxKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTWgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSBjW2EyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCkKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOaChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDE0NTczID8gYTIgKyAxMiB8IDAgOiAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE9oKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCAxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNmKGEyKTsKICAgICAgICAgIEJoKGEyICsgMzI4IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiArIDIwIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUmgoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2goYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSAtMTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVGgoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMiArIDQgfCAwOwogICAgICAgICAgZzIgPSBkMjsKICAgICAgICAgIGYyID0gZXEoMjQpIHwgMDsKICAgICAgICAgIGlpKGYyLCBiMik7CiAgICAgICAgICBjW2cyID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2cyID4+IDJdOwogICAgICAgICAgamkoYTIsIGYyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFVoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGEyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCA/IChkMiA9IGEyICsgNCB8IDAsIGIyID0gY1tkMiA+PiAyXSB8IDAsIGNbZDIgPj4gMl0gPSBiMiArIC0xLCAoYjIgfCAwKSA9PSAwKSA6IDApIHsKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgICBxcShhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFZoKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA1MTE2OwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFhoKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFdoKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGEyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCA/IChkMiA9IGEyICsgNCB8IDAsIGIyID0gY1tkMiA+PiAyXSB8IDAsIGNbZDIgPj4gMl0gPSBiMiArIC0xLCAoYjIgfCAwKSA9PSAwKSA6IDApIHsKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgICBxcShhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFhoKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWWgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBaaChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9oKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTQ5NjYgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJGgoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWkoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDUxNDQ7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgY2koYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYmkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYTIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwID8gKGQyID0gYTIgKyA0IHwgMCwgYjIgPSBjW2QyID4+IDJdIHwgMCwgY1tkMiA+PiAyXSA9IGIyICsgLTEsIChiMiB8IDApID09IDApIDogMCkgewogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA4ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICAgIHFxKGEyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2koYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkaShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBwcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApIHsKICAgICAgICAgICAgaGkoYTIpOwogICAgICAgICAgICBqcChhMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZpKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTUxMjcgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ2koYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaGkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpaShiMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBNZChiMik7CiAgICAgICAgICBjW2IyID4+IDJdID0gNTE3MjsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2IyICsgMTIgPj4gMl0gPSAwOwogICAgICAgICAgY1tiMiArIDE2ID4+IDJdID0gMDsKICAgICAgICAgIGFbYjIgKyAyMCA+PiAwXSA9IDE7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGppKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA1MTkyOwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHBpKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtpKGIyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDA7CiAgICAgICAgICBrMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGgyID0gazI7CiAgICAgICAgICBlMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gY1tiMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICgoZTIgfCAwKSAhPSAoaTIgfCAwKSkgewogICAgICAgICAgICBqMiA9IGgyICsgNCB8IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBmMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICBnMiA9IGNbZTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2oyID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgaWYgKGcyIHwgMCkgewogICAgICAgICAgICAgICAgZzIgPSBnMiArIDQgfCAwOwogICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IChjW2cyID4+IDJdIHwgMCkgKyAxOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkMiA9ICRbY1soY1tmMiA+PiAyXSB8IDApICsgMTIgPj4gMl0gJiA2M10oZjIsIGQyKSB8IDA7CiAgICAgICAgICAgICAgU2QoaDIpOwogICAgICAgICAgICAgIGUyID0gZTIgKyA4IHwgMDsKICAgICAgICAgICAgfSB3aGlsZSAoKGUyIHwgMCkgIT0gKGkyIHwgMCkpOwogICAgICAgICAgfQogICAgICAgICAgZTIgPSBiMiArIDIwIHwgMDsKICAgICAgICAgIGlmIChhW2UyID4+IDBdIHwgMCkgewogICAgICAgICAgICBhW2UyID4+IDBdID0gMDsKICAgICAgICAgICAgbmkoY1tiMiArIDQgPj4gMl0gfCAwKTsKICAgICAgICAgIH0KICAgICAgICAgIFYgPSBrMjsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGxpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1MTcyOwogICAgICAgICAgVGQoYTIgKyA4IHwgMCk7CiAgICAgICAgICBRZChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1pKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGxpKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbmkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMDsKICAgICAgICAgIGIyID0gKChvaShjW2EyID4+IDJdIHwgMCkgfCAwKSAmIDI1NSkgPDwgMjQ7CiAgICAgICAgICBiMiA9ICgob2koY1thMiA+PiAyXSB8IDApIHwgMCkgJiAyNTUpIDw8IDE2IHwgYjI7CiAgICAgICAgICBiMiA9IGIyIHwgKChvaShjW2EyID4+IDJdIHwgMCkgfCAwKSAmIDI1NSkgPDwgODsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjIgfCAob2koY1thMiA+PiAyXSB8IDApIHwgMCkgJiAyNTU7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9pKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGQyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICBlMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICBiMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyICsgMTsKICAgICAgICAgIHJldHVybiBhW2QyICsgYjIgPj4gMF0gfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHFpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHBxKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSBjW2EyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCkKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgOCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDE1NDUwID8gYTIgKyAxMiB8IDAgOiAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCAxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHVpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDA7CiAgICAgICAgICBqMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gajIgKyAxMiB8IDA7CiAgICAgICAgICBmMiA9IGoyOwogICAgICAgICAgYjIgPSBqMiArIDggfCAwOwogICAgICAgICAgaDIgPSBlcSgxODApIHwgMDsKICAgICAgICAgIHdpKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIHhpKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDA7CiAgICAgICAgICBqMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gajIgKyAxMiB8IDA7CiAgICAgICAgICBmMiA9IGoyOwogICAgICAgICAgYjIgPSBqMiArIDggfCAwOwogICAgICAgICAgaDIgPSBlcSgxODApIHwgMDsKICAgICAgICAgIFVpKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIFZpKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdpKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGZlKGEyKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1MjIwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHlpKGEyICsgOCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4aShhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBmMiA9IGVxKDE2KSB8IDA7CiAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gNTI0NDsKICAgICAgICAgIGNbZjIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBYZShhMiwgZTIpOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5aShiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB4ZShiMiwgMzIsIDEsIDgsIDApOwogICAgICAgICAgbWMoYjIgKyA4MCB8IDAsIDMyLCAxLCA4LCAwKTsKICAgICAgICAgIGFbYjIgKyAxNjAgPj4gMF0gPSAwOwogICAgICAgICAgYVtiMiArIDE2MSA+PiAwXSA9IDA7CiAgICAgICAgICBDaShiMiArIDE2NCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6aShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNTIyMDsKICAgICAgICAgIERpKGEyICsgOCB8IDApOwogICAgICAgICAgbGUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBBaShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB6aShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJpKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiBFaShhMiArIDggfCAwLCBjW2EyICsgNCA+PiAyXSB8IDAsIGIyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENpKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGFbYjIgKyA0ID4+IDBdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRGkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcWMoYTIgKyA4MCB8IDApOwogICAgICAgICAgeWUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFaShiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMDsKICAgICAgICAgIGgyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZjIgPSBoMjsKICAgICAgICAgIGlmICghKGFbYjIgKyAxNjEgPj4gMF0gfCAwKSkKICAgICAgICAgICAgb2MoYjIgKyA4MCB8IDApOwogICAgICAgICAgZzIgPSBiMiArIDE2NCB8IDA7CiAgICAgICAgICBpZiAoRmkoZzIpIHwgMCkgewogICAgICAgICAgICBkMiA9IEdpKGIyICsgODAgfCAwLCBkMiwgY1tnMiA+PiAyXSB8IDAsIDApIHwgMDsKICAgICAgICAgICAgY1tmMiA+PiAyXSA9IGQyOwogICAgICAgICAgICBTZShkMiwgZTIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgSWkoSGkoZDIpIHwgMCwgZTIsIDQpOwogICAgICAgICAgICBjW2YyID4+IDJdID0gTmUoZTIpIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIEppKGcyLCBmMik7CiAgICAgICAgICBWID0gaDI7CiAgICAgICAgICByZXR1cm4gZTIgKyA0IHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmkoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChhW2IyICsgNCA+PiAwXSB8IDApICE9IDAgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHaShhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBkMiA9IChLaShhMiwgYjIsIChjW2EyICsgMzYgPj4gMl0gfCAwKSArIChlMiAqIDQ0IHwgMCkgfCAwKSB8IDApICsgZDIgfCAwOwogICAgICAgICAgYjIgPSBjW2EyICsgMjQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKChkMiB8IDApIDwgMCkKICAgICAgICAgICAgcmV0dXJuIGQyICsgYjIgfCAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gZDIgLSAoZDIgPj4+IDAgPCBiMiA+Pj4gMCA/IDAgOiBiMikgfCAwOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBjW2EyID4+IDJdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSWkoYjIsIGMyLCBkMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIGlmICgoZDIgfCAwKSA+IDApIHsKICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgYVtjMiArIGUyID4+IDBdID0gb2koYjIpIHwgMDsKICAgICAgICAgICAgICBlMiA9IGUyICsgMSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKChlMiB8IDApICE9IChkMiB8IDApKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSmkoYjIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIGUyID0gYjIgKyA0IHwgMDsKICAgICAgICAgIGlmICghKGFbZTIgPj4gMF0gfCAwKSkKICAgICAgICAgICAgYVtlMiA+PiAwXSA9IDE7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gS2koYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIGQyID0gTGkoYjIsIGQyKSB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gZDI7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoZDIpIHsKICAgICAgICAgICAgICBpZiAoZDIgPj4+IDAgPj0gMzIpIHsKICAgICAgICAgICAgICAgIGQyID0gY1thMiArIDI4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwID4gZTIgPj4+IDApIHsKICAgICAgICAgICAgICAgIGUyID0gZDIgLSBlMiB8IDA7CiAgICAgICAgICAgICAgICBkMiA9IExpKGIyLCAoY1thMiArIDY4ID4+IDJdIHwgMCkgKyAoKGQyICsgLTEgfCAwKSAqIDQ0IHwgMCkgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICBlMiA9IGQyIDw8IGUyIHwgKE1pKGIyLCBlMikgfCAwKTsKICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIGUyID0gTGkoYjIsIChjW2EyICsgNjggPj4gMl0gfCAwKSArICgoZDIgKyAtMSB8IDApICogNDQgfCAwKSB8IDApIHwgMDsKICAgICAgICAgICAgICBkMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGlmICgoZTIgfCAwKSA8ICgxIDw8IGQyICsgLTEgfCAwKSkgewogICAgICAgICAgICAgICAgZDIgPSBlMiArIDEgKyAoLTEgPDwgZDIpIHwgMDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBkMiA9IGUyICsgMSB8IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIGQyID0gTmkoYjIsIGEyICsgNDggfCAwKSB8IDA7CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm4gZDIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMDsKICAgICAgICAgIG4yID0gYTIgKyA4IHwgMDsKICAgICAgICAgIG0yID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IGNbYjIgKyAxNiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoZjIpIHsKICAgICAgICAgICAgZTIgPSBhMiArIDQgfCAwOwogICAgICAgICAgICBkMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICBsMiA9IG0yID4+PiAxNTsKICAgICAgICAgICAgY1tuMiA+PiAyXSA9IGwyOwogICAgICAgICAgICBqMiA9IChkMiA+Pj4gMCkgLyAobDIgPj4+IDApIHwgMDsKICAgICAgICAgICAgaTIgPSBqMiA+Pj4gKGNbYjIgKyA0MCA+PiAyXSB8IDApOwogICAgICAgICAgICBnMiA9IGNbZjIgKyAoaTIgPDwgMikgPj4gMl0gfCAwOwogICAgICAgICAgICBpMiA9IChjW2YyICsgKGkyICsgMSA8PCAyKSA+PiAyXSB8IDApICsgMSB8IDA7CiAgICAgICAgICAgIGgyID0gZzIgKyAxIHwgMDsKICAgICAgICAgICAgazIgPSBjW2IyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgIGlmIChpMiA+Pj4gMCA+IGgyID4+PiAwKSB7CiAgICAgICAgICAgICAgZjIgPSBnMjsKICAgICAgICAgICAgICBnMiA9IGkyOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGgyID0gKGcyICsgZjIgfCAwKSA+Pj4gMTsKICAgICAgICAgICAgICAgIGkyID0gKGNbazIgKyAoaDIgPDwgMikgPj4gMl0gfCAwKSA+Pj4gMCA+IGoyID4+PiAwOwogICAgICAgICAgICAgICAgZjIgPSBpMiA/IGYyIDogaDI7CiAgICAgICAgICAgICAgICBnMiA9IGkyID8gaDIgOiBnMjsKICAgICAgICAgICAgICAgIGgyID0gZjIgKyAxIHwgMDsKICAgICAgICAgICAgICB9IHdoaWxlIChnMiA+Pj4gMCA+IGgyID4+PiAwKTsKICAgICAgICAgICAgICBnMiA9IGYyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGYyID0gcShjW2syICsgKGcyIDw8IDIpID4+IDJdIHwgMCwgbDIpIHwgMDsKICAgICAgICAgICAgaWYgKChnMiB8IDApID09IChjW2IyICsgMzIgPj4gMl0gfCAwKSkKICAgICAgICAgICAgICBoMiA9IG0yOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgaDIgPSBxKGNbazIgKyAoaDIgPDwgMikgPj4gMl0gfCAwLCBsMikgfCAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgazIgPSBtMiA+Pj4gMTU7CiAgICAgICAgICAgIGNbbjIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgaTIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgICAgbDIgPSBjW2IyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgIGUyID0gYTIgKyA0IHwgMDsKICAgICAgICAgICAgZDIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgajIgPSBpMiA+Pj4gMTsKICAgICAgICAgICAgZjIgPSAwOwogICAgICAgICAgICBoMiA9IG0yOwogICAgICAgICAgICBnMiA9IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBvMiA9IHEoY1tsMiArIChqMiA8PCAyKSA+PiAyXSB8IDAsIGsyKSB8IDA7CiAgICAgICAgICAgICAgbTIgPSBvMiA+Pj4gMCA+IGQyID4+PiAwOwogICAgICAgICAgICAgIGgyID0gbTIgPyBvMiA6IGgyOwogICAgICAgICAgICAgIGYyID0gbTIgPyBmMiA6IG8yOwogICAgICAgICAgICAgIGcyID0gbTIgPyBnMiA6IGoyOwogICAgICAgICAgICAgIGkyID0gbTIgPyBqMiA6IGkyOwogICAgICAgICAgICAgIGoyID0gKGcyICsgaTIgfCAwKSA+Pj4gMTsKICAgICAgICAgICAgfSB3aGlsZSAoKGoyIHwgMCkgIT0gKGcyIHwgMCkpOwogICAgICAgICAgfQogICAgICAgICAgY1tlMiA+PiAyXSA9IGQyIC0gZjI7CiAgICAgICAgICBvMiA9IGgyIC0gZjIgfCAwOwogICAgICAgICAgY1tuMiA+PiAyXSA9IG8yOwogICAgICAgICAgaWYgKG8yID4+PiAwIDwgMTY3NzcyMTYpCiAgICAgICAgICAgIE9pKGEyKTsKICAgICAgICAgIG4yID0gKGNbYjIgKyAxMiA+PiAyXSB8IDApICsgKGcyIDw8IDIpIHwgMDsKICAgICAgICAgIGNbbjIgPj4gMl0gPSAoY1tuMiA+PiAyXSB8IDApICsgMTsKICAgICAgICAgIG4yID0gYjIgKyAyOCB8IDA7CiAgICAgICAgICBvMiA9IChjW24yID4+IDJdIHwgMCkgKyAtMSB8IDA7CiAgICAgICAgICBjW24yID4+IDJdID0gbzI7CiAgICAgICAgICBpZiAoIW8yKQogICAgICAgICAgICBYYyhiMik7CiAgICAgICAgICByZXR1cm4gZzIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBNaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgaWYgKGIyID4+PiAwID4gMTkpIHsKICAgICAgICAgICAgZDIgPSAoUGkoYTIpIHwgMCkgJiA2NTUzNTsKICAgICAgICAgICAgcmV0dXJuIChNaShhMiwgYjIgKyAtMTYgfCAwKSB8IDApIDw8IDE2IHwgZDIgfCAwOwogICAgICAgICAgfQogICAgICAgICAgZTIgPSBhMiArIDQgfCAwOwogICAgICAgICAgZjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgIGcyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGQyID0gKGNbZzIgPj4gMl0gfCAwKSA+Pj4gYjI7CiAgICAgICAgICBjW2cyID4+IDJdID0gZDI7CiAgICAgICAgICBiMiA9IChmMiA+Pj4gMCkgLyAoZDIgPj4+IDApIHwgMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBmMiAtIChxKGIyLCBkMikgfCAwKTsKICAgICAgICAgIGlmIChkMiA+Pj4gMCA8IDE2Nzc3MjE2KQogICAgICAgICAgICBPaShhMik7CiAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMDsKICAgICAgICAgIGUyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGYyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICBkMiA9IHEoZjIgPj4+IDEzLCBjW2IyICsgOCA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgIGcyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGgyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGgyID4+PiAwID49IGQyID4+PiAwOwogICAgICAgICAgaWYgKGkyKSB7CiAgICAgICAgICAgIGNbZzIgPj4gMl0gPSBoMiAtIGQyOwogICAgICAgICAgICBkMiA9IGYyIC0gZDIgfCAwOwogICAgICAgICAgICBjW2UyID4+IDJdID0gZDI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjW2UyID4+IDJdID0gZDI7CiAgICAgICAgICAgIGgyID0gYjIgKyAxMiB8IDA7CiAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAoY1toMiA+PiAyXSB8IDApICsgMTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChkMiA+Pj4gMCA8IDE2Nzc3MjE2KQogICAgICAgICAgICBPaShhMik7CiAgICAgICAgICBoMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICBhMiA9IChjW2gyID4+IDJdIHwgMCkgKyAtMSB8IDA7CiAgICAgICAgICBjW2gyID4+IDJdID0gYTI7CiAgICAgICAgICBpZiAoIWEyKQogICAgICAgICAgICBjZChiMik7CiAgICAgICAgICByZXR1cm4gaTIgJiAxIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT2koYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGIyID0gYTIgKyA0IHwgMDsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGUyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGUyID0gZTIgPDwgOCB8IChvaShjW2EyID4+IDJdIHwgMCkgfCAwKSAmIDI1NTsKICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGUyOwogICAgICAgICAgICBmMiA9IGNbZDIgPj4gMl0gPDwgODsKICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGYyOwogICAgICAgICAgfSB3aGlsZSAoZjIgPj4+IDAgPCAxNjc3NzIxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBmMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgYjIgPSBhMiArIDggfCAwOwogICAgICAgICAgZTIgPSAoY1tiMiA+PiAyXSB8IDApID4+PiAxNjsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBlMjsKICAgICAgICAgIGIyID0gKGYyID4+PiAwKSAvIChlMiA+Pj4gMCkgfCAwOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGYyIC0gKHEoYjIsIGUyKSB8IDApOwogICAgICAgICAgT2koYTIpOwogICAgICAgICAgcmV0dXJuIGIyICYgNjU1MzUgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBRaShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBwcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFJpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gY1thMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgIGlmIChhMiB8IDApCiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDQgPj4gMl0gJiAyNTVdKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2koYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuICgoY1tiMiArIDQgPj4gMl0gfCAwKSA9PSAxNTkwNCA/IGEyICsgMTIgfCAwIDogMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBUaShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBEYShhMiwgMTYpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBmZShhMik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNTI3MjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBXaShhMiArIDggfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVmkoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgZjIgPSBlcSgxNikgfCAwOwogICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDUyOTY7CiAgICAgICAgICBjW2YyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gZjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgWGUoYTIsIGUyKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2koYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgeGUoYjIsIDMyLCAxLCA4LCAwKTsKICAgICAgICAgIG1jKGIyICsgODAgfCAwLCAzMiwgMSwgOCwgMCk7CiAgICAgICAgICBhW2IyICsgMTYwID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAxNjEgPj4gMF0gPSAwOwogICAgICAgICAgX2koYjIgKyAxNjQgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWGkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDUyNzI7CiAgICAgICAgICAkaShhMiArIDggfCAwKTsKICAgICAgICAgIGxlKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWWkoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgWGkoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBaaShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gYWooYTIgKyA4IHwgMCwgY1thMiArIDQgPj4gMl0gfCAwLCBiMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfaShiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBhW2IyICsgNCA+PiAwXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uICRpKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHFjKGEyICsgODAgfCAwKTsKICAgICAgICAgIHllKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWooYjIsIGQyLCBlMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBoMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGYyID0gaDI7CiAgICAgICAgICBpZiAoIShhW2IyICsgMTYxID4+IDBdIHwgMCkpCiAgICAgICAgICAgIG9jKGIyICsgODAgfCAwKTsKICAgICAgICAgIGcyID0gYjIgKyAxNjQgfCAwOwogICAgICAgICAgaWYgKGJqKGcyKSB8IDApIHsKICAgICAgICAgICAgZDIgPSBHaShiMiArIDgwIHwgMCwgZDIsIGNbZzIgPj4gMl0gfCAwLCAwKSB8IDA7CiAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgV2UoZDIsIGUyKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIElpKEhpKGQyKSB8IDAsIGUyLCA0KTsKICAgICAgICAgICAgY1tmMiA+PiAyXSA9IFJlKGUyKSB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICBjaihnMiwgZjIpOwogICAgICAgICAgViA9IGgyOwogICAgICAgICAgcmV0dXJuIGUyICsgNCB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGJqKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoYVtiMiArIDQgPj4gMF0gfCAwKSAhPSAwIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2ooYjIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIGUyID0gYjIgKyA0IHwgMDsKICAgICAgICAgIGlmICghKGFbZTIgPj4gMF0gfCAwKSkKICAgICAgICAgICAgYVtlMiA+PiAwXSA9IDE7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlaihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZqKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTY0MDIgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ2ooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaGooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMDsKICAgICAgICAgIGoyID0gVjsKICAgICAgICAgIFYgPSBWICsgMzIgfCAwOwogICAgICAgICAgZTIgPSBqMiArIDEyIHwgMDsKICAgICAgICAgIGYyID0gajI7CiAgICAgICAgICBiMiA9IGoyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGVxKDE3MikgfCAwOwogICAgICAgICAgamooaDIsIGNbYTIgKyA0ID4+IDJdIHwgMCk7CiAgICAgICAgICBnMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAga2ooZjIsIGgyLCBlMik7CiAgICAgICAgICBoMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgYjIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gYTIgKyAxNiB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIgPj4+IDAgPj0gKGNbaTIgPj4gMl0gfCAwKSA+Pj4gMCkgewogICAgICAgICAgICAgIGIyID0gKGIyIC0gKGNbZzIgPj4gMl0gfCAwKSA+PiAzKSArIDEgfCAwOwogICAgICAgICAgICAgIGQyID0gZWUoZzIpIHwgMDsKICAgICAgICAgICAgICBpZiAoZDIgPj4+IDAgPCBiMiA+Pj4gMCkKICAgICAgICAgICAgICAgIGNyKGcyKTsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIGsyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBsMiA9IChjW2kyID4+IDJdIHwgMCkgLSBrMiB8IDA7CiAgICAgICAgICAgICAgICBpMiA9IGwyID4+IDI7CiAgICAgICAgICAgICAgICBiZSgKICAgICAgICAgICAgICAgICAgZTIsCiAgICAgICAgICAgICAgICAgIGwyID4+IDMgPj4+IDAgPCBkMiA+Pj4gMSA+Pj4gMCA/IGkyID4+PiAwIDwgYjIgPj4+IDAgPyBiMiA6IGkyIDogZDIsCiAgICAgICAgICAgICAgICAgIChjW2gyID4+IDJdIHwgMCkgLSBrMiA+PiAzLAogICAgICAgICAgICAgICAgICBhMiArIDE2IHwgMAogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIGkyID0gZTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgIGgyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICAgIGEyID0gZjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIGNbaDIgKyA0ID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICBjW2kyID4+IDJdID0gaDIgKyA4OwogICAgICAgICAgICAgICAgY2UoZzIsIGUyKTsKICAgICAgICAgICAgICAgIGRlKGUyKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAkZChlMiwgZzIsIDEpOwogICAgICAgICAgICAgIGwyID0gZTIgKyA0IHwgMDsKICAgICAgICAgICAgICBrMiA9IGNbbDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGNbazIgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgICAgIGkyID0gZjIgKyA0IHwgMDsKICAgICAgICAgICAgICBjW2syICsgNCA+PiAyXSA9IGNbaTIgPj4gMl07CiAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGsyICsgODsKICAgICAgICAgICAgICBhZShlMik7CiAgICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIFNkKGYyKTsKICAgICAgICAgIFYgPSBqMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaWooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMDsKICAgICAgICAgIGoyID0gVjsKICAgICAgICAgIFYgPSBWICsgMzIgfCAwOwogICAgICAgICAgZTIgPSBqMiArIDEyIHwgMDsKICAgICAgICAgIGYyID0gajI7CiAgICAgICAgICBiMiA9IGoyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGVxKDE3NikgfCAwOwogICAgICAgICAgQWooaDIsIGNbYTIgKyA0ID4+IDJdIHwgMCk7CiAgICAgICAgICBnMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAgQmooZjIsIGgyLCBlMik7CiAgICAgICAgICBoMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgYjIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgIGkyID0gYTIgKyAxNiB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoYjIgPj4+IDAgPj0gKGNbaTIgPj4gMl0gfCAwKSA+Pj4gMCkgewogICAgICAgICAgICAgIGIyID0gKGIyIC0gKGNbZzIgPj4gMl0gfCAwKSA+PiAzKSArIDEgfCAwOwogICAgICAgICAgICAgIGQyID0gZWUoZzIpIHwgMDsKICAgICAgICAgICAgICBpZiAoZDIgPj4+IDAgPCBiMiA+Pj4gMCkKICAgICAgICAgICAgICAgIGNyKGcyKTsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIGsyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBsMiA9IChjW2kyID4+IDJdIHwgMCkgLSBrMiB8IDA7CiAgICAgICAgICAgICAgICBpMiA9IGwyID4+IDI7CiAgICAgICAgICAgICAgICBiZSgKICAgICAgICAgICAgICAgICAgZTIsCiAgICAgICAgICAgICAgICAgIGwyID4+IDMgPj4+IDAgPCBkMiA+Pj4gMSA+Pj4gMCA/IGkyID4+PiAwIDwgYjIgPj4+IDAgPyBiMiA6IGkyIDogZDIsCiAgICAgICAgICAgICAgICAgIChjW2gyID4+IDJdIHwgMCkgLSBrMiA+PiAzLAogICAgICAgICAgICAgICAgICBhMiArIDE2IHwgMAogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIGkyID0gZTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgIGgyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICAgIGEyID0gZjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIGNbaDIgKyA0ID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICBjW2kyID4+IDJdID0gaDIgKyA4OwogICAgICAgICAgICAgICAgY2UoZzIsIGUyKTsKICAgICAgICAgICAgICAgIGRlKGUyKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAkZChlMiwgZzIsIDEpOwogICAgICAgICAgICAgIGwyID0gZTIgKyA0IHwgMDsKICAgICAgICAgICAgICBrMiA9IGNbbDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGNbazIgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgICAgIGkyID0gZjIgKyA0IHwgMDsKICAgICAgICAgICAgICBjW2syICsgNCA+PiAyXSA9IGNbaTIgPj4gMl07CiAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGsyICsgODsKICAgICAgICAgICAgICBhZShlMik7CiAgICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIFNkKGYyKTsKICAgICAgICAgIFYgPSBqMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gamooYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZmUoYTIpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDUzMjQ7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgbGooYTIgKyA4IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtqKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA1MzQ4OwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFhlKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGxqKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHhlKGIyLCA4LCAxLCA4LCAwKTsKICAgICAgICAgIG1jKGIyICsgODAgfCAwLCA4LCAxLCA4LCAwKTsKICAgICAgICAgIGFbYjIgKyAxNjAgPj4gMF0gPSAwOwogICAgICAgICAgYVtiMiArIDE2MSA+PiAwXSA9IDA7CiAgICAgICAgICBwaihiMiArIDE2MiB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtaihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNTMyNDsKICAgICAgICAgIHFqKGEyICsgOCB8IDApOwogICAgICAgICAgbGUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuaihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBtaihhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9qKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiByaihhMiArIDggfCAwLCBjW2EyICsgNCA+PiAyXSB8IDAsIGIyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBqKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcWooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcWMoYTIgKyA4MCB8IDApOwogICAgICAgICAgeWUoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiByaihiMiwgYzIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBnMjsKICAgICAgICAgIGlmICghKGFbYjIgKyAxNjEgPj4gMF0gfCAwKSkKICAgICAgICAgICAgb2MoYjIgKyA4MCB8IDApOwogICAgICAgICAgZjIgPSBiMiArIDE2MiB8IDA7CiAgICAgICAgICBpZiAoc2ooZjIpIHwgMCkgewogICAgICAgICAgICBjMiA9IChHaShiMiArIDgwIHwgMCwgYzIsIGFbZjIgPj4gMF0gfCAwLCAwKSB8IDApICYgMjU1OwogICAgICAgICAgICBhW2UyID4+IDBdID0gYzI7CiAgICAgICAgICAgIHRqKGMyLCBkMik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBJaShIaShjMikgfCAwLCBkMiwgMSk7CiAgICAgICAgICAgIGFbZTIgPj4gMF0gPSB1aihkMikgfCAwOwogICAgICAgICAgfQogICAgICAgICAgdmooZjIsIGUyKTsKICAgICAgICAgIFYgPSBnMjsKICAgICAgICAgIHJldHVybiBkMiArIDEgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzaihiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKGFbYjIgKyAxID4+IDBdIHwgMCkgIT0gMCB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRqKGIyLCBjMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGFbYzIgPj4gMF0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWooYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIGFbYjIgPj4gMF0gfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB2aihiMiwgYzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwOwogICAgICAgICAgZDIgPSBiMiArIDEgfCAwOwogICAgICAgICAgaWYgKCEoYVtkMiA+PiAwXSB8IDApKQogICAgICAgICAgICBhW2QyID4+IDBdID0gMTsKICAgICAgICAgIGFbYjIgPj4gMF0gPSBhW2MyID4+IDBdIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gd2ooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4aihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHlqKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTY5MDAgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gemooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQWooYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZmUoYTIpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDUzNzY7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgQ2ooYTIgKyA4IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJqKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA1NDAwOwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFhlKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENqKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHhlKGIyLCAxNiwgMSwgOCwgMCk7CiAgICAgICAgICBtYyhiMiArIDgwIHwgMCwgMTYsIDEsIDgsIDApOwogICAgICAgICAgYVtiMiArIDE2MCA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMTYxID4+IDBdID0gMDsKICAgICAgICAgIEdqKGIyICsgMTYyIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIERqKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1Mzc2OwogICAgICAgICAgSGooYTIgKyA4IHwgMCk7CiAgICAgICAgICBsZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVqKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERqKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmooYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIElqKGEyICsgOCB8IDAsIGNbYTIgKyA0ID4+IDJdIHwgMCwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gR2ooYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYVtiMiArIDIgPj4gMF0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBIaihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBxYyhhMiArIDgwIHwgMCk7CiAgICAgICAgICB5ZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIElqKGMyLCBkMiwgZTIpIHsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgaDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBmMiA9IGgyOwogICAgICAgICAgaWYgKCEoYVtjMiArIDE2MSA+PiAwXSB8IDApKQogICAgICAgICAgICBvYyhjMiArIDgwIHwgMCk7CiAgICAgICAgICBnMiA9IGMyICsgMTYyIHwgMDsKICAgICAgICAgIGlmIChKaihnMikgfCAwKSB7CiAgICAgICAgICAgIGQyID0gKEdpKGMyICsgODAgfCAwLCBkMiwgYltnMiA+PiAxXSB8IDAsIDApIHwgMCkgJiA2NTUzNTsKICAgICAgICAgICAgYltmMiA+PiAxXSA9IGQyOwogICAgICAgICAgICBLaihkMiwgZTIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgSWkoSGkoZDIpIHwgMCwgZTIsIDIpOwogICAgICAgICAgICBiW2YyID4+IDFdID0gTGooZTIpIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIE1qKGcyLCBmMik7CiAgICAgICAgICBWID0gaDI7CiAgICAgICAgICByZXR1cm4gZTIgKyAyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSmooYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChhW2IyICsgMiA+PiAwXSB8IDApICE9IDAgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBLaihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBUZShhMiwgYjIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMaihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gT2UoYTIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTWooYzIsIGQyKSB7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMDsKICAgICAgICAgIGUyID0gYzIgKyAyIHwgMDsKICAgICAgICAgIGlmICghKGFbZTIgPj4gMF0gfCAwKSkKICAgICAgICAgICAgYVtlMiA+PiAwXSA9IDE7CiAgICAgICAgICBiW2MyID4+IDFdID0gYltkMiA+PiAxXSB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5qKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHBxKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT2ooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYTIgPSBjW2EyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCkKICAgICAgICAgICAgY2FbY1soY1thMiA+PiAyXSB8IDApICsgNCA+PiAyXSAmIDI1NV0oYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBQaihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyICsgNCA+PiAyXSB8IDApID09IDE3Mzk4ID8gYTIgKyAxMiB8IDAgOiAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFqKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIERhKGEyLCAxNik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFJqKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDA7CiAgICAgICAgICBqMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gajIgKyAxMiB8IDA7CiAgICAgICAgICBmMiA9IGoyOwogICAgICAgICAgYjIgPSBqMiArIDggfCAwOwogICAgICAgICAgaDIgPSBlcSgxNzIpIHwgMDsKICAgICAgICAgIFRqKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIFVqKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNqKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDA7CiAgICAgICAgICBqMiA9IFY7CiAgICAgICAgICBWID0gViArIDMyIHwgMDsKICAgICAgICAgIGUyID0gajIgKyAxMiB8IDA7CiAgICAgICAgICBmMiA9IGoyOwogICAgICAgICAgYjIgPSBqMiArIDggfCAwOwogICAgICAgICAgaDIgPSBlcSgxNzYpIHwgMDsKICAgICAgICAgIGdrKGgyLCBjW2EyICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgZzIgPSBhMiArIDggfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIGhrKGYyLCBoMiwgZTIpOwogICAgICAgICAgaDIgPSBhMiArIDEyIHwgMDsKICAgICAgICAgIGIyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICBpMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGIyID4+PiAwID49IChjW2kyID4+IDJdIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICBiMiA9IChiMiAtIChjW2cyID4+IDJdIHwgMCkgPj4gMykgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGVlKGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgYjIgPj4+IDApCiAgICAgICAgICAgICAgICBjcihnMik7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBrMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSAoY1tpMiA+PiAyXSB8IDApIC0gazIgfCAwOwogICAgICAgICAgICAgICAgaTIgPSBsMiA+PiAyOwogICAgICAgICAgICAgICAgYmUoCiAgICAgICAgICAgICAgICAgIGUyLAogICAgICAgICAgICAgICAgICBsMiA+PiAzID4+PiAwIDwgZDIgPj4+IDEgPj4+IDAgPyBpMiA+Pj4gMCA8IGIyID4+PiAwID8gYjIgOiBpMiA6IGQyLAogICAgICAgICAgICAgICAgICAoY1toMiA+PiAyXSB8IDApIC0gazIgPj4gMywKICAgICAgICAgICAgICAgICAgYTIgKyAxNiB8IDAKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBpMiA9IGUyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBoMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICAgICAgICBhMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGNbYTIgPj4gMl07CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGgyICsgODsKICAgICAgICAgICAgICAgIGNlKGcyLCBlMik7CiAgICAgICAgICAgICAgICBkZShlMik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgJGQoZTIsIGcyLCAxKTsKICAgICAgICAgICAgICBsMiA9IGUyICsgNCB8IDA7CiAgICAgICAgICAgICAgazIgPSBjW2wyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBjW2syID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgICAgICBpMiA9IGYyICsgNCB8IDA7CiAgICAgICAgICAgICAgY1trMiArIDQgPj4gMl0gPSBjW2kyID4+IDJdOwogICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBrMiArIDg7CiAgICAgICAgICAgICAgYWUoZTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBTZChmMik7CiAgICAgICAgICBWID0gajI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRqKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGZlKGEyKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1NDI4OwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFZqKGEyICsgOCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVaihhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBjW2EyID4+IDJdID0gYjI7CiAgICAgICAgICBmMiA9IGVxKDE2KSB8IDA7CiAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gNTQ1MjsKICAgICAgICAgIGNbZjIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBmMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICBYZShhMiwgZTIpOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWaihiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB4ZShiMiwgOCwgMSwgOCwgMCk7CiAgICAgICAgICBtYyhiMiArIDgwIHwgMCwgOCwgMSwgOCwgMCk7CiAgICAgICAgICBhW2IyICsgMTYwID4+IDBdID0gMDsKICAgICAgICAgIGFbYjIgKyAxNjEgPj4gMF0gPSAwOwogICAgICAgICAgWmooYjIgKyAxNjIgfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2ooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDU0Mjg7CiAgICAgICAgICBfaihhMiArIDggfCAwKTsKICAgICAgICAgIGxlKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWGooYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgV2ooYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBZaihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gJGooYTIgKyA4IHwgMCwgY1thMiArIDQgPj4gMl0gfCAwLCBiMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBaaihiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9qKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHFjKGEyICsgODAgfCAwKTsKICAgICAgICAgIHllKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJGooYjIsIGMyLCBlMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBoMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGYyID0gaDI7CiAgICAgICAgICBpZiAoIShhW2IyICsgMTYxID4+IDBdIHwgMCkpCiAgICAgICAgICAgIG9jKGIyICsgODAgfCAwKTsKICAgICAgICAgIGcyID0gYjIgKyAxNjIgfCAwOwogICAgICAgICAgaWYgKGFrKGcyKSB8IDApIHsKICAgICAgICAgICAgYzIgPSAoR2koYjIgKyA4MCB8IDAsIGMyLCBkW2cyID4+IDBdIHwgMCwgMCkgfCAwKSAmIDI1NTsKICAgICAgICAgICAgYVtmMiA+PiAwXSA9IGMyOwogICAgICAgICAgICBVZShjMiwgZTIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgSWkoSGkoYzIpIHwgMCwgZTIsIDEpOwogICAgICAgICAgICBhW2YyID4+IDBdID0gUGUoZTIpIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIGJrKGcyLCBmMik7CiAgICAgICAgICBWID0gaDI7CiAgICAgICAgICByZXR1cm4gZTIgKyAxIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYWsoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChhW2IyICsgMSA+PiAwXSB8IDApICE9IDAgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBiayhiMiwgYzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwOwogICAgICAgICAgZDIgPSBiMiArIDEgfCAwOwogICAgICAgICAgaWYgKCEoYVtkMiA+PiAwXSB8IDApKQogICAgICAgICAgICBhW2QyID4+IDBdID0gMTsKICAgICAgICAgIGFbYjIgPj4gMF0gPSBhW2MyID4+IDBdIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY2soYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkayhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVrKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTc4OTYgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZmsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ2soYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZmUoYTIpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDU0ODA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgaWsoYTIgKyA4IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGhrKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBiMjsKICAgICAgICAgIGYyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgKyA4ID4+IDJdID0gMDsKICAgICAgICAgIGNbZjIgPj4gMl0gPSA1NTA0OwogICAgICAgICAgY1tmMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFhlKGEyLCBlMik7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGlrKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHhlKGIyLCAxNiwgMSwgOCwgMCk7CiAgICAgICAgICBtYyhiMiArIDgwIHwgMCwgMTYsIDEsIDgsIDApOwogICAgICAgICAgYVtiMiArIDE2MCA+PiAwXSA9IDA7CiAgICAgICAgICBhW2IyICsgMTYxID4+IDBdID0gMDsKICAgICAgICAgIG1rKGIyICsgMTYyIHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGprKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1NDgwOwogICAgICAgICAgbmsoYTIgKyA4IHwgMCk7CiAgICAgICAgICBsZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtrKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGprKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGsoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIG9rKGEyICsgOCB8IDAsIGNbYTIgKyA0ID4+IDJdIHwgMCwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbWsoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYVtiMiArIDIgPj4gMF0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBuayhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBxYyhhMiArIDgwIHwgMCk7CiAgICAgICAgICB5ZShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9rKGMyLCBkMiwgZjIpIHsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIHZhciBnMiA9IDAsIGgyID0gMCwgaTIgPSAwOwogICAgICAgICAgaTIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBnMiA9IGkyOwogICAgICAgICAgaWYgKCEoYVtjMiArIDE2MSA+PiAwXSB8IDApKQogICAgICAgICAgICBvYyhjMiArIDgwIHwgMCk7CiAgICAgICAgICBoMiA9IGMyICsgMTYyIHwgMDsKICAgICAgICAgIGlmIChwayhoMikgfCAwKSB7CiAgICAgICAgICAgIGQyID0gKEdpKGMyICsgODAgfCAwLCBkMiwgZVtoMiA+PiAxXSB8IDAsIDApIHwgMCkgJiA2NTUzNTsKICAgICAgICAgICAgYltnMiA+PiAxXSA9IGQyOwogICAgICAgICAgICBUZShkMiwgZjIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgSWkoSGkoZDIpIHwgMCwgZjIsIDIpOwogICAgICAgICAgICBiW2cyID4+IDFdID0gT2UoZjIpIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIHFrKGgyLCBnMik7CiAgICAgICAgICBWID0gaTI7CiAgICAgICAgICByZXR1cm4gZjIgKyAyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcGsoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgcmV0dXJuIChhW2IyICsgMiA+PiAwXSB8IDApICE9IDAgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBxayhjMiwgZDIpIHsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwOwogICAgICAgICAgZTIgPSBjMiArIDIgfCAwOwogICAgICAgICAgaWYgKCEoYVtlMiA+PiAwXSB8IDApKQogICAgICAgICAgICBhW2UyID4+IDBdID0gMTsKICAgICAgICAgIGJbYzIgPj4gMV0gPSBiW2QyID4+IDFdIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcHEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzayhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICBjYVtjWyhjW2EyID4+IDJdIHwgMCkgKyA0ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRrKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiAoKGNbYjIgKyA0ID4+IDJdIHwgMCkgPT0gMTgzOTQgPyBhMiArIDEyIHwgMCA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgRGEoYTIsIDE2KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdmsoKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdrKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBFayhhMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4aygpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5aygpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6ayhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwKSB7CiAgICAgICAgICAgIEZrKGEyKTsKICAgICAgICAgICAganAoYTIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBBaygpIHsKICAgICAgICAgIHJldHVybiBHaygpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQmsoKSB7CiAgICAgICAgICByZXR1cm4gSGsoKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENrKCkgewogICAgICAgICAgcmV0dXJuIElrKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEaygpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFayhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gMzM2MDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRmsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwLCBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBiMjsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2EyID4+IDJdOwogICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICBkMiA9IGEyICsgNCB8IDA7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBjW2QyID4+IDJdID0gMDsKICAgICAgICAgIHdhKGUyKTsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDA7CiAgICAgICAgICBmMiA9IGEyICsgMTIgfCAwOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgY1tmMiA+PiAyXSA9IDA7CiAgICAgICAgICBHYShlMik7CiAgICAgICAgICBHYShkMik7CiAgICAgICAgICB3YShhMik7CiAgICAgICAgICBWID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdrKCkgewogICAgICAgICAgcmV0dXJuIDMzNjA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhrKCkgewogICAgICAgICAgcmV0dXJuIDMzNjg7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIElrKCkgewogICAgICAgICAgcmV0dXJuIDMzODQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEprKCkgewogICAgICAgICAgcmV0dXJuIDE4NTc5OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBLaygpIHsKICAgICAgICAgIHJldHVybiAxODU4MjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTGsoKSB7CiAgICAgICAgICByZXR1cm4gMTg1ODQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE1rKCkgewogICAgICAgICAgdmFyIGEyID0gMDsKICAgICAgICAgIGEyID0gZXEoMTYpIHwgMDsKICAgICAgICAgIFRrKGEyKTsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5rKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGMyID0gMCwgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGMyID0gYjI7CiAgICAgICAgICBlMiA9IEFrKCkgfCAwOwogICAgICAgICAgZDIgPSBQayhjMikgfCAwOwogICAgICAgICAgYzIgPSBRayhjMikgfCAwOwogICAgICAgICAgRShlMiB8IDAsIGQyIHwgMCwgYzIgfCAwLCBKaygpIHwgMCwgMTIsIGEyIHwgMCk7CiAgICAgICAgICBWID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE9rKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBSayhZW2EyICYgM10oKSB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUGsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFrKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBTaygpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUmsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gU2soKSB7CiAgICAgICAgICByZXR1cm4gNTUyNDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVGsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgMTIgPj4gMl0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVayhhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBmMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBoMjsKICAgICAgICAgIGgyID0gQWsoKSB8IDA7CiAgICAgICAgICBnMiA9IFdrKGYyKSB8IDA7CiAgICAgICAgICBmMiA9IFhrKGYyKSB8IDA7CiAgICAgICAgICBiMiA9IGJsKCkgfCAwOwogICAgICAgICAgRihoMiB8IDAsIGEyIHwgMCwgZzIgfCAwLCBmMiB8IDAsIGIyIHwgMCwgNCwgWWsoZTIpIHwgMCwgMCk7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFZrKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gWmsoYjIpIHwgMDsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGEyID0gZzIgKyAoZjIgPj4gMSkgfCAwOwogICAgICAgICAgaWYgKGYyICYgMSkKICAgICAgICAgICAgYjIgPSBjWyhjW2EyID4+IDJdIHwgMCkgKyBiMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IF9rKGQyKSB8IDA7CiAgICAgICAgICBnMiA9ICRrKGUyKSB8IDA7CiAgICAgICAgICBlYVtiMiAmIDE1XShhMiwgZjIsIGcyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2soYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFhrKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhbCgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWWsoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBlcSg4KSB8IDA7CiAgICAgICAgICBkMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2EyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFprKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9rKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uICRrKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFsKCkgewogICAgICAgICAgcmV0dXJuIDE0NDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYmwoKSB7CiAgICAgICAgICByZXR1cm4gMTg1ODc7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGNsKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGYyID0gZDIgKyA4IHwgMDsKICAgICAgICAgIGgyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGgyOwogICAgICAgICAgaDIgPSBBaygpIHwgMDsKICAgICAgICAgIGcyID0gZWwoZjIpIHwgMDsKICAgICAgICAgIGYyID0gZmwoZjIpIHwgMDsKICAgICAgICAgIGIyID0gamwoKSB8IDA7CiAgICAgICAgICBGKGgyIHwgMCwgYTIgfCAwLCBnMiB8IDAsIGYyIHwgMCwgYjIgfCAwLCA3LCBnbChlMikgfCAwLCAwKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZGwoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZjIgPSBaayhiMikgfCAwOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGUyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgYTIgPSBmMiArIChlMiA+PiAxKSB8IDA7CiAgICAgICAgICBpZiAoZTIgJiAxKQogICAgICAgICAgICBiMiA9IGNbKGNbYTIgPj4gMl0gfCAwKSArIGIyID4+IDJdIHwgMDsKICAgICAgICAgIGYyID0gaGwoZDIpIHwgMDsKICAgICAgICAgIGRhW2IyICYgMTVdKGEyLCBmMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAzOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBmbChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gaWwoKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gZXEoOCkgfCAwOwogICAgICAgICAgZDIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBobChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpbCgpIHsKICAgICAgICAgIHJldHVybiA1NTI4OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqbCgpIHsKICAgICAgICAgIHJldHVybiAxODU5MzsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga2woYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgZjIgPSBkMiArIDggfCAwOwogICAgICAgICAgaDIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gaDI7CiAgICAgICAgICBoMiA9IEFrKCkgfCAwOwogICAgICAgICAgZzIgPSBtbChmMikgfCAwOwogICAgICAgICAgZjIgPSBubChmMikgfCAwOwogICAgICAgICAgYjIgPSBybCgpIHwgMDsKICAgICAgICAgIEYoaDIgfCAwLCBhMiB8IDAsIGcyIHwgMCwgZjIgfCAwLCBiMiB8IDAsIDQxLCBvbChlMikgfCAwLCAwKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbGwoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGUyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBlMjsKICAgICAgICAgIGcyID0gWmsoYjIpIHwgMDsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGEyID0gZzIgKyAoZjIgPj4gMSkgfCAwOwogICAgICAgICAgaWYgKGYyICYgMSkKICAgICAgICAgICAgYjIgPSBjWyhjW2EyID4+IDJdIHwgMCkgKyBiMiA+PiAyXSB8IDA7CiAgICAgICAgICBjW2QyID4+IDJdID0gWltiMiAmIDE1XShhMikgfCAwOwogICAgICAgICAgZzIgPSBwbChkMikgfCAwOwogICAgICAgICAgViA9IGUyOwogICAgICAgICAgcmV0dXJuIGcyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbWwoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG5sKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBxbCgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gb2woYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBlcSg4KSB8IDA7CiAgICAgICAgICBkMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2EyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBjW2EyID4+IDJdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcWwoKSB7CiAgICAgICAgICByZXR1cm4gNTU0MDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmwoKSB7CiAgICAgICAgICByZXR1cm4gMTg1OTg7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHNsKCkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0bChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gQWwoYTIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdWwoKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdmwoKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gd2woYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgaWYgKGEyIHwgMCkgewogICAgICAgICAgICBCbChhMik7CiAgICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geGwoKSB7CiAgICAgICAgICByZXR1cm4gQ2woKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHlsKCkgewogICAgICAgICAgcmV0dXJuIERsKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6bCgpIHsKICAgICAgICAgIHJldHVybiBFbCgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQWwoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDM0MDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gYjI7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgZDIgPSBhMiArIDQgfCAwOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDA7CiAgICAgICAgICBXaChlMik7CiAgICAgICAgICBkMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBjW2QyID4+IDJdID0gMDsKICAgICAgICAgIGYyID0gYTIgKyAyMCB8IDA7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgIFVoKGUyKTsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgY1tkMiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGNbZjIgPj4gMl07CiAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgIFVoKGUyKTsKICAgICAgICAgIFVoKGQyKTsKICAgICAgICAgIGJpKGEyICsgOCB8IDApOwogICAgICAgICAgV2goYTIpOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDbCgpIHsKICAgICAgICAgIHJldHVybiAzNDAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEbCgpIHsKICAgICAgICAgIHJldHVybiAzNDA4OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFbCgpIHsKICAgICAgICAgIHJldHVybiAzNDI0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGbCgpIHsKICAgICAgICAgIHZhciBhMiA9IDA7CiAgICAgICAgICBhMiA9IGVxKDI0KSB8IDA7CiAgICAgICAgICBNbChhMik7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHbChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBjMiA9IDAsIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBjMiA9IGIyOwogICAgICAgICAgZTIgPSB4bCgpIHwgMDsKICAgICAgICAgIGQyID0gSWwoYzIpIHwgMDsKICAgICAgICAgIGMyID0gSmwoYzIpIHwgMDsKICAgICAgICAgIEUoZTIgfCAwLCBkMiB8IDAsIGMyIHwgMCwgSmsoKSB8IDAsIDEzLCBhMiB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBIbChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gS2woWVthMiAmIDNdKCkgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIElsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKbChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gTGwoKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIExsKCkgewogICAgICAgICAgcmV0dXJuIDU1NDg7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE1sKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgY1thMiArIDEyID4+IDJdID0gMDsKICAgICAgICAgIGNbYTIgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICBjW2EyICsgMjAgPj4gMl0gPSAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBObChhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDAsIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBkMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZDI7CiAgICAgICAgICBmMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICBoMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbZTIgPj4gMl0gPSBjW2IyID4+IDJdOwogICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSBoMjsKICAgICAgICAgIGgyID0geGwoKSB8IDA7CiAgICAgICAgICBnMiA9IFBsKGYyKSB8IDA7CiAgICAgICAgICBmMiA9IFFsKGYyKSB8IDA7CiAgICAgICAgICBiMiA9IGJsKCkgfCAwOwogICAgICAgICAgRihoMiB8IDAsIGEyIHwgMCwgZzIgfCAwLCBmMiB8IDAsIGIyIHwgMCwgNSwgUmwoZTIpIHwgMCwgMCk7CiAgICAgICAgICBWID0gZDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE9sKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gU2woYjIpIHwgMDsKICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGEyID0gZzIgKyAoZjIgPj4gMSkgfCAwOwogICAgICAgICAgaWYgKGYyICYgMSkKICAgICAgICAgICAgYjIgPSBjWyhjW2EyID4+IDJdIHwgMCkgKyBiMiA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IF9rKGQyKSB8IDA7CiAgICAgICAgICBnMiA9ICRrKGUyKSB8IDA7CiAgICAgICAgICBlYVtiMiAmIDE1XShhMiwgZjIsIGcyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUGwoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBUbCgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUmwoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBlcSg4KSB8IDA7CiAgICAgICAgICBkMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2EyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRsKCkgewogICAgICAgICAgcmV0dXJuIDE2MDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVWwoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgZDIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGQyOwogICAgICAgICAgZjIgPSBkMiArIDggfCAwOwogICAgICAgICAgaDIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tiMiA+PiAyXTsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gaDI7CiAgICAgICAgICBoMiA9IHhsKCkgfCAwOwogICAgICAgICAgZzIgPSBXbChmMikgfCAwOwogICAgICAgICAgZjIgPSBYbChmMikgfCAwOwogICAgICAgICAgYjIgPSBqbCgpIHwgMDsKICAgICAgICAgIEYoaDIgfCAwLCBhMiB8IDAsIGcyIHwgMCwgZjIgfCAwLCBiMiB8IDAsIDgsIFlsKGUyKSB8IDAsIDApOwogICAgICAgICAgViA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWbChhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBmMiA9IFNsKGIyKSB8IDA7CiAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgZTIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBhMiA9IGYyICsgKGUyID4+IDEpIHwgMDsKICAgICAgICAgIGlmIChlMiAmIDEpCiAgICAgICAgICAgIGIyID0gY1soY1thMiA+PiAyXSB8IDApICsgYjIgPj4gMl0gfCAwOwogICAgICAgICAgZjIgPSAkayhkMikgfCAwOwogICAgICAgICAgZGFbYjIgJiAxNV0oYTIsIGYyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV2woYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDM7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFhsKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiBabCgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWWwoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBlcSg4KSB8IDA7CiAgICAgICAgICBkMiA9IGNbYTIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBjW2EyID4+IDJdOwogICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFpsKCkgewogICAgICAgICAgcmV0dXJuIDU1NTI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9sKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMDsKICAgICAgICAgIGQyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZTIgPSBkMjsKICAgICAgICAgIGYyID0gZDIgKyA4IHwgMDsKICAgICAgICAgIGgyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGNbYjIgPj4gMl07CiAgICAgICAgICBjW2UyICsgNCA+PiAyXSA9IGgyOwogICAgICAgICAgaDIgPSB4bCgpIHwgMDsKICAgICAgICAgIGcyID0gYW0oZjIpIHwgMDsKICAgICAgICAgIGYyID0gYm0oZjIpIHwgMDsKICAgICAgICAgIGIyID0gamwoKSB8IDA7CiAgICAgICAgICBGKGgyIHwgMCwgYTIgfCAwLCBnMiB8IDAsIGYyIHwgMCwgYjIgfCAwLCA5LCBjbShlMikgfCAwLCAwKTsKICAgICAgICAgIFYgPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJGwoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZjIgPSBTbChiMikgfCAwOwogICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgIGUyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgYTIgPSBmMiArIChlMiA+PiAxKSB8IDA7CiAgICAgICAgICBpZiAoZTIgJiAxKQogICAgICAgICAgICBiMiA9IGNbKGNbYTIgPj4gMl0gfCAwKSArIGIyID4+IDJdIHwgMDsKICAgICAgICAgIGYyID0gaGwoZDIpIHwgMDsKICAgICAgICAgIGRhW2IyICYgMTVdKGEyLCBmMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAzOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBibShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gZG0oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGNtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gZXEoOCkgfCAwOwogICAgICAgICAgZDIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBjW2IyID4+IDJdID0gY1thMiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gZDI7CiAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkbSgpIHsKICAgICAgICAgIHJldHVybiA1NTY0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlbSgpIHsKICAgICAgICAgIGphKCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZtKCkgewogICAgICAgICAgZ20oKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ20oKSB7CiAgICAgICAgICBobSgyMjE0NCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGhtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBhMjsKICAgICAgICAgIGltKCk7CiAgICAgICAgICBWID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGltKCkgewogICAgICAgICAgTShqbSgpIHwgMCwgMTg2NTMpOwogICAgICAgICAgQyhrbSgpIHwgMCwgMTg2NTgsIDEsIDEsIDApOwogICAgICAgICAgbG0oMTg2NjMpOwogICAgICAgICAgbW0oMTg2NjgpOwogICAgICAgICAgbm0oMTg2ODApOwogICAgICAgICAgb20oMTg2OTQpOwogICAgICAgICAgcG0oMTg3MDApOwogICAgICAgICAgcW0oMTg3MTUpOwogICAgICAgICAgcm0oMTg3MTkpOwogICAgICAgICAgc20oMTg3MzIpOwogICAgICAgICAgdG0oMTg3MzcpOwogICAgICAgICAgdW0oMTg3NTEpOwogICAgICAgICAgdm0oMTg3NTcpOwogICAgICAgICAgSyh3bSgpIHwgMCwgMTg3NjQpOwogICAgICAgICAgSyh4bSgpIHwgMCwgMTg3NzYpOwogICAgICAgICAgTCh5bSgpIHwgMCwgNCwgMTg4MDkpOwogICAgICAgICAgTCh6bSgpIHwgMCwgMiwgMTg4MjIpOwogICAgICAgICAgTChBbSgpIHwgMCwgNCwgMTg4MzcpOwogICAgICAgICAgRyhCbSgpIHwgMCwgMTg4NTIpOwogICAgICAgICAgQ20oMTg4NjgpOwogICAgICAgICAgRG0oMTg4OTgpOwogICAgICAgICAgRW0oMTg5MzUpOwogICAgICAgICAgRm0oMTg5NzQpOwogICAgICAgICAgR20oMTkwMDUpOwogICAgICAgICAgSG0oMTkwNDUpOwogICAgICAgICAgSW0oMTkwNzQpOwogICAgICAgICAgSm0oMTkxMTIpOwogICAgICAgICAgS20oMTkxNDIpOwogICAgICAgICAgRG0oMTkxODEpOwogICAgICAgICAgRW0oMTkyMTMpOwogICAgICAgICAgRm0oMTkyNDYpOwogICAgICAgICAgR20oMTkyNzkpOwogICAgICAgICAgSG0oMTkzMTMpOwogICAgICAgICAgSW0oMTkzNDYpOwogICAgICAgICAgTG0oMTkzODApOwogICAgICAgICAgTW0oMTk0MTEpOwogICAgICAgICAgTm0oMTk0NDMpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqbSgpIHsKICAgICAgICAgIHJldHVybiBfbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga20oKSB7CiAgICAgICAgICByZXR1cm4gWm4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGxtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGEyID0gWG4oKSB8IDA7CiAgICAgICAgICBJKGEyIHwgMCwgY1tkMiA+PiAyXSB8IDAsIDEsIC0xMjggPDwgMjQgPj4gMjQgfCAwLCAxMjcgPDwgMjQgPj4gMjQgfCAwKTsKICAgICAgICAgIFYgPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbW0oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGEyOwogICAgICAgICAgYTIgPSBWbigpIHwgMDsKICAgICAgICAgIEkoYTIgfCAwLCBjW2QyID4+IDJdIHwgMCwgMSwgLTEyOCA8PCAyNCA+PiAyNCB8IDAsIDEyNyA8PCAyNCA+PiAyNCB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBubShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICBjW2QyID4+IDJdID0gYTI7CiAgICAgICAgICBhMiA9IFRuKCkgfCAwOwogICAgICAgICAgSShhMiB8IDAsIGNbZDIgPj4gMl0gfCAwLCAxLCAwLCAyNTUpOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICBjW2QyID4+IDJdID0gYTI7CiAgICAgICAgICBhMiA9IFJuKCkgfCAwOwogICAgICAgICAgSShhMiB8IDAsIGNbZDIgPj4gMl0gfCAwLCAyLCAtMzI3NjggPDwgMTYgPj4gMTYgfCAwLCAzMjc2NyA8PCAxNiA+PiAxNiB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICBjW2QyID4+IDJdID0gYTI7CiAgICAgICAgICBhMiA9IFBuKCkgfCAwOwogICAgICAgICAgSShhMiB8IDAsIGNbZDIgPj4gMl0gfCAwLCAyLCAwLCA2NTUzNSk7CiAgICAgICAgICBWID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHFtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGEyID0gTm4oKSB8IDA7CiAgICAgICAgICBJKGEyIHwgMCwgY1tkMiA+PiAyXSB8IDAsIDQsIC0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3KTsKICAgICAgICAgIFYgPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcm0oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGEyOwogICAgICAgICAgYTIgPSBMbigpIHwgMDsKICAgICAgICAgIEkoYTIgfCAwLCBjW2QyID4+IDJdIHwgMCwgNCwgMCwgLTEpOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICBjW2QyID4+IDJdID0gYTI7CiAgICAgICAgICBhMiA9IEpuKCkgfCAwOwogICAgICAgICAgSShhMiB8IDAsIGNbZDIgPj4gMl0gfCAwLCA0LCAtMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0Nyk7CiAgICAgICAgICBWID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGEyID0gSG4oKSB8IDA7CiAgICAgICAgICBJKGEyIHwgMCwgY1tkMiA+PiAyXSB8IDAsIDQsIDAsIC0xKTsKICAgICAgICAgIFYgPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdW0oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgY1tkMiA+PiAyXSA9IGEyOwogICAgICAgICAgYTIgPSBGbigpIHwgMDsKICAgICAgICAgIEgoYTIgfCAwLCBjW2QyID4+IDJdIHwgMCwgNCk7CiAgICAgICAgICBWID0gYjI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZtKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGEyID0gRG4oKSB8IDA7CiAgICAgICAgICBIKGEyIHwgMCwgY1tkMiA+PiAyXSB8IDAsIDgpOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3bSgpIHsKICAgICAgICAgIHJldHVybiBDbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24geG0oKSB7CiAgICAgICAgICByZXR1cm4gQm4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHltKCkgewogICAgICAgICAgcmV0dXJuIEFuKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6bSgpIHsKICAgICAgICAgIHJldHVybiB6bigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQW0oKSB7CiAgICAgICAgICByZXR1cm4geW4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJtKCkgewogICAgICAgICAgcmV0dXJuIHhuKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gdW4oKSB8IDA7CiAgICAgICAgICBhMiA9IHZuKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gcm4oKSB8IDA7CiAgICAgICAgICBhMiA9IHNuKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gb24oKSB8IDA7CiAgICAgICAgICBhMiA9IHBuKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gbG4oKSB8IDA7CiAgICAgICAgICBhMiA9IG1uKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gaG4oKSB8IDA7CiAgICAgICAgICBhMiA9IGpuKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBIbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gZW4oKSB8IDA7CiAgICAgICAgICBhMiA9IGZuKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBJbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gYm4oKSB8IDA7CiAgICAgICAgICBhMiA9IGNuKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gX20oKSB8IDA7CiAgICAgICAgICBhMiA9ICRtKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBLbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gWG0oKSB8IDA7CiAgICAgICAgICBhMiA9IFltKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gVW0oKSB8IDA7CiAgICAgICAgICBhMiA9IFZtKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBNbShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gUm0oKSB8IDA7CiAgICAgICAgICBhMiA9IFNtKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBObShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgIGUyID0gT20oKSB8IDA7CiAgICAgICAgICBhMiA9IFBtKCkgfCAwOwogICAgICAgICAgSihlMiB8IDAsIGEyIHwgMCwgY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBPbSgpIHsKICAgICAgICAgIHJldHVybiBRbSgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUG0oKSB7CiAgICAgICAgICByZXR1cm4gNzsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUW0oKSB7CiAgICAgICAgICByZXR1cm4gMzQ0MDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUm0oKSB7CiAgICAgICAgICByZXR1cm4gVG0oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNtKCkgewogICAgICAgICAgcmV0dXJuIDc7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRtKCkgewogICAgICAgICAgcmV0dXJuIDM0NDg7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFVtKCkgewogICAgICAgICAgcmV0dXJuIFdtKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWbSgpIHsKICAgICAgICAgIHJldHVybiA2OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBXbSgpIHsKICAgICAgICAgIHJldHVybiAzNDU2OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBYbSgpIHsKICAgICAgICAgIHJldHVybiBabSgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWW0oKSB7CiAgICAgICAgICByZXR1cm4gNTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWm0oKSB7CiAgICAgICAgICByZXR1cm4gMzQ2NDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX20oKSB7CiAgICAgICAgICByZXR1cm4gYW4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uICRtKCkgewogICAgICAgICAgcmV0dXJuIDQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFuKCkgewogICAgICAgICAgcmV0dXJuIDM0NzI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGJuKCkgewogICAgICAgICAgcmV0dXJuIGRuKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBjbigpIHsKICAgICAgICAgIHJldHVybiA1OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkbigpIHsKICAgICAgICAgIHJldHVybiAzNDgwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlbigpIHsKICAgICAgICAgIHJldHVybiBnbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZm4oKSB7CiAgICAgICAgICByZXR1cm4gNDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ24oKSB7CiAgICAgICAgICByZXR1cm4gMzQ4ODsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaG4oKSB7CiAgICAgICAgICByZXR1cm4ga24oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGpuKCkgewogICAgICAgICAgcmV0dXJuIDM7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtuKCkgewogICAgICAgICAgcmV0dXJuIDM0OTY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGxuKCkgewogICAgICAgICAgcmV0dXJuIG5uKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtbigpIHsKICAgICAgICAgIHJldHVybiAyOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBubigpIHsKICAgICAgICAgIHJldHVybiAzNTA0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBvbigpIHsKICAgICAgICAgIHJldHVybiBxbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcG4oKSB7CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcW4oKSB7CiAgICAgICAgICByZXR1cm4gMzUxMjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcm4oKSB7CiAgICAgICAgICByZXR1cm4gdG4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHNuKCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRuKCkgewogICAgICAgICAgcmV0dXJuIDM1MjA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHVuKCkgewogICAgICAgICAgcmV0dXJuIHduKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB2bigpIHsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3bigpIHsKICAgICAgICAgIHJldHVybiAzNTI4OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4bigpIHsKICAgICAgICAgIHJldHVybiAzNTM2OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5bigpIHsKICAgICAgICAgIHJldHVybiAzNTQ0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6bigpIHsKICAgICAgICAgIHJldHVybiAzNTc2OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBBbigpIHsKICAgICAgICAgIHJldHVybiAzNjAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBCbigpIHsKICAgICAgICAgIHJldHVybiAzNjI0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDbigpIHsKICAgICAgICAgIHJldHVybiAzNjQ4OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEbigpIHsKICAgICAgICAgIHJldHVybiBFbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRW4oKSB7CiAgICAgICAgICByZXR1cm4gNDE0NDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRm4oKSB7CiAgICAgICAgICByZXR1cm4gR24oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEduKCkgewogICAgICAgICAgcmV0dXJuIDQxMzY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhuKCkgewogICAgICAgICAgcmV0dXJuIEluKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBJbigpIHsKICAgICAgICAgIHJldHVybiA0MTI4OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKbigpIHsKICAgICAgICAgIHJldHVybiBLbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gS24oKSB7CiAgICAgICAgICByZXR1cm4gNDEyMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTG4oKSB7CiAgICAgICAgICByZXR1cm4gTW4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE1uKCkgewogICAgICAgICAgcmV0dXJuIDQxMTI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5uKCkgewogICAgICAgICAgcmV0dXJuIE9uKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBPbigpIHsKICAgICAgICAgIHJldHVybiA0MTA0OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBQbigpIHsKICAgICAgICAgIHJldHVybiBRbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUW4oKSB7CiAgICAgICAgICByZXR1cm4gNDA5NjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUm4oKSB7CiAgICAgICAgICByZXR1cm4gU24oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNuKCkgewogICAgICAgICAgcmV0dXJuIDQwODg7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRuKCkgewogICAgICAgICAgcmV0dXJuIFVuKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVbigpIHsKICAgICAgICAgIHJldHVybiA0MDcyOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWbigpIHsKICAgICAgICAgIHJldHVybiBXbigpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV24oKSB7CiAgICAgICAgICByZXR1cm4gNDA4MDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWG4oKSB7CiAgICAgICAgICByZXR1cm4gWW4oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFluKCkgewogICAgICAgICAgcmV0dXJuIDQwNjQ7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFpuKCkgewogICAgICAgICAgcmV0dXJuIDQwNTY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9uKCkgewogICAgICAgICAgcmV0dXJuIDQwNDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uICRuKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGQyID0gYjIgKyA4IHwgMDsKICAgICAgICAgIGUyID0gYjIgKyA0IHwgMDsKICAgICAgICAgIGYyID0gYjI7CiAgICAgICAgICBjW2YyID4+IDJdID0gYTI7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBjWyhjW2UyID4+IDJdIHwgMCkgKyA0ID4+IDJdOwogICAgICAgICAgYTIgPSBKbyhjW2QyID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYW8oKSB7CiAgICAgICAgICByZXR1cm4gMjE2MzY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGJvKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAoYTIgKyAtNDggfCAwKSA+Pj4gMCA8IDEwIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY28oKSB7CiAgICAgICAgICByZXR1cm4gNTU3NjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZW8oYjIsIGMyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgZDIgPSBhW2IyID4+IDBdIHwgMDsKICAgICAgICAgIGUyID0gYVtjMiA+PiAwXSB8IDA7CiAgICAgICAgICBpZiAoZDIgPDwgMjQgPj4gMjQgPT0gMCA/IDEgOiBkMiA8PCAyNCA+PiAyNCAhPSBlMiA8PCAyNCA+PiAyNCkKICAgICAgICAgICAgYjIgPSBlMjsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgICAgIGMyID0gYzIgKyAxIHwgMDsKICAgICAgICAgICAgICBkMiA9IGFbYjIgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGUyID0gYVtjMiA+PiAwXSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKCEoZDIgPDwgMjQgPj4gMjQgPT0gMCA/IDEgOiBkMiA8PCAyNCA+PiAyNCAhPSBlMiA8PCAyNCA+PiAyNCkpOwogICAgICAgICAgICBiMiA9IGUyOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIChkMiAmIDI1NSkgLSAoYjIgJiAyNTUpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZm8oYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBmMiA9IGIyOwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoIShmMiAmIDMpKQogICAgICAgICAgICAgICAgZTIgPSA1OwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgZDIgPSBmMjsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIGlmICghKGFbYjIgPj4gMF0gfCAwKSkgewogICAgICAgICAgICAgICAgICAgIGIyID0gZDI7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBiMiA9IGIyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICAgICAgICAgIGlmICghKGQyICYgMykpIHsKICAgICAgICAgICAgICAgICAgICBlMiA9IDU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIGlmICgoZTIgfCAwKSA9PSA1KSB7CiAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgZDIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoISgoZDIgJiAtMjEzOTA2MjE0NCBeIC0yMTM5MDYyMTQ0KSAmIGQyICsgLTE2ODQzMDA5KSkKICAgICAgICAgICAgICAgIGIyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoKGQyICYgMjU1KSA8PCAyNCA+PiAyNCkKICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgICAgIHdoaWxlICgoYVtiMiA+PiAwXSB8IDApICE9IDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGIyIC0gZjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBnbyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGhvKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpbyhiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBkMiA9IGIyICsgNzQgfCAwOwogICAgICAgICAgZTIgPSBhW2QyID4+IDBdIHwgMDsKICAgICAgICAgIGFbZDIgPj4gMF0gPSBlMiArIDI1NSB8IGUyOwogICAgICAgICAgZDIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICghKGQyICYgOCkpIHsKICAgICAgICAgICAgY1tiMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgIGUyID0gY1tiMiArIDQ0ID4+IDJdIHwgMDsKICAgICAgICAgICAgY1tiMiArIDI4ID4+IDJdID0gZTI7CiAgICAgICAgICAgIGNbYjIgKyAyMCA+PiAyXSA9IGUyOwogICAgICAgICAgICBjW2IyICsgMTYgPj4gMl0gPSBlMiArIChjW2IyICsgNDggPj4gMl0gfCAwKTsKICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGQyIHwgMzI7CiAgICAgICAgICAgIGIyID0gLTE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqbyhiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDA7CiAgICAgICAgICBmMiA9IGUyICsgMTYgfCAwOwogICAgICAgICAgZzIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgIGlmICghZzIpCiAgICAgICAgICAgIGlmICghKGlvKGUyKSB8IDApKSB7CiAgICAgICAgICAgICAgZzIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBoMiA9IDU7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIGYyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgaDIgPSA1OwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoKGgyIHwgMCkgPT0gNSkgewogICAgICAgICAgICAgICAgajIgPSBlMiArIDIwIHwgMDsKICAgICAgICAgICAgICAgIGkyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBmMiA9IGkyOwogICAgICAgICAgICAgICAgaWYgKChnMiAtIGkyIHwgMCkgPj4+IDAgPCBkMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgICBmMiA9IGFhW2NbZTIgKyAzNiA+PiAyXSAmIDddKGUyLCBiMiwgZDIpIHwgMDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBiOgogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmICgoYVtlMiArIDc1ID4+IDBdIHwgMCkgPCAwIHwgKGQyIHwgMCkgPT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgaDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgZzIgPSBiMjsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgaTIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gaTIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYVtiMiArIGcyID4+IDBdIHwgMCkgPT0gMTApCiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZzIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBoMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZzIgPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICBpMiA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZjIgPSBhYVtjW2UyICsgMzYgPj4gMl0gJiA3XShlMiwgYjIsIGkyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoZjIgPj4+IDAgPCBpMiA+Pj4gMCkKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gaTI7CiAgICAgICAgICAgICAgICAgICAgICBnMiA9IGIyICsgaTIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgZDIgPSBkMiAtIGkyIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGYyID0gY1tqMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICB1cihmMiB8IDAsIGcyIHwgMCwgZDIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0gKGNbajIgPj4gMl0gfCAwKSArIGQyOwogICAgICAgICAgICAgICAgZjIgPSBoMiArIGQyIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHJldHVybiBmMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtvKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGlmICghYjIpCiAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYjIgPSBsbyhjW2IyID4+IDJdIHwgMCwgY1tiMiArIDQgPj4gMl0gfCAwLCBhMikgfCAwOwogICAgICAgICAgcmV0dXJuICgoYjIgfCAwKSA9PSAwID8gYTIgOiBiMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsbyhiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwOwogICAgICAgICAgbzIgPSAoY1tiMiA+PiAyXSB8IDApICsgMTc5NDg5NTEzOCB8IDA7CiAgICAgICAgICBoMiA9IG1vKGNbYjIgKyA4ID4+IDJdIHwgMCwgbzIpIHwgMDsKICAgICAgICAgIGYyID0gbW8oY1tiMiArIDEyID4+IDJdIHwgMCwgbzIpIHwgMDsKICAgICAgICAgIGcyID0gbW8oY1tiMiArIDE2ID4+IDJdIHwgMCwgbzIpIHwgMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKChoMiA+Pj4gMCA8IGQyID4+PiAyID4+PiAwID8gKG4yID0gZDIgLSAoaDIgPDwgMikgfCAwLCBmMiA+Pj4gMCA8IG4yID4+PiAwICYgZzIgPj4+IDAgPCBuMiA+Pj4gMCkgOiAwKSA/ICgoZzIgfCBmMikgJiAzIHwgMCkgPT0gMCA6IDApIHsKICAgICAgICAgICAgICAgIG4yID0gZjIgPj4+IDI7CiAgICAgICAgICAgICAgICBtMiA9IGcyID4+PiAyOwogICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgajIgPSBoMiA+Pj4gMTsKICAgICAgICAgICAgICAgICAgazIgPSBsMiArIGoyIHwgMDsKICAgICAgICAgICAgICAgICAgaTIgPSBrMiA8PCAxOwogICAgICAgICAgICAgICAgICBnMiA9IGkyICsgbjIgfCAwOwogICAgICAgICAgICAgICAgICBmMiA9IG1vKGNbYjIgKyAoZzIgPDwgMikgPj4gMl0gfCAwLCBvMikgfCAwOwogICAgICAgICAgICAgICAgICBnMiA9IG1vKGNbYjIgKyAoZzIgKyAxIDw8IDIpID4+IDJdIHwgMCwgbzIpIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKCEoZzIgPj4+IDAgPCBkMiA+Pj4gMCAmIGYyID4+PiAwIDwgKGQyIC0gZzIgfCAwKSA+Pj4gMCkpIHsKICAgICAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoYVtiMiArIChnMiArIGYyKSA+PiAwXSB8IDApIHsKICAgICAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmMiA9IGVvKGUyLCBiMiArIGcyIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICBpZiAoIWYyKQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBmMiA9IChmMiB8IDApIDwgMDsKICAgICAgICAgICAgICAgICAgaWYgKChoMiB8IDApID09IDEpIHsKICAgICAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBsMiA9IGYyID8gbDIgOiBrMjsKICAgICAgICAgICAgICAgICAgaDIgPSBmMiA/IGoyIDogaDIgLSBqMiB8IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmMiA9IGkyICsgbTIgfCAwOwogICAgICAgICAgICAgICAgZzIgPSBtbyhjW2IyICsgKGYyIDw8IDIpID4+IDJdIHwgMCwgbzIpIHwgMDsKICAgICAgICAgICAgICAgIGYyID0gbW8oY1tiMiArIChmMiArIDEgPDwgMikgPj4gMl0gfCAwLCBvMikgfCAwOwogICAgICAgICAgICAgICAgaWYgKGYyID4+PiAwIDwgZDIgPj4+IDAgJiBnMiA+Pj4gMCA8IChkMiAtIGYyIHwgMCkgPj4+IDApCiAgICAgICAgICAgICAgICAgIGYyID0gKGFbYjIgKyAoZjIgKyBnMikgPj4gMF0gfCAwKSA9PSAwID8gYjIgKyBmMiB8IDAgOiAwOwogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHJldHVybiBmMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1vKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBjMiA9IDA7CiAgICAgICAgICBjMiA9IHRyKGEyIHwgMCkgfCAwOwogICAgICAgICAgcmV0dXJuICgoYjIgfCAwKSA9PSAwID8gYTIgOiBjMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBubyhiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMDsKICAgICAgICAgIGgyID0gZDIgJiAyNTU7CiAgICAgICAgICBmMiA9IChlMiB8IDApICE9IDA7CiAgICAgICAgICBhOgogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmIChmMiAmIChiMiAmIDMgfCAwKSAhPSAwKSB7CiAgICAgICAgICAgICAgICBnMiA9IGQyICYgMjU1OwogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgaWYgKChhW2IyID4+IDBdIHwgMCkgPT0gZzIgPDwgMjQgPj4gMjQpIHsKICAgICAgICAgICAgICAgICAgICBnMiA9IDY7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBiMiA9IGIyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIGUyID0gZTIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgIGYyID0gKGUyIHwgMCkgIT0gMDsKICAgICAgICAgICAgICAgICAgaWYgKCEoZjIgJiAoYjIgJiAzIHwgMCkgIT0gMCkpIHsKICAgICAgICAgICAgICAgICAgICBnMiA9IDU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIGcyID0gNTsKICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgaWYgKChnMiB8IDApID09IDUpCiAgICAgICAgICAgIGlmIChmMikKICAgICAgICAgICAgICBnMiA9IDY7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICBiMiA9IDA7CiAgICAgICAgICBiOgogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmICgoZzIgfCAwKSA9PSA2KSB7CiAgICAgICAgICAgICAgICBpZiAoKGFbYjIgPj4gMF0gfCAwKSAhPSAoZDIgJiAyNTUpIDw8IDI0ID4+IDI0KSB7CiAgICAgICAgICAgICAgICAgIGYyID0gcShoMiwgMTY4NDMwMDkpIHwgMDsKICAgICAgICAgICAgICAgICAgYzoKICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgaWYgKGUyID4+PiAwID4gMykKICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gY1tiMiA+PiAyXSBeIGYyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaDIgJiAtMjEzOTA2MjE0NCBeIC0yMTM5MDYyMTQ0KSAmIGgyICsgLTE2ODQzMDA5IHwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBiMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZTIgKyAtNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUyID4+PiAwID4gMyk7CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKCFlMikKICAgICAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgIGYyID0gZDIgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKChhW2IyID4+IDBdIHwgMCkgPT0gZjIgPDwgMjQgPj4gMjQpCiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiOwogICAgICAgICAgICAgICAgICAgIGUyID0gZTIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFlMikgewogICAgICAgICAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICBiMiA9IGIyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9vKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHJldHVybiBybyhhMiwgYjIsIGMyLCAxLCA4KSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHBvKGIyLCBlMiwgZjIsIGcyLCBoMiwgaTIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZTIgPSArZTI7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgaDIgPSBoMiB8IDA7CiAgICAgICAgICBpMiA9IGkyIHwgMDsKICAgICAgICAgIHZhciBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwLCBwMiA9IDAsIHIyID0gMCwgczIgPSAwLCB0MiA9IDAsIHYyID0gMCwgdzIgPSAwLCB4MiA9IDAsIHkyID0gMCwgejIgPSAwLCBBMiA9IDAsIEIyID0gMCwgQzIgPSAwLCBEMiA9IDAsIEUyID0gMCwgRjIgPSAwLCBHMiA9IDAsIEgyID0gMDsKICAgICAgICAgIEgyID0gVjsKICAgICAgICAgIFYgPSBWICsgNTYwIHwgMDsKICAgICAgICAgIGwyID0gSDIgKyAzMiB8IDA7CiAgICAgICAgICB3MiA9IEgyICsgNTM2IHwgMDsKICAgICAgICAgIEcyID0gSDI7CiAgICAgICAgICBGMiA9IEcyOwogICAgICAgICAgbTIgPSBIMiArIDU0MCB8IDA7CiAgICAgICAgICBjW3cyID4+IDJdID0gMDsKICAgICAgICAgIEUyID0gbTIgKyAxMiB8IDA7CiAgICAgICAgICBEbyhlMikgfCAwOwogICAgICAgICAgajIgPSB1KCkgfCAwOwogICAgICAgICAgaWYgKChqMiB8IDApIDwgMCkgewogICAgICAgICAgICBlMiA9IC1lMjsKICAgICAgICAgICAgRG8oZTIpIHwgMDsKICAgICAgICAgICAgRDIgPSAxOwogICAgICAgICAgICBDMiA9IDIwMjQ3OwogICAgICAgICAgICBqMiA9IHUoKSB8IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBEMiA9IChoMiAmIDIwNDkgfCAwKSAhPSAwICYgMTsKICAgICAgICAgICAgQzIgPSAoaDIgJiAyMDQ4IHwgMCkgPT0gMCA/IChoMiAmIDEgfCAwKSA9PSAwID8gMjAyNDggOiAyMDI1MyA6IDIwMjUwOwogICAgICAgICAgfQogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKHRydWUgJiAoajIgJiAyMTQ2NDM1MDcyIHwgMCkgPT0gMjE0NjQzNTA3MikgewogICAgICAgICAgICAgIEcyID0gKGkyICYgMzIgfCAwKSAhPSAwOwogICAgICAgICAgICAgIGoyID0gRDIgKyAzIHwgMDsKICAgICAgICAgICAgICB6byhiMiwgMzIsIGYyLCBqMiwgaDIgJiAtNjU1MzcpOwogICAgICAgICAgICAgIHRvKGIyLCBDMiwgRDIpOwogICAgICAgICAgICAgIHRvKGIyLCBlMiAhPSBlMiB8IGZhbHNlID8gRzIgPyAyMDI3NCA6IDIwMjc4IDogRzIgPyAyMDI2NiA6IDIwMjcwLCAzKTsKICAgICAgICAgICAgICB6byhiMiwgMzIsIGYyLCBqMiwgaDIgXiA4MTkyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByMiA9ICtFbyhlMiwgdzIpICogMjsKICAgICAgICAgICAgICBqMiA9IHIyICE9IDA7CiAgICAgICAgICAgICAgaWYgKGoyKQogICAgICAgICAgICAgICAgY1t3MiA+PiAyXSA9IChjW3cyID4+IDJdIHwgMCkgKyAtMTsKICAgICAgICAgICAgICB2MiA9IGkyIHwgMzI7CiAgICAgICAgICAgICAgaWYgKCh2MiB8IDApID09IDk3KSB7CiAgICAgICAgICAgICAgICBvMiA9IGkyICYgMzI7CiAgICAgICAgICAgICAgICBzMiA9IChvMiB8IDApID09IDAgPyBDMiA6IEMyICsgOSB8IDA7CiAgICAgICAgICAgICAgICBwMiA9IEQyIHwgMjsKICAgICAgICAgICAgICAgIGoyID0gMTIgLSBnMiB8IDA7CiAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICBpZiAoIShnMiA+Pj4gMCA+IDExIHwgKGoyIHwgMCkgPT0gMCkpIHsKICAgICAgICAgICAgICAgICAgICBlMiA9IDg7CiAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgajIgPSBqMiArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gZTIgKiAxNjsKICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoajIgfCAwKSAhPSAwKTsKICAgICAgICAgICAgICAgICAgICBpZiAoKGFbczIgPj4gMF0gfCAwKSA9PSA0NSkgewogICAgICAgICAgICAgICAgICAgICAgZTIgPSAtKGUyICsgKC1yMiAtIGUyKSk7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgZTIgPSByMiArIGUyIC0gZTI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgIGUyID0gcjI7CiAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICBrMiA9IGNbdzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgajIgPSAoazIgfCAwKSA8IDAgPyAwIC0gazIgfCAwIDogazI7CiAgICAgICAgICAgICAgICBqMiA9IHlvKGoyLCAoKGoyIHwgMCkgPCAwKSA8PCAzMSA+PiAzMSwgRTIpIHwgMDsKICAgICAgICAgICAgICAgIGlmICgoajIgfCAwKSA9PSAoRTIgfCAwKSkgewogICAgICAgICAgICAgICAgICBqMiA9IG0yICsgMTEgfCAwOwogICAgICAgICAgICAgICAgICBhW2oyID4+IDBdID0gNDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBhW2oyICsgLTEgPj4gMF0gPSAoazIgPj4gMzEgJiAyKSArIDQzOwogICAgICAgICAgICAgICAgbjIgPSBqMiArIC0yIHwgMDsKICAgICAgICAgICAgICAgIGFbbjIgPj4gMF0gPSBpMiArIDE1OwogICAgICAgICAgICAgICAgazIgPSAoZzIgfCAwKSA8IDE7CiAgICAgICAgICAgICAgICBsMiA9IChoMiAmIDggfCAwKSA9PSAwOwogICAgICAgICAgICAgICAgbTIgPSBHMjsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgRDIgPSB+fmUyOwogICAgICAgICAgICAgICAgICBqMiA9IG0yICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIGFbbTIgPj4gMF0gPSBvMiB8IGRbNjQwICsgRDIgPj4gMF07CiAgICAgICAgICAgICAgICAgIGUyID0gKGUyIC0gKyhEMiB8IDApKSAqIDE2OwogICAgICAgICAgICAgICAgICBpZiAoKGoyIC0gRjIgfCAwKSA9PSAxID8gIShsMiAmIChrMiAmIGUyID09IDApKSA6IDApIHsKICAgICAgICAgICAgICAgICAgICBhW2oyID4+IDBdID0gNDY7CiAgICAgICAgICAgICAgICAgICAgbTIgPSBtMiArIDIgfCAwOwogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICBtMiA9IGoyOwogICAgICAgICAgICAgICAgfSB3aGlsZSAoZTIgIT0gMCk7CiAgICAgICAgICAgICAgICBpZiAoKGcyIHwgMCkgIT0gMCA/ICgtMiAtIEYyICsgbTIgfCAwKSA8IChnMiB8IDApIDogMCkgewogICAgICAgICAgICAgICAgICBrMiA9IEUyOwogICAgICAgICAgICAgICAgICBsMiA9IG4yOwogICAgICAgICAgICAgICAgICBqMiA9IGcyICsgMiArIGsyIC0gbDIgfCAwOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgazIgPSBFMjsKICAgICAgICAgICAgICAgICAgbDIgPSBuMjsKICAgICAgICAgICAgICAgICAgajIgPSBrMiAtIEYyIC0gbDIgKyBtMiB8IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBFMiA9IGoyICsgcDIgfCAwOwogICAgICAgICAgICAgICAgem8oYjIsIDMyLCBmMiwgRTIsIGgyKTsKICAgICAgICAgICAgICAgIHRvKGIyLCBzMiwgcDIpOwogICAgICAgICAgICAgICAgem8oYjIsIDQ4LCBmMiwgRTIsIGgyIF4gNjU1MzYpOwogICAgICAgICAgICAgICAgRjIgPSBtMiAtIEYyIHwgMDsKICAgICAgICAgICAgICAgIHRvKGIyLCBHMiwgRjIpOwogICAgICAgICAgICAgICAgRzIgPSBrMiAtIGwyIHwgMDsKICAgICAgICAgICAgICAgIHpvKGIyLCA0OCwgajIgLSAoRjIgKyBHMikgfCAwLCAwLCAwKTsKICAgICAgICAgICAgICAgIHRvKGIyLCBuMiwgRzIpOwogICAgICAgICAgICAgICAgem8oYjIsIDMyLCBmMiwgRTIsIGgyIF4gODE5Mik7CiAgICAgICAgICAgICAgICBqMiA9IEUyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGsyID0gKGcyIHwgMCkgPCAwID8gNiA6IGcyOwogICAgICAgICAgICAgIGlmIChqMikgewogICAgICAgICAgICAgICAgajIgPSAoY1t3MiA+PiAyXSB8IDApICsgLTI4IHwgMDsKICAgICAgICAgICAgICAgIGNbdzIgPj4gMl0gPSBqMjsKICAgICAgICAgICAgICAgIGUyID0gcjIgKiAyNjg0MzU0NTY7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGUyID0gcjI7CiAgICAgICAgICAgICAgICBqMiA9IGNbdzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBCMiA9IChqMiB8IDApIDwgMCA/IGwyIDogbDIgKyAyODggfCAwOwogICAgICAgICAgICAgIGwyID0gQjI7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgejIgPSB+fmUyID4+PiAwOwogICAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IHoyOwogICAgICAgICAgICAgICAgbDIgPSBsMiArIDQgfCAwOwogICAgICAgICAgICAgICAgZTIgPSAoZTIgLSArKHoyID4+PiAwKSkgKiAxZTk7CiAgICAgICAgICAgICAgfSB3aGlsZSAoZTIgIT0gMCk7CiAgICAgICAgICAgICAgejIgPSBCMjsKICAgICAgICAgICAgICBpZiAoKGoyIHwgMCkgPiAwKSB7CiAgICAgICAgICAgICAgICBvMiA9IEIyOwogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgbjIgPSAoajIgfCAwKSA8IDI5ID8gajIgOiAyOTsKICAgICAgICAgICAgICAgICAgajIgPSBsMiArIC00IHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKGoyID4+PiAwID49IG8yID4+PiAwKSB7CiAgICAgICAgICAgICAgICAgICAgbTIgPSAwOwogICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgIHQyID0gcnIoY1tqMiA+PiAyXSB8IDAsIDAsIG4yIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgdDIgPSBscih0MiB8IDAsIHUoKSB8IDAsIG0yIHwgMCwgMCkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgeDIgPSB1KCkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgbTIgPSBwcih0MiB8IDAsIHgyIHwgMCwgMWU5LCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICB5MiA9IGtyKG0yIHwgMCwgdSgpIHwgMCwgMWU5LCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICB5MiA9IG1yKHQyIHwgMCwgeDIgfCAwLCB5MiB8IDAsIHUoKSB8IDApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIHUoKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2oyID4+IDJdID0geTI7CiAgICAgICAgICAgICAgICAgICAgICBqMiA9IGoyICsgLTQgfCAwOwogICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGoyID4+PiAwID49IG8yID4+PiAwKTsKICAgICAgICAgICAgICAgICAgICBpZiAobTIpIHsKICAgICAgICAgICAgICAgICAgICAgIHkyID0gbzIgKyAtNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW3kyID4+IDJdID0gbTI7CiAgICAgICAgICAgICAgICAgICAgICBtMiA9IHkyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgICAgbTIgPSBvMjsKICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgbTIgPSBvMjsKICAgICAgICAgICAgICAgICAgYToKICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgaWYgKGwyID4+PiAwID4gbTIgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgajIgPSBsMjsKICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBsMiA9IGoyICsgLTQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjW2wyID4+IDJdIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBqMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsMiA+Pj4gMCA+IG0yID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgajIgPSBsMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgajIgPSAoY1t3MiA+PiAyXSB8IDApIC0gbjIgfCAwOwogICAgICAgICAgICAgICAgICBjW3cyID4+IDJdID0gajI7CiAgICAgICAgICAgICAgICAgIGlmICgoajIgfCAwKSA+IDApCiAgICAgICAgICAgICAgICAgICAgbzIgPSBtMjsKICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgbTIgPSBCMjsKICAgICAgICAgICAgICBpZiAoKGoyIHwgMCkgPCAwKSB7CiAgICAgICAgICAgICAgICBnMiA9ICgoazIgKyAyNSB8IDApIC8gOSB8IDApICsgMSB8IDA7CiAgICAgICAgICAgICAgICB0MiA9ICh2MiB8IDApID09IDEwMjsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgczIgPSAwIC0gajIgfCAwOwogICAgICAgICAgICAgICAgICBzMiA9IChzMiB8IDApIDwgOSA/IHMyIDogOTsKICAgICAgICAgICAgICAgICAgaWYgKG0yID4+PiAwIDwgbDIgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICBuMiA9ICgxIDw8IHMyKSArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgICBvMiA9IDFlOSA+Pj4gczI7CiAgICAgICAgICAgICAgICAgICAgcDIgPSAwOwogICAgICAgICAgICAgICAgICAgIGoyID0gbTI7CiAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgeTIgPSBjW2oyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSAoeTIgPj4+IHMyKSArIHAyOwogICAgICAgICAgICAgICAgICAgICAgcDIgPSBxKHkyICYgbjIsIG8yKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBqMiA9IGoyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoajIgPj4+IDAgPCBsMiA+Pj4gMCk7CiAgICAgICAgICAgICAgICAgICAgbTIgPSAoY1ttMiA+PiAyXSB8IDApID09IDAgPyBtMiArIDQgfCAwIDogbTI7CiAgICAgICAgICAgICAgICAgICAgaWYgKHAyKSB7CiAgICAgICAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gcDI7CiAgICAgICAgICAgICAgICAgICAgICBsMiA9IGwyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICBtMiA9IChjW20yID4+IDJdIHwgMCkgPT0gMCA/IG0yICsgNCB8IDAgOiBtMjsKICAgICAgICAgICAgICAgICAgajIgPSB0MiA/IEIyIDogbTI7CiAgICAgICAgICAgICAgICAgIGwyID0gKGwyIC0gajIgPj4gMiB8IDApID4gKGcyIHwgMCkgPyBqMiArIChnMiA8PCAyKSB8IDAgOiBsMjsKICAgICAgICAgICAgICAgICAgajIgPSAoY1t3MiA+PiAyXSB8IDApICsgczIgfCAwOwogICAgICAgICAgICAgICAgICBjW3cyID4+IDJdID0gajI7CiAgICAgICAgICAgICAgICB9IHdoaWxlICgoajIgfCAwKSA8IDApOwogICAgICAgICAgICAgICAgdDIgPSBtMjsKICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIHQyID0gbTI7CiAgICAgICAgICAgICAgaWYgKHQyID4+PiAwIDwgbDIgPj4+IDApIHsKICAgICAgICAgICAgICAgIGoyID0gKHoyIC0gdDIgPj4gMikgKiA5IHwgMDsKICAgICAgICAgICAgICAgIG4yID0gY1t0MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBpZiAobjIgPj4+IDAgPj0gMTApIHsKICAgICAgICAgICAgICAgICAgbTIgPSAxMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIG0yID0gbTIgKiAxMCB8IDA7CiAgICAgICAgICAgICAgICAgICAgajIgPSBqMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICB9IHdoaWxlIChuMiA+Pj4gMCA+PSBtMiA+Pj4gMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBqMiA9IDA7CiAgICAgICAgICAgICAgeDIgPSAodjIgfCAwKSA9PSAxMDM7CiAgICAgICAgICAgICAgeTIgPSAoazIgfCAwKSAhPSAwOwogICAgICAgICAgICAgIG0yID0gazIgLSAoKHYyIHwgMCkgPT0gMTAyID8gMCA6IGoyKSArICgoeTIgJiB4MikgPDwgMzEgPj4gMzEpIHwgMDsKICAgICAgICAgICAgICBpZiAoKG0yIHwgMCkgPCAoKChsMiAtIHoyID4+IDIpICogOSB8IDApICsgLTkgfCAwKSkgewogICAgICAgICAgICAgICAgdzIgPSBtMiArIDkyMTYgfCAwOwogICAgICAgICAgICAgICAgbTIgPSAodzIgfCAwKSAvIDkgfCAwOwogICAgICAgICAgICAgICAgZzIgPSBCMiArIDQgKyAobTIgKyAtMTAyNCA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICBtMiA9IHcyIC0gKG0yICogOSB8IDApIHwgMDsKICAgICAgICAgICAgICAgIGlmICgobTIgfCAwKSA8IDgpIHsKICAgICAgICAgICAgICAgICAgbjIgPSAxMDsKICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICBuMiA9IG4yICogMTAgfCAwOwogICAgICAgICAgICAgICAgICAgIGlmICgobTIgfCAwKSA8IDcpCiAgICAgICAgICAgICAgICAgICAgICBtMiA9IG0yICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICBuMiA9IDEwOwogICAgICAgICAgICAgICAgcDIgPSBjW2cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIG0yID0gKHAyID4+PiAwKSAvIChuMiA+Pj4gMCkgfCAwOwogICAgICAgICAgICAgICAgczIgPSBwMiAtIChxKG0yLCBuMikgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICBvMiA9IChnMiArIDQgfCAwKSA9PSAobDIgfCAwKTsKICAgICAgICAgICAgICAgIGlmICghKG8yICYgKHMyIHwgMCkgPT0gMCkpIHsKICAgICAgICAgICAgICAgICAgcjIgPSAobTIgJiAxIHwgMCkgPT0gMCA/IDkwMDcxOTkyNTQ3NDA5OTIgOiA5MDA3MTk5MjU0NzQwOTk0OwogICAgICAgICAgICAgICAgICB3MiA9IG4yID4+PiAxOwogICAgICAgICAgICAgICAgICBlMiA9IHMyID4+PiAwIDwgdzIgPj4+IDAgPyAwLjUgOiBvMiAmIChzMiB8IDApID09ICh3MiB8IDApID8gMSA6IDEuNTsKICAgICAgICAgICAgICAgICAgaWYgKEQyKSB7CiAgICAgICAgICAgICAgICAgICAgdzIgPSAoYVtDMiA+PiAwXSB8IDApID09IDQ1OwogICAgICAgICAgICAgICAgICAgIGUyID0gdzIgPyAtZTIgOiBlMjsKICAgICAgICAgICAgICAgICAgICByMiA9IHcyID8gLXIyIDogcjI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgbTIgPSBwMiAtIHMyIHwgMDsKICAgICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IG0yOwogICAgICAgICAgICAgICAgICBpZiAocjIgKyBlMiAhPSByMikgewogICAgICAgICAgICAgICAgICAgIHcyID0gbTIgKyBuMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tnMiA+PiAyXSA9IHcyOwogICAgICAgICAgICAgICAgICAgIGlmICh3MiA+Pj4gMCA+IDk5OTk5OTk5OSkgewogICAgICAgICAgICAgICAgICAgICAgbjIgPSBnMjsKICAgICAgICAgICAgICAgICAgICAgIGoyID0gdDI7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgICBtMiA9IG4yICsgLTQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjW24yID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0yID4+PiAwIDwgajIgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBqMiA9IGoyICsgLTQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHcyID0gKGNbbTIgPj4gMl0gfCAwKSArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjW20yID4+IDJdID0gdzI7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3MiA+Pj4gMCA+IDk5OTk5OTk5OSkKICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IG0yOwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IGoyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIG0yID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICBuMiA9IHQyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBqMiA9ICh6MiAtIG4yID4+IDIpICogOSB8IDA7CiAgICAgICAgICAgICAgICAgICAgcDIgPSBjW24yID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAocDIgPj4+IDAgPj0gMTApIHsKICAgICAgICAgICAgICAgICAgICAgIG8yID0gMTA7CiAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgIG8yID0gbzIgKiAxMCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGoyID0gajIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHAyID4+PiAwID49IG8yID4+PiAwKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgbTIgPSBnMjsKICAgICAgICAgICAgICAgICAgICBuMiA9IHQyOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBtMiA9IGcyOwogICAgICAgICAgICAgICAgICBuMiA9IHQyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdzIgPSBtMiArIDQgfCAwOwogICAgICAgICAgICAgICAgbDIgPSBsMiA+Pj4gMCA+IHcyID4+PiAwID8gdzIgOiBsMjsKICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIG4yID0gdDI7CiAgICAgICAgICAgICAgZzIgPSAwIC0gajIgfCAwOwogICAgICAgICAgICAgIGI6CiAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICBpZiAobDIgPj4+IDAgPiBuMiA+Pj4gMCkKICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgbTIgPSBsMiArIC00IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChjW20yID4+IDJdIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICB3MiA9IGwyOwogICAgICAgICAgICAgICAgICAgICAgICB2MiA9IDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAobTIgPj4+IDAgPiBuMiA+Pj4gMCkKICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBtMjsKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB3MiA9IG0yOwogICAgICAgICAgICAgICAgICAgICAgICB2MiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdzIgPSBsMjsKICAgICAgICAgICAgICAgICAgICB2MiA9IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgaWYgKHgyKSB7CiAgICAgICAgICAgICAgICAgIGsyID0gazIgKyAoKHkyIF4gMSkgJiAxKSB8IDA7CiAgICAgICAgICAgICAgICAgIGlmICgoazIgfCAwKSA+IChqMiB8IDApICYgKGoyIHwgMCkgPiAtNSkgewogICAgICAgICAgICAgICAgICAgIG8yID0gaTIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgazIgPSBrMiArIC0xIC0gajIgfCAwOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIG8yID0gaTIgKyAtMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgazIgPSBrMiArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoIShoMiAmIDgpKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHYyID8gKEEyID0gY1t3MiArIC00ID4+IDJdIHwgMCwgKEEyIHwgMCkgIT0gMCkgOiAwKQogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKEEyID4+PiAwKSAlIDEwIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICBsMiA9IDEwOwogICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBsMiAqIDEwIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBtMiA9IG0yICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCEoKEEyID4+PiAwKSAlIChsMiA+Pj4gMCkgfCAwIHwgMCkpOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgIG0yID0gMDsKICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgICBtMiA9IDk7CiAgICAgICAgICAgICAgICAgICAgbDIgPSAoKHcyIC0gejIgPj4gMikgKiA5IHwgMCkgKyAtOSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKChvMiB8IDMyIHwgMCkgPT0gMTAyKSB7CiAgICAgICAgICAgICAgICAgICAgICBpMiA9IGwyIC0gbTIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaTIgPSAoaTIgfCAwKSA+IDAgPyBpMiA6IDA7CiAgICAgICAgICAgICAgICAgICAgICBrMiA9IChrMiB8IDApIDwgKGkyIHwgMCkgPyBrMiA6IGkyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gbDIgKyBqMiAtIG0yIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gKGkyIHwgMCkgPiAwID8gaTIgOiAwOwogICAgICAgICAgICAgICAgICAgICAgazIgPSAoazIgfCAwKSA8IChpMiB8IDApID8gazIgOiBpMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgIG8yID0gaTI7CiAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgIHQyID0gKGsyIHwgMCkgIT0gMDsKICAgICAgICAgICAgICBwMiA9IHQyID8gMSA6IGgyID4+PiAzICYgMTsKICAgICAgICAgICAgICBzMiA9IChvMiB8IDMyIHwgMCkgPT0gMTAyOwogICAgICAgICAgICAgIGlmIChzMikgewogICAgICAgICAgICAgICAgeDIgPSAwOwogICAgICAgICAgICAgICAgajIgPSAoajIgfCAwKSA+IDAgPyBqMiA6IDA7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGwyID0gKGoyIHwgMCkgPCAwID8gZzIgOiBqMjsKICAgICAgICAgICAgICAgIGwyID0geW8obDIsICgobDIgfCAwKSA8IDApIDw8IDMxID4+IDMxLCBFMikgfCAwOwogICAgICAgICAgICAgICAgbTIgPSBFMjsKICAgICAgICAgICAgICAgIGlmICgobTIgLSBsMiB8IDApIDwgMikKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGwyID0gbDIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgYVtsMiA+PiAwXSA9IDQ4OwogICAgICAgICAgICAgICAgICB9IHdoaWxlICgobTIgLSBsMiB8IDApIDwgMik7CiAgICAgICAgICAgICAgICBhW2wyICsgLTEgPj4gMF0gPSAoajIgPj4gMzEgJiAyKSArIDQzOwogICAgICAgICAgICAgICAgajIgPSBsMiArIC0yIHwgMDsKICAgICAgICAgICAgICAgIGFbajIgPj4gMF0gPSBvMjsKICAgICAgICAgICAgICAgIHgyID0gajI7CiAgICAgICAgICAgICAgICBqMiA9IG0yIC0gajIgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBqMiA9IEQyICsgMSArIGsyICsgcDIgKyBqMiB8IDA7CiAgICAgICAgICAgICAgem8oYjIsIDMyLCBmMiwgajIsIGgyKTsKICAgICAgICAgICAgICB0byhiMiwgQzIsIEQyKTsKICAgICAgICAgICAgICB6byhiMiwgNDgsIGYyLCBqMiwgaDIgXiA2NTUzNik7CiAgICAgICAgICAgICAgaWYgKHMyKSB7CiAgICAgICAgICAgICAgICBwMiA9IG4yID4+PiAwID4gQjIgPj4+IDAgPyBCMiA6IG4yOwogICAgICAgICAgICAgICAgczIgPSBHMiArIDkgfCAwOwogICAgICAgICAgICAgICAgbjIgPSBzMjsKICAgICAgICAgICAgICAgIG8yID0gRzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgIG0yID0gcDI7CiAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgIGwyID0geW8oY1ttMiA+PiAyXSB8IDAsIDAsIHMyKSB8IDA7CiAgICAgICAgICAgICAgICAgIGlmICgobTIgfCAwKSA9PSAocDIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgIGlmICgobDIgfCAwKSA9PSAoczIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgYVtvMiA+PiAwXSA9IDQ4OwogICAgICAgICAgICAgICAgICAgICAgbDIgPSBvMjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobDIgPj4+IDAgPiBHMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgICAgIHdyKEcyIHwgMCwgNDgsIGwyIC0gRjIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgICAgIGwyID0gbDIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGwyID4+PiAwID4gRzIgPj4+IDApOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRvKGIyLCBsMiwgbjIgLSBsMiB8IDApOwogICAgICAgICAgICAgICAgICBtMiA9IG0yICsgNCB8IDA7CiAgICAgICAgICAgICAgICB9IHdoaWxlIChtMiA+Pj4gMCA8PSBCMiA+Pj4gMCk7CiAgICAgICAgICAgICAgICBpZiAoISgoaDIgJiA4IHwgMCkgPT0gMCAmICh0MiBeIDEpKSkKICAgICAgICAgICAgICAgICAgdG8oYjIsIDIwMjgyLCAxKTsKICAgICAgICAgICAgICAgIGlmIChtMiA+Pj4gMCA8IHcyID4+PiAwICYgKGsyIHwgMCkgPiAwKQogICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgIGwyID0geW8oY1ttMiA+PiAyXSB8IDAsIDAsIHMyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKGwyID4+PiAwID4gRzIgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICAgIHdyKEcyIHwgMCwgNDgsIGwyIC0gRjIgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICBsMiA9IGwyICsgLTEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGwyID4+PiAwID4gRzIgPj4+IDApOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0byhiMiwgbDIsIChrMiB8IDApIDwgOSA/IGsyIDogOSk7CiAgICAgICAgICAgICAgICAgICAgbTIgPSBtMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgIGwyID0gazIgKyAtOSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKCEobTIgPj4+IDAgPCB3MiA+Pj4gMCAmIChrMiB8IDApID4gOSkpIHsKICAgICAgICAgICAgICAgICAgICAgIGsyID0gbDI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgIGsyID0gbDI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHpvKGIyLCA0OCwgazIgKyA5IHwgMCwgOSwgMCk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHcyID0gdjIgPyB3MiA6IG4yICsgNCB8IDA7CiAgICAgICAgICAgICAgICBpZiAobjIgPj4+IDAgPCB3MiA+Pj4gMCAmIChrMiB8IDApID4gLTEpIHsKICAgICAgICAgICAgICAgICAgZzIgPSBHMiArIDkgfCAwOwogICAgICAgICAgICAgICAgICB0MiA9IChoMiAmIDggfCAwKSA9PSAwOwogICAgICAgICAgICAgICAgICB2MiA9IGcyOwogICAgICAgICAgICAgICAgICBwMiA9IDAgLSBGMiB8IDA7CiAgICAgICAgICAgICAgICAgIHMyID0gRzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgbzIgPSBuMjsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGwyID0geW8oY1tvMiA+PiAyXSB8IDAsIDAsIGcyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKChsMiB8IDApID09IChnMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICBhW3MyID4+IDBdID0gNDg7CiAgICAgICAgICAgICAgICAgICAgICBsMiA9IHMyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgaWYgKChvMiB8IDApID09IChuMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG0yID0gbDIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgdG8oYjIsIGwyLCAxKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQyICYgKGsyIHwgMCkgPCAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBtMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB0byhiMiwgMjAyODIsIDEpOwogICAgICAgICAgICAgICAgICAgICAgICBsMiA9IG0yOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwyID4+PiAwIDw9IEcyID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB3cihHMiB8IDAsIDQ4LCBsMiArIHAyIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gbDIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsMiA+Pj4gMCA+IEcyID4+PiAwKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgICAgRjIgPSB2MiAtIGwyIHwgMDsKICAgICAgICAgICAgICAgICAgICB0byhiMiwgbDIsIChrMiB8IDApID4gKEYyIHwgMCkgPyBGMiA6IGsyKTsKICAgICAgICAgICAgICAgICAgICBrMiA9IGsyIC0gRjIgfCAwOwogICAgICAgICAgICAgICAgICAgIG8yID0gbzIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobzIgPj4+IDAgPCB3MiA+Pj4gMCAmIChrMiB8IDApID4gLTEpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgem8oYjIsIDQ4LCBrMiArIDE4IHwgMCwgMTgsIDApOwogICAgICAgICAgICAgICAgdG8oYjIsIHgyLCBFMiAtIHgyIHwgMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHpvKGIyLCAzMiwgZjIsIGoyLCBoMiBeIDgxOTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBWID0gSDI7CiAgICAgICAgICByZXR1cm4gKChqMiB8IDApIDwgKGYyIHwgMCkgPyBmMiA6IGoyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHFvKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGUyID0gKGNbYjIgPj4gMl0gfCAwKSArICg4IC0gMSkgJiB+KDggLSAxKTsKICAgICAgICAgIGQyID0gK2dbZTIgPj4gM107CiAgICAgICAgICBjW2IyID4+IDJdID0gZTIgKyA4OwogICAgICAgICAgZ1thMiA+PiAzXSA9IGQyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBybyhiMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgZzIgPSBnMiB8IDA7CiAgICAgICAgICB2YXIgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwLCByMiA9IDAsIHMyID0gMCwgdDIgPSAwOwogICAgICAgICAgdDIgPSBWOwogICAgICAgICAgViA9IFYgKyAyMjQgfCAwOwogICAgICAgICAgcDIgPSB0MiArIDIwOCB8IDA7CiAgICAgICAgICBxMiA9IHQyICsgMTYwIHwgMDsKICAgICAgICAgIHIyID0gdDIgKyA4MCB8IDA7CiAgICAgICAgICBzMiA9IHQyOwogICAgICAgICAgaDIgPSBxMjsKICAgICAgICAgIGkyID0gaDIgKyA0MCB8IDA7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgICBoMiA9IGgyICsgNCB8IDA7CiAgICAgICAgICB9IHdoaWxlICgoaDIgfCAwKSA8IChpMiB8IDApKTsKICAgICAgICAgIGNbcDIgPj4gMl0gPSBjW2UyID4+IDJdOwogICAgICAgICAgaWYgKChzbygwLCBkMiwgcDIsIHIyLCBxMiwgZjIsIGcyKSB8IDApIDwgMCkKICAgICAgICAgICAgZTIgPSAtMTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBpZiAoKGNbYjIgKyA3NiA+PiAyXSB8IDApID4gLTEpCiAgICAgICAgICAgICAgbzIgPSBobyhiMikgfCAwOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgbzIgPSAwOwogICAgICAgICAgICBlMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICBuMiA9IGUyICYgMzI7CiAgICAgICAgICAgIGlmICgoYVtiMiArIDc0ID4+IDBdIHwgMCkgPCAxKQogICAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBlMiAmIC0zMzsKICAgICAgICAgICAgaDIgPSBiMiArIDQ4IHwgMDsKICAgICAgICAgICAgaWYgKCEoY1toMiA+PiAyXSB8IDApKSB7CiAgICAgICAgICAgICAgaTIgPSBiMiArIDQ0IHwgMDsKICAgICAgICAgICAgICBqMiA9IGNbaTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGNbaTIgPj4gMl0gPSBzMjsKICAgICAgICAgICAgICBrMiA9IGIyICsgMjggfCAwOwogICAgICAgICAgICAgIGNbazIgPj4gMl0gPSBzMjsKICAgICAgICAgICAgICBsMiA9IGIyICsgMjAgfCAwOwogICAgICAgICAgICAgIGNbbDIgPj4gMl0gPSBzMjsKICAgICAgICAgICAgICBjW2gyID4+IDJdID0gODA7CiAgICAgICAgICAgICAgbTIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgICAgICBjW20yID4+IDJdID0gczIgKyA4MDsKICAgICAgICAgICAgICBlMiA9IHNvKGIyLCBkMiwgcDIsIHIyLCBxMiwgZjIsIGcyKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGoyKSB7CiAgICAgICAgICAgICAgICBhYVtjW2IyICsgMzYgPj4gMl0gJiA3XShiMiwgMCwgMCkgfCAwOwogICAgICAgICAgICAgICAgZTIgPSAoY1tsMiA+PiAyXSB8IDApID09IDAgPyAtMSA6IGUyOwogICAgICAgICAgICAgICAgY1tpMiA+PiAyXSA9IGoyOwogICAgICAgICAgICAgICAgY1toMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICBjW20yID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIGNbazIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBlMiA9IHNvKGIyLCBkMiwgcDIsIHIyLCBxMiwgZjIsIGcyKSB8IDA7CiAgICAgICAgICAgIGgyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBoMiB8IG4yOwogICAgICAgICAgICBpZiAobzIgfCAwKQogICAgICAgICAgICAgIGdvKGIyKTsKICAgICAgICAgICAgZTIgPSAoaDIgJiAzMiB8IDApID09IDAgPyBlMiA6IC0xOwogICAgICAgICAgfQogICAgICAgICAgViA9IHQyOwogICAgICAgICAgcmV0dXJuIGUyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc28oZDIsIGUyLCBmMiwgaDIsIGkyLCBqMiwgazIpIHsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGgyID0gaDIgfCAwOwogICAgICAgICAgaTIgPSBpMiB8IDA7CiAgICAgICAgICBqMiA9IGoyIHwgMDsKICAgICAgICAgIGsyID0gazIgfCAwOwogICAgICAgICAgdmFyIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMCwgcDIgPSAwLCBxMiA9IDAsIHIyID0gMCwgczIgPSAwLCB0MiA9IDAsIHYyID0gMCwgdzIgPSAwLCB4MiA9IDAsIHkyID0gMCwgejIgPSAwLCBBMiA9IDAsIEIyID0gMCwgQzIgPSAwLCBEMiA9IDAsIEUyID0gMCwgRjIgPSAwLCBHMiA9IDAsIEgyID0gMCwgSTIgPSAwLCBKMiA9IDAsIEsyID0gMDsKICAgICAgICAgIEoyID0gVjsKICAgICAgICAgIFYgPSBWICsgNjQgfCAwOwogICAgICAgICAgRzIgPSBKMiArIDU2IHwgMDsKICAgICAgICAgIEkyID0gSjIgKyA0MCB8IDA7CiAgICAgICAgICBCMiA9IEoyOwogICAgICAgICAgRDIgPSBKMiArIDQ4IHwgMDsKICAgICAgICAgIEUyID0gSjIgKyA2MCB8IDA7CiAgICAgICAgICBjW0cyID4+IDJdID0gZTI7CiAgICAgICAgICB5MiA9IChkMiB8IDApICE9IDA7CiAgICAgICAgICB6MiA9IEIyICsgNDAgfCAwOwogICAgICAgICAgQTIgPSB6MjsKICAgICAgICAgIEIyID0gQjIgKyAzOSB8IDA7CiAgICAgICAgICBDMiA9IEQyICsgNCB8IDA7CiAgICAgICAgICBsMiA9IDA7CiAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICBuMiA9IDA7CiAgICAgICAgICBhOgogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgIGlmICgoZTIgfCAwKSA+IC0xKQogICAgICAgICAgICAgICAgICAgIGlmICgobDIgfCAwKSA+ICgyMTQ3NDgzNjQ3IC0gZTIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgY1soYW8oKSB8IDApID4+IDJdID0gNjE7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IC0xOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gbDIgKyBlMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICByMiA9IGNbRzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgbDIgPSBhW3IyID4+IDBdIHwgMDsKICAgICAgICAgICAgICAgIGlmICghKGwyIDw8IDI0ID4+IDI0KSkgewogICAgICAgICAgICAgICAgICB4MiA9IDkyOwogICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbTIgPSByMjsKICAgICAgICAgICAgICAgIGI6CiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChsMiA8PCAyNCA+PiAyNCkgewogICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogewogICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDEwOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gbTI7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHcyID0gbTIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICBjW0cyID4+IDJdID0gdzI7CiAgICAgICAgICAgICAgICAgICAgbDIgPSBhW3cyID4+IDBdIHwgMDsKICAgICAgICAgICAgICAgICAgICBtMiA9IHcyOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjOgogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmICgoeDIgfCAwKSA9PSAxMCkgewogICAgICAgICAgICAgICAgICAgICAgeDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgbDIgPSBtMjsKICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhW20yICsgMSA+PiAwXSB8IDApICE9IDM3KQogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGM7CiAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gbDIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSBtMiArIDIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjW0cyID4+IDJdID0gbTI7CiAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoYVttMiA+PiAwXSB8IDApID09IDM3KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgIGwyID0gbDIgLSByMiB8IDA7CiAgICAgICAgICAgICAgICBpZiAoeTIpCiAgICAgICAgICAgICAgICAgIHRvKGQyLCByMiwgbDIpOwogICAgICAgICAgICAgIH0gd2hpbGUgKChsMiB8IDApICE9IDApOwogICAgICAgICAgICAgIHcyID0gKGJvKGFbKGNbRzIgPj4gMl0gfCAwKSArIDEgPj4gMF0gfCAwKSB8IDApID09IDA7CiAgICAgICAgICAgICAgbTIgPSBjW0cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoIXcyID8gKGFbbTIgKyAyID4+IDBdIHwgMCkgPT0gMzYgOiAwKSB7CiAgICAgICAgICAgICAgICB0MiA9IChhW20yICsgMSA+PiAwXSB8IDApICsgLTQ4IHwgMDsKICAgICAgICAgICAgICAgIHAyID0gMTsKICAgICAgICAgICAgICAgIGwyID0gMzsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdDIgPSAtMTsKICAgICAgICAgICAgICAgIHAyID0gbjI7CiAgICAgICAgICAgICAgICBsMiA9IDE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGwyID0gbTIgKyBsMiB8IDA7CiAgICAgICAgICAgICAgY1tHMiA+PiAyXSA9IGwyOwogICAgICAgICAgICAgIG0yID0gYVtsMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgbjIgPSAobTIgPDwgMjQgPj4gMjQpICsgLTMyIHwgMDsKICAgICAgICAgICAgICBpZiAobjIgPj4+IDAgPiAzMSB8ICgxIDw8IG4yICYgNzU5MTMgfCAwKSA9PSAwKQogICAgICAgICAgICAgICAgbzIgPSAwOwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgbzIgPSAwOwogICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICBvMiA9IDEgPDwgbjIgfCBvMjsKICAgICAgICAgICAgICAgICAgbDIgPSBsMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICBjW0cyID4+IDJdID0gbDI7CiAgICAgICAgICAgICAgICAgIG0yID0gYVtsMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgICAgIG4yID0gKG0yIDw8IDI0ID4+IDI0KSArIC0zMiB8IDA7CiAgICAgICAgICAgICAgICB9IHdoaWxlICghKG4yID4+PiAwID4gMzEgfCAoMSA8PCBuMiAmIDc1OTEzIHwgMCkgPT0gMCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAobTIgPDwgMjQgPj4gMjQgPT0gNDIpIHsKICAgICAgICAgICAgICAgIGlmICgoYm8oYVtsMiArIDEgPj4gMF0gfCAwKSB8IDApICE9IDAgPyAoSDIgPSBjW0cyID4+IDJdIHwgMCwgKGFbSDIgKyAyID4+IDBdIHwgMCkgPT0gMzYpIDogMCkgewogICAgICAgICAgICAgICAgICBsMiA9IEgyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIGNbaTIgKyAoKGFbbDIgPj4gMF0gfCAwKSArIC00OCA8PCAyKSA+PiAyXSA9IDEwOwogICAgICAgICAgICAgICAgICBsMiA9IGNbaDIgKyAoKGFbbDIgPj4gMF0gfCAwKSArIC00OCA8PCAzKSA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIG4yID0gMTsKICAgICAgICAgICAgICAgICAgbTIgPSBIMiArIDMgfCAwOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgaWYgKHAyIHwgMCkgewogICAgICAgICAgICAgICAgICAgIGUyID0gLTE7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHkyKSB7CiAgICAgICAgICAgICAgICAgICAgdzIgPSAoY1tmMiA+PiAyXSB8IDApICsgKDQgLSAxKSAmIH4oNCAtIDEpOwogICAgICAgICAgICAgICAgICAgIGwyID0gY1t3MiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IHcyICsgNDsKICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICBuMiA9IDA7CiAgICAgICAgICAgICAgICAgIG0yID0gKGNbRzIgPj4gMl0gfCAwKSArIDEgfCAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY1tHMiA+PiAyXSA9IG0yOwogICAgICAgICAgICAgICAgdzIgPSAobDIgfCAwKSA8IDA7CiAgICAgICAgICAgICAgICB2MiA9IHcyID8gMCAtIGwyIHwgMCA6IGwyOwogICAgICAgICAgICAgICAgbzIgPSB3MiA/IG8yIHwgODE5MiA6IG8yOwogICAgICAgICAgICAgICAgdzIgPSBuMjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgbDIgPSB1byhHMikgfCAwOwogICAgICAgICAgICAgICAgaWYgKChsMiB8IDApIDwgMCkgewogICAgICAgICAgICAgICAgICBlMiA9IC0xOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHYyID0gbDI7CiAgICAgICAgICAgICAgICB3MiA9IHAyOwogICAgICAgICAgICAgICAgbTIgPSBjW0cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgIGlmICgoYVttMiA+PiAwXSB8IDApID09IDQ2KSB7CiAgICAgICAgICAgICAgICAgIGwyID0gbTIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKChhW2wyID4+IDBdIHwgMCkgIT0gNDIpIHsKICAgICAgICAgICAgICAgICAgICBjW0cyID4+IDJdID0gbDI7CiAgICAgICAgICAgICAgICAgICAgbDIgPSB1byhHMikgfCAwOwogICAgICAgICAgICAgICAgICAgIG0yID0gY1tHMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGJvKGFbbTIgKyAyID4+IDBdIHwgMCkgfCAwID8gKEYyID0gY1tHMiA+PiAyXSB8IDAsIChhW0YyICsgMyA+PiAwXSB8IDApID09IDM2KSA6IDApIHsKICAgICAgICAgICAgICAgICAgICBsMiA9IEYyICsgMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tpMiArICgoYVtsMiA+PiAwXSB8IDApICsgLTQ4IDw8IDIpID4+IDJdID0gMTA7CiAgICAgICAgICAgICAgICAgICAgbDIgPSBjW2gyICsgKChhW2wyID4+IDBdIHwgMCkgKyAtNDggPDwgMykgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIG0yID0gRjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICBjW0cyID4+IDJdID0gbTI7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHcyIHwgMCkgewogICAgICAgICAgICAgICAgICAgIGUyID0gLTE7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoeTIpIHsKICAgICAgICAgICAgICAgICAgICBzMiA9IChjW2YyID4+IDJdIHwgMCkgKyAoNCAtIDEpICYgfig0IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgbDIgPSBjW3MyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gczIgKyA0OwogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICBsMiA9IDA7CiAgICAgICAgICAgICAgICAgIG0yID0gKGNbRzIgPj4gMl0gfCAwKSArIDIgfCAwOwogICAgICAgICAgICAgICAgICBjW0cyID4+IDJdID0gbTI7CiAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgbDIgPSAtMTsKICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgczIgPSAwOwogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBpZiAoKChhW20yID4+IDBdIHwgMCkgKyAtNjUgfCAwKSA+Pj4gMCA+IDU3KSB7CiAgICAgICAgICAgICAgICAgIGUyID0gLTE7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBuMiA9IG0yOwogICAgICAgICAgICAgICAgbTIgPSBtMiArIDEgfCAwOwogICAgICAgICAgICAgICAgY1tHMiA+PiAyXSA9IG0yOwogICAgICAgICAgICAgICAgbjIgPSBhWyhhW24yID4+IDBdIHwgMCkgKyAtNjUgKyAoMTc2ICsgKHMyICogNTggfCAwKSkgPj4gMF0gfCAwOwogICAgICAgICAgICAgICAgcDIgPSBuMiAmIDI1NTsKICAgICAgICAgICAgICAgIGlmICgocDIgKyAtMSB8IDApID4+PiAwID49IDgpCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICBzMiA9IHAyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIShuMiA8PCAyNCA+PiAyNCkpIHsKICAgICAgICAgICAgICAgIGUyID0gLTE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcTIgPSAodDIgfCAwKSA+IC0xOwogICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICBpZiAobjIgPDwgMjQgPj4gMjQgPT0gMTkpCiAgICAgICAgICAgICAgICAgIGlmIChxMikgewogICAgICAgICAgICAgICAgICAgIGUyID0gLTE7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgeDIgPSA1NDsKICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICBpZiAocTIpIHsKICAgICAgICAgICAgICAgICAgICBjW2kyICsgKHQyIDw8IDIpID4+IDJdID0gcDI7CiAgICAgICAgICAgICAgICAgICAgcTIgPSBoMiArICh0MiA8PCAzKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgdDIgPSBjW3EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgeDIgPSBJMjsKICAgICAgICAgICAgICAgICAgICBjW3gyID4+IDJdID0gY1txMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICBjW3gyICsgNCA+PiAyXSA9IHQyOwogICAgICAgICAgICAgICAgICAgIHgyID0gNTQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKCF5MikgewogICAgICAgICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHZvKEkyLCBwMiwgZjIsIGsyKTsKICAgICAgICAgICAgICAgICAgbTIgPSBjW0cyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgeDIgPSA1NTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgaWYgKCh4MiB8IDApID09IDU0KSB7CiAgICAgICAgICAgICAgICB4MiA9IDA7CiAgICAgICAgICAgICAgICBpZiAoeTIpCiAgICAgICAgICAgICAgICAgIHgyID0gNTU7CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIGwyID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZDoKICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgIGlmICgoeDIgfCAwKSA9PSA1NSkgewogICAgICAgICAgICAgICAgICAgIHgyID0gMDsKICAgICAgICAgICAgICAgICAgICBtMiA9IGFbbTIgKyAtMSA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgbTIgPSAoczIgfCAwKSAhPSAwICYgKG0yICYgMTUgfCAwKSA9PSAzID8gbTIgJiAtMzMgOiBtMjsKICAgICAgICAgICAgICAgICAgICBuMiA9IG8yICYgLTY1NTM3OwogICAgICAgICAgICAgICAgICAgIHQyID0gKG8yICYgODE5MiB8IDApID09IDAgPyBvMiA6IG4yOwogICAgICAgICAgICAgICAgICAgIGU6CiAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0yIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEwOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgoczIgJiAyNTUpIDw8IDI0ID4+IDI0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbY1tJMiA+PiAyXSA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBkOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbY1tJMiA+PiAyXSA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBkOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gY1tJMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbbDIgKyA0ID4+IDJdID0gKChlMiB8IDApIDwgMCkgPDwgMzEgPj4gMzE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYltjW0kyID4+IDJdID4+IDFdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtjW0kyID4+IDJdID4+IDBdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tjW0kyID4+IDJdID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBjW0kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDQgPj4gMl0gPSAoKGUyIHwgMCkgPCAwKSA8PCAzMSA+PiAzMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMjogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSAxMjA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsMiA9IGwyID4+PiAwID4gOCA/IGwyIDogODsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gdDIgfCA4OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA2NzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg4OgogICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIwOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IHQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA2NzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSBJMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEyID0geG8oY1txMiA+PiAyXSB8IDAsIGNbcTIgKyA0ID4+IDJdIHwgMCwgejIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gQTIgLSBxMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IDIwMjMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAodDIgJiA4IHwgMCkgPT0gMCB8IChsMiB8IDApID4gKG4yIHwgMCkgPyBsMiA6IG4yICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IHQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA3MzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNToKICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbjIgPSBJMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0yID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IGNbbjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobjIgfCAwKSA8IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSBtcigwLCAwLCBtMiB8IDAsIG4yIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IHUoKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8yID0gSTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbbzIgPj4gMl0gPSBtMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tvMiArIDQgPj4gMl0gPSBuMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbzIgPSAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IDIwMjMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDcyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbzIgPSAodDIgJiAyMDQ5IHwgMCkgIT0gMCAmIDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gKHQyICYgMjA0OCB8IDApID09IDAgPyAodDIgJiAxIHwgMCkgPT0gMCA/IDIwMjMwIDogMjAyMzIgOiAyMDIzMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA3MjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gSTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IDIwMjMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSBjW24yID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gY1tuMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA3MjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk5OiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW0IyID4+IDBdID0gY1tJMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIyID0gQjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IDIwMjMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSBuMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwyID0gQTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gY1tJMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IChzMiB8IDApID09IDAgPyAyMDI0MCA6IHMyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBubyhzMiwgMCwgbDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEsyID0gKHQyIHwgMCkgPT0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIyID0gczI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IDIwMjMwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSBLMiA/IGwyIDogdDIgLSBzMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMiA9IG4yOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBLMiA/IHMyICsgbDIgfCAwIDogdDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NzogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tEMiA+PiAyXSA9IGNbSTIgPj4gMl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW0MyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbSTIgPj4gMl0gPSBEMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gLTE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDc5OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODM6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgem8oZDIsIDMyLCB2MiwgMCwgdDIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gODk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IGwyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDc5OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MToKICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcwOgogICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5NzoKICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMzoKICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMjoKICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMTogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBfW2oyICYgMV0oZDIsICtnW0kyID4+IDNdLCB2MiwgbDIsIHQyLCBtMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZDsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbzIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSAyMDIzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEyID0gbDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMiA9IHQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBBMjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICBmOgogICAgICAgICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh4MiB8IDApID09IDY3KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSBJMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBxMiA9IHdvKGNbcTIgPj4gMl0gfCAwLCBjW3EyICsgNCA+PiAyXSB8IDAsIHoyLCBtMiAmIDMyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBJMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IChuMiAmIDggfCAwKSA9PSAwIHwgKGNbcDIgPj4gMl0gfCAwKSA9PSAwICYgKGNbcDIgKyA0ID4+IDJdIHwgMCkgPT0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBvMiA9IHAyID8gMCA6IDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwMiA/IDIwMjMwIDogMjAyMzAgKyAobTIgPj4+IDQpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDczOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh4MiB8IDApID09IDcyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSB5byhtMiwgbjIsIHoyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbjIgPSB0MjsKICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDczOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh4MiB8IDApID09IDc5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIG8yID0gY1tJMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMiA9IGNbbzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMiA9IEFvKEUyLCBtMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbjIgPSAobTIgfCAwKSA8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobjIgfCBtMiA+Pj4gMCA+IChwMiAtIGwyIHwgMCkgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA4MzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsMiA9IG0yICsgbDIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAyID4+PiAwID4gbDIgPj4+IDApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8yID0gbzIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoeDIgfCAwKSA9PSA4MykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4yKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gLTE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHpvKGQyLCAzMiwgdjIsIGwyLCB0Mik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsMikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSA4OTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbjIgPSBjW0kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8yID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0yID0gY1tuMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbTIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDg5OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGY7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSBBbyhFMiwgbTIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbzIgPSBtMiArIG8yIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvMiB8IDApID4gKGwyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IDg5OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGY7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8oZDIsIEUyLCBtMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvMiA+Pj4gMCA+PSBsMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gODk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gbjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICBpZiAoKHgyIHwgMCkgPT0gNzMpIHsKICAgICAgICAgICAgICAgICAgICAgIHgyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIG0yID0gSTI7CiAgICAgICAgICAgICAgICAgICAgICBtMiA9IChjW20yID4+IDJdIHwgMCkgIT0gMCB8IChjW20yICsgNCA+PiAyXSB8IDApICE9IDA7CiAgICAgICAgICAgICAgICAgICAgICBLMiA9IChsMiB8IDApICE9IDAgfCBtMjsKICAgICAgICAgICAgICAgICAgICAgIG0yID0gQTIgLSBxMiArICgobTIgXiAxKSAmIDEpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIHIyID0gSzIgPyBxMiA6IHoyOwogICAgICAgICAgICAgICAgICAgICAgcTIgPSBLMiA/IChsMiB8IDApID4gKG0yIHwgMCkgPyBsMiA6IG0yIDogMDsKICAgICAgICAgICAgICAgICAgICAgIG0yID0gKGwyIHwgMCkgPiAtMSA/IG4yICYgLTY1NTM3IDogbjI7CiAgICAgICAgICAgICAgICAgICAgICBsMiA9IEEyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHgyIHwgMCkgPT0gODkpIHsKICAgICAgICAgICAgICAgICAgICAgIHgyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIHpvKGQyLCAzMiwgdjIsIGwyLCB0MiBeIDgxOTIpOwogICAgICAgICAgICAgICAgICAgICAgbDIgPSAodjIgfCAwKSA+IChsMiB8IDApID8gdjIgOiBsMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0MiA9IGwyIC0gcjIgfCAwOwogICAgICAgICAgICAgICAgICAgIHMyID0gKHEyIHwgMCkgPCAodDIgfCAwKSA/IHQyIDogcTI7CiAgICAgICAgICAgICAgICAgICAgSzIgPSBzMiArIG8yIHwgMDsKICAgICAgICAgICAgICAgICAgICBsMiA9ICh2MiB8IDApIDwgKEsyIHwgMCkgPyBLMiA6IHYyOwogICAgICAgICAgICAgICAgICAgIHpvKGQyLCAzMiwgbDIsIEsyLCBtMik7CiAgICAgICAgICAgICAgICAgICAgdG8oZDIsIHAyLCBvMik7CiAgICAgICAgICAgICAgICAgICAgem8oZDIsIDQ4LCBsMiwgSzIsIG0yIF4gNjU1MzYpOwogICAgICAgICAgICAgICAgICAgIHpvKGQyLCA0OCwgczIsIHQyLCAwKTsKICAgICAgICAgICAgICAgICAgICB0byhkMiwgcjIsIHQyKTsKICAgICAgICAgICAgICAgICAgICB6byhkMiwgMzIsIGwyLCBLMiwgbTIgXiA4MTkyKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgIG4yID0gdzI7CiAgICAgICAgICAgIH0KICAgICAgICAgIGc6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKCh4MiB8IDApID09IDkyKSB7CiAgICAgICAgICAgICAgICBpZiAoIWQyKQogICAgICAgICAgICAgICAgICBpZiAoIW4yKQogICAgICAgICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZTIgPSAxOwogICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICBsMiA9IGNbaTIgKyAoZTIgPDwgMikgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFsMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB2byhoMiArIChlMiA8PCAzKSB8IDAsIGwyLCBmMiwgazIpOwogICAgICAgICAgICAgICAgICAgICAgZTIgPSBlMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGUyID4+PiAwID49IDEwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZzsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChjW2kyICsgKGUyIDw8IDIpID4+IDJdIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IC0xOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBnOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZTIgPSBlMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGUyID4+PiAwID49IDEwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBWID0gSjI7CiAgICAgICAgICByZXR1cm4gZTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0byhhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBpZiAoIShjW2EyID4+IDJdICYgMzIpKQogICAgICAgICAgICBqbyhiMiwgZDIsIGEyKSB8IDA7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHVvKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMDsKICAgICAgICAgIGlmICghKGJvKGFbY1tiMiA+PiAyXSA+PiAwXSB8IDApIHwgMCkpCiAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBlMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGQyID0gKGQyICogMTAgfCAwKSArIC00OCArIChhW2UyID4+IDBdIHwgMCkgfCAwOwogICAgICAgICAgICAgIGUyID0gZTIgKyAxIHwgMDsKICAgICAgICAgICAgICBjW2IyID4+IDJdID0gZTI7CiAgICAgICAgICAgIH0gd2hpbGUgKChibyhhW2UyID4+IDBdIHwgMCkgfCAwKSAhPSAwKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHZvKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGgyID0gMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKGIyID4+PiAwIDw9IDIwKQogICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgc3dpdGNoIChiMiB8IDApIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHsKICAgICAgICAgICAgICAgICAgICAgIGIyID0gKGNbZDIgPj4gMl0gfCAwKSArICg0IC0gMSkgJiB+KDQgLSAxKTsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gYjIgKyA0OwogICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogewogICAgICAgICAgICAgICAgICAgICAgZTIgPSAoY1tkMiA+PiAyXSB8IDApICsgKDQgLSAxKSAmIH4oNCAtIDEpOwogICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBlMiArIDQ7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgY1tlMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSAoKGIyIHwgMCkgPCAwKSA8PCAzMSA+PiAzMTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IHsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gKGNbZDIgPj4gMl0gfCAwKSArICg0IC0gMSkgJiB+KDQgLSAxKTsKICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gZTIgKyA0OwogICAgICAgICAgICAgICAgICAgICAgZTIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gKGNbZDIgPj4gMl0gfCAwKSArICg4IC0gMSkgJiB+KDggLSAxKTsKICAgICAgICAgICAgICAgICAgICAgIGIyID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICBmMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gZTIgKyA4OwogICAgICAgICAgICAgICAgICAgICAgZTIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiB7CiAgICAgICAgICAgICAgICAgICAgICBmMiA9IChjW2QyID4+IDJdIHwgMCkgKyAoNCAtIDEpICYgfig0IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGYyICsgNDsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gKGUyICYgNjU1MzUpIDw8IDE2ID4+IDE2OwogICAgICAgICAgICAgICAgICAgICAgZjIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gKChlMiB8IDApIDwgMCkgPDwgMzEgPj4gMzE7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiB7CiAgICAgICAgICAgICAgICAgICAgICBmMiA9IChjW2QyID4+IDJdIHwgMCkgKyAoNCAtIDEpICYgfig0IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGYyICsgNDsKICAgICAgICAgICAgICAgICAgICAgIGYyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gZTIgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6IHsKICAgICAgICAgICAgICAgICAgICAgIGYyID0gKGNbZDIgPj4gMl0gfCAwKSArICg0IC0gMSkgJiB+KDQgLSAxKTsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gY1tmMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gZjIgKyA0OwogICAgICAgICAgICAgICAgICAgICAgZTIgPSAoZTIgJiAyNTUpIDw8IDI0ID4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgZjIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gKChlMiB8IDApIDwgMCkgPDwgMzEgPj4gMzE7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiB7CiAgICAgICAgICAgICAgICAgICAgICBmMiA9IChjW2QyID4+IDJdIHwgMCkgKyAoNCAtIDEpICYgfig0IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGYyICsgNDsKICAgICAgICAgICAgICAgICAgICAgIGYyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gZTIgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiB7CiAgICAgICAgICAgICAgICAgICAgICBmMiA9IChjW2QyID4+IDJdIHwgMCkgKyAoOCAtIDEpICYgfig4IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICBoMiA9ICtnW2YyID4+IDNdOwogICAgICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGYyICsgODsKICAgICAgICAgICAgICAgICAgICAgIGdbYTIgPj4gM10gPSBoMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHsKICAgICAgICAgICAgICAgICAgICAgIGRhW2UyICYgMTVdKGEyLCBkMik7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdvKGIyLCBjMiwgZTIsIGYyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGlmICghKChiMiB8IDApID09IDAgJiAoYzIgfCAwKSA9PSAwKSkKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGUyID0gZTIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgYVtlMiA+PiAwXSA9IGRbNjQwICsgKGIyICYgMTUpID4+IDBdIHwgMCB8IGYyOwogICAgICAgICAgICAgIGIyID0gcXIoYjIgfCAwLCBjMiB8IDAsIDQpIHwgMDsKICAgICAgICAgICAgICBjMiA9IHUoKSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKCEoKGIyIHwgMCkgPT0gMCAmIChjMiB8IDApID09IDApKTsKICAgICAgICAgIHJldHVybiBlMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHhvKGIyLCBjMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGlmICghKChiMiB8IDApID09IDAgJiAoYzIgfCAwKSA9PSAwKSkKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGQyID0gZDIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgYVtkMiA+PiAwXSA9IGIyICYgNyB8IDQ4OwogICAgICAgICAgICAgIGIyID0gcXIoYjIgfCAwLCBjMiB8IDAsIDMpIHwgMDsKICAgICAgICAgICAgICBjMiA9IHUoKSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKCEoKGIyIHwgMCkgPT0gMCAmIChjMiB8IDApID09IDApKTsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHlvKGIyLCBjMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgaWYgKGMyID4+PiAwID4gMCB8IChjMiB8IDApID09IDAgJiBiMiA+Pj4gMCA+IDQyOTQ5NjcyOTUpIHsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGUyID0gYjI7CiAgICAgICAgICAgICAgYjIgPSBwcihiMiB8IDAsIGMyIHwgMCwgMTAsIDApIHwgMDsKICAgICAgICAgICAgICBmMiA9IGMyOwogICAgICAgICAgICAgIGMyID0gdSgpIHwgMDsKICAgICAgICAgICAgICBnMiA9IGtyKGIyIHwgMCwgYzIgfCAwLCAxMCwgMCkgfCAwOwogICAgICAgICAgICAgIGcyID0gbXIoZTIgfCAwLCBmMiB8IDAsIGcyIHwgMCwgdSgpIHwgMCkgfCAwOwogICAgICAgICAgICAgIHUoKSB8IDA7CiAgICAgICAgICAgICAgZDIgPSBkMiArIC0xIHwgMDsKICAgICAgICAgICAgICBhW2QyID4+IDBdID0gZzIgJiAyNTUgfCA0ODsKICAgICAgICAgICAgfSB3aGlsZSAoZjIgPj4+IDAgPiA5IHwgKGYyIHwgMCkgPT0gOSAmIGUyID4+PiAwID4gNDI5NDk2NzI5NSk7CiAgICAgICAgICAgIGMyID0gYjI7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgYzIgPSBiMjsKICAgICAgICAgIGlmIChjMikKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGcyID0gYzI7CiAgICAgICAgICAgICAgYzIgPSAoYzIgPj4+IDApIC8gMTAgfCAwOwogICAgICAgICAgICAgIGQyID0gZDIgKyAtMSB8IDA7CiAgICAgICAgICAgICAgYVtkMiA+PiAwXSA9IGcyIC0gKGMyICogMTAgfCAwKSB8IDQ4OwogICAgICAgICAgICB9IHdoaWxlIChnMiA+Pj4gMCA+PSAxMCk7CiAgICAgICAgICByZXR1cm4gZDIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6byhhMiwgYjIsIGMyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDA7CiAgICAgICAgICBnMiA9IFY7CiAgICAgICAgICBWID0gViArIDI1NiB8IDA7CiAgICAgICAgICBmMiA9IGcyOwogICAgICAgICAgaWYgKChjMiB8IDApID4gKGQyIHwgMCkgJiAoZTIgJiA3MzcyOCB8IDApID09IDApIHsKICAgICAgICAgICAgZTIgPSBjMiAtIGQyIHwgMDsKICAgICAgICAgICAgd3IoZjIgfCAwLCBiMiA8PCAyNCA+PiAyNCB8IDAsIChlMiA+Pj4gMCA8IDI1NiA/IGUyIDogMjU2KSB8IDApIHwgMDsKICAgICAgICAgICAgaWYgKGUyID4+PiAwID4gMjU1KSB7CiAgICAgICAgICAgICAgYjIgPSBjMiAtIGQyIHwgMDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICB0byhhMiwgZjIsIDI1Nik7CiAgICAgICAgICAgICAgICBlMiA9IGUyICsgLTI1NiB8IDA7CiAgICAgICAgICAgICAgfSB3aGlsZSAoZTIgPj4+IDAgPiAyNTUpOwogICAgICAgICAgICAgIGUyID0gYjIgJiAyNTU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdG8oYTIsIGYyLCBlMik7CiAgICAgICAgICB9CiAgICAgICAgICBWID0gZzI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFvKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYTIgPSBCbyhhMiwgYjIsIDApIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJvKGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmIChiMikgewogICAgICAgICAgICAgIGlmIChkMiA+Pj4gMCA8IDEyOCkgewogICAgICAgICAgICAgICAgYVtiMiA+PiAwXSA9IGQyOwogICAgICAgICAgICAgICAgYjIgPSAxOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghKGNbY1soQ28oKSB8IDApICsgMTc2ID4+IDJdID4+IDJdIHwgMCkpCiAgICAgICAgICAgICAgICBpZiAoKGQyICYgLTEyOCB8IDApID09IDU3MjE2KSB7CiAgICAgICAgICAgICAgICAgIGFbYjIgPj4gMF0gPSBkMjsKICAgICAgICAgICAgICAgICAgYjIgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGNbKGFvKCkgfCAwKSA+PiAyXSA9IDI1OwogICAgICAgICAgICAgICAgICBiMiA9IC0xOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoZDIgPj4+IDAgPCAyMDQ4KSB7CiAgICAgICAgICAgICAgICBhW2IyID4+IDBdID0gZDIgPj4+IDYgfCAxOTI7CiAgICAgICAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IGQyICYgNjMgfCAxMjg7CiAgICAgICAgICAgICAgICBiMiA9IDI7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwIDwgNTUyOTYgfCAoZDIgJiAtODE5MiB8IDApID09IDU3MzQ0KSB7CiAgICAgICAgICAgICAgICBhW2IyID4+IDBdID0gZDIgPj4+IDEyIHwgMjI0OwogICAgICAgICAgICAgICAgYVtiMiArIDEgPj4gMF0gPSBkMiA+Pj4gNiAmIDYzIHwgMTI4OwogICAgICAgICAgICAgICAgYVtiMiArIDIgPj4gMF0gPSBkMiAmIDYzIHwgMTI4OwogICAgICAgICAgICAgICAgYjIgPSAzOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgoZDIgKyAtNjU1MzYgfCAwKSA+Pj4gMCA8IDEwNDg1NzYpIHsKICAgICAgICAgICAgICAgIGFbYjIgPj4gMF0gPSBkMiA+Pj4gMTggfCAyNDA7CiAgICAgICAgICAgICAgICBhW2IyICsgMSA+PiAwXSA9IGQyID4+PiAxMiAmIDYzIHwgMTI4OwogICAgICAgICAgICAgICAgYVtiMiArIDIgPj4gMF0gPSBkMiA+Pj4gNiAmIDYzIHwgMTI4OwogICAgICAgICAgICAgICAgYVtiMiArIDMgPj4gMF0gPSBkMiAmIDYzIHwgMTI4OwogICAgICAgICAgICAgICAgYjIgPSA0OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNbKGFvKCkgfCAwKSA+PiAyXSA9IDI1OwogICAgICAgICAgICAgICAgYjIgPSAtMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgYjIgPSAxOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQ28oKSB7CiAgICAgICAgICByZXR1cm4gY28oKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIERvKGEyKSB7CiAgICAgICAgICBhMiA9ICthMjsKICAgICAgICAgIHZhciBiMiA9IDA7CiAgICAgICAgICBnW2ggPj4gM10gPSBhMjsKICAgICAgICAgIGIyID0gY1toID4+IDJdIHwgMDsKICAgICAgICAgIHQoY1toICsgNCA+PiAyXSB8IDApOwogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRW8oYTIsIGIyKSB7CiAgICAgICAgICBhMiA9ICthMjsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBnW2ggPj4gM10gPSBhMjsKICAgICAgICAgIGQyID0gY1toID4+IDJdIHwgMDsKICAgICAgICAgIGUyID0gY1toICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBmMiA9IHFyKGQyIHwgMCwgZTIgfCAwLCA1MikgfCAwOwogICAgICAgICAgdSgpIHwgMDsKICAgICAgICAgIHN3aXRjaCAoZjIgJiAyMDQ3KSB7CiAgICAgICAgICAgIGNhc2UgMDogewogICAgICAgICAgICAgIGlmIChhMiAhPSAwKSB7CiAgICAgICAgICAgICAgICBhMiA9ICtFbyhhMiAqIDE4NDQ2NzQ0MDczNzA5NTUyZTMsIGIyKTsKICAgICAgICAgICAgICAgIGQyID0gKGNbYjIgPj4gMl0gfCAwKSArIC02NCB8IDA7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMjA0NzoKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgICAgIGNbYjIgPj4gMl0gPSAoZjIgJiAyMDQ3KSArIC0xMDIyOwogICAgICAgICAgICAgIGNbaCA+PiAyXSA9IGQyOwogICAgICAgICAgICAgIGNbaCArIDQgPj4gMl0gPSBlMiAmIC0yMTQ2NDM1MDczIHwgMTA3MTY0NDY3MjsKICAgICAgICAgICAgICBhMiA9ICtnW2ggPj4gM107CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiArYTI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEZvKGIyLCBjMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKCFkMikKICAgICAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIGUyID0gYVtiMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgICAgIGYyID0gYVtjMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgICAgIGlmIChlMiA8PCAyNCA+PiAyNCAhPSBmMiA8PCAyNCA+PiAyNCkKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgZDIgPSBkMiArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKCFkMikgewogICAgICAgICAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGIyID0gYjIgKyAxIHwgMDsKICAgICAgICAgICAgICAgICAgICBjMiA9IGMyICsgMSB8IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGIyID0gKGUyICYgMjU1KSAtIChmMiAmIDI1NSkgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gR28oYTIsIGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBnMiA9IGYyOwogICAgICAgICAgY1tnMiA+PiAyXSA9IGUyOwogICAgICAgICAgZTIgPSBIbyhhMiwgYjIsIGQyLCBnMikgfCAwOwogICAgICAgICAgViA9IGYyOwogICAgICAgICAgcmV0dXJuIGUyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSG8oYjIsIGQyLCBlMiwgZjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgdmFyIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMDsKICAgICAgICAgIGoyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYwIHwgMDsKICAgICAgICAgIGcyID0gajIgKyAxNDQgfCAwOwogICAgICAgICAgaTIgPSBqMjsKICAgICAgICAgIHVyKGkyIHwgMCwgMzY3MiwgMTQ0KSB8IDA7CiAgICAgICAgICBpZiAoKGQyICsgLTEgfCAwKSA+Pj4gMCA+IDIxNDc0ODM2NDYpCiAgICAgICAgICAgIGlmICghZDIpIHsKICAgICAgICAgICAgICBiMiA9IGcyOwogICAgICAgICAgICAgIGQyID0gMTsKICAgICAgICAgICAgICBoMiA9IDQ7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY1soYW8oKSB8IDApID4+IDJdID0gNjE7CiAgICAgICAgICAgICAgZDIgPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgZWxzZQogICAgICAgICAgICBoMiA9IDQ7CiAgICAgICAgICBpZiAoKGgyIHwgMCkgPT0gNCkgewogICAgICAgICAgICBoMiA9IC0yIC0gYjIgfCAwOwogICAgICAgICAgICBoMiA9IGQyID4+PiAwID4gaDIgPj4+IDAgPyBoMiA6IGQyOwogICAgICAgICAgICBjW2kyICsgNDggPj4gMl0gPSBoMjsKICAgICAgICAgICAgZzIgPSBpMiArIDIwIHwgMDsKICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGIyOwogICAgICAgICAgICBjW2kyICsgNDQgPj4gMl0gPSBiMjsKICAgICAgICAgICAgZDIgPSBiMiArIGgyIHwgMDsKICAgICAgICAgICAgYjIgPSBpMiArIDE2IHwgMDsKICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGQyOwogICAgICAgICAgICBjW2kyICsgMjggPj4gMl0gPSBkMjsKICAgICAgICAgICAgZDIgPSBvbyhpMiwgZTIsIGYyKSB8IDA7CiAgICAgICAgICAgIGlmIChoMikgewogICAgICAgICAgICAgIGkyID0gY1tnMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgYVtpMiArICgoKGkyIHwgMCkgPT0gKGNbYjIgPj4gMl0gfCAwKSkgPDwgMzEgPj4gMzEpID4+IDBdID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgViA9IGoyOwogICAgICAgICAgcmV0dXJuIGQyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSW8oYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZTIgPSBhMiArIDIwIHwgMDsKICAgICAgICAgIGYyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICBhMiA9IChjW2EyICsgMTYgPj4gMl0gfCAwKSAtIGYyIHwgMDsKICAgICAgICAgIGEyID0gYTIgPj4+IDAgPiBkMiA+Pj4gMCA/IGQyIDogYTI7CiAgICAgICAgICB1cihmMiB8IDAsIGIyIHwgMCwgYTIgfCAwKSB8IDA7CiAgICAgICAgICBjW2UyID4+IDJdID0gKGNbZTIgPj4gMl0gfCAwKSArIGEyOwogICAgICAgICAgcmV0dXJuIGQyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSm8oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgYzIgPSAwOwogICAgICAgICAgYjIgPSAoZm8oYTIpIHwgMCkgKyAxIHwgMDsKICAgICAgICAgIGMyID0gZHIoYjIpIHwgMDsKICAgICAgICAgIGlmICghYzIpCiAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYTIgPSB1cihjMiB8IDAsIGEyIHwgMCwgYjIgfCAwKSB8IDA7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBLbyhiMiwgZTIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDA7CiAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICBpZiAoKGRbNjU2ICsgZjIgPj4gMF0gfCAwKSA9PSAoYjIgfCAwKSkgewogICAgICAgICAgICAgIGcyID0gNDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBmMiA9IGYyICsgMSB8IDA7CiAgICAgICAgICAgIGlmICgoZjIgfCAwKSA9PSA4NykgewogICAgICAgICAgICAgIGIyID0gODc7CiAgICAgICAgICAgICAgZzIgPSA1OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKGcyIHwgMCkgPT0gNCkKICAgICAgICAgICAgaWYgKCFmMikKICAgICAgICAgICAgICBmMiA9IDc1MjsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgYjIgPSBmMjsKICAgICAgICAgICAgICBnMiA9IDU7CiAgICAgICAgICAgIH0KICAgICAgICAgIGlmICgoZzIgfCAwKSA9PSA1KSB7CiAgICAgICAgICAgIGYyID0gNzUyOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgZzIgPSBmMjsKICAgICAgICAgICAgICAgIGYyID0gZjIgKyAxIHwgMDsKICAgICAgICAgICAgICB9IHdoaWxlICgoYVtnMiA+PiAwXSB8IDApICE9IDApOwogICAgICAgICAgICAgIGIyID0gYjIgKyAtMSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKChiMiB8IDApICE9IDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIExvKGYyLCBjW2UyICsgMjAgPj4gMl0gfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIExvKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHJldHVybiBrbyhhMiwgYjIpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTW8oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIEtvKGEyLCBjWyhObygpIHwgMCkgKyAxNzYgPj4gMl0gfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5vKCkgewogICAgICAgICAgcmV0dXJuIGNvKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBPbyhiMiwgYzIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwOwogICAgICAgICAgZTIgPSBNbyhiMikgfCAwOwogICAgICAgICAgYjIgPSBmbyhlMikgfCAwOwogICAgICAgICAgaWYgKGIyID4+PiAwID49IGQyID4+PiAwKSB7CiAgICAgICAgICAgIGIyID0gZDIgKyAtMSB8IDA7CiAgICAgICAgICAgIGlmICghZDIpCiAgICAgICAgICAgICAgYjIgPSA2ODsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgdXIoYzIgfCAwLCBlMiB8IDAsIGIyIHwgMCkgfCAwOwogICAgICAgICAgICAgIGFbYzIgKyBiMiA+PiAwXSA9IDA7CiAgICAgICAgICAgICAgYjIgPSA2ODsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdXIoYzIgfCAwLCBlMiB8IDAsIGIyICsgMSB8IDApIHwgMDsKICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGIyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUG8oKSB7CiAgICAgICAgICB2YXIgYTIgPSAwLCBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgZTIgPSBWOwogICAgICAgICAgViA9IFYgKyA0OCB8IDA7CiAgICAgICAgICBnMiA9IGUyICsgMzIgfCAwOwogICAgICAgICAgYjIgPSBlMiArIDI0IHwgMDsKICAgICAgICAgIGgyID0gZTIgKyAxNiB8IDA7CiAgICAgICAgICBmMiA9IGUyOwogICAgICAgICAgZTIgPSBlMiArIDM2IHwgMDsKICAgICAgICAgIGEyID0gUW8oKSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwID8gKGQyID0gY1thMiA+PiAyXSB8IDAsIGQyIHwgMCkgOiAwKSB7CiAgICAgICAgICAgIGEyID0gZDIgKyA0OCB8IDA7CiAgICAgICAgICAgIGlmICghKFJvKGEyKSB8IDApKSB7CiAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IDIwNDIwOwogICAgICAgICAgICAgIFRvKDIwMzcwLCBiMik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYjIgPSBTbyhhMikgfCAwOwogICAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gMTEyNjkwMjUyOSAmICh1KCkgfCAwKSA9PSAxMTI5MDc0MjQ3KQogICAgICAgICAgICAgIGEyID0gY1tkMiArIDQ0ID4+IDJdIHwgMDsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGEyID0gZDIgKyA4MCB8IDA7CiAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgZDIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgYTIgPSBjW2QyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICAgIGlmIChhYVtjWyhjWzk1NF0gfCAwKSArIDE2ID4+IDJdICYgN10oMzgxNiwgZDIsIGUyKSB8IDApIHsKICAgICAgICAgICAgICBoMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGgyID0gWltjWyhjW2gyID4+IDJdIHwgMCkgKyA4ID4+IDJdICYgMTVdKGgyKSB8IDA7CiAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDIwNDIwOwogICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gYTI7CiAgICAgICAgICAgICAgY1tmMiArIDggPj4gMl0gPSBoMjsKICAgICAgICAgICAgICBUbygyMDI4NCwgZjIpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAyMDQyMDsKICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGEyOwogICAgICAgICAgICAgIFRvKDIwMzI5LCBoMik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIFRvKDIwNDA4LCBnMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFvKCkgewogICAgICAgICAgcmV0dXJuIDIxNjQwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBSbyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IFNvKGEyKSB8IDA7CiAgICAgICAgICByZXR1cm4gKGEyICYgLTI1NiB8IDApID09IDExMjY5MDI1MjggJiAodSgpIHwgMCkgPT0gMTEyOTA3NDI0NyB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNvKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDA7CiAgICAgICAgICBiMiA9IGEyOwogICAgICAgICAgYTIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgIHQoY1tiMiArIDQgPj4gMl0gfCAwKTsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFRvKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIFUoKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVW8oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWbyhhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBVbyhhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFdvKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWG8oYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBZbyhkMiwgZTIsIGYyKSB7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICB2YXIgZzIgPSAwLCBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMDsKICAgICAgICAgIGwyID0gVjsKICAgICAgICAgIFYgPSBWICsgNjQgfCAwOwogICAgICAgICAgajIgPSBsMjsKICAgICAgICAgIGlmICghKGFwKGQyLCBlMiwgMCkgfCAwKSkKICAgICAgICAgICAgaWYgKChlMiB8IDApICE9IDAgPyAoazIgPSBlcChlMiwgMzg0MCwgMzgyNCwgMCkgfCAwLCAoazIgfCAwKSAhPSAwKSA6IDApIHsKICAgICAgICAgICAgICBjW2oyID4+IDJdID0gazI7CiAgICAgICAgICAgICAgY1tqMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgICAgIGNbajIgKyA4ID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgY1tqMiArIDEyID4+IDJdID0gLTE7CiAgICAgICAgICAgICAgZDIgPSBqMiArIDE2IHwgMDsKICAgICAgICAgICAgICBlMiA9IGoyICsgMjQgfCAwOwogICAgICAgICAgICAgIGcyID0gajIgKyA0OCB8IDA7CiAgICAgICAgICAgICAgaDIgPSBkMjsKICAgICAgICAgICAgICBpMiA9IGgyICsgMzYgfCAwOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgaDIgPSBoMiArIDQgfCAwOwogICAgICAgICAgICAgIH0gd2hpbGUgKChoMiB8IDApIDwgKGkyIHwgMCkpOwogICAgICAgICAgICAgIGJbZDIgKyAzNiA+PiAxXSA9IDA7CiAgICAgICAgICAgICAgYVtkMiArIDM4ID4+IDBdID0gMDsKICAgICAgICAgICAgICBjW2cyID4+IDJdID0gMTsKICAgICAgICAgICAgICBmYVtjWyhjW2syID4+IDJdIHwgMCkgKyAyOCA+PiAyXSAmIDddKGsyLCBqMiwgY1tmMiA+PiAyXSB8IDAsIDEpOwogICAgICAgICAgICAgIGlmICgoY1tlMiA+PiAyXSB8IDApID09IDEpIHsKICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBjW2QyID4+IDJdOwogICAgICAgICAgICAgICAgZDIgPSAxOwogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgZDIgPSAwOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGQyID0gMTsKICAgICAgICAgIFYgPSBsMjsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFpvKGEyLCBiMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICBnMiA9IGcyIHwgMDsKICAgICAgICAgIGlmIChhcChhMiwgY1tiMiArIDggPj4gMl0gfCAwLCBnMikgfCAwKQogICAgICAgICAgICBkcCgwLCBiMiwgZDIsIGUyLCBmMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIF9vKGIyLCBkMiwgZTIsIGYyLCBnMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICBnMiA9IGcyIHwgMDsKICAgICAgICAgIHZhciBoMiA9IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoIShhcChiMiwgY1tkMiArIDggPj4gMl0gfCAwLCBnMikgfCAwKSkgewogICAgICAgICAgICAgIGlmIChhcChiMiwgY1tkMiA+PiAyXSB8IDAsIGcyKSB8IDApIHsKICAgICAgICAgICAgICAgIGlmICgoY1tkMiArIDE2ID4+IDJdIHwgMCkgIT0gKGUyIHwgMCkgPyAoaDIgPSBkMiArIDIwIHwgMCwgKGNbaDIgPj4gMl0gfCAwKSAhPSAoZTIgfCAwKSkgOiAwKSB7CiAgICAgICAgICAgICAgICAgIGNbZDIgKyAzMiA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgIGcyID0gZDIgKyA0MCB8IDA7CiAgICAgICAgICAgICAgICAgIGNbZzIgPj4gMl0gPSAoY1tnMiA+PiAyXSB8IDApICsgMTsKICAgICAgICAgICAgICAgICAgaWYgKChjW2QyICsgMzYgPj4gMl0gfCAwKSA9PSAxID8gKGNbZDIgKyAyNCA+PiAyXSB8IDApID09IDIgOiAwKQogICAgICAgICAgICAgICAgICAgIGFbZDIgKyA1NCA+PiAwXSA9IDE7CiAgICAgICAgICAgICAgICAgIGNbZDIgKyA0NCA+PiAyXSA9IDQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChmMiB8IDApID09IDEpCiAgICAgICAgICAgICAgICAgIGNbZDIgKyAzMiA+PiAyXSA9IDE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBjcCgwLCBkMiwgZTIsIGYyKTsKICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJG8oYTIsIGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgaWYgKGFwKGEyLCBjW2IyICsgOCA+PiAyXSB8IDAsIDApIHwgMCkKICAgICAgICAgICAgYnAoMCwgYjIsIGQyLCBlMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFwKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGlmIChkMikKICAgICAgICAgICAgaWYgKChhMiB8IDApID09IChiMiB8IDApKQogICAgICAgICAgICAgIGEyID0gMTsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGEyID0gKGVvKGNbYTIgKyA0ID4+IDJdIHwgMCwgY1tiMiArIDQgPj4gMl0gfCAwKSB8IDApID09IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGEyID0gKGNbYTIgKyA0ID4+IDJdIHwgMCkgPT0gKGNbYjIgKyA0ID4+IDJdIHwgMCk7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBicChiMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICB2YXIgZzIgPSAwOwogICAgICAgICAgYjIgPSBkMiArIDE2IHwgMDsKICAgICAgICAgIGcyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoZzIpIHsKICAgICAgICAgICAgICBpZiAoKGcyIHwgMCkgIT0gKGUyIHwgMCkpIHsKICAgICAgICAgICAgICAgIGYyID0gZDIgKyAzNiB8IDA7CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gKGNbZjIgPj4gMl0gfCAwKSArIDE7CiAgICAgICAgICAgICAgICBjW2QyICsgMjQgPj4gMl0gPSAyOwogICAgICAgICAgICAgICAgYVtkMiArIDU0ID4+IDBdID0gMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBiMiA9IGQyICsgMjQgfCAwOwogICAgICAgICAgICAgIGlmICgoY1tiMiA+PiAyXSB8IDApID09IDIpCiAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gZjI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgIGNbZDIgKyAyNCA+PiAyXSA9IGYyOwogICAgICAgICAgICAgIGNbZDIgKyAzNiA+PiAyXSA9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY3AoYTIsIGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMDsKICAgICAgICAgIGlmICgoY1tiMiArIDQgPj4gMl0gfCAwKSA9PSAoZDIgfCAwKSA/IChmMiA9IGIyICsgMjggfCAwLCAoY1tmMiA+PiAyXSB8IDApICE9IDEpIDogMCkKICAgICAgICAgICAgY1tmMiA+PiAyXSA9IGUyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkcChiMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgZzIgPSBnMiB8IDA7CiAgICAgICAgICBhW2QyICsgNTMgPj4gMF0gPSAxOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKChjW2QyICsgNCA+PiAyXSB8IDApID09IChmMiB8IDApKSB7CiAgICAgICAgICAgICAgYVtkMiArIDUyID4+IDBdID0gMTsKICAgICAgICAgICAgICBiMiA9IGQyICsgMTYgfCAwOwogICAgICAgICAgICAgIGYyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgaWYgKCFmMikgewogICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgY1tkMiArIDI0ID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICBjW2QyICsgMzYgPj4gMl0gPSAxOwogICAgICAgICAgICAgICAgaWYgKCEoKGcyIHwgMCkgPT0gMSA/IChjW2QyICsgNDggPj4gMl0gfCAwKSA9PSAxIDogMCkpCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgYVtkMiArIDU0ID4+IDBdID0gMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoKGYyIHwgMCkgIT0gKGUyIHwgMCkpIHsKICAgICAgICAgICAgICAgIGcyID0gZDIgKyAzNiB8IDA7CiAgICAgICAgICAgICAgICBjW2cyID4+IDJdID0gKGNbZzIgPj4gMl0gfCAwKSArIDE7CiAgICAgICAgICAgICAgICBhW2QyICsgNTQgPj4gMF0gPSAxOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGYyID0gZDIgKyAyNCB8IDA7CiAgICAgICAgICAgICAgYjIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gMikgewogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgYjIgPSBnMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKChiMiB8IDApID09IDEgPyAoY1tkMiArIDQ4ID4+IDJdIHwgMCkgPT0gMSA6IDApCiAgICAgICAgICAgICAgICBhW2QyICsgNTQgPj4gMF0gPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVwKGQyLCBlMiwgZjIsIGcyKSB7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICBnMiA9IGcyIHwgMDsKICAgICAgICAgIHZhciBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMCwgcDIgPSAwOwogICAgICAgICAgcDIgPSBWOwogICAgICAgICAgViA9IFYgKyA2NCB8IDA7CiAgICAgICAgICBuMiA9IHAyOwogICAgICAgICAgbTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgIG8yID0gZDIgKyAoY1ttMiArIC04ID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgbTIgPSBjW20yICsgLTQgPj4gMl0gfCAwOwogICAgICAgICAgY1tuMiA+PiAyXSA9IGYyOwogICAgICAgICAgY1tuMiArIDQgPj4gMl0gPSBkMjsKICAgICAgICAgIGNbbjIgKyA4ID4+IDJdID0gZTI7CiAgICAgICAgICBjW24yICsgMTIgPj4gMl0gPSBnMjsKICAgICAgICAgIGQyID0gbjIgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IG4yICsgMjAgfCAwOwogICAgICAgICAgZzIgPSBuMiArIDI0IHwgMDsKICAgICAgICAgIGgyID0gbjIgKyAyOCB8IDA7CiAgICAgICAgICBpMiA9IG4yICsgMzIgfCAwOwogICAgICAgICAgajIgPSBuMiArIDQwIHwgMDsKICAgICAgICAgIGsyID0gZDI7CiAgICAgICAgICBsMiA9IGsyICsgMzYgfCAwOwogICAgICAgICAgZG8gewogICAgICAgICAgICBjW2syID4+IDJdID0gMDsKICAgICAgICAgICAgazIgPSBrMiArIDQgfCAwOwogICAgICAgICAgfSB3aGlsZSAoKGsyIHwgMCkgPCAobDIgfCAwKSk7CiAgICAgICAgICBiW2QyICsgMzYgPj4gMV0gPSAwOwogICAgICAgICAgYVtkMiArIDM4ID4+IDBdID0gMDsKICAgICAgICAgIGE6CiAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgaWYgKGFwKG0yLCBmMiwgMCkgfCAwKSB7CiAgICAgICAgICAgICAgICBjW24yICsgNDggPj4gMl0gPSAxOwogICAgICAgICAgICAgICAgaGFbY1soY1ttMiA+PiAyXSB8IDApICsgMjAgPj4gMl0gJiAzXShtMiwgbjIsIG8yLCBvMiwgMSwgMCk7CiAgICAgICAgICAgICAgICBkMiA9IChjW2cyID4+IDJdIHwgMCkgPT0gMSA/IG8yIDogMDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZ2FbY1soY1ttMiA+PiAyXSB8IDApICsgMjQgPj4gMl0gJiAzXShtMiwgbjIsIG8yLCAxLCAwKTsKICAgICAgICAgICAgICAgIHN3aXRjaCAoY1tuMiArIDM2ID4+IDJdIHwgMCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6IHsKICAgICAgICAgICAgICAgICAgICBkMiA9IChjW2oyID4+IDJdIHwgMCkgPT0gMSAmIChjW2gyID4+IDJdIHwgMCkgPT0gMSAmIChjW2kyID4+IDJdIHwgMCkgPT0gMSA/IGNbZTIgPj4gMl0gfCAwIDogMDsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGNbZzIgPj4gMl0gfCAwKSAhPSAxID8gISgoY1tqMiA+PiAyXSB8IDApID09IDAgJiAoY1toMiA+PiAyXSB8IDApID09IDEgJiAoY1tpMiA+PiAyXSB8IDApID09IDEpIDogMCkgewogICAgICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZDIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIFYgPSBwMjsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIFVvKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ3AoYTIsIGIyLCBkMiwgZTIsIGYyLCBnMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgaWYgKGFwKGEyLCBjW2IyICsgOCA+PiAyXSB8IDAsIGcyKSB8IDApCiAgICAgICAgICAgIGRwKDAsIGIyLCBkMiwgZTIsIGYyKTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBhMiA9IGNbYTIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgaGFbY1soY1thMiA+PiAyXSB8IDApICsgMjAgPj4gMl0gJiAzXShhMiwgYjIsIGQyLCBlMiwgZjIsIGcyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaHAoYjIsIGQyLCBlMiwgZjIsIGcyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgdmFyIGgyID0gMCwgaTIgPSAwLCBqMiA9IDA7CiAgICAgICAgICBhOgogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmICghKGFwKGIyLCBjW2QyICsgOCA+PiAyXSB8IDAsIGcyKSB8IDApKSB7CiAgICAgICAgICAgICAgICBpZiAoIShhcChiMiwgY1tkMiA+PiAyXSB8IDAsIGcyKSB8IDApKSB7CiAgICAgICAgICAgICAgICAgIGkyID0gY1tiMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBnYVtjWyhjW2kyID4+IDJdIHwgMCkgKyAyNCA+PiAyXSAmIDNdKGkyLCBkMiwgZTIsIGYyLCBnMik7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChjW2QyICsgMTYgPj4gMl0gfCAwKSAhPSAoZTIgfCAwKSA/IChpMiA9IGQyICsgMjAgfCAwLCAoY1tpMiA+PiAyXSB8IDApICE9IChlMiB8IDApKSA6IDApIHsKICAgICAgICAgICAgICAgICAgY1tkMiArIDMyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICAgIGYyID0gZDIgKyA0NCB8IDA7CiAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgaWYgKChjW2YyID4+IDJdIHwgMCkgIT0gNCkgewogICAgICAgICAgICAgICAgICAgICAgaDIgPSBkMiArIDUyIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGFbaDIgPj4gMF0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgajIgPSBkMiArIDUzIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGFbajIgPj4gMF0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2IyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBoYVtjWyhjW2IyID4+IDJdIHwgMCkgKyAyMCA+PiAyXSAmIDNdKGIyLCBkMiwgZTIsIGUyLCAxLCBnMik7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtqMiA+PiAwXSB8IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgajIgPSAoYVtoMiA+PiAwXSB8IDApID09IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSAzOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoajIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICBjW2kyID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgIGoyID0gZDIgKyA0MCB8IDA7CiAgICAgICAgICAgICAgICAgIGNbajIgPj4gMl0gPSAoY1tqMiA+PiAyXSB8IDApICsgMTsKICAgICAgICAgICAgICAgICAgaWYgKChjW2QyICsgMzYgPj4gMl0gfCAwKSAhPSAxKQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBpZiAoKGNbZDIgKyAyNCA+PiAyXSB8IDApICE9IDIpCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGFbZDIgKyA1NCA+PiAwXSA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChmMiB8IDApID09IDEpCiAgICAgICAgICAgICAgICAgIGNbZDIgKyAzMiA+PiAyXSA9IDE7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBjcCgwLCBkMiwgZTIsIGYyKTsKICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpcChhMiwgYjIsIGQyLCBlMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBpZiAoYXAoYTIsIGNbYjIgKyA4ID4+IDJdIHwgMCwgMCkgfCAwKQogICAgICAgICAgICBicCgwLCBiMiwgZDIsIGUyKTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBhMiA9IGNbYTIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgZmFbY1soY1thMiA+PiAyXSB8IDApICsgMjggPj4gMl0gJiA3XShhMiwgYjIsIGQyLCBlMik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGpwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGVyKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga3AoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBscCgpIHsKICAgICAgICAgIHZhciBhMiA9IDAsIGIyID0gMDsKICAgICAgICAgIGEyID0gUW8oKSB8IDA7CiAgICAgICAgICBpZiAoKGEyIHwgMCA/IChiMiA9IGNbYTIgPj4gMl0gfCAwLCBiMiB8IDApIDogMCkgPyBSbyhiMiArIDQ4IHwgMCkgfCAwIDogMCkKICAgICAgICAgICAgbXAoY1tiMiArIDEyID4+IDJdIHwgMCk7CiAgICAgICAgICBtcChucCgpIHwgMCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1wKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGJhW2EyICYgM10oKTsKICAgICAgICAgIFRvKDIwNTU5LCBiMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG5wKCkgewogICAgICAgICAgcmV0dXJuIDI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9wKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcHAoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBxcChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gMjA1OTk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1OTE2OwogICAgICAgICAgdnAoYTIgKyA0IHwgMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHNwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJwKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdHAoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIHVwKGEyICsgNCB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdXAoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIGNbYTIgPj4gMl0gfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB2cChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBpZiAod3AoYTIpIHwgMCA/IChiMiA9IHhwKGNbYTIgPj4gMl0gfCAwKSB8IDAsIGQyID0gYjIgKyA4IHwgMCwgYTIgPSBjW2QyID4+IDJdIHwgMCwgY1tkMiA+PiAyXSA9IGEyICsgLTEsIChhMiB8IDApIDwgMSkgOiAwKQogICAgICAgICAgICBqcChiMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4cChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gYTIgKyAtMTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5cChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNTkzNjsKICAgICAgICAgIHZwKGEyICsgNCB8IDApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB6cChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB5cChhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiB1cChhMiArIDQgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJwKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQ3AoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcnAoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEcCgpIHsKICAgICAgICAgIHZhciBhMiA9IDA7CiAgICAgICAgICBhMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIFRvKDIwODQ4LCBhMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEVwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIFVvKGEyKTsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRnAoYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgcmV0dXJuIGFwKGEyLCBiMiwgMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHcChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBVbyhhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEhwKGQyLCBlMiwgZjIpIHsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIHZhciBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMDsKICAgICAgICAgIG4yID0gVjsKICAgICAgICAgIFYgPSBWICsgNjQgfCAwOwogICAgICAgICAgbDIgPSBuMjsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmICghKGFwKGUyLCA0MDQ4LCAwKSB8IDApKSB7CiAgICAgICAgICAgICAgaWYgKElwKGQyLCBlMiwgMCkgfCAwKSB7CiAgICAgICAgICAgICAgICBlMiA9IGNbZjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgaWYgKCFlMikgewogICAgICAgICAgICAgICAgICBlMiA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IGNbZTIgPj4gMl07CiAgICAgICAgICAgICAgICBlMiA9IDE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKChlMiB8IDApICE9IDAgPyAoZzIgPSBlcChlMiwgMzg0MCwgMzk3NiwgMCkgfCAwLCAoZzIgfCAwKSAhPSAwKSA6IDApIHsKICAgICAgICAgICAgICAgIGUyID0gY1tmMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBpZiAoZTIgfCAwKQogICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgICAgICAgIGUyID0gY1tnMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgaTIgPSBkMiArIDggfCAwOwogICAgICAgICAgICAgICAgaDIgPSBjW2kyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGlmICgoZTIgJiA3ICYgKGgyIF4gNykgfCAwKSA9PSAwID8gKChlMiAmIDk2IF4gOTYpICYgaDIgfCAwKSA9PSAwIDogMCkgewogICAgICAgICAgICAgICAgICBoMiA9IGQyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgICBkMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBnMiA9IGcyICsgMTIgfCAwOwogICAgICAgICAgICAgICAgICBlMiA9IGNbZzIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBpZiAoIShhcChkMiwgZTIsIDApIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoYXAoZDIsIDQwNDAsIDApIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKCFlMikgewogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZTIgPSAoZXAoZTIsIDM4NDAsIDM5OTIsIDApIHwgMCkgPT0gMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoZDIpIHsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gZXAoZDIsIDM4NDAsIDM5NzYsIDApIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChlMiB8IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY1tpMiA+PiAyXSAmIDEpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gSnAoZTIsIGNbZzIgPj4gMl0gfCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZTIgPSBjW2gyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChlMikgewogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGVwKGUyLCAzODQwLCA0MDA4LCAwKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlMiB8IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjW2kyID4+IDJdICYgMSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IEtwKGUyLCBjW2cyID4+IDJdIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gY1toMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKChlMiB8IDApICE9IDAgPyAoajIgPSBlcChlMiwgMzg0MCwgMzgyNCwgMCkgfCAwLCAoajIgfCAwKSAhPSAwKSA6IDApID8gKGsyID0gY1tnMiA+PiAyXSB8IDAsIChrMiB8IDApICE9IDApIDogMCkgPyAobTIgPSBlcChrMiwgMzg0MCwgMzgyNCwgMCkgfCAwLCAobTIgfCAwKSAhPSAwKSA6IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gbTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbbDIgKyA4ID4+IDJdID0gajI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDEyID4+IDJdID0gLTE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBsMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGwyICsgMjQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gbDIgKyA0OCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBpMiA9IGgyICsgMzYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbaDIgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBoMiArIDQgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKChoMiB8IDApIDwgKGkyIHwgMCkpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJbZTIgKyAzNiA+PiAxXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYVtlMiArIDM4ID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2cyID4+IDJdID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgICBmYVtjWyhjW20yID4+IDJdIHwgMCkgKyAyOCA+PiAyXSAmIDddKG0yLCBsMiwgY1tmMiA+PiAyXSB8IDAsIDEpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbZDIgPj4gMl0gfCAwKSA9PSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNbZjIgPj4gMl0gfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgIGUyID0gMTsKICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgZTIgPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBWID0gbjI7CiAgICAgICAgICByZXR1cm4gZTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBJcChhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBpZiAoIShjW2EyICsgOCA+PiAyXSAmIDI0KSkKICAgICAgICAgICAgaWYgKChiMiB8IDApICE9IDAgPyAoZTIgPSBlcChiMiwgMzg0MCwgMzk2MCwgMCkgfCAwLCAoZTIgfCAwKSAhPSAwKSA6IDApIHsKICAgICAgICAgICAgICBkMiA9IChjW2UyICsgOCA+PiAyXSAmIDI0IHwgMCkgIT0gMDsKICAgICAgICAgICAgICBmMiA9IDU7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBkMiA9IDE7CiAgICAgICAgICAgIGYyID0gNTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoZjIgfCAwKSA9PSA1KQogICAgICAgICAgICBkMiA9IGFwKGEyLCBiMiwgZDIpIHwgMDsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEpwKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDAsIGUyID0gMCwgZjIgPSAwLCBnMiA9IDAsIGgyID0gMDsKICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgIGlmICghYjIpIHsKICAgICAgICAgICAgICBiMiA9IDA7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZDIgPSBlcChiMiwgMzg0MCwgMzk3NiwgMCkgfCAwOwogICAgICAgICAgICBpZiAoIWQyKSB7CiAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGYyID0gY1thMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICBpZiAoY1tkMiArIDggPj4gMl0gJiB+ZjIgfCAwKSB7CiAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGUyID0gYTIgKyAxMiB8IDA7CiAgICAgICAgICAgIGIyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGQyID0gZDIgKyAxMiB8IDA7CiAgICAgICAgICAgIGlmIChhcChiMiwgY1tkMiA+PiAyXSB8IDAsIDApIHwgMCkgewogICAgICAgICAgICAgIGIyID0gMTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoKGYyICYgMSB8IDApID09IDAgfCAoYjIgfCAwKSA9PSAwKSB7CiAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGEyID0gZXAoYjIsIDM4NDAsIDM5NzYsIDApIHwgMDsKICAgICAgICAgICAgaWYgKCFhMikgewogICAgICAgICAgICAgIGgyID0gOTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBiMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgfQogICAgICAgICAgaWYgKChoMiB8IDApID09IDkpIHsKICAgICAgICAgICAgYjIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgaWYgKChiMiB8IDApICE9IDAgPyAoZzIgPSBlcChiMiwgMzg0MCwgNDAwOCwgMCkgfCAwLCAoZzIgfCAwKSAhPSAwKSA6IDApCiAgICAgICAgICAgICAgYjIgPSBLcChnMiwgY1tkMiA+PiAyXSB8IDApIHwgMDsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtwKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBkMiA9IDA7CiAgICAgICAgICBpZiAoKCgoYjIgfCAwKSAhPSAwID8gKGQyID0gZXAoYjIsIDM4NDAsIDQwMDgsIDApIHwgMCwgKGQyIHwgMCkgIT0gMCkgOiAwKSA/IChjW2QyICsgOCA+PiAyXSAmIH5jW2EyICsgOCA+PiAyXSB8IDApID09IDAgOiAwKSA/IGFwKGNbYTIgKyAxMiA+PiAyXSB8IDAsIGNbZDIgKyAxMiA+PiAyXSB8IDAsIDApIHwgMCA6IDApCiAgICAgICAgICAgIGEyID0gYXAoY1thMiArIDE2ID4+IDJdIHwgMCwgY1tkMiArIDE2ID4+IDJdIHwgMCwgMCkgfCAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBhMiA9IDA7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMcChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBVbyhhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE1wKGIyLCBkMiwgZTIsIGYyLCBnMiwgaDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgZzIgPSBnMiB8IDA7CiAgICAgICAgICBoMiA9IGgyIHwgMDsKICAgICAgICAgIHZhciBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwLCByMiA9IDA7CiAgICAgICAgICBpZiAoYXAoYjIsIGNbZDIgKyA4ID4+IDJdIHwgMCwgaDIpIHwgMCkKICAgICAgICAgICAgZHAoMCwgZDIsIGUyLCBmMiwgZzIpOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHIyID0gZDIgKyA1MiB8IDA7CiAgICAgICAgICAgIGoyID0gYVtyMiA+PiAwXSB8IDA7CiAgICAgICAgICAgIHEyID0gZDIgKyA1MyB8IDA7CiAgICAgICAgICAgIGkyID0gYVtxMiA+PiAwXSB8IDA7CiAgICAgICAgICAgIHAyID0gY1tiMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgICAgbTIgPSBiMiArIDE2ICsgKHAyIDw8IDMpIHwgMDsKICAgICAgICAgICAgYVtyMiA+PiAwXSA9IDA7CiAgICAgICAgICAgIGFbcTIgPj4gMF0gPSAwOwogICAgICAgICAgICBRcChiMiArIDE2IHwgMCwgZDIsIGUyLCBmMiwgZzIsIGgyKTsKICAgICAgICAgICAgazIgPSBhW3IyID4+IDBdIHwgMDsKICAgICAgICAgICAgajIgPSBrMiB8IGoyOwogICAgICAgICAgICBsMiA9IGFbcTIgPj4gMF0gfCAwOwogICAgICAgICAgICBpMiA9IGwyIHwgaTI7CiAgICAgICAgICAgIGE6CiAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgIGlmICgocDIgfCAwKSA+IDEpIHsKICAgICAgICAgICAgICAgICAgbjIgPSBkMiArIDI0IHwgMDsKICAgICAgICAgICAgICAgICAgbzIgPSBiMiArIDggfCAwOwogICAgICAgICAgICAgICAgICBwMiA9IGQyICsgNTQgfCAwOwogICAgICAgICAgICAgICAgICBiMiA9IGIyICsgMjQgfCAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgaTIgPSBpMiAmIDE7CiAgICAgICAgICAgICAgICAgICAgajIgPSBqMiAmIDE7CiAgICAgICAgICAgICAgICAgICAgaWYgKGFbcDIgPj4gMF0gfCAwKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICBpZiAoIShrMiA8PCAyNCA+PiAyNCkpIHsKICAgICAgICAgICAgICAgICAgICAgIGlmIChsMiA8PCAyNCA+PiAyNCA/IChjW28yID4+IDJdICYgMSB8IDApID09IDAgOiAwKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbbjIgPj4gMl0gfCAwKSA9PSAxKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY1tvMiA+PiAyXSAmIDIpKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBhW3IyID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICBhW3EyID4+IDBdID0gMDsKICAgICAgICAgICAgICAgICAgICBRcChiMiwgZDIsIGUyLCBmMiwgZzIsIGgyKTsKICAgICAgICAgICAgICAgICAgICBrMiA9IGFbcjIgPj4gMF0gfCAwOwogICAgICAgICAgICAgICAgICAgIGoyID0gazIgfCBqMjsKICAgICAgICAgICAgICAgICAgICBsMiA9IGFbcTIgPj4gMF0gfCAwOwogICAgICAgICAgICAgICAgICAgIGkyID0gbDIgfCBpMjsKICAgICAgICAgICAgICAgICAgICBiMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGIyID4+PiAwIDwgbTIgPj4+IDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgYVtyMiA+PiAwXSA9IGoyIDw8IDI0ID4+IDI0ICE9IDAgJiAxOwogICAgICAgICAgICBhW3EyID4+IDBdID0gaTIgPDwgMjQgPj4gMjQgIT0gMCAmIDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5wKGIyLCBkMiwgZTIsIGYyLCBnMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICBnMiA9IGcyIHwgMDsKICAgICAgICAgIHZhciBoMiA9IDAsIGkyID0gMCwgajIgPSAwLCBrMiA9IDAsIGwyID0gMCwgbTIgPSAwLCBuMiA9IDAsIG8yID0gMCwgcDIgPSAwOwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoIShhcChiMiwgY1tkMiArIDggPj4gMl0gfCAwLCBnMikgfCAwKSkgewogICAgICAgICAgICAgICAgaWYgKCEoYXAoYjIsIGNbZDIgPj4gMl0gfCAwLCBnMikgfCAwKSkgewogICAgICAgICAgICAgICAgICBwMiA9IGNbYjIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIGsyID0gYjIgKyAxNiArIChwMiA8PCAzKSB8IDA7CiAgICAgICAgICAgICAgICAgIFJwKGIyICsgMTYgfCAwLCBkMiwgZTIsIGYyLCBnMik7CiAgICAgICAgICAgICAgICAgIGgyID0gYjIgKyAyNCB8IDA7CiAgICAgICAgICAgICAgICAgIGlmICgocDIgfCAwKSA8PSAxKQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBiMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKChiMiAmIDIgfCAwKSA9PSAwID8gKGoyID0gZDIgKyAzNiB8IDAsIChjW2oyID4+IDJdIHwgMCkgIT0gMSkgOiAwKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYjIgJiAxKSkgewogICAgICAgICAgICAgICAgICAgICAgYjIgPSBkMiArIDU0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2IyID4+IDBdIHwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbajIgPj4gMl0gfCAwKSA9PSAxKQogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgICAgIFJwKGgyLCBkMiwgZTIsIGYyLCBnMik7CiAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gaDIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgyID4+PiAwID49IGsyID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGIyID0gZDIgKyAyNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgaTIgPSBkMiArIDU0IHwgMDsKICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKGFbaTIgPj4gMF0gfCAwKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgICAgaWYgKChjW2oyID4+IDJdIHwgMCkgPT0gMSA/IChjW2IyID4+IDJdIHwgMCkgPT0gMSA6IDApCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgICBScChoMiwgZDIsIGUyLCBmMiwgZzIpOwogICAgICAgICAgICAgICAgICAgICAgaDIgPSBoMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGgyID4+PiAwID49IGsyID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBiMiA9IGQyICsgNTQgfCAwOwogICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgIGlmIChhW2IyID4+IDBdIHwgMCkKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgUnAoaDIsIGQyLCBlMiwgZjIsIGcyKTsKICAgICAgICAgICAgICAgICAgICBoMiA9IGgyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKGgyID4+PiAwID49IGsyID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChjW2QyICsgMTYgPj4gMl0gfCAwKSAhPSAoZTIgfCAwKSA/IChwMiA9IGQyICsgMjAgfCAwLCAoY1twMiA+PiAyXSB8IDApICE9IChlMiB8IDApKSA6IDApIHsKICAgICAgICAgICAgICAgICAgY1tkMiArIDMyID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICAgIG8yID0gZDIgKyA0NCB8IDA7CiAgICAgICAgICAgICAgICAgIGlmICgoY1tvMiA+PiAyXSB8IDApICE9IDQpIHsKICAgICAgICAgICAgICAgICAgICBqMiA9IGIyICsgMTYgKyAoY1tiMiArIDEyID4+IDJdIDw8IDMpIHwgMDsKICAgICAgICAgICAgICAgICAgICBrMiA9IGQyICsgNTIgfCAwOwogICAgICAgICAgICAgICAgICAgIGYyID0gZDIgKyA1MyB8IDA7CiAgICAgICAgICAgICAgICAgICAgbDIgPSBkMiArIDU0IHwgMDsKICAgICAgICAgICAgICAgICAgICBtMiA9IGIyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgbjIgPSBkMiArIDI0IHwgMDsKICAgICAgICAgICAgICAgICAgICBoMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgaTIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICBiMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgYjoKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpMiA+Pj4gMCA+PSBqMiA+Pj4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGkyID0gMTg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgYVtrMiA+PiAwXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGFbZjIgPj4gMF0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICBRcChpMiwgZDIsIGUyLCBlMiwgMSwgZzIpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtsMiA+PiAwXSB8IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpMiA9IDE4OwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbZjIgPj4gMF0gfCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhW2syID4+IDBdIHwgMCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNbbTIgPj4gMl0gJiAxKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkyID0gMTk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY1tuMiA+PiAyXSB8IDApID09IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMiA9IDE5OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY1ttMiA+PiAyXSAmIDIpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSAxOTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICAgICAgICBpMiA9IGkyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKChpMiB8IDApID09IDE4KQogICAgICAgICAgICAgICAgICAgICAgaWYgKGIyKQogICAgICAgICAgICAgICAgICAgICAgICBpMiA9IDE5OwogICAgICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IDQ7CiAgICAgICAgICAgICAgICAgICAgaWYgKChpMiB8IDApID09IDE5KQogICAgICAgICAgICAgICAgICAgICAgYjIgPSAzOwogICAgICAgICAgICAgICAgICAgIGNbbzIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICBpZiAoaDIgJiAxKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY1twMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICBlMiA9IGQyICsgNDAgfCAwOwogICAgICAgICAgICAgICAgICBjW2UyID4+IDJdID0gKGNbZTIgPj4gMl0gfCAwKSArIDE7CiAgICAgICAgICAgICAgICAgIGlmICgoY1tkMiArIDM2ID4+IDJdIHwgMCkgIT0gMSkKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgaWYgKChjW2QyICsgMjQgPj4gMl0gfCAwKSAhPSAyKQogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBhW2QyICsgNTQgPj4gMF0gPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoZjIgfCAwKSA9PSAxKQogICAgICAgICAgICAgICAgICBjW2QyICsgMzIgPj4gMl0gPSAxOwogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgY3AoMCwgZDIsIGUyLCBmMik7CiAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT3AoYjIsIGQyLCBlMiwgZjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgdmFyIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoIShhcChiMiwgY1tkMiArIDggPj4gMl0gfCAwLCAwKSB8IDApKSB7CiAgICAgICAgICAgICAgICBoMiA9IGNbYjIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBnMiA9IGIyICsgMTYgKyAoaDIgPDwgMykgfCAwOwogICAgICAgICAgICAgICAgUHAoYjIgKyAxNiB8IDAsIGQyLCBlMiwgZjIpOwogICAgICAgICAgICAgICAgaWYgKChoMiB8IDApID4gMSkgewogICAgICAgICAgICAgICAgICBoMiA9IGQyICsgNTQgfCAwOwogICAgICAgICAgICAgICAgICBiMiA9IGIyICsgMjQgfCAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgUHAoYjIsIGQyLCBlMiwgZjIpOwogICAgICAgICAgICAgICAgICAgIGlmIChhW2gyID4+IDBdIHwgMCkKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBiMiArIDggfCAwOwogICAgICAgICAgICAgICAgICB9IHdoaWxlIChiMiA+Pj4gMCA8IGcyID4+PiAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgIGJwKDAsIGQyLCBlMiwgZjIpOwogICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFBwKGEyLCBiMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaWYgKGQyKSB7CiAgICAgICAgICAgIGYyID0gZzIgPj4gODsKICAgICAgICAgICAgaWYgKGcyICYgMSkKICAgICAgICAgICAgICBmMiA9IGNbKGNbZDIgPj4gMl0gfCAwKSArIGYyID4+IDJdIHwgMDsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICBhMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgZmFbY1soY1thMiA+PiAyXSB8IDApICsgMjggPj4gMl0gJiA3XShhMiwgYjIsIGQyICsgZjIgfCAwLCAoZzIgJiAyIHwgMCkgPT0gMCA/IDIgOiBlMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFFwKGEyLCBiMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICBnMiA9IGcyIHwgMDsKICAgICAgICAgIHZhciBoMiA9IDAsIGkyID0gMDsKICAgICAgICAgIGkyID0gY1thMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgaDIgPSBpMiA+PiA4OwogICAgICAgICAgaWYgKGkyICYgMSkKICAgICAgICAgICAgaDIgPSBjWyhjW2UyID4+IDJdIHwgMCkgKyBoMiA+PiAyXSB8IDA7CiAgICAgICAgICBhMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgaGFbY1soY1thMiA+PiAyXSB8IDApICsgMjAgPj4gMl0gJiAzXShhMiwgYjIsIGQyLCBlMiArIGgyIHwgMCwgKGkyICYgMiB8IDApID09IDAgPyAyIDogZjIsIGcyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUnAoYTIsIGIyLCBkMiwgZTIsIGYyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgdmFyIGcyID0gMCwgaDIgPSAwOwogICAgICAgICAgaDIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBnMiA9IGgyID4+IDg7CiAgICAgICAgICBpZiAoaDIgJiAxKQogICAgICAgICAgICBnMiA9IGNbKGNbZDIgPj4gMl0gfCAwKSArIGcyID4+IDJdIHwgMDsKICAgICAgICAgIGEyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBnYVtjWyhjW2EyID4+IDJdIHwgMCkgKyAyNCA+PiAyXSAmIDNdKGEyLCBiMiwgZDIgKyBnMiB8IDAsIChoMiAmIDIgfCAwKSA9PSAwID8gMiA6IGUyLCBmMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNwKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1ODk2OwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBUcChhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBjMiA9IDA7CiAgICAgICAgICBiMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGMyID0gYjI7CiAgICAgICAgICBVcChjMiwgYTIpOwogICAgICAgICAgYTIgPSBWcChjMikgfCAwOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVXAoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgX3AoYTIsIGIyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVnAoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgV3AoZDIsIGNbYTIgKyA0ID4+IDJdIHwgMCk7CiAgICAgICAgICBpZiAoISgoWHAoZDIpIHwgMCkgPDwgMjQgPj4gMjQpKQogICAgICAgICAgICBhMiA9IFpwKFlwKGEyKSB8IDApIHwgMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYTIgPSAwOwogICAgICAgICAgViA9IGIyOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gV3AoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBYcChiMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gYVtjW2IyID4+IDJdID4+IDBdIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWXAoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWnAoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMDsKICAgICAgICAgIGcyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZjIgPSBnMjsKICAgICAgICAgIGIyID0gY1tiMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBhW2IyID4+IDBdIHwgMDsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmIChkMiA8PCAyNCA+PiAyNCAhPSAxKQogICAgICAgICAgICAgIGlmICghKGQyICYgMikpIHsKICAgICAgICAgICAgICAgIGFbYjIgPj4gMF0gPSAyOwogICAgICAgICAgICAgICAgZTIgPSAxOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBUbygyMDk4NSwgZjIpOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZTIgPSAwOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgViA9IGcyOwogICAgICAgICAgcmV0dXJuIGUyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gX3AoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGIyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIGNbYTIgKyA4ID4+IDJdID0gYjIgKyAxOwogICAgICAgICAgY1thMiArIDEyID4+IDJdID0gMDsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJHAoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgYzIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBjMiA9IGIyOwogICAgICAgICAgVXAoYzIsIGEyKTsKICAgICAgICAgIGFxKGMyKTsKICAgICAgICAgIFYgPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYXEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMCwgZDIgPSAwOwogICAgICAgICAgYjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBkMiA9IGIyOwogICAgICAgICAgV3AoZDIsIGNbYTIgKyA0ID4+IDJdIHwgMCk7CiAgICAgICAgICBicShkMik7CiAgICAgICAgICBjcShZcChhMikgfCAwKTsKICAgICAgICAgIFYgPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYnEoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYVtjW2IyID4+IDJdID4+IDBdID0gMTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gY3EoYjIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYVtjW2IyICsgOCA+PiAyXSA+PiAwXSA9IDE7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRxKCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGMyID0gMDsKICAgICAgICAgIGMyID0gKGEyIHwgMCkgPT0gMCA/IDEgOiBhMjsKICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgIGIyID0gZHIoYzIpIHwgMDsKICAgICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICAgIGEyID0gNjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBhMiA9IGRxKCkgfCAwOwogICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgYTIgPSA1OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJhW2EyICYgM10oKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoYTIgfCAwKSA9PSA1KSB7CiAgICAgICAgICAgIGMyID0gdig0KSB8IDA7CiAgICAgICAgICAgIFNwKGMyKTsKICAgICAgICAgICAgeChjMiB8IDAsIDM4ODAsIDEyMSk7CiAgICAgICAgICB9IGVsc2UgaWYgKChhMiB8IDApID09IDYpCiAgICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZnEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIGVxKGEyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGdxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaHEoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGYyOwogICAgICAgICAgY1tlMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICBhMiA9IGFhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDE2ID4+IDJdICYgN10oYTIsIGIyLCBlMikgfCAwOwogICAgICAgICAgaWYgKGEyKQogICAgICAgICAgICBjW2QyID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgIFYgPSBmMjsKICAgICAgICAgIHJldHVybiBhMiAmIDEgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpcShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBpZiAoIWEyKQogICAgICAgICAgICBhMiA9IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGEyID0gKGVwKGEyLCAzODQwLCAzOTc2LCAwKSB8IDApICE9IDAgJiAxOwogICAgICAgICAgcmV0dXJuIGEyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ganEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGtxKCkgewogICAgICAgICAgcmV0dXJuIChscSgpIHwgMCkgPiAwIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbHEoKSB7CiAgICAgICAgICByZXR1cm4geSgpIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbXEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBucShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBtcShhMik7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9xKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAyMTAzOTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcHEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBxcShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICB2YXIgYjIgPSAwLCBkMiA9IDA7CiAgICAgICAgICBiMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICBpZiAoISgoY1tiMiA+PiAyXSB8IDApICE9IDAgPyAoZDIgPSBjW2IyID4+IDJdIHwgMCwgY1tiMiA+PiAyXSA9IGQyICsgLTEsIChkMiB8IDApICE9IDApIDogMCkpCiAgICAgICAgICAgIGNhW2NbKGNbYTIgPj4gMl0gfCAwKSArIDE2ID4+IDJdICYgMjU1XShhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHJxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0ganEoYTIpIHwgMDsKICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYnIoYTIsIDIxMTQ1KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc3EoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0cShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwLCBlMiA9IDA7CiAgICAgICAgICBlMiA9IGZvKGIyKSB8IDA7CiAgICAgICAgICBkMiA9IGVxKGUyICsgMTMgfCAwKSB8IDA7CiAgICAgICAgICBjW2QyID4+IDJdID0gZTI7CiAgICAgICAgICBjW2QyICsgNCA+PiAyXSA9IGUyOwogICAgICAgICAgY1tkMiArIDggPj4gMl0gPSAwOwogICAgICAgICAgZDIgPSB1cShkMikgfCAwOwogICAgICAgICAgdXIoZDIgfCAwLCBiMiB8IDAsIGUyICsgMSB8IDApIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSBkMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdXEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIGEyICsgMTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB2cShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjW2EyID4+IDJdID0gNTkxNjsKICAgICAgICAgIHRxKGEyICsgNCB8IDAsIGIyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gd3EoYjIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1tiMiA+PiAyXSA9IDU5MzY7CiAgICAgICAgICB0cShiMiArIDQgfCAwLCAoYVtkMiArIDExID4+IDBdIHwgMCkgPCAwID8gY1tkMiA+PiAyXSB8IDAgOiBkMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHhxKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1OTM2OwogICAgICAgICAgdHEoYTIgKyA0IHwgMCwgYjIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5cShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IHYoOCkgfCAwOwogICAgICAgICAgdnEoYTIsIDIxMTYzKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1OTU2OwogICAgICAgICAgeChhMiB8IDAsIDM5MjgsIDEyMyk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHpxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGEyID0gdig4KSB8IDA7CiAgICAgICAgICB2cShhMiwgMjExNjMpOwogICAgICAgICAgY1thMiA+PiAyXSA9IDU5NzY7CiAgICAgICAgICB4KGEyIHwgMCwgMzk0NCwgMTIzKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQXEoYjIsIGQyLCBlMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwLCBoMiA9IDAsIGkyID0gMDsKICAgICAgICAgIGcyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgZjIgPSBnMjsKICAgICAgICAgIGlmIChlMiA+Pj4gMCA+IDQyOTQ5NjcyNzkpCiAgICAgICAgICAgIHlxKGIyKTsKICAgICAgICAgIGlmIChlMiA+Pj4gMCA8IDExKQogICAgICAgICAgICBhW2IyICsgMTEgPj4gMF0gPSBlMjsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBpMiA9IGUyICsgMTYgJiAtMTY7CiAgICAgICAgICAgIGgyID0gZXEoaTIpIHwgMDsKICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGgyOwogICAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IGkyIHwgLTIxNDc0ODM2NDg7CiAgICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gZTI7CiAgICAgICAgICAgIGIyID0gaDI7CiAgICAgICAgICB9CiAgICAgICAgICBCcShiMiwgZDIsIGUyKSB8IDA7CiAgICAgICAgICBhW2YyID4+IDBdID0gMDsKICAgICAgICAgIG5iKGIyICsgZTIgfCAwLCBmMik7CiAgICAgICAgICBWID0gZzI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJxKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGlmIChjMiB8IDApCiAgICAgICAgICAgIHVyKGEyIHwgMCwgYjIgfCAwLCBjMiB8IDApIHwgMDsKICAgICAgICAgIHJldHVybiBhMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIENxKGIyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGlmICgoYVtiMiArIDExID4+IDBdIHwgMCkgPCAwKQogICAgICAgICAgICBEYShjW2IyID4+IDJdIHwgMCwgY1tiMiArIDggPj4gMl0gJiAyMTQ3NDgzNjQ3KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRHEoYjIsIGQyLCBlMiwgZjIsIGcyLCBoMiwgaTIsIGoyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgaDIgPSBoMiB8IDA7CiAgICAgICAgICBpMiA9IGkyIHwgMDsKICAgICAgICAgIGoyID0gajIgfCAwOwogICAgICAgICAgdmFyIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwOwogICAgICAgICAgbzIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBuMiA9IG8yOwogICAgICAgICAgaWYgKCgtMTggLSBkMiB8IDApID4+PiAwIDwgZTIgPj4+IDApCiAgICAgICAgICAgIHlxKGIyKTsKICAgICAgICAgIGlmICgoYVtiMiArIDExID4+IDBdIHwgMCkgPCAwKQogICAgICAgICAgICBtMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBtMiA9IGIyOwogICAgICAgICAgaWYgKGQyID4+PiAwIDwgMjE0NzQ4MzYyMykgewogICAgICAgICAgICBrMiA9IGUyICsgZDIgfCAwOwogICAgICAgICAgICBsMiA9IGQyIDw8IDE7CiAgICAgICAgICAgIGsyID0gazIgPj4+IDAgPCBsMiA+Pj4gMCA/IGwyIDogazI7CiAgICAgICAgICAgIGsyID0gazIgPj4+IDAgPCAxMSA/IDExIDogazIgKyAxNiAmIC0xNjsKICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICBrMiA9IC0xNzsKICAgICAgICAgIGwyID0gZXEoazIpIHwgMDsKICAgICAgICAgIGlmIChnMiB8IDApCiAgICAgICAgICAgIEJxKGwyLCBtMiwgZzIpIHwgMDsKICAgICAgICAgIGlmIChpMiB8IDApCiAgICAgICAgICAgIEJxKGwyICsgZzIgfCAwLCBqMiwgaTIpIHwgMDsKICAgICAgICAgIGYyID0gZjIgLSBoMiB8IDA7CiAgICAgICAgICBlMiA9IGYyIC0gZzIgfCAwOwogICAgICAgICAgaWYgKGUyIHwgMCkKICAgICAgICAgICAgQnEobDIgKyBnMiArIGkyIHwgMCwgbTIgKyBnMiArIGgyIHwgMCwgZTIpIHwgMDsKICAgICAgICAgIGUyID0gZDIgKyAxIHwgMDsKICAgICAgICAgIGlmICgoZTIgfCAwKSAhPSAxMSkKICAgICAgICAgICAgRGEobTIsIGUyKTsKICAgICAgICAgIGNbYjIgPj4gMl0gPSBsMjsKICAgICAgICAgIGNbYjIgKyA4ID4+IDJdID0gazIgfCAtMjE0NzQ4MzY0ODsKICAgICAgICAgIGkyID0gZjIgKyBpMiB8IDA7CiAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IGkyOwogICAgICAgICAgYVtuMiA+PiAwXSA9IDA7CiAgICAgICAgICBuYihsMiArIGkyIHwgMCwgbjIpOwogICAgICAgICAgViA9IG8yOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBFcShiMiwgZDIsIGUyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICB2YXIgZjIgPSAwLCBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMDsKICAgICAgICAgIGsyID0gVjsKICAgICAgICAgIFYgPSBWICsgMTYgfCAwOwogICAgICAgICAgaTIgPSBrMjsKICAgICAgICAgIGoyID0gYjIgKyAxMSB8IDA7CiAgICAgICAgICBmMiA9IGFbajIgPj4gMF0gfCAwOwogICAgICAgICAgaDIgPSBmMiA8PCAyNCA+PiAyNCA8IDA7CiAgICAgICAgICBpZiAoaDIpIHsKICAgICAgICAgICAgZzIgPSAoY1tiMiArIDggPj4gMl0gJiAyMTQ3NDgzNjQ3KSArIC0xIHwgMDsKICAgICAgICAgICAgZjIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBnMiA9IDEwOwogICAgICAgICAgICBmMiA9IGYyICYgMjU1OwogICAgICAgICAgfQogICAgICAgICAgaWYgKChnMiAtIGYyIHwgMCkgPj4+IDAgPj0gZTIgPj4+IDApIHsKICAgICAgICAgICAgaWYgKGUyIHwgMCkgewogICAgICAgICAgICAgIGlmIChoMikKICAgICAgICAgICAgICAgIGcyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgZzIgPSBiMjsKICAgICAgICAgICAgICBCcShnMiArIGYyIHwgMCwgZDIsIGUyKSB8IDA7CiAgICAgICAgICAgICAgZjIgPSBmMiArIGUyIHwgMDsKICAgICAgICAgICAgICBpZiAoKGFbajIgPj4gMF0gfCAwKSA8IDApCiAgICAgICAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IGYyOwogICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIGFbajIgPj4gMF0gPSBmMjsKICAgICAgICAgICAgICBhW2kyID4+IDBdID0gMDsKICAgICAgICAgICAgICBuYihnMiArIGYyIHwgMCwgaTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgRHEoYjIsIGcyLCBmMiArIGUyIC0gZzIgfCAwLCBmMiwgZjIsIDAsIGUyLCBkMik7CiAgICAgICAgICBWID0gazI7CiAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGcShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gRXEoYTIsIGIyLCBsYihiMikgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdxKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGlmICghYzIpCiAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgYTIgPSBGbyhhMiwgYjIsIGMyKSB8IDA7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBIcShiMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgZzIgPSBnMiB8IDA7CiAgICAgICAgICB2YXIgaDIgPSAwLCBpMiA9IDA7CiAgICAgICAgICBoMiA9IGFbYjIgKyAxMSA+PiAwXSB8IDA7CiAgICAgICAgICBpMiA9IGgyIDw8IDI0ID4+IDI0IDwgMDsKICAgICAgICAgIGlmIChpMikKICAgICAgICAgICAgaDIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGgyID0gaDIgJiAyNTU7CiAgICAgICAgICBpZiAoKGcyIHwgMCkgPT0gLTEgfCBoMiA+Pj4gMCA8IGQyID4+PiAwKQogICAgICAgICAgICB6cShiMik7CiAgICAgICAgICBoMiA9IGgyIC0gZDIgfCAwOwogICAgICAgICAgZTIgPSBoMiA+Pj4gMCA8IGUyID4+PiAwID8gaDIgOiBlMjsKICAgICAgICAgIGlmIChpMikKICAgICAgICAgICAgYjIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgIGgyID0gZTIgPj4+IDAgPiBnMiA+Pj4gMDsKICAgICAgICAgIGIyID0gR3EoYjIgKyBkMiB8IDAsIGYyLCBoMiA/IGcyIDogZTIpIHwgMDsKICAgICAgICAgIGlmICghYjIpCiAgICAgICAgICAgIHJldHVybiAoZTIgPj4+IDAgPCBnMiA+Pj4gMCA/IC0xIDogaDIgJiAxKSB8IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSXEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBKcShhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBqcChhMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAyMTIyODsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTHEoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgY1thMiA+PiAyXSA9IGQyOwogICAgICAgICAgY1thMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTXEoYTIsIGIyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZjIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBlMiA9IGYyOwogICAgICAgICAgZWFbY1soY1thMiA+PiAyXSB8IDApICsgMTIgPj4gMl0gJiAxNV0oZTIsIGEyLCBiMik7CiAgICAgICAgICBpZiAoKGNbZTIgKyA0ID4+IDJdIHwgMCkgPT0gKGNbZDIgKyA0ID4+IDJdIHwgMCkpCiAgICAgICAgICAgIGEyID0gKGNbZTIgPj4gMl0gfCAwKSA9PSAoY1tkMiA+PiAyXSB8IDApOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBhMiA9IDA7CiAgICAgICAgICBWID0gZjI7CiAgICAgICAgICByZXR1cm4gYTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOcShhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICByZXR1cm4gKChjW2IyID4+IDJdIHwgMCkgPT0gKGQyIHwgMCkgPyAoY1tiMiArIDQgPj4gMl0gfCAwKSA9PSAoYTIgfCAwKSA6IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT3EoYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgaWYgKChjMiB8IDApID4gMjU2KQogICAgICAgICAgICBBcShhMiwgMjExNzYsIGxiKDIxMTc2KSB8IDApOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBQcShhMiwgMCwgYzIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBQcShhMiwgYjIsIGMyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBRcShhMiwgYzIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBRcShiMiwgZDIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDA7CiAgICAgICAgICBpMiA9IFY7CiAgICAgICAgICBWID0gViArIDEwNDAgfCAwOwogICAgICAgICAgZzIgPSBpMiArIDEwMjQgfCAwOwogICAgICAgICAgZTIgPSBpMjsKICAgICAgICAgIGgyID0gY1soYW8oKSB8IDApID4+IDJdIHwgMDsKICAgICAgICAgIGYyID0gUnEoT28oZDIsIGUyLCAxMDI0KSB8IDAsIGUyKSB8IDA7CiAgICAgICAgICBpZiAoIShhW2YyID4+IDBdIHwgMCkpIHsKICAgICAgICAgICAgY1tnMiA+PiAyXSA9IGQyOwogICAgICAgICAgICBHbyhlMiwgMTAyNCwgMjEyMTEsIGcyKSB8IDA7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgZTIgPSBmMjsKICAgICAgICAgIGNbKGFvKCkgfCAwKSA+PiAyXSA9IGgyOwogICAgICAgICAgQXEoYjIsIGUyLCBsYihlMikgfCAwKTsKICAgICAgICAgIFYgPSBpMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gUnEoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgc3dpdGNoIChhMiB8IDApIHsKICAgICAgICAgICAgY2FzZSAwOiB7CiAgICAgICAgICAgICAgZDIgPSBiMjsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXNlIC0xOiB7CiAgICAgICAgICAgICAgYTIgPSBjWyhhbygpIHwgMCkgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGUyID0gMzsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGUyID0gMzsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgoZTIgfCAwKSA9PSAzKQogICAgICAgICAgICBpZiAoKGEyIHwgMCkgPT0gMjgpCiAgICAgICAgICAgICAgZDIgPSAyMjE0NTsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIFAoKTsKICAgICAgICAgIHJldHVybiBkMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFNxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGpwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVHEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgcmV0dXJuIDIxMzUzOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVcShhMiwgYjIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBpZiAoKGQyIHwgMCkgPiAyNTYpIHsKICAgICAgICAgICAgV3EoKSB8IDA7CiAgICAgICAgICAgIGIyID0gNjE4MDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIFhxKCkgfCAwOwogICAgICAgICAgICBiMiA9IDYxNzY7CiAgICAgICAgICB9CiAgICAgICAgICBjW2EyID4+IDJdID0gZDI7CiAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGIyOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBWcShhMiwgYjIsIGMyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBpZiAoKGMyIHwgMCkgPiAyNTYpCiAgICAgICAgICAgIEFxKGEyLCAyMTMxOSwgbGIoMjEzMTkpIHwgMCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIFBxKGEyLCAwLCBjMik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFdxKCkgewogICAgICAgICAgaWYgKChhWzIxNDg4XSB8IDApID09IDAgPyBUcCgyMTQ4OCkgfCAwIDogMCkKICAgICAgICAgICAgJHAoMjE0ODgpOwogICAgICAgICAgcmV0dXJuIDYxODA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFhxKCkgewogICAgICAgICAgaWYgKChhWzIxNDgwXSB8IDApID09IDAgPyBUcCgyMTQ4MCkgfCAwIDogMCkKICAgICAgICAgICAgJHAoMjE0ODApOwogICAgICAgICAgcmV0dXJuIDYxNzY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFlxKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHlwKGEyKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWnEoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgWXEoYTIpOwogICAgICAgICAganAoYTIpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBfcShhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICB2YXIgZDIgPSAwOwogICAgICAgICAgZDIgPSBjW2IyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICBlYVtjWyhjW2QyID4+IDJdIHwgMCkgKyAyNCA+PiAyXSAmIDE1XShhMiwgZDIsIGNbYjIgPj4gMl0gfCAwKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gJHEoYjIsIGQyLCBlMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBoMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGcyID0gaDI7CiAgICAgICAgICBpZiAoY1tkMiA+PiAyXSB8IDApIHsKICAgICAgICAgICAgZjIgPSBhW2UyICsgMTEgPj4gMF0gfCAwOwogICAgICAgICAgICBpZiAoZjIgPDwgMjQgPj4gMjQgPCAwKQogICAgICAgICAgICAgIGYyID0gY1tlMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZjIgPSBmMiAmIDI1NTsKICAgICAgICAgICAgaWYgKGYyIHwgMCkKICAgICAgICAgICAgICBGcShlMiwgMjE0MTcpIHwgMDsKICAgICAgICAgICAgX3EoZzIsIGQyKTsKICAgICAgICAgICAgZDIgPSBhW2cyICsgMTEgPj4gMF0gfCAwOwogICAgICAgICAgICBmMiA9IGQyIDw8IDI0ID4+IDI0IDwgMDsKICAgICAgICAgICAgRXEoZTIsIGYyID8gY1tnMiA+PiAyXSB8IDAgOiBnMiwgZjIgPyBjW2cyICsgNCA+PiAyXSB8IDAgOiBkMiAmIDI1NSkgfCAwOwogICAgICAgICAgICBDcShnMik7CiAgICAgICAgICB9CiAgICAgICAgICBjW2IyID4+IDJdID0gY1tlMiA+PiAyXTsKICAgICAgICAgIGNbYjIgKyA0ID4+IDJdID0gY1tlMiArIDQgPj4gMl07CiAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IGNbZTIgKyA4ID4+IDJdOwogICAgICAgICAgZjIgPSAwOwogICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgaWYgKChmMiB8IDApID09IDMpCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNbZTIgKyAoZjIgPDwgMikgPj4gMl0gPSAwOwogICAgICAgICAgICBmMiA9IGYyICsgMSB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICBWID0gaDI7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGFyKGEyLCBiMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHZhciBlMiA9IDAsIGYyID0gMCwgZzIgPSAwOwogICAgICAgICAgZTIgPSBWOwogICAgICAgICAgViA9IFYgKyAzMiB8IDA7CiAgICAgICAgICBnMiA9IGUyICsgMTIgfCAwOwogICAgICAgICAgZjIgPSBlMjsKICAgICAgICAgIEFxKGYyLCBkMiwgbGIoZDIpIHwgMCk7CiAgICAgICAgICAkcShnMiwgYjIsIGYyKTsKICAgICAgICAgIHdxKGEyLCBnMik7CiAgICAgICAgICBDcShnMik7CiAgICAgICAgICBDcShmMik7CiAgICAgICAgICBjW2EyID4+IDJdID0gNjE5MjsKICAgICAgICAgIGYyID0gYjI7CiAgICAgICAgICBiMiA9IGNbZjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgIGQyID0gYTIgKyA4IHwgMDsKICAgICAgICAgIGNbZDIgPj4gMl0gPSBjW2YyID4+IDJdOwogICAgICAgICAgY1tkMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIFYgPSBlMjsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYnIoYTIsIGIyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgdmFyIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBmMiA9IFY7CiAgICAgICAgICBWID0gViArIDE2IHwgMDsKICAgICAgICAgIGUyID0gZjIgKyA4IHwgMDsKICAgICAgICAgIGQyID0gdigxNikgfCAwOwogICAgICAgICAgV3EoKSB8IDA7CiAgICAgICAgICBjW2YyID4+IDJdID0gYTI7CiAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IDYxODA7CiAgICAgICAgICBjW2UyID4+IDJdID0gY1tmMiA+PiAyXTsKICAgICAgICAgIGNbZTIgKyA0ID4+IDJdID0gY1tmMiArIDQgPj4gMl07CiAgICAgICAgICBhcihkMiwgZTIsIGIyKTsKICAgICAgICAgIHgoZDIgfCAwLCA0MjcyLCAxMzYpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBjcihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBhMiA9IHYoOCkgfCAwOwogICAgICAgICAgdnEoYTIsIDIxNDIwKTsKICAgICAgICAgIGNbYTIgPj4gMl0gPSA1OTU2OwogICAgICAgICAgeChhMiB8IDAsIDM5MjgsIDEyMyk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRyKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMCwgazIgPSAwLCBsMiA9IDAsIG0yID0gMCwgbjIgPSAwLCBvMiA9IDAsIHAyID0gMCwgcTIgPSAwLCByMiA9IDAsIHMyID0gMCwgdDIgPSAwLCB1MiA9IDAsIHYyID0gMCwgdzIgPSAwOwogICAgICAgICAgdzIgPSBWOwogICAgICAgICAgViA9IFYgKyAxNiB8IDA7CiAgICAgICAgICBuMiA9IHcyOwogICAgICAgICAgZG8KICAgICAgICAgICAgaWYgKGEyID4+PiAwIDwgMjQ1KSB7CiAgICAgICAgICAgICAgazIgPSBhMiA+Pj4gMCA8IDExID8gMTYgOiBhMiArIDExICYgLTg7CiAgICAgICAgICAgICAgYTIgPSBrMiA+Pj4gMzsKICAgICAgICAgICAgICBtMiA9IGNbNTQxMl0gfCAwOwogICAgICAgICAgICAgIGQyID0gbTIgPj4+IGEyOwogICAgICAgICAgICAgIGlmIChkMiAmIDMgfCAwKSB7CiAgICAgICAgICAgICAgICBiMiA9IChkMiAmIDEgXiAxKSArIGEyIHwgMDsKICAgICAgICAgICAgICAgIGEyID0gMjE2ODggKyAoYjIgPDwgMSA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICBkMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBlMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgZjIgPSBlMiArIDggfCAwOwogICAgICAgICAgICAgICAgZzIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGlmICgoZzIgfCAwKSA9PSAoYTIgfCAwKSkKICAgICAgICAgICAgICAgICAgY1s1NDEyXSA9IG0yICYgfigxIDw8IGIyKTsKICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICBjW2cyICsgMTIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdjIgPSBiMiA8PCAzOwogICAgICAgICAgICAgICAgY1tlMiArIDQgPj4gMl0gPSB2MiB8IDM7CiAgICAgICAgICAgICAgICB2MiA9IGUyICsgdjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgIGNbdjIgPj4gMl0gPSBjW3YyID4+IDJdIHwgMTsKICAgICAgICAgICAgICAgIHYyID0gZjI7CiAgICAgICAgICAgICAgICBWID0gdzI7CiAgICAgICAgICAgICAgICByZXR1cm4gdjIgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsMiA9IGNbNTQxNF0gfCAwOwogICAgICAgICAgICAgIGlmIChrMiA+Pj4gMCA+IGwyID4+PiAwKSB7CiAgICAgICAgICAgICAgICBpZiAoZDIgfCAwKSB7CiAgICAgICAgICAgICAgICAgIGIyID0gMiA8PCBhMjsKICAgICAgICAgICAgICAgICAgYjIgPSBkMiA8PCBhMiAmIChiMiB8IDAgLSBiMik7CiAgICAgICAgICAgICAgICAgIGIyID0gKGIyICYgMCAtIGIyKSArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgaTIgPSBiMiA+Pj4gMTIgJiAxNjsKICAgICAgICAgICAgICAgICAgYjIgPSBiMiA+Pj4gaTI7CiAgICAgICAgICAgICAgICAgIGQyID0gYjIgPj4+IDUgJiA4OwogICAgICAgICAgICAgICAgICBiMiA9IGIyID4+PiBkMjsKICAgICAgICAgICAgICAgICAgZzIgPSBiMiA+Pj4gMiAmIDQ7CiAgICAgICAgICAgICAgICAgIGIyID0gYjIgPj4+IGcyOwogICAgICAgICAgICAgICAgICBhMiA9IGIyID4+PiAxICYgMjsKICAgICAgICAgICAgICAgICAgYjIgPSBiMiA+Pj4gYTI7CiAgICAgICAgICAgICAgICAgIGUyID0gYjIgPj4+IDEgJiAxOwogICAgICAgICAgICAgICAgICBlMiA9IChkMiB8IGkyIHwgZzIgfCBhMiB8IGUyKSArIChiMiA+Pj4gZTIpIHwgMDsKICAgICAgICAgICAgICAgICAgYjIgPSAyMTY4OCArIChlMiA8PCAxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgYTIgPSBiMiArIDggfCAwOwogICAgICAgICAgICAgICAgICBnMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBpMiA9IGcyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgIGQyID0gY1tpMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIGlmICgoZDIgfCAwKSA9PSAoYjIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgIGEyID0gbTIgJiB+KDEgPDwgZTIpOwogICAgICAgICAgICAgICAgICAgIGNbNTQxMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjW2QyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgYTIgPSBtMjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2MiA9IGUyIDw8IDM7CiAgICAgICAgICAgICAgICAgIGgyID0gdjIgLSBrMiB8IDA7CiAgICAgICAgICAgICAgICAgIGNbZzIgKyA0ID4+IDJdID0gazIgfCAzOwogICAgICAgICAgICAgICAgICBmMiA9IGcyICsgazIgfCAwOwogICAgICAgICAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IGgyIHwgMTsKICAgICAgICAgICAgICAgICAgY1tnMiArIHYyID4+IDJdID0gaDI7CiAgICAgICAgICAgICAgICAgIGlmIChsMiB8IDApIHsKICAgICAgICAgICAgICAgICAgICBlMiA9IGNbNTQxN10gfCAwOwogICAgICAgICAgICAgICAgICAgIGIyID0gbDIgPj4+IDM7CiAgICAgICAgICAgICAgICAgICAgZDIgPSAyMTY4OCArIChiMiA8PCAxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICBiMiA9IDEgPDwgYjI7CiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYTIgJiBiMikpIHsKICAgICAgICAgICAgICAgICAgICAgIGNbNTQxMl0gPSBhMiB8IGIyOwogICAgICAgICAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgIGEyID0gZDIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgIGNbYjIgKyAxMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgIGNbZTIgKyA4ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgY1tlMiArIDEyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY1s1NDE0XSA9IGgyOwogICAgICAgICAgICAgICAgICBjWzU0MTddID0gZjI7CiAgICAgICAgICAgICAgICAgIHYyID0gaTI7CiAgICAgICAgICAgICAgICAgIFYgPSB3MjsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHYyIHwgMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGcyID0gY1s1NDEzXSB8IDA7CiAgICAgICAgICAgICAgICBpZiAoZzIpIHsKICAgICAgICAgICAgICAgICAgZDIgPSAoZzIgJiAwIC0gZzIpICsgLTEgfCAwOwogICAgICAgICAgICAgICAgICBmMiA9IGQyID4+PiAxMiAmIDE2OwogICAgICAgICAgICAgICAgICBkMiA9IGQyID4+PiBmMjsKICAgICAgICAgICAgICAgICAgZTIgPSBkMiA+Pj4gNSAmIDg7CiAgICAgICAgICAgICAgICAgIGQyID0gZDIgPj4+IGUyOwogICAgICAgICAgICAgICAgICBoMiA9IGQyID4+PiAyICYgNDsKICAgICAgICAgICAgICAgICAgZDIgPSBkMiA+Pj4gaDI7CiAgICAgICAgICAgICAgICAgIGkyID0gZDIgPj4+IDEgJiAyOwogICAgICAgICAgICAgICAgICBkMiA9IGQyID4+PiBpMjsKICAgICAgICAgICAgICAgICAgajIgPSBkMiA+Pj4gMSAmIDE7CiAgICAgICAgICAgICAgICAgIGoyID0gY1syMTk1MiArICgoZTIgfCBmMiB8IGgyIHwgaTIgfCBqMikgKyAoZDIgPj4+IGoyKSA8PCAyKSA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIGQyID0gajI7CiAgICAgICAgICAgICAgICAgIGkyID0gajI7CiAgICAgICAgICAgICAgICAgIGoyID0gKGNbajIgKyA0ID4+IDJdICYgLTgpIC0gazIgfCAwOwogICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgIGEyID0gY1tkMiArIDE2ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbZDIgKyAyMCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaDIgPSAoY1thMiArIDQgPj4gMl0gJiAtOCkgLSBrMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgZjIgPSBoMiA+Pj4gMCA8IGoyID4+PiAwOwogICAgICAgICAgICAgICAgICAgIGQyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgaTIgPSBmMiA/IGEyIDogaTI7CiAgICAgICAgICAgICAgICAgICAgajIgPSBmMiA/IGgyIDogajI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaDIgPSBpMiArIGsyIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKGgyID4+PiAwID4gaTIgPj4+IDApIHsKICAgICAgICAgICAgICAgICAgICBmMiA9IGNbaTIgKyAyNCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2kyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gKGkyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBpMiArIDIwIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiMikgewogICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gaTIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGIyICsgMjAgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGNbaTIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgY1tkMiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyA4ID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICBpZiAoZjIgfCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1tpMiArIDI4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSAyMTk1MiArIChiMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaTIgfCAwKSA9PSAoY1thMiA+PiAyXSB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbNTQxM10gPSBnMiAmIH4oMSA8PCBiMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBmMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjWygoY1t2MiA+PiAyXSB8IDApID09IChpMiB8IDApID8gdjIgOiBmMiArIDIwIHwgMCkgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgY1tkMiArIDI0ID4+IDJdID0gZjI7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1tpMiArIDE2ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgKyAxNiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyAyNCA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1tpMiArIDIwID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIyIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgKyAyMCA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyAyNCA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICAgIGlmIChqMiA+Pj4gMCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICB2MiA9IGoyICsgazIgfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1tpMiArIDQgPj4gMl0gPSB2MiB8IDM7CiAgICAgICAgICAgICAgICAgICAgICB2MiA9IGkyICsgdjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGNbdjIgPj4gMl0gPSBjW3YyID4+IDJdIHwgMTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgY1tpMiArIDQgPj4gMl0gPSBrMiB8IDM7CiAgICAgICAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGoyIHwgMTsKICAgICAgICAgICAgICAgICAgICAgIGNbaDIgKyBqMiA+PiAyXSA9IGoyOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGwyIHwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGNbNTQxN10gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGwyID4+PiAzOwogICAgICAgICAgICAgICAgICAgICAgICBkMiA9IDIxNjg4ICsgKGIyIDw8IDEgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IDEgPDwgYjI7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGIyICYgbTIpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1s1NDEyXSA9IGIyIHwgbTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTIgPj4gMl0gPSBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgY1tlMiArIDggPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgY1tlMiArIDEyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBjWzU0MTRdID0gajI7CiAgICAgICAgICAgICAgICAgICAgICBjWzU0MTddID0gaDI7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHYyID0gaTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgICBWID0gdzI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYyIHwgMDsKICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgbTIgPSBrMjsKICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICBtMiA9IGsyOwogICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgbTIgPSBrMjsKICAgICAgICAgICAgfSBlbHNlIGlmIChhMiA+Pj4gMCA8PSA0Mjk0OTY3MjMxKSB7CiAgICAgICAgICAgICAgYTIgPSBhMiArIDExIHwgMDsKICAgICAgICAgICAgICBrMiA9IGEyICYgLTg7CiAgICAgICAgICAgICAgZTIgPSBjWzU0MTNdIHwgMDsKICAgICAgICAgICAgICBpZiAoZTIpIHsKICAgICAgICAgICAgICAgIGYyID0gMCAtIGsyIHwgMDsKICAgICAgICAgICAgICAgIGEyID0gYTIgPj4+IDg7CiAgICAgICAgICAgICAgICBpZiAoYTIpCiAgICAgICAgICAgICAgICAgIGlmIChrMiA+Pj4gMCA+IDE2Nzc3MjE1KQogICAgICAgICAgICAgICAgICAgIGoyID0gMzE7CiAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIG0yID0gKGEyICsgMTA0ODMyMCB8IDApID4+PiAxNiAmIDg7CiAgICAgICAgICAgICAgICAgICAgcTIgPSBhMiA8PCBtMjsKICAgICAgICAgICAgICAgICAgICBpMiA9IChxMiArIDUyMDE5MiB8IDApID4+PiAxNiAmIDQ7CiAgICAgICAgICAgICAgICAgICAgcTIgPSBxMiA8PCBpMjsKICAgICAgICAgICAgICAgICAgICBqMiA9IChxMiArIDI0NTc2MCB8IDApID4+PiAxNiAmIDI7CiAgICAgICAgICAgICAgICAgICAgajIgPSAxNCAtIChpMiB8IG0yIHwgajIpICsgKHEyIDw8IGoyID4+PiAxNSkgfCAwOwogICAgICAgICAgICAgICAgICAgIGoyID0gazIgPj4+IChqMiArIDcgfCAwKSAmIDEgfCBqMiA8PCAxOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIGoyID0gMDsKICAgICAgICAgICAgICAgIGQyID0gY1syMTk1MiArIChqMiA8PCAyKSA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBhOgogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmICghZDIpIHsKICAgICAgICAgICAgICAgICAgICAgIGQyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIHEyID0gNjE7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGkyID0gazIgPDwgKChqMiB8IDApID09IDMxID8gMCA6IDI1IC0gKGoyID4+PiAxKSB8IDApOwogICAgICAgICAgICAgICAgICAgICAgZzIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSAoY1tkMiArIDQgPj4gMl0gJiAtOCkgLSBrMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoMiA+Pj4gMCA8IGYyID4+PiAwKQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxMiA9IDY1OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gaDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBxMiA9IGNbZDIgKyAyMCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tkMiArIDE2ICsgKGkyID4+PiAzMSA8PCAyKSA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gKHEyIHwgMCkgPT0gMCB8IChxMiB8IDApID09IChkMiB8IDApID8gZzIgOiBxMjsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikgewogICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSA2MTsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSBpMiA8PCAxOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgaWYgKChxMiB8IDApID09IDYxKSB7CiAgICAgICAgICAgICAgICAgIGlmICgoZDIgfCAwKSA9PSAwICYgKGEyIHwgMCkgPT0gMCkgewogICAgICAgICAgICAgICAgICAgIGEyID0gMiA8PCBqMjsKICAgICAgICAgICAgICAgICAgICBhMiA9IChhMiB8IDAgLSBhMikgJiBlMjsKICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgICAgICAgICBtMiA9IGsyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIG0yID0gKGEyICYgMCAtIGEyKSArIC0xIHwgMDsKICAgICAgICAgICAgICAgICAgICBoMiA9IG0yID4+PiAxMiAmIDE2OwogICAgICAgICAgICAgICAgICAgIG0yID0gbTIgPj4+IGgyOwogICAgICAgICAgICAgICAgICAgIGcyID0gbTIgPj4+IDUgJiA4OwogICAgICAgICAgICAgICAgICAgIG0yID0gbTIgPj4+IGcyOwogICAgICAgICAgICAgICAgICAgIGkyID0gbTIgPj4+IDIgJiA0OwogICAgICAgICAgICAgICAgICAgIG0yID0gbTIgPj4+IGkyOwogICAgICAgICAgICAgICAgICAgIGoyID0gbTIgPj4+IDEgJiAyOwogICAgICAgICAgICAgICAgICAgIG0yID0gbTIgPj4+IGoyOwogICAgICAgICAgICAgICAgICAgIGQyID0gbTIgPj4+IDEgJiAxOwogICAgICAgICAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgICAgICAgICAgICBkMiA9IGNbMjE5NTIgKyAoKGcyIHwgaDIgfCBpMiB8IGoyIHwgZDIpICsgKG0yID4+PiBkMikgPDwgMikgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICghZDIpIHsKICAgICAgICAgICAgICAgICAgICBpMiA9IGEyOwogICAgICAgICAgICAgICAgICAgIGgyID0gZjI7CiAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgIHEyID0gNjU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKHEyIHwgMCkgPT0gNjUpIHsKICAgICAgICAgICAgICAgICAgZzIgPSBkMjsKICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICBtMiA9IChjW2cyICsgNCA+PiAyXSAmIC04KSAtIGsyIHwgMDsKICAgICAgICAgICAgICAgICAgICBkMiA9IG0yID4+PiAwIDwgZjIgPj4+IDA7CiAgICAgICAgICAgICAgICAgICAgZjIgPSBkMiA/IG0yIDogZjI7CiAgICAgICAgICAgICAgICAgICAgYTIgPSBkMiA/IGcyIDogYTI7CiAgICAgICAgICAgICAgICAgICAgZDIgPSBjW2cyICsgMTYgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGlmICghZDIpCiAgICAgICAgICAgICAgICAgICAgICBkMiA9IGNbZzIgKyAyMCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikgewogICAgICAgICAgICAgICAgICAgICAgaTIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gZjI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgIGcyID0gZDI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoKGkyIHwgMCkgIT0gMCA/IGgyID4+PiAwIDwgKChjWzU0MTRdIHwgMCkgLSBrMiB8IDApID4+PiAwIDogMCkgPyAobDIgPSBpMiArIGsyIHwgMCwgbDIgPj4+IDAgPiBpMiA+Pj4gMCkgOiAwKSB7CiAgICAgICAgICAgICAgICAgIGcyID0gY1tpMiArIDI0ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgYjIgPSBjW2kyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmICgoYjIgfCAwKSA9PSAoaTIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgYTIgPSBpMiArIDIwIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gaTIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYjIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gYjIgKyAyMCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tmMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBmMiA9IGIyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tmMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gZjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBmMjsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHYyID0gY1tpMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgY1t2MiArIDEyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IHYyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmIChnMikgewogICAgICAgICAgICAgICAgICAgICAgYTIgPSBjW2kyICsgMjggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgZDIgPSAyMTk1MiArIChhMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkyIHwgMCkgPT0gKGNbZDIgPj4gMl0gfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYjIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGUyICYgfigxIDw8IGEyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTNdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gZzIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbKChjW3YyID4+IDJdIHwgMCkgPT0gKGkyIHwgMCkgPyB2MiA6IGcyICsgMjAgfCAwKSA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIyKQogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDI0ID4+IDJdID0gZzI7CiAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbaTIgKyAxNiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoYTIgfCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbYjIgKyAxNiA+PiAyXSA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgICBjW2EyICsgMjQgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1tpMiArIDIwID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChhMikgewogICAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMjAgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICAgICAgY1thMiArIDI0ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgIGI6CiAgICAgICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgICAgIGlmIChoMiA+Pj4gMCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gaDIgKyBrMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbaTIgKyA0ID4+IDJdID0gdjIgfCAzOwogICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGkyICsgdjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgY1t2MiA+PiAyXSA9IGNbdjIgPj4gMl0gfCAxOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgY1tpMiArIDQgPj4gMl0gPSBrMiB8IDM7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbbDIgKyA0ID4+IDJdID0gaDIgfCAxOwogICAgICAgICAgICAgICAgICAgICAgICBjW2wyICsgaDIgPj4gMl0gPSBoMjsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBoMiA+Pj4gMzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgyID4+PiAwIDwgMjU2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSAyMTY4OCArIChiMiA8PCAxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbNTQxMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gMSA8PCBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhMiAmIGIyKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1s1NDEyXSA9IGEyIHwgYjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gbDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDEyID4+IDJdID0gbDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDggPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2wyICsgMTIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGgyID4+PiA4OwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgyID4+PiAwID4gMTY3NzcyMTUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IDMxOwogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdTIgPSAoYjIgKyAxMDQ4MzIwIHwgMCkgPj4+IDE2ICYgODsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYjIgPDwgdTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MiA9ICh2MiArIDUyMDE5MiB8IDApID4+PiAxNiAmIDQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IHYyIDw8IHQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSAodjIgKyAyNDU3NjAgfCAwKSA+Pj4gMTYgJiAyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSAxNCAtICh0MiB8IHUyIHwgZDIpICsgKHYyIDw8IGQyID4+PiAxNSkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBoMiA+Pj4gKGQyICsgNyB8IDApICYgMSB8IGQyIDw8IDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IDIxOTUyICsgKGQyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDI4ID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gbDIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gMSA8PCBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZTIgJiBhMikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTNdID0gZTIgfCBhMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gbDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDI0ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDEyID4+IDJdID0gbDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDggPj4gMl0gPSBsMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjOgogICAgICAgICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYjIgKyA0ID4+IDJdICYgLTggfCAwKSAhPSAoaDIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGgyIDw8ICgoZDIgfCAwKSA9PSAzMSA/IDAgOiAyNSAtIChkMiA+Pj4gMSkgfCAwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGIyICsgMTYgKyAoZTIgPj4+IDMxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYTIgKyA0ID4+IDJdICYgLTggfCAwKSA9PSAoaDIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZTIgPDwgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBsMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDI0ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbbDIgKyAxMiA+PiAyXSA9IGwyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2wyICsgOCA+PiAyXSA9IGwyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICAgICAgdTIgPSBiMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGNbdTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBjW3YyICsgMTIgPj4gMl0gPSBsMjsKICAgICAgICAgICAgICAgICAgICAgICAgY1t1MiA+PiAyXSA9IGwyOwogICAgICAgICAgICAgICAgICAgICAgICBjW2wyICsgOCA+PiAyXSA9IHYyOwogICAgICAgICAgICAgICAgICAgICAgICBjW2wyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgY1tsMiArIDI0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgIHYyID0gaTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgViA9IHcyOwogICAgICAgICAgICAgICAgICByZXR1cm4gdjIgfCAwOwogICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgIG0yID0gazI7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBtMiA9IGsyOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBtMiA9IC0xOwogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgZDIgPSBjWzU0MTRdIHwgMDsKICAgICAgICAgIGlmIChkMiA+Pj4gMCA+PSBtMiA+Pj4gMCkgewogICAgICAgICAgICBiMiA9IGQyIC0gbTIgfCAwOwogICAgICAgICAgICBhMiA9IGNbNTQxN10gfCAwOwogICAgICAgICAgICBpZiAoYjIgPj4+IDAgPiAxNSkgewogICAgICAgICAgICAgIHYyID0gYTIgKyBtMiB8IDA7CiAgICAgICAgICAgICAgY1s1NDE3XSA9IHYyOwogICAgICAgICAgICAgIGNbNTQxNF0gPSBiMjsKICAgICAgICAgICAgICBjW3YyICsgNCA+PiAyXSA9IGIyIHwgMTsKICAgICAgICAgICAgICBjW2EyICsgZDIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IG0yIHwgMzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjWzU0MTRdID0gMDsKICAgICAgICAgICAgICBjWzU0MTddID0gMDsKICAgICAgICAgICAgICBjW2EyICsgNCA+PiAyXSA9IGQyIHwgMzsKICAgICAgICAgICAgICB2MiA9IGEyICsgZDIgKyA0IHwgMDsKICAgICAgICAgICAgICBjW3YyID4+IDJdID0gY1t2MiA+PiAyXSB8IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdjIgPSBhMiArIDggfCAwOwogICAgICAgICAgICBWID0gdzI7CiAgICAgICAgICAgIHJldHVybiB2MiB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICBoMiA9IGNbNTQxNV0gfCAwOwogICAgICAgICAgaWYgKGgyID4+PiAwID4gbTIgPj4+IDApIHsKICAgICAgICAgICAgdDIgPSBoMiAtIG0yIHwgMDsKICAgICAgICAgICAgY1s1NDE1XSA9IHQyOwogICAgICAgICAgICB2MiA9IGNbNTQxOF0gfCAwOwogICAgICAgICAgICB1MiA9IHYyICsgbTIgfCAwOwogICAgICAgICAgICBjWzU0MThdID0gdTI7CiAgICAgICAgICAgIGNbdTIgKyA0ID4+IDJdID0gdDIgfCAxOwogICAgICAgICAgICBjW3YyICsgNCA+PiAyXSA9IG0yIHwgMzsKICAgICAgICAgICAgdjIgPSB2MiArIDggfCAwOwogICAgICAgICAgICBWID0gdzI7CiAgICAgICAgICAgIHJldHVybiB2MiB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIShjWzU1MzBdIHwgMCkpIHsKICAgICAgICAgICAgY1s1NTMyXSA9IDQwOTY7CiAgICAgICAgICAgIGNbNTUzMV0gPSA0MDk2OwogICAgICAgICAgICBjWzU1MzNdID0gLTE7CiAgICAgICAgICAgIGNbNTUzNF0gPSAtMTsKICAgICAgICAgICAgY1s1NTM1XSA9IDA7CiAgICAgICAgICAgIGNbNTUyM10gPSAwOwogICAgICAgICAgICBjWzU1MzBdID0gbjIgJiAtMTYgXiAxNDMxNjU1NzY4OwogICAgICAgICAgICBhMiA9IDQwOTY7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgYTIgPSBjWzU1MzJdIHwgMDsKICAgICAgICAgIGkyID0gbTIgKyA0OCB8IDA7CiAgICAgICAgICBqMiA9IG0yICsgNDcgfCAwOwogICAgICAgICAgZzIgPSBhMiArIGoyIHwgMDsKICAgICAgICAgIGYyID0gMCAtIGEyIHwgMDsKICAgICAgICAgIGsyID0gZzIgJiBmMjsKICAgICAgICAgIGlmIChrMiA+Pj4gMCA8PSBtMiA+Pj4gMCkgewogICAgICAgICAgICB2MiA9IDA7CiAgICAgICAgICAgIFYgPSB3MjsKICAgICAgICAgICAgcmV0dXJuIHYyIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIGEyID0gY1s1NTIyXSB8IDA7CiAgICAgICAgICBpZiAoYTIgfCAwID8gKGwyID0gY1s1NTIwXSB8IDAsIG4yID0gbDIgKyBrMiB8IDAsIG4yID4+PiAwIDw9IGwyID4+PiAwIHwgbjIgPj4+IDAgPiBhMiA+Pj4gMCkgOiAwKSB7CiAgICAgICAgICAgIHYyID0gMDsKICAgICAgICAgICAgViA9IHcyOwogICAgICAgICAgICByZXR1cm4gdjIgfCAwOwogICAgICAgICAgfQogICAgICAgICAgZDoKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoIShjWzU1MjNdICYgNCkpIHsKICAgICAgICAgICAgICAgIGQyID0gY1s1NDE4XSB8IDA7CiAgICAgICAgICAgICAgICBlOgogICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgIGlmIChkMikgewogICAgICAgICAgICAgICAgICAgICAgZTIgPSAyMjA5NjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuMiA+Pj4gMCA8PSBkMiA+Pj4gMCA/IChuMiArIChjW2UyICsgNCA+PiAyXSB8IDApIHwgMCkgPj4+IDAgPiBkMiA+Pj4gMCA6IDApCiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1tlMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSAxMjg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGIyID0gZzIgLSBoMiAmIGYyOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGIyID4+PiAwIDwgMjE0NzQ4MzY0NykgewogICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGZyKGIyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYTIgfCAwKSA9PSAoKGNbZTIgPj4gMl0gfCAwKSArIChjW2UyICsgNCA+PiAyXSB8IDApIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEyIHwgMCkgIT0gKC0xIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnMiA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSAxNDU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBkOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgICAgIHEyID0gMTM2OwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgICAgcTIgPSAxMjg7CiAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgIGlmICgocTIgfCAwKSA9PSAxMjgpIHsKICAgICAgICAgICAgICAgICAgICBkMiA9IGZyKDApIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoKGQyIHwgMCkgIT0gKC0xIHwgMCkgPyAoYjIgPSBkMiwgbzIgPSBjWzU1MzFdIHwgMCwgcDIgPSBvMiArIC0xIHwgMCwgYjIgPSAoKHAyICYgYjIgfCAwKSA9PSAwID8gMCA6IChwMiArIGIyICYgMCAtIG8yKSAtIGIyIHwgMCkgKyBrMiB8IDAsIG8yID0gY1s1NTIwXSB8IDAsIHAyID0gYjIgKyBvMiB8IDAsIGIyID4+PiAwID4gbTIgPj4+IDAgJiBiMiA+Pj4gMCA8IDIxNDc0ODM2NDcpIDogMCkgewogICAgICAgICAgICAgICAgICAgICAgbjIgPSBjWzU1MjJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChuMiB8IDAgPyBwMiA+Pj4gMCA8PSBvMiA+Pj4gMCB8IHAyID4+PiAwID4gbjIgPj4+IDAgOiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBhMiA9IGZyKGIyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEyIHwgMCkgPT0gKGQyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgZzIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgcTIgPSAxNDU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGQ7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgICBxMiA9IDEzNjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgaWYgKChxMiB8IDApID09IDEzNikgewogICAgICAgICAgICAgICAgICAgIGQyID0gMCAtIGIyIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoIShpMiA+Pj4gMCA+IGIyID4+PiAwICYgKGIyID4+PiAwIDwgMjE0NzQ4MzY0NyAmIChlMiB8IDApICE9ICgtMSB8IDApKSkpCiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGUyIHwgMCkgPT0gKC0xIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGgyID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICAgIHEyID0gMTQ1OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBkOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGEyID0gY1s1NTMyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgYTIgPSBqMiAtIGIyICsgYTIgJiAwIC0gYTI7CiAgICAgICAgICAgICAgICAgICAgaWYgKGEyID4+PiAwID49IDIxNDc0ODM2NDcpIHsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICBnMiA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgcTIgPSAxNDU7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBkOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoKGZyKGEyKSB8IDApID09ICgtMSB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICBmcihkMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgYjIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGgyID0gYTIgKyBiMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBnMiA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgcTIgPSAxNDU7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBkOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgY1s1NTIzXSA9IGNbNTUyM10gfCA0OwogICAgICAgICAgICAgICAgcTIgPSAxNDM7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGIyID0gMDsKICAgICAgICAgICAgICAgIHEyID0gMTQzOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgaWYgKCgocTIgfCAwKSA9PSAxNDMgPyBrMiA+Pj4gMCA8IDIxNDc0ODM2NDcgOiAwKSA/ICh0MiA9IGZyKGsyKSB8IDAsIHAyID0gZnIoMCkgfCAwLCByMiA9IHAyIC0gdDIgfCAwLCBzMiA9IHIyID4+PiAwID4gKG0yICsgNDAgfCAwKSA+Pj4gMCwgISgodDIgfCAwKSA9PSAoLTEgfCAwKSB8IHMyIF4gMSB8IHQyID4+PiAwIDwgcDIgPj4+IDAgJiAoKHQyIHwgMCkgIT0gKC0xIHwgMCkgJiAocDIgfCAwKSAhPSAoLTEgfCAwKSkgXiAxKSkgOiAwKSB7CiAgICAgICAgICAgIGgyID0gczIgPyByMiA6IGIyOwogICAgICAgICAgICBnMiA9IHQyOwogICAgICAgICAgICBxMiA9IDE0NTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgocTIgfCAwKSA9PSAxNDUpIHsKICAgICAgICAgICAgYjIgPSAoY1s1NTIwXSB8IDApICsgaDIgfCAwOwogICAgICAgICAgICBjWzU1MjBdID0gYjI7CiAgICAgICAgICAgIGlmIChiMiA+Pj4gMCA+IChjWzU1MjFdIHwgMCkgPj4+IDApCiAgICAgICAgICAgICAgY1s1NTIxXSA9IGIyOwogICAgICAgICAgICBqMiA9IGNbNTQxOF0gfCAwOwogICAgICAgICAgICBmOgogICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICBpZiAoajIpIHsKICAgICAgICAgICAgICAgICAgYjIgPSAyMjA5NjsKICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICBhMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGQyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGlmICgoZzIgfCAwKSA9PSAoYTIgKyBkMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICBxMiA9IDE1NDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoIWUyKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgICAgYjIgPSBlMjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoKChxMiB8IDApID09IDE1NCA/ICh1MiA9IGIyICsgNCB8IDAsIChjW2IyICsgMTIgPj4gMl0gJiA4IHwgMCkgPT0gMCkgOiAwKSA/IGcyID4+PiAwID4gajIgPj4+IDAgJiBhMiA+Pj4gMCA8PSBqMiA+Pj4gMCA6IDApIHsKICAgICAgICAgICAgICAgICAgICBjW3UyID4+IDJdID0gZDIgKyBoMjsKICAgICAgICAgICAgICAgICAgICB2MiA9IChjWzU0MTVdIHwgMCkgKyBoMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgdDIgPSBqMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgIHQyID0gKHQyICYgNyB8IDApID09IDAgPyAwIDogMCAtIHQyICYgNzsKICAgICAgICAgICAgICAgICAgICB1MiA9IGoyICsgdDIgfCAwOwogICAgICAgICAgICAgICAgICAgIHQyID0gdjIgLSB0MiB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1s1NDE4XSA9IHUyOwogICAgICAgICAgICAgICAgICAgIGNbNTQxNV0gPSB0MjsKICAgICAgICAgICAgICAgICAgICBjW3UyICsgNCA+PiAyXSA9IHQyIHwgMTsKICAgICAgICAgICAgICAgICAgICBjW2oyICsgdjIgKyA0ID4+IDJdID0gNDA7CiAgICAgICAgICAgICAgICAgICAgY1s1NDE5XSA9IGNbNTUzNF07CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGcyID4+PiAwIDwgKGNbNTQxNl0gfCAwKSA+Pj4gMCkKICAgICAgICAgICAgICAgICAgICBjWzU0MTZdID0gZzI7CiAgICAgICAgICAgICAgICAgIGQyID0gZzIgKyBoMiB8IDA7CiAgICAgICAgICAgICAgICAgIGIyID0gMjIwOTY7CiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKChjW2IyID4+IDJdIHwgMCkgPT0gKGQyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgIHEyID0gMTYyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGEyID0gY1tiMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgICBiMiA9IGEyOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICgocTIgfCAwKSA9PSAxNjIgPyAoY1tiMiArIDEyID4+IDJdICYgOCB8IDApID09IDAgOiAwKSB7CiAgICAgICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgICAgIGwyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICBjW2wyID4+IDJdID0gKGNbbDIgPj4gMl0gfCAwKSArIGgyOwogICAgICAgICAgICAgICAgICAgIGwyID0gZzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgICBsMiA9IGcyICsgKChsMiAmIDcgfCAwKSA9PSAwID8gMCA6IDAgLSBsMiAmIDcpIHwgMDsKICAgICAgICAgICAgICAgICAgICBiMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBkMiArICgoYjIgJiA3IHwgMCkgPT0gMCA/IDAgOiAwIC0gYjIgJiA3KSB8IDA7CiAgICAgICAgICAgICAgICAgICAgazIgPSBsMiArIG0yIHwgMDsKICAgICAgICAgICAgICAgICAgICBpMiA9IGIyIC0gbDIgLSBtMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tsMiArIDQgPj4gMl0gPSBtMiB8IDM7CiAgICAgICAgICAgICAgICAgICAgZzoKICAgICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoajIgfCAwKSA9PSAoYjIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gKGNbNTQxNV0gfCAwKSArIGkyIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTVdID0gdjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1s1NDE4XSA9IGsyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgKyA0ID4+IDJdID0gdjIgfCAxOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY1s1NDE3XSB8IDApID09IChiMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IChjWzU0MTRdIHwgMCkgKyBpMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTRdID0gdjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTddID0gazI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgNCA+PiAyXSA9IHYyIHwgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgKyB2MiA+PiAyXSA9IHYyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1tiMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYTIgJiAzIHwgMCkgPT0gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIgPSBhMiAmIC04OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBhMiA+Pj4gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEyID4+PiAwIDwgMjU2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tiMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZDIgfCAwKSA9PSAoYTIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTJdID0gY1s1NDEyXSAmIH4oMSA8PCBlMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1thMiArIDEyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgKyA4ID4+IDJdID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnMiA9IGNbYjIgKyAyNCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbYjIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEyIHwgMCkgPT0gKGIyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGIyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZDIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbZTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYTIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMiA9IGEyICsgMjAgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZTIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSBhMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBjW2YyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGYyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGYyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGNbYjIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW3YyICsgMTIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IHYyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWcyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tiMiArIDI4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gMjE5NTIgKyAoZDIgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjW2UyID4+IDJdIHwgMCkgIT0gKGIyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGcyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbKChjW3YyID4+IDJdIHwgMCkgPT0gKGIyIHwgMCkgPyB2MiA6IGcyICsgMjAgfCAwKSA+PiAyXSA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBoOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbZTIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYTIgfCAwKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1s1NDEzXSA9IGNbNTQxM10gJiB+KDEgPDwgZDIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbYTIgKyAyNCA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBiMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZTIgfCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbYTIgKyAxNiA+PiAyXSA9IGUyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2UyICsgMjQgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tkMiArIDQgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2EyICsgMjAgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgKyAyNCA+PiAyXSA9IGEyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBiMiArIGgyIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gaDIgKyBpMiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMiA9IGkyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gY1tiMiA+PiAyXSAmIC0yOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgKyA0ID4+IDJdID0gZjIgfCAxOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgKyBmMiA+PiAyXSA9IGYyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gZjIgPj4+IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYyID4+PiAwIDwgMjU2KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IDIxNjg4ICsgKGIyIDw8IDEgPDwgMikgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBjWzU0MTJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gMSA8PCBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGEyICYgYjIpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbNTQxMl0gPSBhMiB8IGIyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGQyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGQyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gazI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2IyICsgMTIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgKyA4ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMTIgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGYyID4+PiA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYyID4+PiAwID4gMTY3NzcyMTUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IDMxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUyID0gKGIyICsgMTA0ODMyMCB8IDApID4+PiAxNiAmIDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYjIgPDwgdTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gKHYyICsgNTIwMTkyIHwgMCkgPj4+IDE2ICYgNDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSB2MiA8PCB0MjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSAodjIgKyAyNDU3NjAgfCAwKSA+Pj4gMTYgJiAyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IDE0IC0gKHQyIHwgdTIgfCBlMikgKyAodjIgPDwgZTIgPj4+IDE1KSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZjIgPj4+IChlMiArIDcgfCAwKSAmIDEgfCBlMiA8PCAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IDIxOTUyICsgKGUyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMjggPj4gMl0gPSBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGsyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNbYTIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbNTQxM10gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gMSA8PCBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhMiAmIGQyKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1s1NDEzXSA9IGEyIHwgZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gazI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMjQgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbazIgKyAxMiA+PiAyXSA9IGsyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY1trMiArIDggPj4gMl0gPSBrMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYjIgKyA0ID4+IDJdICYgLTggfCAwKSAhPSAoZjIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZjIgPDwgKChlMiB8IDApID09IDMxID8gMCA6IDI1IC0gKGUyID4+PiAxKSB8IDApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGIyICsgMTYgKyAoZTIgPj4+IDMxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY1thMiArIDQgPj4gMl0gJiAtOCB8IDApID09IChmMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGUyIDw8IDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMjQgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMTIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgOCA+PiAyXSA9IGsyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB1MiA9IGIyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBjW3UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW3YyICsgMTIgPj4gMl0gPSBrMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW3UyID4+IDJdID0gazI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY1trMiArIDggPj4gMl0gPSB2MjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2syICsgMjQgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICAgICAgdjIgPSBsMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgIFYgPSB3MjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjIgfCAwOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGIyID0gMjIwOTY7CiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgYTIgPSBjW2IyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoYTIgPj4+IDAgPD0gajIgPj4+IDAgPyAodjIgPSBhMiArIChjW2IyICsgNCA+PiAyXSB8IDApIHwgMCwgdjIgPj4+IDAgPiBqMiA+Pj4gMCkgOiAwKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBjW2IyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZjIgPSB2MiArIC00NyB8IDA7CiAgICAgICAgICAgICAgICAgIGEyID0gZjIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgYTIgPSBmMiArICgoYTIgJiA3IHwgMCkgPT0gMCA/IDAgOiAwIC0gYTIgJiA3KSB8IDA7CiAgICAgICAgICAgICAgICAgIGYyID0gajIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgIGEyID0gYTIgPj4+IDAgPCBmMiA+Pj4gMCA/IGoyIDogYTI7CiAgICAgICAgICAgICAgICAgIGIyID0gYTIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgZDIgPSBoMiArIC00MCB8IDA7CiAgICAgICAgICAgICAgICAgIHQyID0gZzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgdDIgPSAodDIgJiA3IHwgMCkgPT0gMCA/IDAgOiAwIC0gdDIgJiA3OwogICAgICAgICAgICAgICAgICB1MiA9IGcyICsgdDIgfCAwOwogICAgICAgICAgICAgICAgICB0MiA9IGQyIC0gdDIgfCAwOwogICAgICAgICAgICAgICAgICBjWzU0MThdID0gdTI7CiAgICAgICAgICAgICAgICAgIGNbNTQxNV0gPSB0MjsKICAgICAgICAgICAgICAgICAgY1t1MiArIDQgPj4gMl0gPSB0MiB8IDE7CiAgICAgICAgICAgICAgICAgIGNbZzIgKyBkMiArIDQgPj4gMl0gPSA0MDsKICAgICAgICAgICAgICAgICAgY1s1NDE5XSA9IGNbNTUzNF07CiAgICAgICAgICAgICAgICAgIGQyID0gYTIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgY1tkMiA+PiAyXSA9IDI3OwogICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gY1s1NTI0XTsKICAgICAgICAgICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBjWzU1MjVdOwogICAgICAgICAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IGNbNTUyNl07CiAgICAgICAgICAgICAgICAgIGNbYjIgKyAxMiA+PiAyXSA9IGNbNTUyN107CiAgICAgICAgICAgICAgICAgIGNbNTUyNF0gPSBnMjsKICAgICAgICAgICAgICAgICAgY1s1NTI1XSA9IGgyOwogICAgICAgICAgICAgICAgICBjWzU1MjddID0gMDsKICAgICAgICAgICAgICAgICAgY1s1NTI2XSA9IGIyOwogICAgICAgICAgICAgICAgICBiMiA9IGEyICsgMjQgfCAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgdTIgPSBiMjsKICAgICAgICAgICAgICAgICAgICBiMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IDc7CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCh1MiArIDggfCAwKSA+Pj4gMCA8IHYyID4+PiAwKTsKICAgICAgICAgICAgICAgICAgaWYgKChhMiB8IDApICE9IChqMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgZzIgPSBhMiAtIGoyIHwgMDsKICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gY1tkMiA+PiAyXSAmIC0yOwogICAgICAgICAgICAgICAgICAgIGNbajIgKyA0ID4+IDJdID0gZzIgfCAxOwogICAgICAgICAgICAgICAgICAgIGNbYTIgPj4gMl0gPSBnMjsKICAgICAgICAgICAgICAgICAgICBiMiA9IGcyID4+PiAzOwogICAgICAgICAgICAgICAgICAgIGlmIChnMiA+Pj4gMCA8IDI1NikgewogICAgICAgICAgICAgICAgICAgICAgZDIgPSAyMTY4OCArIChiMiA8PCAxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1s1NDEyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBiMiA9IDEgPDwgYjI7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhMiAmIGIyKSkgewogICAgICAgICAgICAgICAgICAgICAgICBjWzU0MTJdID0gYTIgfCBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMiArIDggfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGoyOwogICAgICAgICAgICAgICAgICAgICAgY1tiMiArIDEyID4+IDJdID0gajI7CiAgICAgICAgICAgICAgICAgICAgICBjW2oyICsgOCA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgY1tqMiArIDEyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYjIgPSBnMiA+Pj4gODsKICAgICAgICAgICAgICAgICAgICBpZiAoYjIpCiAgICAgICAgICAgICAgICAgICAgICBpZiAoZzIgPj4+IDAgPiAxNjc3NzIxNSkKICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSAzMTsKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB1MiA9IChiMiArIDEwNDgzMjAgfCAwKSA+Pj4gMTYgJiA4OwogICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGIyIDw8IHUyOwogICAgICAgICAgICAgICAgICAgICAgICB0MiA9ICh2MiArIDUyMDE5MiB8IDApID4+PiAxNiAmIDQ7CiAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gdjIgPDwgdDI7CiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gKHYyICsgMjQ1NzYwIHwgMCkgPj4+IDE2ICYgMjsKICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSAxNCAtICh0MiB8IHUyIHwgZTIpICsgKHYyIDw8IGUyID4+PiAxNSkgfCAwOwogICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGcyID4+PiAoZTIgKyA3IHwgMCkgJiAxIHwgZTIgPDwgMTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgZDIgPSAyMTk1MiArIChlMiA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1tqMiArIDI4ID4+IDJdID0gZTI7CiAgICAgICAgICAgICAgICAgICAgY1tqMiArIDIwID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgICBiMiA9IGNbNTQxM10gfCAwOwogICAgICAgICAgICAgICAgICAgIGEyID0gMSA8PCBlMjsKICAgICAgICAgICAgICAgICAgICBpZiAoIShiMiAmIGEyKSkgewogICAgICAgICAgICAgICAgICAgICAgY1s1NDEzXSA9IGIyIHwgYTI7CiAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gajI7CiAgICAgICAgICAgICAgICAgICAgICBjW2oyICsgMjQgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgICAgIGNbajIgKyAxMiA+PiAyXSA9IGoyOwogICAgICAgICAgICAgICAgICAgICAgY1tqMiArIDggPj4gMl0gPSBqMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBiMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgIGo6CiAgICAgICAgICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNbYjIgKyA0ID4+IDJdICYgLTggfCAwKSAhPSAoZzIgfCAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZzIgPDwgKChlMiB8IDApID09IDMxID8gMCA6IDI1IC0gKGUyID4+PiAxKSB8IDApOwogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IGIyICsgMTYgKyAoZTIgPj4+IDMxIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY1thMiArIDQgPj4gMl0gJiAtOCB8IDApID09IChnMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGo7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IGUyIDw8IDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gYTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBqMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2oyICsgMjQgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2oyICsgMTIgPj4gMl0gPSBqMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjW2oyICsgOCA+PiAyXSA9IGoyOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGY7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgICAgICB1MiA9IGIyICsgOCB8IDA7CiAgICAgICAgICAgICAgICAgICAgdjIgPSBjW3UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBjW3YyICsgMTIgPj4gMl0gPSBqMjsKICAgICAgICAgICAgICAgICAgICBjW3UyID4+IDJdID0gajI7CiAgICAgICAgICAgICAgICAgICAgY1tqMiArIDggPj4gMl0gPSB2MjsKICAgICAgICAgICAgICAgICAgICBjW2oyICsgMTIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgICBjW2oyICsgMjQgPj4gMl0gPSAwOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2MiA9IGNbNTQxNl0gfCAwOwogICAgICAgICAgICAgICAgICBpZiAoKHYyIHwgMCkgPT0gMCB8IGcyID4+PiAwIDwgdjIgPj4+IDApCiAgICAgICAgICAgICAgICAgICAgY1s1NDE2XSA9IGcyOwogICAgICAgICAgICAgICAgICBjWzU1MjRdID0gZzI7CiAgICAgICAgICAgICAgICAgIGNbNTUyNV0gPSBoMjsKICAgICAgICAgICAgICAgICAgY1s1NTI3XSA9IDA7CiAgICAgICAgICAgICAgICAgIGNbNTQyMV0gPSBjWzU1MzBdOwogICAgICAgICAgICAgICAgICBjWzU0MjBdID0gLTE7CiAgICAgICAgICAgICAgICAgIGNbNTQyNV0gPSAyMTY4ODsKICAgICAgICAgICAgICAgICAgY1s1NDI0XSA9IDIxNjg4OwogICAgICAgICAgICAgICAgICBjWzU0MjddID0gMjE2OTY7CiAgICAgICAgICAgICAgICAgIGNbNTQyNl0gPSAyMTY5NjsKICAgICAgICAgICAgICAgICAgY1s1NDI5XSA9IDIxNzA0OwogICAgICAgICAgICAgICAgICBjWzU0MjhdID0gMjE3MDQ7CiAgICAgICAgICAgICAgICAgIGNbNTQzMV0gPSAyMTcxMjsKICAgICAgICAgICAgICAgICAgY1s1NDMwXSA9IDIxNzEyOwogICAgICAgICAgICAgICAgICBjWzU0MzNdID0gMjE3MjA7CiAgICAgICAgICAgICAgICAgIGNbNTQzMl0gPSAyMTcyMDsKICAgICAgICAgICAgICAgICAgY1s1NDM1XSA9IDIxNzI4OwogICAgICAgICAgICAgICAgICBjWzU0MzRdID0gMjE3Mjg7CiAgICAgICAgICAgICAgICAgIGNbNTQzN10gPSAyMTczNjsKICAgICAgICAgICAgICAgICAgY1s1NDM2XSA9IDIxNzM2OwogICAgICAgICAgICAgICAgICBjWzU0MzldID0gMjE3NDQ7CiAgICAgICAgICAgICAgICAgIGNbNTQzOF0gPSAyMTc0NDsKICAgICAgICAgICAgICAgICAgY1s1NDQxXSA9IDIxNzUyOwogICAgICAgICAgICAgICAgICBjWzU0NDBdID0gMjE3NTI7CiAgICAgICAgICAgICAgICAgIGNbNTQ0M10gPSAyMTc2MDsKICAgICAgICAgICAgICAgICAgY1s1NDQyXSA9IDIxNzYwOwogICAgICAgICAgICAgICAgICBjWzU0NDVdID0gMjE3Njg7CiAgICAgICAgICAgICAgICAgIGNbNTQ0NF0gPSAyMTc2ODsKICAgICAgICAgICAgICAgICAgY1s1NDQ3XSA9IDIxNzc2OwogICAgICAgICAgICAgICAgICBjWzU0NDZdID0gMjE3NzY7CiAgICAgICAgICAgICAgICAgIGNbNTQ0OV0gPSAyMTc4NDsKICAgICAgICAgICAgICAgICAgY1s1NDQ4XSA9IDIxNzg0OwogICAgICAgICAgICAgICAgICBjWzU0NTFdID0gMjE3OTI7CiAgICAgICAgICAgICAgICAgIGNbNTQ1MF0gPSAyMTc5MjsKICAgICAgICAgICAgICAgICAgY1s1NDUzXSA9IDIxODAwOwogICAgICAgICAgICAgICAgICBjWzU0NTJdID0gMjE4MDA7CiAgICAgICAgICAgICAgICAgIGNbNTQ1NV0gPSAyMTgwODsKICAgICAgICAgICAgICAgICAgY1s1NDU0XSA9IDIxODA4OwogICAgICAgICAgICAgICAgICBjWzU0NTddID0gMjE4MTY7CiAgICAgICAgICAgICAgICAgIGNbNTQ1Nl0gPSAyMTgxNjsKICAgICAgICAgICAgICAgICAgY1s1NDU5XSA9IDIxODI0OwogICAgICAgICAgICAgICAgICBjWzU0NThdID0gMjE4MjQ7CiAgICAgICAgICAgICAgICAgIGNbNTQ2MV0gPSAyMTgzMjsKICAgICAgICAgICAgICAgICAgY1s1NDYwXSA9IDIxODMyOwogICAgICAgICAgICAgICAgICBjWzU0NjNdID0gMjE4NDA7CiAgICAgICAgICAgICAgICAgIGNbNTQ2Ml0gPSAyMTg0MDsKICAgICAgICAgICAgICAgICAgY1s1NDY1XSA9IDIxODQ4OwogICAgICAgICAgICAgICAgICBjWzU0NjRdID0gMjE4NDg7CiAgICAgICAgICAgICAgICAgIGNbNTQ2N10gPSAyMTg1NjsKICAgICAgICAgICAgICAgICAgY1s1NDY2XSA9IDIxODU2OwogICAgICAgICAgICAgICAgICBjWzU0NjldID0gMjE4NjQ7CiAgICAgICAgICAgICAgICAgIGNbNTQ2OF0gPSAyMTg2NDsKICAgICAgICAgICAgICAgICAgY1s1NDcxXSA9IDIxODcyOwogICAgICAgICAgICAgICAgICBjWzU0NzBdID0gMjE4NzI7CiAgICAgICAgICAgICAgICAgIGNbNTQ3M10gPSAyMTg4MDsKICAgICAgICAgICAgICAgICAgY1s1NDcyXSA9IDIxODgwOwogICAgICAgICAgICAgICAgICBjWzU0NzVdID0gMjE4ODg7CiAgICAgICAgICAgICAgICAgIGNbNTQ3NF0gPSAyMTg4ODsKICAgICAgICAgICAgICAgICAgY1s1NDc3XSA9IDIxODk2OwogICAgICAgICAgICAgICAgICBjWzU0NzZdID0gMjE4OTY7CiAgICAgICAgICAgICAgICAgIGNbNTQ3OV0gPSAyMTkwNDsKICAgICAgICAgICAgICAgICAgY1s1NDc4XSA9IDIxOTA0OwogICAgICAgICAgICAgICAgICBjWzU0ODFdID0gMjE5MTI7CiAgICAgICAgICAgICAgICAgIGNbNTQ4MF0gPSAyMTkxMjsKICAgICAgICAgICAgICAgICAgY1s1NDgzXSA9IDIxOTIwOwogICAgICAgICAgICAgICAgICBjWzU0ODJdID0gMjE5MjA7CiAgICAgICAgICAgICAgICAgIGNbNTQ4NV0gPSAyMTkyODsKICAgICAgICAgICAgICAgICAgY1s1NDg0XSA9IDIxOTI4OwogICAgICAgICAgICAgICAgICBjWzU0ODddID0gMjE5MzY7CiAgICAgICAgICAgICAgICAgIGNbNTQ4Nl0gPSAyMTkzNjsKICAgICAgICAgICAgICAgICAgdjIgPSBoMiArIC00MCB8IDA7CiAgICAgICAgICAgICAgICAgIHQyID0gZzIgKyA4IHwgMDsKICAgICAgICAgICAgICAgICAgdDIgPSAodDIgJiA3IHwgMCkgPT0gMCA/IDAgOiAwIC0gdDIgJiA3OwogICAgICAgICAgICAgICAgICB1MiA9IGcyICsgdDIgfCAwOwogICAgICAgICAgICAgICAgICB0MiA9IHYyIC0gdDIgfCAwOwogICAgICAgICAgICAgICAgICBjWzU0MThdID0gdTI7CiAgICAgICAgICAgICAgICAgIGNbNTQxNV0gPSB0MjsKICAgICAgICAgICAgICAgICAgY1t1MiArIDQgPj4gMl0gPSB0MiB8IDE7CiAgICAgICAgICAgICAgICAgIGNbZzIgKyB2MiArIDQgPj4gMl0gPSA0MDsKICAgICAgICAgICAgICAgICAgY1s1NDE5XSA9IGNbNTUzNF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICBiMiA9IGNbNTQxNV0gfCAwOwogICAgICAgICAgICBpZiAoYjIgPj4+IDAgPiBtMiA+Pj4gMCkgewogICAgICAgICAgICAgIHQyID0gYjIgLSBtMiB8IDA7CiAgICAgICAgICAgICAgY1s1NDE1XSA9IHQyOwogICAgICAgICAgICAgIHYyID0gY1s1NDE4XSB8IDA7CiAgICAgICAgICAgICAgdTIgPSB2MiArIG0yIHwgMDsKICAgICAgICAgICAgICBjWzU0MThdID0gdTI7CiAgICAgICAgICAgICAgY1t1MiArIDQgPj4gMl0gPSB0MiB8IDE7CiAgICAgICAgICAgICAgY1t2MiArIDQgPj4gMl0gPSBtMiB8IDM7CiAgICAgICAgICAgICAgdjIgPSB2MiArIDggfCAwOwogICAgICAgICAgICAgIFYgPSB3MjsKICAgICAgICAgICAgICByZXR1cm4gdjIgfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBjWyhhbygpIHwgMCkgPj4gMl0gPSA0ODsKICAgICAgICAgIHYyID0gMDsKICAgICAgICAgIFYgPSB3MjsKICAgICAgICAgIHJldHVybiB2MiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVyKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDAsIGoyID0gMDsKICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGQyID0gYTIgKyAtOCB8IDA7CiAgICAgICAgICBmMiA9IGNbNTQxNl0gfCAwOwogICAgICAgICAgYTIgPSBjW2EyICsgLTQgPj4gMl0gfCAwOwogICAgICAgICAgYjIgPSBhMiAmIC04OwogICAgICAgICAgajIgPSBkMiArIGIyIHwgMDsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmICghKGEyICYgMSkpIHsKICAgICAgICAgICAgICBlMiA9IGNbZDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGlmICghKGEyICYgMykpCiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgaDIgPSBkMiArICgwIC0gZTIpIHwgMDsKICAgICAgICAgICAgICBnMiA9IGUyICsgYjIgfCAwOwogICAgICAgICAgICAgIGlmIChoMiA+Pj4gMCA8IGYyID4+PiAwKQogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIGlmICgoY1s1NDE3XSB8IDApID09IChoMiB8IDApKSB7CiAgICAgICAgICAgICAgICBhMiA9IGoyICsgNCB8IDA7CiAgICAgICAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgaWYgKChiMiAmIDMgfCAwKSAhPSAzKSB7CiAgICAgICAgICAgICAgICAgIGkyID0gaDI7CiAgICAgICAgICAgICAgICAgIGIyID0gZzI7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY1s1NDE0XSA9IGcyOwogICAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGIyICYgLTI7CiAgICAgICAgICAgICAgICBjW2gyICsgNCA+PiAyXSA9IGcyIHwgMTsKICAgICAgICAgICAgICAgIGNbaDIgKyBnMiA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkMiA9IGUyID4+PiAzOwogICAgICAgICAgICAgIGlmIChlMiA+Pj4gMCA8IDI1NikgewogICAgICAgICAgICAgICAgYTIgPSBjW2gyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBiMiA9IGNbaDIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBpZiAoKGIyIHwgMCkgPT0gKGEyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgY1s1NDEyXSA9IGNbNTQxMl0gJiB+KDEgPDwgZDIpOwogICAgICAgICAgICAgICAgICBpMiA9IGgyOwogICAgICAgICAgICAgICAgICBiMiA9IGcyOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGNbYTIgKyAxMiA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IGEyOwogICAgICAgICAgICAgICAgICBpMiA9IGgyOwogICAgICAgICAgICAgICAgICBiMiA9IGcyOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZjIgPSBjW2gyICsgMjQgPj4gMl0gfCAwOwogICAgICAgICAgICAgIGEyID0gY1toMiArIDEyID4+IDJdIHwgMDsKICAgICAgICAgICAgICBkbwogICAgICAgICAgICAgICAgaWYgKChhMiB8IDApID09IChoMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgIGIyID0gaDIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgIGQyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgICAgICAgYTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKCFhMikgewogICAgICAgICAgICAgICAgICAgIGEyID0gY1tiMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFhMikgewogICAgICAgICAgICAgICAgICAgICAgYTIgPSAwOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICBiMiA9IGQyOwogICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgIGUyID0gYTIgKyAyMCB8IDA7CiAgICAgICAgICAgICAgICAgICAgZDIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoIWQyKSB7CiAgICAgICAgICAgICAgICAgICAgICBlMiA9IGEyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgICAgICAgZDIgPSBjW2UyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghZDIpCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gZTI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIGEyID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICBiMiA9IGUyOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGkyID0gY1toMiArIDggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBjW2kyICsgMTIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgY1thMiArIDggPj4gMl0gPSBpMjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgaWYgKGYyKSB7CiAgICAgICAgICAgICAgICBiMiA9IGNbaDIgKyAyOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBkMiA9IDIxOTUyICsgKGIyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgIGlmICgoY1tkMiA+PiAyXSB8IDApID09IChoMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgIGNbZDIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgaWYgKCFhMikgewogICAgICAgICAgICAgICAgICAgIGNbNTQxM10gPSBjWzU0MTNdICYgfigxIDw8IGIyKTsKICAgICAgICAgICAgICAgICAgICBpMiA9IGgyOwogICAgICAgICAgICAgICAgICAgIGIyID0gZzI7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGkyID0gZjIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgIGNbKChjW2kyID4+IDJdIHwgMCkgPT0gKGgyIHwgMCkgPyBpMiA6IGYyICsgMjAgfCAwKSA+PiAyXSA9IGEyOwogICAgICAgICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgICAgICAgaTIgPSBoMjsKICAgICAgICAgICAgICAgICAgICBiMiA9IGcyOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjW2EyICsgMjQgPj4gMl0gPSBmMjsKICAgICAgICAgICAgICAgIGIyID0gaDIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICBkMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgaWYgKGQyIHwgMCkgewogICAgICAgICAgICAgICAgICBjW2EyICsgMTYgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgY1tkMiArIDI0ID4+IDJdID0gYTI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBiMiA9IGNbYjIgKyA0ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGlmIChiMikgewogICAgICAgICAgICAgICAgICBjW2EyICsgMjAgPj4gMl0gPSBiMjsKICAgICAgICAgICAgICAgICAgY1tiMiArIDI0ID4+IDJdID0gYTI7CiAgICAgICAgICAgICAgICAgIGkyID0gaDI7CiAgICAgICAgICAgICAgICAgIGIyID0gZzI7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBpMiA9IGgyOwogICAgICAgICAgICAgICAgICBiMiA9IGcyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpMiA9IGgyOwogICAgICAgICAgICAgICAgYjIgPSBnMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaTIgPSBkMjsKICAgICAgICAgICAgICBoMiA9IGQyOwogICAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICBpZiAoaDIgPj4+IDAgPj0gajIgPj4+IDApCiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIGEyID0gajIgKyA0IHwgMDsKICAgICAgICAgIGUyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICBpZiAoIShlMiAmIDEpKQogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICBpZiAoIShlMiAmIDIpKSB7CiAgICAgICAgICAgIGlmICgoY1s1NDE4XSB8IDApID09IChqMiB8IDApKSB7CiAgICAgICAgICAgICAgajIgPSAoY1s1NDE1XSB8IDApICsgYjIgfCAwOwogICAgICAgICAgICAgIGNbNTQxNV0gPSBqMjsKICAgICAgICAgICAgICBjWzU0MThdID0gaTI7CiAgICAgICAgICAgICAgY1tpMiArIDQgPj4gMl0gPSBqMiB8IDE7CiAgICAgICAgICAgICAgaWYgKChpMiB8IDApICE9IChjWzU0MTddIHwgMCkpCiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgY1s1NDE3XSA9IDA7CiAgICAgICAgICAgICAgY1s1NDE0XSA9IDA7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgoY1s1NDE3XSB8IDApID09IChqMiB8IDApKSB7CiAgICAgICAgICAgICAgajIgPSAoY1s1NDE0XSB8IDApICsgYjIgfCAwOwogICAgICAgICAgICAgIGNbNTQxNF0gPSBqMjsKICAgICAgICAgICAgICBjWzU0MTddID0gaDI7CiAgICAgICAgICAgICAgY1tpMiArIDQgPj4gMl0gPSBqMiB8IDE7CiAgICAgICAgICAgICAgY1toMiArIGoyID4+IDJdID0gajI7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGYyID0gKGUyICYgLTgpICsgYjIgfCAwOwogICAgICAgICAgICBkMiA9IGUyID4+PiAzOwogICAgICAgICAgICBkbwogICAgICAgICAgICAgIGlmIChlMiA+Pj4gMCA8IDI1NikgewogICAgICAgICAgICAgICAgYjIgPSBjW2oyICsgOCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBhMiA9IGNbajIgKyAxMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICBpZiAoKGEyIHwgMCkgPT0gKGIyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgY1s1NDEyXSA9IGNbNTQxMl0gJiB+KDEgPDwgZDIpOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGNbYjIgKyAxMiA+PiAyXSA9IGEyOwogICAgICAgICAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGIyOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgZzIgPSBjW2oyICsgMjQgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgYTIgPSBjW2oyICsgMTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgICAgaWYgKChhMiB8IDApID09IChqMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgYjIgPSBqMiArIDE2IHwgMDsKICAgICAgICAgICAgICAgICAgICBkMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgICAgICAgICAgYTIgPSBjW2QyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBpZiAoIWEyKSB7CiAgICAgICAgICAgICAgICAgICAgICBhMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFhMikgewogICAgICAgICAgICAgICAgICAgICAgICBkMiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgICAgYjIgPSBkMjsKICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgZTIgPSBhMiArIDIwIHwgMDsKICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gYTIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gY1tlMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZDIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gZDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBkMjsKICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBlMjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgZDIgPSBhMjsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBkMiA9IGNbajIgKyA4ID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgICAgICBjW2QyICsgMTIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICBjW2EyICsgOCA+PiAyXSA9IGQyOwogICAgICAgICAgICAgICAgICAgIGQyID0gYTI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlICgwKTsKICAgICAgICAgICAgICAgIGlmIChnMiB8IDApIHsKICAgICAgICAgICAgICAgICAgYTIgPSBjW2oyICsgMjggPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBiMiA9IDIxOTUyICsgKGEyIDw8IDIpIHwgMDsKICAgICAgICAgICAgICAgICAgaWYgKChjW2IyID4+IDJdIHwgMCkgPT0gKGoyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICBjW2IyID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikgewogICAgICAgICAgICAgICAgICAgICAgY1s1NDEzXSA9IGNbNTQxM10gJiB+KDEgPDwgYTIpOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGUyID0gZzIgKyAxNiB8IDA7CiAgICAgICAgICAgICAgICAgICAgY1soKGNbZTIgPj4gMl0gfCAwKSA9PSAoajIgfCAwKSA/IGUyIDogZzIgKyAyMCB8IDApID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFkMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNbZDIgKyAyNCA+PiAyXSA9IGcyOwogICAgICAgICAgICAgICAgICBhMiA9IGoyICsgMTYgfCAwOwogICAgICAgICAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgICBpZiAoYjIgfCAwKSB7CiAgICAgICAgICAgICAgICAgICAgY1tkMiArIDE2ID4+IDJdID0gYjI7CiAgICAgICAgICAgICAgICAgICAgY1tiMiArIDI0ID4+IDJdID0gZDI7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgYTIgPSBjW2EyICsgNCA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgIGlmIChhMiB8IDApIHsKICAgICAgICAgICAgICAgICAgICBjW2QyICsgMjAgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICBjW2EyICsgMjQgPj4gMl0gPSBkMjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgICBjW2kyICsgNCA+PiAyXSA9IGYyIHwgMTsKICAgICAgICAgICAgY1toMiArIGYyID4+IDJdID0gZjI7CiAgICAgICAgICAgIGlmICgoaTIgfCAwKSA9PSAoY1s1NDE3XSB8IDApKSB7CiAgICAgICAgICAgICAgY1s1NDE0XSA9IGYyOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY1thMiA+PiAyXSA9IGUyICYgLTI7CiAgICAgICAgICAgIGNbaTIgKyA0ID4+IDJdID0gYjIgfCAxOwogICAgICAgICAgICBjW2gyICsgYjIgPj4gMl0gPSBiMjsKICAgICAgICAgICAgZjIgPSBiMjsKICAgICAgICAgIH0KICAgICAgICAgIGEyID0gZjIgPj4+IDM7CiAgICAgICAgICBpZiAoZjIgPj4+IDAgPCAyNTYpIHsKICAgICAgICAgICAgZDIgPSAyMTY4OCArIChhMiA8PCAxIDw8IDIpIHwgMDsKICAgICAgICAgICAgYjIgPSBjWzU0MTJdIHwgMDsKICAgICAgICAgICAgYTIgPSAxIDw8IGEyOwogICAgICAgICAgICBpZiAoIShiMiAmIGEyKSkgewogICAgICAgICAgICAgIGNbNTQxMl0gPSBiMiB8IGEyOwogICAgICAgICAgICAgIGEyID0gZDI7CiAgICAgICAgICAgICAgYjIgPSBkMiArIDggfCAwOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGIyID0gZDIgKyA4IHwgMDsKICAgICAgICAgICAgICBhMiA9IGNbYjIgPj4gMl0gfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBpMjsKICAgICAgICAgICAgY1thMiArIDEyID4+IDJdID0gaTI7CiAgICAgICAgICAgIGNbaTIgKyA4ID4+IDJdID0gYTI7CiAgICAgICAgICAgIGNbaTIgKyAxMiA+PiAyXSA9IGQyOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBhMiA9IGYyID4+PiA4OwogICAgICAgICAgaWYgKGEyKQogICAgICAgICAgICBpZiAoZjIgPj4+IDAgPiAxNjc3NzIxNSkKICAgICAgICAgICAgICBlMiA9IDMxOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICBoMiA9IChhMiArIDEwNDgzMjAgfCAwKSA+Pj4gMTYgJiA4OwogICAgICAgICAgICAgIGoyID0gYTIgPDwgaDI7CiAgICAgICAgICAgICAgZzIgPSAoajIgKyA1MjAxOTIgfCAwKSA+Pj4gMTYgJiA0OwogICAgICAgICAgICAgIGoyID0gajIgPDwgZzI7CiAgICAgICAgICAgICAgZTIgPSAoajIgKyAyNDU3NjAgfCAwKSA+Pj4gMTYgJiAyOwogICAgICAgICAgICAgIGUyID0gMTQgLSAoZzIgfCBoMiB8IGUyKSArIChqMiA8PCBlMiA+Pj4gMTUpIHwgMDsKICAgICAgICAgICAgICBlMiA9IGYyID4+PiAoZTIgKyA3IHwgMCkgJiAxIHwgZTIgPDwgMTsKICAgICAgICAgICAgfQogICAgICAgICAgZWxzZQogICAgICAgICAgICBlMiA9IDA7CiAgICAgICAgICBhMiA9IDIxOTUyICsgKGUyIDw8IDIpIHwgMDsKICAgICAgICAgIGNbaTIgKyAyOCA+PiAyXSA9IGUyOwogICAgICAgICAgY1tpMiArIDIwID4+IDJdID0gMDsKICAgICAgICAgIGNbaTIgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICBiMiA9IGNbNTQxM10gfCAwOwogICAgICAgICAgZDIgPSAxIDw8IGUyOwogICAgICAgICAgYToKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICBpZiAoIShiMiAmIGQyKSkgewogICAgICAgICAgICAgICAgY1s1NDEzXSA9IGIyIHwgZDI7CiAgICAgICAgICAgICAgICBjW2EyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgICBjW2kyICsgMjQgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgIGNbaTIgKyAxMiA+PiAyXSA9IGkyOwogICAgICAgICAgICAgICAgY1tpMiArIDggPj4gMl0gPSBpMjsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgYTIgPSBjW2EyID4+IDJdIHwgMDsKICAgICAgICAgICAgICAgIGI6CiAgICAgICAgICAgICAgICAgIGRvCiAgICAgICAgICAgICAgICAgICAgaWYgKChjW2EyICsgNCA+PiAyXSAmIC04IHwgMCkgIT0gKGYyIHwgMCkpIHsKICAgICAgICAgICAgICAgICAgICAgIGUyID0gZjIgPDwgKChlMiB8IDApID09IDMxID8gMCA6IDI1IC0gKGUyID4+PiAxKSB8IDApOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBhMiArIDE2ICsgKGUyID4+PiAzMSA8PCAyKSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY1tkMiA+PiAyXSB8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYjIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY1tiMiArIDQgPj4gMl0gJiAtOCB8IDApID09IChmMiB8IDApKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSBiMjsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gZTIgPDwgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICBhMiA9IGIyOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBjW2QyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgICAgICAgICBjW2kyICsgMjQgPj4gMl0gPSBhMjsKICAgICAgICAgICAgICAgICAgICAgIGNbaTIgKyAxMiA+PiAyXSA9IGkyOwogICAgICAgICAgICAgICAgICAgICAgY1tpMiArIDggPj4gMl0gPSBpMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB3aGlsZSAoMCk7CiAgICAgICAgICAgICAgICBoMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICAgICAgICBqMiA9IGNbaDIgPj4gMl0gfCAwOwogICAgICAgICAgICAgICAgY1tqMiArIDEyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgICBjW2gyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgICBjW2kyICsgOCA+PiAyXSA9IGoyOwogICAgICAgICAgICAgICAgY1tpMiArIDEyID4+IDJdID0gYTI7CiAgICAgICAgICAgICAgICBjW2kyICsgMjQgPj4gMl0gPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgajIgPSAoY1s1NDIwXSB8IDApICsgLTEgfCAwOwogICAgICAgICAgY1s1NDIwXSA9IGoyOwogICAgICAgICAgaWYgKGoyIHwgMCkKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgYTIgPSAyMjEwNDsKICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgIGEyID0gY1thMiA+PiAyXSB8IDA7CiAgICAgICAgICAgIGlmICghYTIpCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICBhMiA9IGEyICsgOCB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICBjWzU0MjBdID0gLTE7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGZyKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHZhciBiMiA9IDAsIGQyID0gMCwgZTIgPSAwOwogICAgICAgICAgZTIgPSBhMiArIDMgJiAtNDsKICAgICAgICAgIGEyID0gc3IoKSB8IDA7CiAgICAgICAgICBiMiA9IGNbYTIgPj4gMl0gfCAwOwogICAgICAgICAgZDIgPSBiMiArIGUyIHwgMDsKICAgICAgICAgIGRvCiAgICAgICAgICAgIGlmICgoZTIgfCAwKSA8IDEgfCBkMiA+Pj4gMCA+IGIyID4+PiAwKSB7CiAgICAgICAgICAgICAgaWYgKGQyID4+PiAwID4gKFIoKSB8IDApID4+PiAwID8gKFQoZDIgfCAwKSB8IDApID09IDAgOiAwKQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY1thMiA+PiAyXSA9IGQyOwogICAgICAgICAgICAgIGUyID0gYjI7CiAgICAgICAgICAgICAgcmV0dXJuIGUyIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgY1soYW8oKSB8IDApID4+IDJdID0gNDg7CiAgICAgICAgICBlMiA9IC0xOwogICAgICAgICAgcmV0dXJuIGUyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZ3IoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgdmFyIGIyID0gMDsKICAgICAgICAgIGIyID0gVjsKICAgICAgICAgIFYgPSBWICsgYTIgfCAwOwogICAgICAgICAgViA9IFYgKyAxNSAmIC0xNjsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGhyKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIFYgPSBhMjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaXIoKSB7CiAgICAgICAgICByZXR1cm4gViB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGpyKGEyLCBiMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIHZhciBjMiA9IDAsIGQyID0gMCwgZTIgPSAwLCBmMiA9IDA7CiAgICAgICAgICBmMiA9IGEyICYgNjU1MzU7CiAgICAgICAgICBlMiA9IGIyICYgNjU1MzU7CiAgICAgICAgICBjMiA9IHEoZTIsIGYyKSB8IDA7CiAgICAgICAgICBkMiA9IGEyID4+PiAxNjsKICAgICAgICAgIGEyID0gKGMyID4+PiAxNikgKyAocShlMiwgZDIpIHwgMCkgfCAwOwogICAgICAgICAgZTIgPSBiMiA+Pj4gMTY7CiAgICAgICAgICBiMiA9IHEoZTIsIGYyKSB8IDA7CiAgICAgICAgICByZXR1cm4gKHQoKGEyID4+PiAxNikgKyAocShlMiwgZDIpIHwgMCkgKyAoKChhMiAmIDY1NTM1KSArIGIyIHwgMCkgPj4+IDE2KSB8IDApLCBhMiArIGIyIDw8IDE2IHwgYzIgJiA2NTUzNSB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24ga3IoYTIsIGIyLCBjMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgdmFyIGUyID0gMCwgZjIgPSAwOwogICAgICAgICAgZTIgPSBhMjsKICAgICAgICAgIGYyID0gYzI7CiAgICAgICAgICBjMiA9IGpyKGUyLCBmMikgfCAwOwogICAgICAgICAgYTIgPSB1KCkgfCAwOwogICAgICAgICAgcmV0dXJuICh0KChxKGIyLCBmMikgfCAwKSArIChxKGQyLCBlMikgfCAwKSArIGEyIHwgYTIgJiAwIHwgMCksIGMyIHwgMCB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbHIoYTIsIGIyLCBjMiwgZDIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgYzIgPSBhMiArIGMyID4+PiAwOwogICAgICAgICAgcmV0dXJuICh0KGIyICsgZDIgKyAoYzIgPj4+IDAgPCBhMiA+Pj4gMCB8IDApID4+PiAwIHwgMCksIGMyIHwgMCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBtcihhMiwgYjIsIGMyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBkMiA9IGIyIC0gZDIgLSAoYzIgPj4+IDAgPiBhMiA+Pj4gMCB8IDApID4+PiAwOwogICAgICAgICAgcmV0dXJuICh0KGQyIHwgMCksIGEyIC0gYzIgPj4+IDAgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG5yKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAoYTIgPyAzMSAtIChyKGEyIF4gYTIgLSAxKSB8IDApIHwgMCA6IDMyKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG9yKGEyLCBiMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIHZhciBnMiA9IDAsIGgyID0gMCwgaTIgPSAwLCBqMiA9IDAsIGsyID0gMCwgbDIgPSAwLCBtMiA9IDAsIG4yID0gMCwgbzIgPSAwLCBwMiA9IDA7CiAgICAgICAgICBsMiA9IGEyOwogICAgICAgICAgajIgPSBiMjsKICAgICAgICAgIGsyID0gajI7CiAgICAgICAgICBoMiA9IGQyOwogICAgICAgICAgbjIgPSBlMjsKICAgICAgICAgIGkyID0gbjI7CiAgICAgICAgICBpZiAoIWsyKSB7CiAgICAgICAgICAgIGcyID0gKGYyIHwgMCkgIT0gMDsKICAgICAgICAgICAgaWYgKCFpMikgewogICAgICAgICAgICAgIGlmIChnMikgewogICAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IChsMiA+Pj4gMCkgJSAoaDIgPj4+IDApOwogICAgICAgICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBuMiA9IDA7CiAgICAgICAgICAgICAgZjIgPSAobDIgPj4+IDApIC8gKGgyID4+PiAwKSA+Pj4gMDsKICAgICAgICAgICAgICByZXR1cm4gKHQobjIgfCAwKSwgZjIpIHwgMDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoIWcyKSB7CiAgICAgICAgICAgICAgICBuMiA9IDA7CiAgICAgICAgICAgICAgICBmMiA9IDA7CiAgICAgICAgICAgICAgICByZXR1cm4gKHQobjIgfCAwKSwgZjIpIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY1tmMiA+PiAyXSA9IGEyIHwgMDsKICAgICAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IGIyICYgMDsKICAgICAgICAgICAgICBuMiA9IDA7CiAgICAgICAgICAgICAgZjIgPSAwOwogICAgICAgICAgICAgIHJldHVybiAodChuMiB8IDApLCBmMikgfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBnMiA9IChpMiB8IDApID09IDA7CiAgICAgICAgICBkbwogICAgICAgICAgICBpZiAoaDIpIHsKICAgICAgICAgICAgICBpZiAoIWcyKSB7CiAgICAgICAgICAgICAgICBnMiA9IChyKGkyIHwgMCkgfCAwKSAtIChyKGsyIHwgMCkgfCAwKSB8IDA7CiAgICAgICAgICAgICAgICBpZiAoZzIgPj4+IDAgPD0gMzEpIHsKICAgICAgICAgICAgICAgICAgbTIgPSBnMiArIDEgfCAwOwogICAgICAgICAgICAgICAgICBpMiA9IDMxIC0gZzIgfCAwOwogICAgICAgICAgICAgICAgICBiMiA9IGcyIC0gMzEgPj4gMzE7CiAgICAgICAgICAgICAgICAgIGgyID0gbTI7CiAgICAgICAgICAgICAgICAgIGEyID0gbDIgPj4+IChtMiA+Pj4gMCkgJiBiMiB8IGsyIDw8IGkyOwogICAgICAgICAgICAgICAgICBiMiA9IGsyID4+PiAobTIgPj4+IDApICYgYjI7CiAgICAgICAgICAgICAgICAgIGcyID0gMDsKICAgICAgICAgICAgICAgICAgaTIgPSBsMiA8PCBpMjsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIWYyKSB7CiAgICAgICAgICAgICAgICAgIG4yID0gMDsKICAgICAgICAgICAgICAgICAgZjIgPSAwOwogICAgICAgICAgICAgICAgICByZXR1cm4gKHQobjIgfCAwKSwgZjIpIHwgMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBhMiB8IDA7CiAgICAgICAgICAgICAgICBjW2YyICsgNCA+PiAyXSA9IGoyIHwgYjIgJiAwOwogICAgICAgICAgICAgICAgbjIgPSAwOwogICAgICAgICAgICAgICAgZjIgPSAwOwogICAgICAgICAgICAgICAgcmV0dXJuICh0KG4yIHwgMCksIGYyKSB8IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGcyID0gaDIgLSAxIHwgMDsKICAgICAgICAgICAgICBpZiAoZzIgJiBoMiB8IDApIHsKICAgICAgICAgICAgICAgIGkyID0gKHIoaDIgfCAwKSB8IDApICsgMzMgLSAocihrMiB8IDApIHwgMCkgfCAwOwogICAgICAgICAgICAgICAgcDIgPSA2NCAtIGkyIHwgMDsKICAgICAgICAgICAgICAgIG0yID0gMzIgLSBpMiB8IDA7CiAgICAgICAgICAgICAgICBqMiA9IG0yID4+IDMxOwogICAgICAgICAgICAgICAgbzIgPSBpMiAtIDMyIHwgMDsKICAgICAgICAgICAgICAgIGIyID0gbzIgPj4gMzE7CiAgICAgICAgICAgICAgICBoMiA9IGkyOwogICAgICAgICAgICAgICAgYTIgPSBtMiAtIDEgPj4gMzEgJiBrMiA+Pj4gKG8yID4+PiAwKSB8IChrMiA8PCBtMiB8IGwyID4+PiAoaTIgPj4+IDApKSAmIGIyOwogICAgICAgICAgICAgICAgYjIgPSBiMiAmIGsyID4+PiAoaTIgPj4+IDApOwogICAgICAgICAgICAgICAgZzIgPSBsMiA8PCBwMiAmIGoyOwogICAgICAgICAgICAgICAgaTIgPSAoazIgPDwgcDIgfCBsMiA+Pj4gKG8yID4+PiAwKSkgJiBqMiB8IGwyIDw8IG0yICYgaTIgLSAzMyA+PiAzMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoZjIgfCAwKSB7CiAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gZzIgJiBsMjsKICAgICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKChoMiB8IDApID09IDEpIHsKICAgICAgICAgICAgICAgIG8yID0gajIgfCBiMiAmIDA7CiAgICAgICAgICAgICAgICBwMiA9IGEyIHwgMCB8IDA7CiAgICAgICAgICAgICAgICByZXR1cm4gKHQobzIgfCAwKSwgcDIpIHwgMDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcDIgPSBucihoMiB8IDApIHwgMDsKICAgICAgICAgICAgICAgIG8yID0gazIgPj4+IChwMiA+Pj4gMCkgfCAwOwogICAgICAgICAgICAgICAgcDIgPSBrMiA8PCAzMiAtIHAyIHwgbDIgPj4+IChwMiA+Pj4gMCkgfCAwOwogICAgICAgICAgICAgICAgcmV0dXJuICh0KG8yIHwgMCksIHAyKSB8IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmIChnMikgewogICAgICAgICAgICAgICAgaWYgKGYyIHwgMCkgewogICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gKGsyID4+PiAwKSAlIChoMiA+Pj4gMCk7CiAgICAgICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG8yID0gMDsKICAgICAgICAgICAgICAgIHAyID0gKGsyID4+PiAwKSAvIChoMiA+Pj4gMCkgPj4+IDA7CiAgICAgICAgICAgICAgICByZXR1cm4gKHQobzIgfCAwKSwgcDIpIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKCFsMikgewogICAgICAgICAgICAgICAgaWYgKGYyIHwgMCkgewogICAgICAgICAgICAgICAgICBjW2YyID4+IDJdID0gMDsKICAgICAgICAgICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSAoazIgPj4+IDApICUgKGkyID4+PiAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG8yID0gMDsKICAgICAgICAgICAgICAgIHAyID0gKGsyID4+PiAwKSAvIChpMiA+Pj4gMCkgPj4+IDA7CiAgICAgICAgICAgICAgICByZXR1cm4gKHQobzIgfCAwKSwgcDIpIHwgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZzIgPSBpMiAtIDEgfCAwOwogICAgICAgICAgICAgIGlmICghKGcyICYgaTIpKSB7CiAgICAgICAgICAgICAgICBpZiAoZjIgfCAwKSB7CiAgICAgICAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBhMiB8IDA7CiAgICAgICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gZzIgJiBrMiB8IGIyICYgMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG8yID0gMDsKICAgICAgICAgICAgICAgIHAyID0gazIgPj4+ICgobnIoaTIgfCAwKSB8IDApID4+PiAwKTsKICAgICAgICAgICAgICAgIHJldHVybiAodChvMiB8IDApLCBwMikgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBnMiA9IChyKGkyIHwgMCkgfCAwKSAtIChyKGsyIHwgMCkgfCAwKSB8IDA7CiAgICAgICAgICAgICAgaWYgKGcyID4+PiAwIDw9IDMwKSB7CiAgICAgICAgICAgICAgICBiMiA9IGcyICsgMSB8IDA7CiAgICAgICAgICAgICAgICBpMiA9IDMxIC0gZzIgfCAwOwogICAgICAgICAgICAgICAgaDIgPSBiMjsKICAgICAgICAgICAgICAgIGEyID0gazIgPDwgaTIgfCBsMiA+Pj4gKGIyID4+PiAwKTsKICAgICAgICAgICAgICAgIGIyID0gazIgPj4+IChiMiA+Pj4gMCk7CiAgICAgICAgICAgICAgICBnMiA9IDA7CiAgICAgICAgICAgICAgICBpMiA9IGwyIDw8IGkyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICghZjIpIHsKICAgICAgICAgICAgICAgIG8yID0gMDsKICAgICAgICAgICAgICAgIHAyID0gMDsKICAgICAgICAgICAgICAgIHJldHVybiAodChvMiB8IDApLCBwMikgfCAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjW2YyID4+IDJdID0gYTIgfCAwOwogICAgICAgICAgICAgIGNbZjIgKyA0ID4+IDJdID0gajIgfCBiMiAmIDA7CiAgICAgICAgICAgICAgbzIgPSAwOwogICAgICAgICAgICAgIHAyID0gMDsKICAgICAgICAgICAgICByZXR1cm4gKHQobzIgfCAwKSwgcDIpIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKDApOwogICAgICAgICAgaWYgKCFoMikgewogICAgICAgICAgICBrMiA9IGkyOwogICAgICAgICAgICBqMiA9IDA7CiAgICAgICAgICAgIGkyID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG0yID0gZDIgfCAwIHwgMDsKICAgICAgICAgICAgbDIgPSBuMiB8IGUyICYgMDsKICAgICAgICAgICAgazIgPSBscihtMiB8IDAsIGwyIHwgMCwgLTEsIC0xKSB8IDA7CiAgICAgICAgICAgIGQyID0gdSgpIHwgMDsKICAgICAgICAgICAgajIgPSBpMjsKICAgICAgICAgICAgaTIgPSAwOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgZTIgPSBqMjsKICAgICAgICAgICAgICBqMiA9IGcyID4+PiAzMSB8IGoyIDw8IDE7CiAgICAgICAgICAgICAgZzIgPSBpMiB8IGcyIDw8IDE7CiAgICAgICAgICAgICAgZTIgPSBhMiA8PCAxIHwgZTIgPj4+IDMxIHwgMDsKICAgICAgICAgICAgICBuMiA9IGEyID4+PiAzMSB8IGIyIDw8IDEgfCAwOwogICAgICAgICAgICAgIG1yKGsyIHwgMCwgZDIgfCAwLCBlMiB8IDAsIG4yIHwgMCkgfCAwOwogICAgICAgICAgICAgIHAyID0gdSgpIHwgMDsKICAgICAgICAgICAgICBvMiA9IHAyID4+IDMxIHwgKChwMiB8IDApIDwgMCA/IC0xIDogMCkgPDwgMTsKICAgICAgICAgICAgICBpMiA9IG8yICYgMTsKICAgICAgICAgICAgICBhMiA9IG1yKAogICAgICAgICAgICAgICAgZTIgfCAwLAogICAgICAgICAgICAgICAgbjIgfCAwLAogICAgICAgICAgICAgICAgbzIgJiBtMiB8IDAsCiAgICAgICAgICAgICAgICAoKChwMiB8IDApIDwgMCA/IC0xIDogMCkgPj4gMzEgfCAoKHAyIHwgMCkgPCAwID8gLTEgOiAwKSA8PCAxKSAmIGwyIHwgMAogICAgICAgICAgICAgICkgfCAwOwogICAgICAgICAgICAgIGIyID0gdSgpIHwgMDsKICAgICAgICAgICAgICBoMiA9IGgyIC0gMSB8IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKChoMiB8IDApICE9IDApOwogICAgICAgICAgICBrMiA9IGoyOwogICAgICAgICAgICBqMiA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBoMiA9IDA7CiAgICAgICAgICBpZiAoZjIgfCAwKSB7CiAgICAgICAgICAgIGNbZjIgPj4gMl0gPSBhMjsKICAgICAgICAgICAgY1tmMiArIDQgPj4gMl0gPSBiMjsKICAgICAgICAgIH0KICAgICAgICAgIG8yID0gKGcyIHwgMCkgPj4+IDMxIHwgKGsyIHwgaDIpIDw8IDEgfCAoaDIgPDwgMSB8IGcyID4+PiAzMSkgJiAwIHwgajI7CiAgICAgICAgICBwMiA9IChnMiA8PCAxIHwgMCA+Pj4gMzEpICYgLTIgfCBpMjsKICAgICAgICAgIHJldHVybiAodChvMiB8IDApLCBwMikgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwcihhMiwgYjIsIGMyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICByZXR1cm4gb3IoYTIsIGIyLCBjMiwgZDIsIDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcXIoYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgaWYgKChjMiB8IDApIDwgMzIpIHsKICAgICAgICAgICAgdChiMiA+Pj4gYzIgfCAwKTsKICAgICAgICAgICAgcmV0dXJuIGEyID4+PiBjMiB8IChiMiAmICgxIDw8IGMyKSAtIDEpIDw8IDMyIC0gYzI7CiAgICAgICAgICB9CiAgICAgICAgICB0KDApOwogICAgICAgICAgcmV0dXJuIGIyID4+PiBjMiAtIDMyIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcnIoYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgaWYgKChjMiB8IDApIDwgMzIpIHsKICAgICAgICAgICAgdChiMiA8PCBjMiB8IChhMiAmICgxIDw8IGMyKSAtIDEgPDwgMzIgLSBjMikgPj4+IDMyIC0gYzIgfCAwKTsKICAgICAgICAgICAgcmV0dXJuIGEyIDw8IGMyOwogICAgICAgICAgfQogICAgICAgICAgdChhMiA8PCBjMiAtIDMyIHwgMCk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc3IoKSB7CiAgICAgICAgICByZXR1cm4gMjIxNzY7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRyKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHJldHVybiAoYTIgJiAyNTUpIDw8IDI0IHwgKGEyID4+IDggJiAyNTUpIDw8IDE2IHwgKGEyID4+IDE2ICYgMjU1KSA8PCA4IHwgYTIgPj4+IDI0IHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdXIoYjIsIGQyLCBlMikgewogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgdmFyIGYyID0gMCwgZzIgPSAwLCBoMiA9IDA7CiAgICAgICAgICBpZiAoKGUyIHwgMCkgPj0gNTEyKSB7CiAgICAgICAgICAgIFMoYjIgfCAwLCBkMiB8IDAsIGUyIHwgMCkgfCAwOwogICAgICAgICAgICByZXR1cm4gYjIgfCAwOwogICAgICAgICAgfQogICAgICAgICAgaDIgPSBiMiB8IDA7CiAgICAgICAgICBnMiA9IGIyICsgZTIgfCAwOwogICAgICAgICAgaWYgKChiMiAmIDMpID09IChkMiAmIDMpKSB7CiAgICAgICAgICAgIHdoaWxlIChiMiAmIDMpIHsKICAgICAgICAgICAgICBpZiAoIWUyKQogICAgICAgICAgICAgICAgcmV0dXJuIGgyIHwgMDsKICAgICAgICAgICAgICBhW2IyID4+IDBdID0gYVtkMiA+PiAwXSB8IDA7CiAgICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgICAgIGQyID0gZDIgKyAxIHwgMDsKICAgICAgICAgICAgICBlMiA9IGUyIC0gMSB8IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZTIgPSBnMiAmIC00IHwgMDsKICAgICAgICAgICAgZjIgPSBlMiAtIDY0IHwgMDsKICAgICAgICAgICAgd2hpbGUgKChiMiB8IDApIDw9IChmMiB8IDApKSB7CiAgICAgICAgICAgICAgY1tiMiA+PiAyXSA9IGNbZDIgPj4gMl07CiAgICAgICAgICAgICAgY1tiMiArIDQgPj4gMl0gPSBjW2QyICsgNCA+PiAyXTsKICAgICAgICAgICAgICBjW2IyICsgOCA+PiAyXSA9IGNbZDIgKyA4ID4+IDJdOwogICAgICAgICAgICAgIGNbYjIgKyAxMiA+PiAyXSA9IGNbZDIgKyAxMiA+PiAyXTsKICAgICAgICAgICAgICBjW2IyICsgMTYgPj4gMl0gPSBjW2QyICsgMTYgPj4gMl07CiAgICAgICAgICAgICAgY1tiMiArIDIwID4+IDJdID0gY1tkMiArIDIwID4+IDJdOwogICAgICAgICAgICAgIGNbYjIgKyAyNCA+PiAyXSA9IGNbZDIgKyAyNCA+PiAyXTsKICAgICAgICAgICAgICBjW2IyICsgMjggPj4gMl0gPSBjW2QyICsgMjggPj4gMl07CiAgICAgICAgICAgICAgY1tiMiArIDMyID4+IDJdID0gY1tkMiArIDMyID4+IDJdOwogICAgICAgICAgICAgIGNbYjIgKyAzNiA+PiAyXSA9IGNbZDIgKyAzNiA+PiAyXTsKICAgICAgICAgICAgICBjW2IyICsgNDAgPj4gMl0gPSBjW2QyICsgNDAgPj4gMl07CiAgICAgICAgICAgICAgY1tiMiArIDQ0ID4+IDJdID0gY1tkMiArIDQ0ID4+IDJdOwogICAgICAgICAgICAgIGNbYjIgKyA0OCA+PiAyXSA9IGNbZDIgKyA0OCA+PiAyXTsKICAgICAgICAgICAgICBjW2IyICsgNTIgPj4gMl0gPSBjW2QyICsgNTIgPj4gMl07CiAgICAgICAgICAgICAgY1tiMiArIDU2ID4+IDJdID0gY1tkMiArIDU2ID4+IDJdOwogICAgICAgICAgICAgIGNbYjIgKyA2MCA+PiAyXSA9IGNbZDIgKyA2MCA+PiAyXTsKICAgICAgICAgICAgICBiMiA9IGIyICsgNjQgfCAwOwogICAgICAgICAgICAgIGQyID0gZDIgKyA2NCB8IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgd2hpbGUgKChiMiB8IDApIDwgKGUyIHwgMCkpIHsKICAgICAgICAgICAgICBjW2IyID4+IDJdID0gY1tkMiA+PiAyXTsKICAgICAgICAgICAgICBiMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgICAgZDIgPSBkMiArIDQgfCAwOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlMiA9IGcyIC0gNCB8IDA7CiAgICAgICAgICAgIHdoaWxlICgoYjIgfCAwKSA8IChlMiB8IDApKSB7CiAgICAgICAgICAgICAgYVtiMiA+PiAwXSA9IGFbZDIgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGFbYjIgKyAxID4+IDBdID0gYVtkMiArIDEgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGFbYjIgKyAyID4+IDBdID0gYVtkMiArIDIgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGFbYjIgKyAzID4+IDBdID0gYVtkMiArIDMgPj4gMF0gfCAwOwogICAgICAgICAgICAgIGIyID0gYjIgKyA0IHwgMDsKICAgICAgICAgICAgICBkMiA9IGQyICsgNCB8IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlICgoYjIgfCAwKSA8IChnMiB8IDApKSB7CiAgICAgICAgICAgIGFbYjIgPj4gMF0gPSBhW2QyID4+IDBdIHwgMDsKICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgICBkMiA9IGQyICsgMSB8IDA7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaDIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB2cihiMiwgYzIsIGQyKSB7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICB2YXIgZTIgPSAwOwogICAgICAgICAgaWYgKChjMiB8IDApIDwgKGIyIHwgMCkgJiAoYjIgfCAwKSA8IChjMiArIGQyIHwgMCkpIHsKICAgICAgICAgICAgZTIgPSBiMjsKICAgICAgICAgICAgYzIgPSBjMiArIGQyIHwgMDsKICAgICAgICAgICAgYjIgPSBiMiArIGQyIHwgMDsKICAgICAgICAgICAgd2hpbGUgKChkMiB8IDApID4gMCkgewogICAgICAgICAgICAgIGIyID0gYjIgLSAxIHwgMDsKICAgICAgICAgICAgICBjMiA9IGMyIC0gMSB8IDA7CiAgICAgICAgICAgICAgZDIgPSBkMiAtIDEgfCAwOwogICAgICAgICAgICAgIGFbYjIgPj4gMF0gPSBhW2MyID4+IDBdIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBiMiA9IGUyOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIHVyKGIyLCBjMiwgZDIpIHwgMDsKICAgICAgICAgIHJldHVybiBiMiB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdyKGIyLCBkMiwgZTIpIHsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIHZhciBmMiA9IDAsIGcyID0gMCwgaDIgPSAwLCBpMiA9IDA7CiAgICAgICAgICBoMiA9IGIyICsgZTIgfCAwOwogICAgICAgICAgZDIgPSBkMiAmIDI1NTsKICAgICAgICAgIGlmICgoZTIgfCAwKSA+PSA2NykgewogICAgICAgICAgICB3aGlsZSAoYjIgJiAzKSB7CiAgICAgICAgICAgICAgYVtiMiA+PiAwXSA9IGQyOwogICAgICAgICAgICAgIGIyID0gYjIgKyAxIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBmMiA9IGgyICYgLTQgfCAwOwogICAgICAgICAgICBpMiA9IGQyIHwgZDIgPDwgOCB8IGQyIDw8IDE2IHwgZDIgPDwgMjQ7CiAgICAgICAgICAgIGcyID0gZjIgLSA2NCB8IDA7CiAgICAgICAgICAgIHdoaWxlICgoYjIgfCAwKSA8PSAoZzIgfCAwKSkgewogICAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBpMjsKICAgICAgICAgICAgICBjW2IyICsgNCA+PiAyXSA9IGkyOwogICAgICAgICAgICAgIGNbYjIgKyA4ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDEyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDE2ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDIwID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDI0ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDI4ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDMyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDM2ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDQwID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDQ0ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDQ4ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDUyID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDU2ID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgY1tiMiArIDYwID4+IDJdID0gaTI7CiAgICAgICAgICAgICAgYjIgPSBiMiArIDY0IHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICB3aGlsZSAoKGIyIHwgMCkgPCAoZjIgfCAwKSkgewogICAgICAgICAgICAgIGNbYjIgPj4gMl0gPSBpMjsKICAgICAgICAgICAgICBiMiA9IGIyICsgNCB8IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlICgoYjIgfCAwKSA8IChoMiB8IDApKSB7CiAgICAgICAgICAgIGFbYjIgPj4gMF0gPSBkMjsKICAgICAgICAgICAgYjIgPSBiMiArIDEgfCAwOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGgyIC0gZTIgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB4cihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICByZXR1cm4gWVthMiAmIDNdKCkgfCAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB5cihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICByZXR1cm4gWlthMiAmIDE1XShiMiB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24genIoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9ICtjMjsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgcmV0dXJuIF9bYTIgJiAxXShiMiB8IDAsICtjMiwgZDIgfCAwLCBlMiB8IDAsIGYyIHwgMCwgZzIgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEFyKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHJldHVybiAkW2EyICYgNjNdKGIyIHwgMCwgYzIgfCAwKSB8IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEJyKGEyLCBiMiwgYzIsIGQyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIHJldHVybiBhYVthMiAmIDddKGIyIHwgMCwgYzIgfCAwLCBkMiB8IDApIHwgMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gQ3IoYTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYmFbYTIgJiAzXSgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBEcihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjYVthMiAmIDI1NV0oYjIgfCAwKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRXIoYTIsIGIyLCBjMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZGFbYTIgJiAxNV0oYjIgfCAwLCBjMiB8IDApOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGcihhMiwgYjIsIGMyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlYVthMiAmIDE1XShiMiB8IDAsIGMyIHwgMCwgZDIgfCAwKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gR3IoYTIsIGIyLCBjMiwgZDIsIGUyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZmFbYTIgJiA3XShiMiB8IDAsIGMyIHwgMCwgZDIgfCAwLCBlMiB8IDApOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBIcihhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBkMiA9IGQyIHwgMDsKICAgICAgICAgIGUyID0gZTIgfCAwOwogICAgICAgICAgZjIgPSBmMiB8IDA7CiAgICAgICAgICBnYVthMiAmIDNdKGIyIHwgMCwgYzIgfCAwLCBkMiB8IDAsIGUyIHwgMCwgZjIgfCAwKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSXIoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMiwgZzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBmMiA9IGYyIHwgMDsKICAgICAgICAgIGcyID0gZzIgfCAwOwogICAgICAgICAgaGFbYTIgJiAzXShiMiB8IDAsIGMyIHwgMCwgZDIgfCAwLCBlMiB8IDAsIGYyIHwgMCwgZzIgfCAwKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSnIoKSB7CiAgICAgICAgICBzKDApOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEtyKGEyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIHMoMSk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTHIoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9ICtiMjsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgcygyKTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBNcihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBzKDMpOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE5yKGEyLCBiMiwgYzIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIHMoNCk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gT3IoKSB7CiAgICAgICAgICBzKDUpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBQcihhMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBzKDYpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBRcihhMiwgYjIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBzKDcpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBScihhMiwgYjIsIGMyKSB7CiAgICAgICAgICBhMiA9IGEyIHwgMDsKICAgICAgICAgIGIyID0gYjIgfCAwOwogICAgICAgICAgYzIgPSBjMiB8IDA7CiAgICAgICAgICBzKDgpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBTcihhMiwgYjIsIGMyLCBkMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBzKDkpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBUcihhMiwgYjIsIGMyLCBkMiwgZTIpIHsKICAgICAgICAgIGEyID0gYTIgfCAwOwogICAgICAgICAgYjIgPSBiMiB8IDA7CiAgICAgICAgICBjMiA9IGMyIHwgMDsKICAgICAgICAgIGQyID0gZDIgfCAwOwogICAgICAgICAgZTIgPSBlMiB8IDA7CiAgICAgICAgICBzKDEwKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gVXIoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgewogICAgICAgICAgYTIgPSBhMiB8IDA7CiAgICAgICAgICBiMiA9IGIyIHwgMDsKICAgICAgICAgIGMyID0gYzIgfCAwOwogICAgICAgICAgZDIgPSBkMiB8IDA7CiAgICAgICAgICBlMiA9IGUyIHwgMDsKICAgICAgICAgIGYyID0gZjIgfCAwOwogICAgICAgICAgcygxMSk7CiAgICAgICAgfQogICAgICAgIHZhciBZID0gW0pyLCBNaywgRmwsIEpyXTsKICAgICAgICB2YXIgWiA9IFtLciwgQXAsIHpiLCBGYiwgcXAsIHRwLCBvcSwgS3EsIFRxLCB3aywgbmEsIHRsLCBPaywgSGwsIEtyLCBLcl07CiAgICAgICAgdmFyIF8gPSBbTHIsIHBvXTsKICAgICAgICB2YXIgJCA9IFsKICAgICAgICAgIE1yLAogICAgICAgICAgQmEsCiAgICAgICAgICBLYSwKICAgICAgICAgIEViLAogICAgICAgICAgamQsCiAgICAgICAgICBOZCwKICAgICAgICAgIFhkLAogICAgICAgICAgamUsCiAgICAgICAgICBrZSwKICAgICAgICAgIG5lLAogICAgICAgICAgX2UsCiAgICAgICAgICBmZiwKICAgICAgICAgIHlmLAogICAgICAgICAgRmYsCiAgICAgICAgICBPZiwKICAgICAgICAgIFZmLAogICAgICAgICAgSGcsCiAgICAgICAgICBRZywKICAgICAgICAgIFpnLAogICAgICAgICAgY2gsCiAgICAgICAgICBsaCwKICAgICAgICAgIHFoLAogICAgICAgICAgemgsCiAgICAgICAgICBFaCwKICAgICAgICAgIE5oLAogICAgICAgICAgX2gsCiAgICAgICAgICBmaSwKICAgICAgICAgIGtpLAogICAgICAgICAgc2ksCiAgICAgICAgICBCaSwKICAgICAgICAgIFNpLAogICAgICAgICAgWmksCiAgICAgICAgICBmaiwKICAgICAgICAgIG9qLAogICAgICAgICAgeWosCiAgICAgICAgICBGaiwKICAgICAgICAgIFBqLAogICAgICAgICAgWWosCiAgICAgICAgICBlaywKICAgICAgICAgIGxrLAogICAgICAgICAgdGssCiAgICAgICAgICBsbCwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yLAogICAgICAgICAgTXIsCiAgICAgICAgICBNciwKICAgICAgICAgIE1yCiAgICAgICAgXTsKICAgICAgICB2YXIgYWEgPSBbTnIsIElvLCBZbywgRnAsIEhwLCBNcSwgTnEsIE5yXTsKICAgICAgICB2YXIgYmEgPSBbT3IsIERwLCBQbywgT3JdOwogICAgICAgIHZhciBjYSA9IFsKICAgICAgICAgIFByLAogICAgICAgICAgcHEsCiAgICAgICAgICB6YSwKICAgICAgICAgIEFhLAogICAgICAgICAgQ2EsCiAgICAgICAgICBJYSwKICAgICAgICAgIEphLAogICAgICAgICAgTGEsCiAgICAgICAgICB5cCwKICAgICAgICAgIG9iLAogICAgICAgICAgR2IsCiAgICAgICAgICB5YiwKICAgICAgICAgIEJiLAogICAgICAgICAgQ2IsCiAgICAgICAgICBMYiwKICAgICAgICAgIE1iLAogICAgICAgICAgWGIsCiAgICAgICAgICBZYiwKICAgICAgICAgIHNjLAogICAgICAgICAgdGMsCiAgICAgICAgICB1YywKICAgICAgICAgIE5jLAogICAgICAgICAgaGQsCiAgICAgICAgICBpZCwKICAgICAgICAgIGtkLAogICAgICAgICAgSmQsCiAgICAgICAgICBPZCwKICAgICAgICAgIFBkLAogICAgICAgICAgUWQsCiAgICAgICAgICBSZCwKICAgICAgICAgIFZkLAogICAgICAgICAgV2QsCiAgICAgICAgICBZZCwKICAgICAgICAgIGhlLAogICAgICAgICAgaWUsCiAgICAgICAgICBsZSwKICAgICAgICAgIG1lLAogICAgICAgICAgWWUsCiAgICAgICAgICBaZSwKICAgICAgICAgICRlLAogICAgICAgICAgZGYsCiAgICAgICAgICBlZiwKICAgICAgICAgIHdmLAogICAgICAgICAgeGYsCiAgICAgICAgICB6ZiwKICAgICAgICAgIERmLAogICAgICAgICAgRWYsCiAgICAgICAgICBNZiwKICAgICAgICAgIE5mLAogICAgICAgICAgUGYsCiAgICAgICAgICBUZiwKICAgICAgICAgIFVmLAogICAgICAgICAgRmcsCiAgICAgICAgICBHZywKICAgICAgICAgIElnLAogICAgICAgICAgUmcsCiAgICAgICAgICBTZywKICAgICAgICAgIFhnLAogICAgICAgICAgWWcsCiAgICAgICAgICBfZywKICAgICAgICAgIGRoLAogICAgICAgICAgZWgsCiAgICAgICAgICBqaCwKICAgICAgICAgIGtoLAogICAgICAgICAgbWgsCiAgICAgICAgICByaCwKICAgICAgICAgIHNoLAogICAgICAgICAgeGgsCiAgICAgICAgICB5aCwKICAgICAgICAgIEFoLAogICAgICAgICAgRmgsCiAgICAgICAgICBHaCwKICAgICAgICAgIExoLAogICAgICAgICAgTWgsCiAgICAgICAgICBPaCwKICAgICAgICAgIFloLAogICAgICAgICAgWmgsCiAgICAgICAgICAkaCwKICAgICAgICAgIGRpLAogICAgICAgICAgZWksCiAgICAgICAgICBnaSwKICAgICAgICAgIGxpLAogICAgICAgICAgbWksCiAgICAgICAgICBxaSwKICAgICAgICAgIHJpLAogICAgICAgICAgdGksCiAgICAgICAgICB6aSwKICAgICAgICAgIEFpLAogICAgICAgICAgUWksCiAgICAgICAgICBSaSwKICAgICAgICAgIFRpLAogICAgICAgICAgWGksCiAgICAgICAgICBZaSwKICAgICAgICAgIGRqLAogICAgICAgICAgZWosCiAgICAgICAgICBnaiwKICAgICAgICAgIG1qLAogICAgICAgICAgbmosCiAgICAgICAgICB3aiwKICAgICAgICAgIHhqLAogICAgICAgICAgemosCiAgICAgICAgICBEaiwKICAgICAgICAgIEVqLAogICAgICAgICAgTmosCiAgICAgICAgICBPaiwKICAgICAgICAgIFFqLAogICAgICAgICAgV2osCiAgICAgICAgICBYaiwKICAgICAgICAgIGNrLAogICAgICAgICAgZGssCiAgICAgICAgICBmaywKICAgICAgICAgIGprLAogICAgICAgICAga2ssCiAgICAgICAgICByaywKICAgICAgICAgIHNrLAogICAgICAgICAgdWssCiAgICAgICAgICBVbywKICAgICAgICAgIFZvLAogICAgICAgICAgV28sCiAgICAgICAgICBYbywKICAgICAgICAgIGZwLAogICAgICAgICAgb3AsCiAgICAgICAgICBwcCwKICAgICAgICAgIHJwLAogICAgICAgICAgc3AsCiAgICAgICAgICB6cCwKICAgICAgICAgIEJwLAogICAgICAgICAgQ3AsCiAgICAgICAgICBFcCwKICAgICAgICAgIEdwLAogICAgICAgICAgTHAsCiAgICAgICAgICBtcSwKICAgICAgICAgIG5xLAogICAgICAgICAgSXEsCiAgICAgICAgICBKcSwKICAgICAgICAgIFNxLAogICAgICAgICAgWXEsCiAgICAgICAgICBacSwKICAgICAgICAgIHprLAogICAgICAgICAgd2wsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByLAogICAgICAgICAgUHIsCiAgICAgICAgICBQciwKICAgICAgICAgIFByCiAgICAgICAgXTsKICAgICAgICB2YXIgZGEgPSBbUXIsIEFiLCBEYiwgbWEsIHBhLCBxYSwgcmEsIHNhLCBxbywgUXIsIFFyLCBRciwgUXIsIFFyLCBRciwgUXJdOwogICAgICAgIHZhciBlYSA9IFtSciwgTHEsIE9xLCBVcSwgVnEsIGxhLCBvYSwgZGwsIFZsLCAkbCwgUnIsIFJyLCBSciwgUnIsIFJyLCBScl07CiAgICAgICAgdmFyIGZhID0gW1NyLCAkbywgaXAsIE9wLCBWaywgT2wsIFNyLCBTcl07CiAgICAgICAgdmFyIGdhID0gW1RyLCBfbywgaHAsIE5wXTsKICAgICAgICB2YXIgaGEgPSBbVXIsIFpvLCBncCwgTXBdOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udjoga3EsCiAgICAgICAgICBfX19jeGFfY2FuX2NhdGNoOiBocSwKICAgICAgICAgIF9fX2N4YV9pc19wb2ludGVyX3R5cGU6IGlxLAogICAgICAgICAgX19fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlczogaW0sCiAgICAgICAgICBfX19lcnJub19sb2NhdGlvbjogYW8sCiAgICAgICAgICBfX19nZXRUeXBlTmFtZTogJG4sCiAgICAgICAgICBfX19tdWxkaTM6IGtyLAogICAgICAgICAgX19fdWRpdmRpMzogcHIsCiAgICAgICAgICBfYml0c2hpZnQ2NExzaHI6IHFyLAogICAgICAgICAgX2JpdHNoaWZ0NjRTaGw6IHJyLAogICAgICAgICAgX2Vtc2NyaXB0ZW5fZ2V0X3NicmtfcHRyOiBzciwKICAgICAgICAgIF9mcmVlOiBlciwKICAgICAgICAgIF9pNjRBZGQ6IGxyLAogICAgICAgICAgX2k2NFN1YnRyYWN0OiBtciwKICAgICAgICAgIF9sbHZtX2Jzd2FwX2kzMjogdHIsCiAgICAgICAgICBfbWFsbG9jOiBkciwKICAgICAgICAgIF9tZW1jcHk6IHVyLAogICAgICAgICAgX21lbW1vdmU6IHZyLAogICAgICAgICAgX21lbXNldDogd3IsCiAgICAgICAgICBkeW5DYWxsX2k6IHhyLAogICAgICAgICAgZHluQ2FsbF9paTogeXIsCiAgICAgICAgICBkeW5DYWxsX2lpZGlpaWk6IHpyLAogICAgICAgICAgZHluQ2FsbF9paWk6IEFyLAogICAgICAgICAgZHluQ2FsbF9paWlpOiBCciwKICAgICAgICAgIGR5bkNhbGxfdjogQ3IsCiAgICAgICAgICBkeW5DYWxsX3ZpOiBEciwKICAgICAgICAgIGR5bkNhbGxfdmlpOiBFciwKICAgICAgICAgIGR5bkNhbGxfdmlpaTogRnIsCiAgICAgICAgICBkeW5DYWxsX3ZpaWlpOiBHciwKICAgICAgICAgIGR5bkNhbGxfdmlpaWlpOiBIciwKICAgICAgICAgIGR5bkNhbGxfdmlpaWlpaTogSXIsCiAgICAgICAgICBnbG9iYWxDdG9yczogaWEsCiAgICAgICAgICBzdGFja0FsbG9jOiBnciwKICAgICAgICAgIHN0YWNrUmVzdG9yZTogaHIsCiAgICAgICAgICBzdGFja1NhdmU6IGlyCiAgICAgICAgfTsKICAgICAgfSgKICAgICAgICAvLyBFTVNDUklQVEVOX0VORF9BU00KICAgICAgICBhc21HbG9iYWxBcmcsCiAgICAgICAgYXNtTGlicmFyeUFyZywKICAgICAgICBidWZmZXIKICAgICAgKQogICAgKTsKICAgIHZhciBfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udiA9IE1vZHVsZTJbIl9fWlN0MTh1bmNhdWdodF9leGNlcHRpb252Il0gPSBhc21bIl9fWlN0MTh1bmNhdWdodF9leGNlcHRpb252Il07CiAgICB2YXIgX19fY3hhX2Nhbl9jYXRjaCA9IE1vZHVsZTJbIl9fX2N4YV9jYW5fY2F0Y2giXSA9IGFzbVsiX19fY3hhX2Nhbl9jYXRjaCJdOwogICAgdmFyIF9fX2N4YV9pc19wb2ludGVyX3R5cGUgPSBNb2R1bGUyWyJfX19jeGFfaXNfcG9pbnRlcl90eXBlIl0gPSBhc21bIl9fX2N4YV9pc19wb2ludGVyX3R5cGUiXTsKICAgIHZhciBfX19lbWJpbmRfcmVnaXN0ZXJfbmF0aXZlX2FuZF9idWlsdGluX3R5cGVzID0gTW9kdWxlMlsiX19fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlcyJdID0gYXNtWyJfX19lbWJpbmRfcmVnaXN0ZXJfbmF0aXZlX2FuZF9idWlsdGluX3R5cGVzIl07CiAgICB2YXIgX19fZXJybm9fbG9jYXRpb24gPSBNb2R1bGUyWyJfX19lcnJub19sb2NhdGlvbiJdID0gYXNtWyJfX19lcnJub19sb2NhdGlvbiJdOwogICAgdmFyIF9fX2dldFR5cGVOYW1lID0gTW9kdWxlMlsiX19fZ2V0VHlwZU5hbWUiXSA9IGFzbVsiX19fZ2V0VHlwZU5hbWUiXTsKICAgIHZhciBfX19tdWxkaTMgPSBNb2R1bGUyWyJfX19tdWxkaTMiXSA9IGFzbVsiX19fbXVsZGkzIl07CiAgICB2YXIgX19fdWRpdmRpMyA9IE1vZHVsZTJbIl9fX3VkaXZkaTMiXSA9IGFzbVsiX19fdWRpdmRpMyJdOwogICAgdmFyIF9iaXRzaGlmdDY0THNociA9IE1vZHVsZTJbIl9iaXRzaGlmdDY0THNociJdID0gYXNtWyJfYml0c2hpZnQ2NExzaHIiXTsKICAgIHZhciBfYml0c2hpZnQ2NFNobCA9IE1vZHVsZTJbIl9iaXRzaGlmdDY0U2hsIl0gPSBhc21bIl9iaXRzaGlmdDY0U2hsIl07CiAgICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X3NicmtfcHRyID0gTW9kdWxlMlsiX2Vtc2NyaXB0ZW5fZ2V0X3NicmtfcHRyIl0gPSBhc21bIl9lbXNjcmlwdGVuX2dldF9zYnJrX3B0ciJdOwogICAgdmFyIF9mcmVlID0gTW9kdWxlMlsiX2ZyZWUiXSA9IGFzbVsiX2ZyZWUiXTsKICAgIHZhciBfaTY0QWRkID0gTW9kdWxlMlsiX2k2NEFkZCJdID0gYXNtWyJfaTY0QWRkIl07CiAgICB2YXIgX2k2NFN1YnRyYWN0ID0gTW9kdWxlMlsiX2k2NFN1YnRyYWN0Il0gPSBhc21bIl9pNjRTdWJ0cmFjdCJdOwogICAgdmFyIF9sbHZtX2Jzd2FwX2kzMiA9IE1vZHVsZTJbIl9sbHZtX2Jzd2FwX2kzMiJdID0gYXNtWyJfbGx2bV9ic3dhcF9pMzIiXTsKICAgIHZhciBfbWFsbG9jID0gTW9kdWxlMlsiX21hbGxvYyJdID0gYXNtWyJfbWFsbG9jIl07CiAgICB2YXIgX21lbWNweSA9IE1vZHVsZTJbIl9tZW1jcHkiXSA9IGFzbVsiX21lbWNweSJdOwogICAgdmFyIF9tZW1tb3ZlID0gTW9kdWxlMlsiX21lbW1vdmUiXSA9IGFzbVsiX21lbW1vdmUiXTsKICAgIHZhciBfbWVtc2V0ID0gTW9kdWxlMlsiX21lbXNldCJdID0gYXNtWyJfbWVtc2V0Il07CiAgICB2YXIgZ2xvYmFsQ3RvcnMgPSBNb2R1bGUyWyJnbG9iYWxDdG9ycyJdID0gYXNtWyJnbG9iYWxDdG9ycyJdOwogICAgdmFyIHN0YWNrQWxsb2MgPSBNb2R1bGUyWyJzdGFja0FsbG9jIl0gPSBhc21bInN0YWNrQWxsb2MiXTsKICAgIHZhciBzdGFja1Jlc3RvcmUgPSBNb2R1bGUyWyJzdGFja1Jlc3RvcmUiXSA9IGFzbVsic3RhY2tSZXN0b3JlIl07CiAgICB2YXIgc3RhY2tTYXZlID0gTW9kdWxlMlsic3RhY2tTYXZlIl0gPSBhc21bInN0YWNrU2F2ZSJdOwogICAgdmFyIGR5bkNhbGxfaSA9IE1vZHVsZTJbImR5bkNhbGxfaSJdID0gYXNtWyJkeW5DYWxsX2kiXTsKICAgIHZhciBkeW5DYWxsX2lpID0gTW9kdWxlMlsiZHluQ2FsbF9paSJdID0gYXNtWyJkeW5DYWxsX2lpIl07CiAgICB2YXIgZHluQ2FsbF9paWRpaWlpID0gTW9kdWxlMlsiZHluQ2FsbF9paWRpaWlpIl0gPSBhc21bImR5bkNhbGxfaWlkaWlpaSJdOwogICAgdmFyIGR5bkNhbGxfaWlpID0gTW9kdWxlMlsiZHluQ2FsbF9paWkiXSA9IGFzbVsiZHluQ2FsbF9paWkiXTsKICAgIHZhciBkeW5DYWxsX2lpaWkgPSBNb2R1bGUyWyJkeW5DYWxsX2lpaWkiXSA9IGFzbVsiZHluQ2FsbF9paWlpIl07CiAgICB2YXIgZHluQ2FsbF92ID0gTW9kdWxlMlsiZHluQ2FsbF92Il0gPSBhc21bImR5bkNhbGxfdiJdOwogICAgdmFyIGR5bkNhbGxfdmkgPSBNb2R1bGUyWyJkeW5DYWxsX3ZpIl0gPSBhc21bImR5bkNhbGxfdmkiXTsKICAgIHZhciBkeW5DYWxsX3ZpaSA9IE1vZHVsZTJbImR5bkNhbGxfdmlpIl0gPSBhc21bImR5bkNhbGxfdmlpIl07CiAgICB2YXIgZHluQ2FsbF92aWlpID0gTW9kdWxlMlsiZHluQ2FsbF92aWlpIl0gPSBhc21bImR5bkNhbGxfdmlpaSJdOwogICAgdmFyIGR5bkNhbGxfdmlpaWkgPSBNb2R1bGUyWyJkeW5DYWxsX3ZpaWlpIl0gPSBhc21bImR5bkNhbGxfdmlpaWkiXTsKICAgIHZhciBkeW5DYWxsX3ZpaWlpaSA9IE1vZHVsZTJbImR5bkNhbGxfdmlpaWlpIl0gPSBhc21bImR5bkNhbGxfdmlpaWlpIl07CiAgICB2YXIgZHluQ2FsbF92aWlpaWlpID0gTW9kdWxlMlsiZHluQ2FsbF92aWlpaWlpIl0gPSBhc21bImR5bkNhbGxfdmlpaWlpaSJdOwogICAgTW9kdWxlMlsiYXNtIl0gPSBhc207CiAgICBpZiAobWVtb3J5SW5pdGlhbGl6ZXIpIHsKICAgICAgaWYgKCFpc0RhdGFVUkkobWVtb3J5SW5pdGlhbGl6ZXIpKSB7CiAgICAgICAgbWVtb3J5SW5pdGlhbGl6ZXIgPSBsb2NhdGVGaWxlKG1lbW9yeUluaXRpYWxpemVyKTsKICAgICAgfQogICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSB8fCBFTlZJUk9OTUVOVF9JU19TSEVMTCkgewogICAgICAgIHZhciBkYXRhID0gcmVhZEJpbmFyeShtZW1vcnlJbml0aWFsaXplcik7CiAgICAgICAgSEVBUFU4LnNldChkYXRhLCBHTE9CQUxfQkFTRSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYWRkUnVuRGVwZW5kZW5jeSgibWVtb3J5IGluaXRpYWxpemVyIik7CiAgICAgICAgdmFyIGFwcGx5TWVtb3J5SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbihkYXRhMikgewogICAgICAgICAgaWYgKGRhdGEyLmJ5dGVMZW5ndGgpCiAgICAgICAgICAgIGRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YTIpOwogICAgICAgICAgSEVBUFU4LnNldChkYXRhMiwgR0xPQkFMX0JBU0UpOwogICAgICAgICAgaWYgKE1vZHVsZTJbIm1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCJdKQogICAgICAgICAgICBkZWxldGUgTW9kdWxlMlsibWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0Il0ucmVzcG9uc2U7CiAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCJtZW1vcnkgaW5pdGlhbGl6ZXIiKTsKICAgICAgICB9OwogICAgICAgIHZhciBkb0Jyb3dzZXJMb2FkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICByZWFkQXN5bmMobWVtb3J5SW5pdGlhbGl6ZXIsIGFwcGx5TWVtb3J5SW5pdGlhbGl6ZXIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcigiY291bGQgbm90IGxvYWQgbWVtb3J5IGluaXRpYWxpemVyICIgKyBtZW1vcnlJbml0aWFsaXplcik7CiAgICAgICAgICAgIHRocm93IGU7CiAgICAgICAgICB9KTsKICAgICAgICB9OwogICAgICAgIHZhciBtZW1vcnlJbml0aWFsaXplckJ5dGVzID0gdHJ5UGFyc2VBc0RhdGFVUkkobWVtb3J5SW5pdGlhbGl6ZXIpOwogICAgICAgIGlmIChtZW1vcnlJbml0aWFsaXplckJ5dGVzKSB7CiAgICAgICAgICBhcHBseU1lbW9yeUluaXRpYWxpemVyKG1lbW9yeUluaXRpYWxpemVyQnl0ZXMuYnVmZmVyKTsKICAgICAgICB9IGVsc2UgaWYgKE1vZHVsZTJbIm1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCJdKSB7CiAgICAgICAgICB2YXIgdXNlUmVxdWVzdCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgcmVxdWVzdCA9IE1vZHVsZTJbIm1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCJdOwogICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlOwogICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMCkgewogICAgICAgICAgICAgIHZhciBkYXRhMiA9IHRyeVBhcnNlQXNEYXRhVVJJKE1vZHVsZTJbIm1lbW9yeUluaXRpYWxpemVyUmVxdWVzdFVSTCJdKTsKICAgICAgICAgICAgICBpZiAoZGF0YTIpIHsKICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZGF0YTIuYnVmZmVyOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oCiAgICAgICAgICAgICAgICAgICJhIHByb2JsZW0gc2VlbXMgdG8gaGF2ZSBoYXBwZW5lZCB3aXRoIE1vZHVsZS5tZW1vcnlJbml0aWFsaXplclJlcXVlc3QsIHN0YXR1czogIiArIHJlcXVlc3Quc3RhdHVzICsgIiwgcmV0cnlpbmcgIiArIG1lbW9yeUluaXRpYWxpemVyCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgZG9Ccm93c2VyTG9hZCgpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBhcHBseU1lbW9yeUluaXRpYWxpemVyKHJlc3BvbnNlKTsKICAgICAgICAgIH07CiAgICAgICAgICBpZiAoTW9kdWxlMlsibWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0Il0ucmVzcG9uc2UpIHsKICAgICAgICAgICAgc2V0VGltZW91dCh1c2VSZXF1ZXN0LCAwKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIE1vZHVsZTJbIm1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCJdLmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLCB1c2VSZXF1ZXN0KTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgZG9Ccm93c2VyTG9hZCgpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgdmFyIGNhbGxlZFJ1bjsKICAgIGZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7CiAgICAgIHRoaXMubmFtZSA9ICJFeGl0U3RhdHVzIjsKICAgICAgdGhpcy5tZXNzYWdlID0gIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoIiArIHN0YXR1cyArICIpIjsKICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7CiAgICB9CiAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7CiAgICAgIGlmICghY2FsbGVkUnVuKQogICAgICAgIHJ1bigpOwogICAgICBpZiAoIWNhbGxlZFJ1bikKICAgICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7CiAgICB9OwogICAgZnVuY3Rpb24gcnVuKGFyZ3MpIHsKICAgICAgYXJncyA9IGFyZ3MgfHwgYXJndW1lbnRzXzsKICAgICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgcHJlUnVuKCk7CiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKQogICAgICAgIHJldHVybjsKICAgICAgZnVuY3Rpb24gZG9SdW4oKSB7CiAgICAgICAgaWYgKGNhbGxlZFJ1bikKICAgICAgICAgIHJldHVybjsKICAgICAgICBjYWxsZWRSdW4gPSB0cnVlOwogICAgICAgIE1vZHVsZTJbImNhbGxlZFJ1biJdID0gdHJ1ZTsKICAgICAgICBpZiAoQUJPUlQpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgaW5pdFJ1bnRpbWUoKTsKICAgICAgICBwcmVNYWluKCk7CiAgICAgICAgaWYgKE1vZHVsZTJbIm9uUnVudGltZUluaXRpYWxpemVkIl0pCiAgICAgICAgICBNb2R1bGUyWyJvblJ1bnRpbWVJbml0aWFsaXplZCJdKCk7CiAgICAgICAgcG9zdFJ1bigpOwogICAgICB9CiAgICAgIGlmIChNb2R1bGUyWyJzZXRTdGF0dXMiXSkgewogICAgICAgIE1vZHVsZTJbInNldFN0YXR1cyJdKCJSdW5uaW5nLi4uIik7CiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIE1vZHVsZTJbInNldFN0YXR1cyJdKCIiKTsKICAgICAgICAgIH0sIDEpOwogICAgICAgICAgZG9SdW4oKTsKICAgICAgICB9LCAxKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBkb1J1bigpOwogICAgICB9CiAgICB9CiAgICBNb2R1bGUyWyJydW4iXSA9IHJ1bjsKICAgIGlmIChNb2R1bGUyWyJwcmVJbml0Il0pIHsKICAgICAgaWYgKHR5cGVvZiBNb2R1bGUyWyJwcmVJbml0Il0gPT0gImZ1bmN0aW9uIikKICAgICAgICBNb2R1bGUyWyJwcmVJbml0Il0gPSBbTW9kdWxlMlsicHJlSW5pdCJdXTsKICAgICAgd2hpbGUgKE1vZHVsZTJbInByZUluaXQiXS5sZW5ndGggPiAwKSB7CiAgICAgICAgTW9kdWxlMlsicHJlSW5pdCJdLnBvcCgpKCk7CiAgICAgIH0KICAgIH0KICAgIG5vRXhpdFJ1bnRpbWUgPSB0cnVlOwogICAgcnVuKCk7CiAgICByZXR1cm4gTW9kdWxlMjsKICB9CgogIC8vIHNyYy9saWIvbGFzbGF6LWRlY29kZXIudHMKICB2YXIgTW9kdWxlID0gbnVsbDsKICB2YXIgUE9JTlRfRk9STUFUX1JFQURFUlMgPSB7CiAgICAwOiAoZHYpID0+IHsKICAgICAgcmV0dXJuIHsKICAgICAgICBwb3NpdGlvbjogW2R2LmdldEludDMyKDAsIHRydWUpLCBkdi5nZXRJbnQzMig0LCB0cnVlKSwgZHYuZ2V0SW50MzIoOCwgdHJ1ZSldLAogICAgICAgIGludGVuc2l0eTogZHYuZ2V0VWludDE2KDEyLCB0cnVlKSwKICAgICAgICBjbGFzc2lmaWNhdGlvbjogZHYuZ2V0VWludDgoMTUpCiAgICAgIH07CiAgICB9LAogICAgMTogKGR2KSA9PiB7CiAgICAgIHJldHVybiB7CiAgICAgICAgcG9zaXRpb246IFtkdi5nZXRJbnQzMigwLCB0cnVlKSwgZHYuZ2V0SW50MzIoNCwgdHJ1ZSksIGR2LmdldEludDMyKDgsIHRydWUpXSwKICAgICAgICBpbnRlbnNpdHk6IGR2LmdldFVpbnQxNigxMiwgdHJ1ZSksCiAgICAgICAgY2xhc3NpZmljYXRpb246IGR2LmdldFVpbnQ4KDE1KQogICAgICB9OwogICAgfSwKICAgIDI6IChkdikgPT4gewogICAgICByZXR1cm4gewogICAgICAgIHBvc2l0aW9uOiBbZHYuZ2V0SW50MzIoMCwgdHJ1ZSksIGR2LmdldEludDMyKDQsIHRydWUpLCBkdi5nZXRJbnQzMig4LCB0cnVlKV0sCiAgICAgICAgaW50ZW5zaXR5OiBkdi5nZXRVaW50MTYoMTIsIHRydWUpLAogICAgICAgIGNsYXNzaWZpY2F0aW9uOiBkdi5nZXRVaW50OCgxNSksCiAgICAgICAgY29sb3I6IFtkdi5nZXRVaW50MTYoMjAsIHRydWUpLCBkdi5nZXRVaW50MTYoMjIsIHRydWUpLCBkdi5nZXRVaW50MTYoMjQsIHRydWUpXQogICAgICB9OwogICAgfSwKICAgIDM6IChkdikgPT4gewogICAgICByZXR1cm4gewogICAgICAgIHBvc2l0aW9uOiBbZHYuZ2V0SW50MzIoMCwgdHJ1ZSksIGR2LmdldEludDMyKDQsIHRydWUpLCBkdi5nZXRJbnQzMig4LCB0cnVlKV0sCiAgICAgICAgaW50ZW5zaXR5OiBkdi5nZXRVaW50MTYoMTIsIHRydWUpLAogICAgICAgIGNsYXNzaWZpY2F0aW9uOiBkdi5nZXRVaW50OCgxNSksCiAgICAgICAgY29sb3I6IFtkdi5nZXRVaW50MTYoMjgsIHRydWUpLCBkdi5nZXRVaW50MTYoMzAsIHRydWUpLCBkdi5nZXRVaW50MTYoMzIsIHRydWUpXQogICAgICB9OwogICAgfQogIH07CiAgZnVuY3Rpb24gcmVhZEFzKGJ1ZiwgVHlwZSA9IHt9LCBvZmZzZXQsIGNvdW50KSB7CiAgICBjb3VudCA9IGNvdW50ID09PSB2b2lkIDAgfHwgY291bnQgPT09IDAgPyAxIDogY291bnQ7CiAgICBjb25zdCBzdWIgPSBidWYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UICogY291bnQpOwogICAgY29uc3QgciA9IG5ldyBUeXBlKHN1Yik7CiAgICBpZiAoY291bnQgPT09IDEpIHsKICAgICAgcmV0dXJuIHJbMF07CiAgICB9CiAgICBjb25zdCByZXQgPSBbXTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykgewogICAgICByZXQucHVzaChyW2ldKTsKICAgIH0KICAgIHJldHVybiByZXQ7CiAgfQogIGZ1bmN0aW9uIHBhcnNlTEFTSGVhZGVyKGFycmF5YnVmZmVyKSB7CiAgICBsZXQgc3RhcnQgPSAzMiAqIDMgKyAzNTsKICAgIGNvbnN0IG8gPSB7CiAgICAgIHBvaW50c09mZnNldDogcmVhZEFzKGFycmF5YnVmZmVyLCBVaW50MzJBcnJheSwgMzIgKiAzKSwKICAgICAgcG9pbnRzRm9ybWF0SWQ6IHJlYWRBcyhhcnJheWJ1ZmZlciwgVWludDhBcnJheSwgMzIgKiAzICsgOCksCiAgICAgIHBvaW50c1N0cnVjdFNpemU6IHJlYWRBcyhhcnJheWJ1ZmZlciwgVWludDE2QXJyYXksIDMyICogMyArIDggKyAxKSwKICAgICAgcG9pbnRzQ291bnQ6IHJlYWRBcyhhcnJheWJ1ZmZlciwgVWludDMyQXJyYXksIDMyICogMyArIDExKSwKICAgICAgc2NhbGU6IHJlYWRBcyhhcnJheWJ1ZmZlciwgRmxvYXQ2NEFycmF5LCBzdGFydCwgMykKICAgIH07CiAgICBzdGFydCArPSAyNDsKICAgIG8ub2Zmc2V0ID0gcmVhZEFzKGFycmF5YnVmZmVyLCBGbG9hdDY0QXJyYXksIHN0YXJ0LCAzKTsKICAgIHN0YXJ0ICs9IDI0OwogICAgY29uc3QgYm91bmRzID0gcmVhZEFzKGFycmF5YnVmZmVyLCBGbG9hdDY0QXJyYXksIHN0YXJ0LCA2KTsKICAgIHN0YXJ0ICs9IDQ4OwogICAgby5tYXhzID0gW2JvdW5kc1swXSwgYm91bmRzWzJdLCBib3VuZHNbNF1dOwogICAgby5taW5zID0gW2JvdW5kc1sxXSwgYm91bmRzWzNdLCBib3VuZHNbNV1dOwogICAgcmV0dXJuIG87CiAgfQogIHZhciBMQVNMb2FkZXIyID0gY2xhc3MgewogICAgYXJyYXlidWZmZXI7CiAgICByZWFkT2Zmc2V0ID0gMDsKICAgIGhlYWRlciA9IHsKICAgICAgcG9pbnRzT2Zmc2V0OiAwLAogICAgICBwb2ludHNGb3JtYXRJZDogMCwKICAgICAgcG9pbnRzU3RydWN0U2l6ZTogMCwKICAgICAgcG9pbnRzQ291bnQ6IDAsCiAgICAgIHNjYWxlOiBbMCwgMCwgMF0sCiAgICAgIG9mZnNldDogWzAsIDAsIDBdLAogICAgICBtYXhzOiBbMF0sCiAgICAgIG1pbnM6IFswXSwKICAgICAgdG90YWxUb1JlYWQ6IDAsCiAgICAgIHRvdGFsUmVhZDogMCwKICAgICAgdmVyc2lvbkFzU3RyaW5nOiAiIiwKICAgICAgaXNDb21wcmVzc2VkOiB0cnVlCiAgICB9OwogICAgY29uc3RydWN0b3IoYXJyYXlidWZmZXIpIHsKICAgICAgdGhpcy5hcnJheWJ1ZmZlciA9IGFycmF5YnVmZmVyOwogICAgfQogICAgLyoqCiAgICAgKiBAcmV0dXJucyBib29sZWFuCiAgICAgKi8KICAgIG9wZW4oKSB7CiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBQYXJzaW5nIG9mIGluY29taW5nIGJpbmFyeQogICAgICogQHJldHVybnMgTEFTSGVhZGVyCiAgICAgKi8KICAgIGdldEhlYWRlcigpIHsKICAgICAgdGhpcy5oZWFkZXIgPSBwYXJzZUxBU0hlYWRlcih0aGlzLmFycmF5YnVmZmVyKTsKICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyOwogICAgfQogICAgLyoqCiAgICAgKiBSZWFkaW5nIGRhdGEKICAgICAqIEBwYXJhbSBjb3VudAogICAgICogQHBhcmFtIHNraXAKICAgICAqIEByZXR1cm5zIG5ldyBBcnJheUJ1ZmZlciwgY291bnQsIGhhc01vcmVEYXRhCiAgICAgKi8KICAgIHJlYWREYXRhKGNvdW50LCBza2lwKSB7CiAgICAgIGNvbnN0IHsgaGVhZGVyLCBhcnJheWJ1ZmZlciB9ID0gdGhpczsKICAgICAgaWYgKCFoZWFkZXIpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzdGFydCByZWFkaW5nIGRhdGEgdGlsbCBhIGhlYWRlciByZXF1ZXN0IGlzIGlzc3VlZCIpOwogICAgICB9CiAgICAgIGxldCB7IHJlYWRPZmZzZXQgfSA9IHRoaXM7CiAgICAgIGxldCBzdGFydDsKICAgICAgaWYgKHNraXAgPD0gMSkgewogICAgICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIGhlYWRlci5wb2ludHNDb3VudCAtIHJlYWRPZmZzZXQpOwogICAgICAgIHN0YXJ0ID0gaGVhZGVyLnBvaW50c09mZnNldCArIHJlYWRPZmZzZXQgKiBoZWFkZXIucG9pbnRzU3RydWN0U2l6ZTsKICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50ICogaGVhZGVyLnBvaW50c1N0cnVjdFNpemU7CiAgICAgICAgcmVhZE9mZnNldCArPSBjb3VudDsKICAgICAgICB0aGlzLnJlYWRPZmZzZXQgPSByZWFkT2Zmc2V0OwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBidWZmZXI6IGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpLAogICAgICAgICAgY291bnQsCiAgICAgICAgICBoYXNNb3JlRGF0YTogcmVhZE9mZnNldCA8IGhlYWRlci5wb2ludHNDb3VudAogICAgICAgIH07CiAgICAgIH0KICAgICAgY29uc3QgcG9pbnRzVG9SZWFkID0gTWF0aC5taW4oY291bnQgKiBza2lwLCBoZWFkZXIucG9pbnRzQ291bnQgLSByZWFkT2Zmc2V0KTsKICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IE1hdGguY2VpbChwb2ludHNUb1JlYWQgLyBza2lwKTsKICAgICAgbGV0IHBvaW50c1JlYWQgPSAwOwogICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShidWZmZXJTaXplICogaGVhZGVyLnBvaW50c1N0cnVjdFNpemUpOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c1RvUmVhZDsgaSsrKSB7CiAgICAgICAgaWYgKGkgJSBza2lwID09PSAwKSB7CiAgICAgICAgICBzdGFydCA9IGhlYWRlci5wb2ludHNPZmZzZXQgKyByZWFkT2Zmc2V0ICogaGVhZGVyLnBvaW50c1N0cnVjdFNpemU7CiAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciwgc3RhcnQsIGhlYWRlci5wb2ludHNTdHJ1Y3RTaXplKTsKICAgICAgICAgIGJ1Zi5zZXQoc3JjLCBwb2ludHNSZWFkICogaGVhZGVyLnBvaW50c1N0cnVjdFNpemUpOwogICAgICAgICAgcG9pbnRzUmVhZCsrOwogICAgICAgIH0KICAgICAgICByZWFkT2Zmc2V0Kys7CiAgICAgIH0KICAgICAgdGhpcy5yZWFkT2Zmc2V0ID0gcmVhZE9mZnNldDsKICAgICAgcmV0dXJuIHsKICAgICAgICBidWZmZXI6IGJ1Zi5idWZmZXIsCiAgICAgICAgY291bnQ6IHBvaW50c1JlYWQsCiAgICAgICAgaGFzTW9yZURhdGE6IHJlYWRPZmZzZXQgPCBoZWFkZXIucG9pbnRzQ291bnQKICAgICAgfTsKICAgIH0KICAgIC8qKgogICAgICogTWV0aG9kIHdoaWNoIGJyaW5ncyBkYXRhIHRvIG51bGwgdG8gY2xvc2UgdGhlIGZpbGUKICAgICAqIEByZXR1cm5zCiAgICAgKi8KICAgIGNsb3NlKCkgewogICAgICB0aGlzLmFycmF5YnVmZmVyID0gbnVsbDsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgfTsKICB2YXIgTEFaTG9hZGVyID0gY2xhc3MgewogICAgYXJyYXlidWZmZXI7CiAgICBpbnN0YW5jZSA9IG51bGw7CiAgICAvLyBMQVNaaXAgaW5zdGFuY2UKICAgIGhlYWRlciA9IG51bGw7CiAgICBjb25zdHJ1Y3RvcihhcnJheWJ1ZmZlcikgewogICAgICB0aGlzLmFycmF5YnVmZmVyID0gYXJyYXlidWZmZXI7CiAgICAgIGlmICghTW9kdWxlKSB7CiAgICAgICAgTW9kdWxlID0gZ2V0TW9kdWxlKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogT3BlbnMgdGhlIGZpbGUKICAgICAqIEByZXR1cm5zIGJvb2xlYW4KICAgICAqLwogICAgb3BlbigpIHsKICAgICAgdHJ5IHsKICAgICAgICBjb25zdCB7IGFycmF5YnVmZmVyIH0gPSB0aGlzOwogICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgTW9kdWxlLkxBU1ppcCgpOwogICAgICAgIGNvbnN0IGFiSW50ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpOwogICAgICAgIGNvbnN0IGJ1ZiA9IE1vZHVsZS5fbWFsbG9jKGFycmF5YnVmZmVyLmJ5dGVMZW5ndGgpOwogICAgICAgIHRoaXMuaW5zdGFuY2UuYXJyYXlidWZmZXIgPSBhcnJheWJ1ZmZlcjsKICAgICAgICB0aGlzLmluc3RhbmNlLmJ1ZiA9IGJ1ZjsKICAgICAgICBNb2R1bGUuSEVBUFU4LnNldChhYkludCwgYnVmKTsKICAgICAgICB0aGlzLmluc3RhbmNlLm9wZW4oYnVmLCBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoKTsKICAgICAgICB0aGlzLmluc3RhbmNlLnJlYWRPZmZzZXQgPSAwOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9wZW4gZmlsZTogJHtlcnJvci5tZXNzYWdlfWApOwogICAgICB9CiAgICB9CiAgICBnZXRIZWFkZXIoKSB7CiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiWW91IG5lZWQgdG8gb3BlbiB0aGUgZmlsZSBiZWZvcmUgdHJ5aW5nIHRvIHJlYWQgaGVhZGVyIik7CiAgICAgIH0KICAgICAgdHJ5IHsKICAgICAgICBjb25zdCBoZWFkZXIgPSBwYXJzZUxBU0hlYWRlcih0aGlzLmluc3RhbmNlLmFycmF5YnVmZmVyKTsKICAgICAgICBoZWFkZXIucG9pbnRzRm9ybWF0SWQgJj0gNjM7CiAgICAgICAgdGhpcy5oZWFkZXIgPSBoZWFkZXI7CiAgICAgICAgcmV0dXJuIGhlYWRlcjsKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgaGVhZGVyOiAke2Vycm9yLm1lc3NhZ2V9YCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQHBhcmFtIGNvdW50CiAgICAgKiBAcGFyYW0gb2Zmc2V0CiAgICAgKiBAcGFyYW0gc2tpcAogICAgICogQHJldHVybnMgRGF0YQogICAgICovCiAgICByZWFkRGF0YShjb3VudCwgb2Zmc2V0LCBza2lwKSB7CiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiWW91IG5lZWQgdG8gb3BlbiB0aGUgZmlsZSBiZWZvcmUgdHJ5aW5nIHRvIHJlYWQgc3R1ZmYiKTsKICAgICAgfQogICAgICBjb25zdCB7IGhlYWRlciwgaW5zdGFuY2UgfSA9IHRoaXM7CiAgICAgIGlmICghaGVhZGVyKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICAgIllvdSBuZWVkIHRvIHF1ZXJ5IGhlYWRlciBiZWZvcmUgcmVhZGluZywgSSBtYWludGFpbiBzdGF0ZSB0aGF0IHdheSwgc29ycnkgOigiCiAgICAgICAgKTsKICAgICAgfQogICAgICB0cnkgewogICAgICAgIGNvbnN0IHBvaW50c1RvUmVhZCA9IE1hdGgubWluKGNvdW50ICogc2tpcCwgaGVhZGVyLnBvaW50c0NvdW50IC0gaW5zdGFuY2UucmVhZE9mZnNldCk7CiAgICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IE1hdGguY2VpbChwb2ludHNUb1JlYWQgLyBza2lwKTsKICAgICAgICBsZXQgcG9pbnRzUmVhZCA9IDA7CiAgICAgICAgY29uc3QgdGhpc0J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUgKiBoZWFkZXIucG9pbnRzU3RydWN0U2l6ZSk7CiAgICAgICAgY29uc3QgYnVmUmVhZCA9IE1vZHVsZS5fbWFsbG9jKGhlYWRlci5wb2ludHNTdHJ1Y3RTaXplKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c1RvUmVhZDsgaSsrKSB7CiAgICAgICAgICBpbnN0YW5jZS5nZXRQb2ludChidWZSZWFkKTsKICAgICAgICAgIGlmIChpICUgc2tpcCA9PT0gMCkgewogICAgICAgICAgICBjb25zdCBhID0gbmV3IFVpbnQ4QXJyYXkoTW9kdWxlLkhFQVBVOC5idWZmZXIsIGJ1ZlJlYWQsIGhlYWRlci5wb2ludHNTdHJ1Y3RTaXplKTsKICAgICAgICAgICAgdGhpc0J1Zi5zZXQoYSwgcG9pbnRzUmVhZCAqIGhlYWRlci5wb2ludHNTdHJ1Y3RTaXplKTsKICAgICAgICAgICAgcG9pbnRzUmVhZCsrOwogICAgICAgICAgfQogICAgICAgICAgaW5zdGFuY2UucmVhZE9mZnNldCsrOwogICAgICAgIH0KICAgICAgICBNb2R1bGUuX2ZyZWUoYnVmUmVhZCk7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGJ1ZmZlcjogdGhpc0J1Zi5idWZmZXIsCiAgICAgICAgICBjb3VudDogcG9pbnRzUmVhZCwKICAgICAgICAgIGhhc01vcmVEYXRhOiBpbnN0YW5jZS5yZWFkT2Zmc2V0IDwgaGVhZGVyLnBvaW50c0NvdW50CiAgICAgICAgfTsKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBEZWxldGVzIHRoZSBpbnN0YW5jZQogICAgICogQHJldHVybnMgYm9vbGVhbgogICAgICovCiAgICBjbG9zZSgpIHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAhPT0gbnVsbCkgewogICAgICAgICAgTW9kdWxlLl9mcmVlKHRoaXMuaW5zdGFuY2UuYnVmKTsKICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVsZXRlKCk7CiAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2xvc2UgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApOwogICAgICB9CiAgICB9CiAgfTsKICB2YXIgTEFTRGVjb2RlciA9IGNsYXNzIHsKICAgIGFycmF5YjsKICAgIGRlY29kZXI7CiAgICBwb2ludHNDb3VudDsKICAgIHBvaW50U2l6ZTsKICAgIHNjYWxlOwogICAgb2Zmc2V0OwogICAgbWluczsKICAgIG1heHM7CiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGxlbiwgaGVhZGVyKSB7CiAgICAgIHRoaXMuYXJyYXliID0gYnVmZmVyOwogICAgICB0aGlzLmRlY29kZXIgPSBQT0lOVF9GT1JNQVRfUkVBREVSU1toZWFkZXIucG9pbnRzRm9ybWF0SWRdOwogICAgICB0aGlzLnBvaW50c0NvdW50ID0gbGVuOwogICAgICB0aGlzLnBvaW50U2l6ZSA9IGhlYWRlci5wb2ludHNTdHJ1Y3RTaXplOwogICAgICB0aGlzLnNjYWxlID0gaGVhZGVyLnNjYWxlOwogICAgICB0aGlzLm9mZnNldCA9IGhlYWRlci5vZmZzZXQ7CiAgICAgIHRoaXMubWlucyA9IGhlYWRlci5taW5zOwogICAgICB0aGlzLm1heHMgPSBoZWFkZXIubWF4czsKICAgIH0KICAgIC8qKgogICAgICogRGVjb2RlcyBkYXRhIGRlcGVuZHMgb24gdGhpcyBwb2ludCBzaXplCiAgICAgKiBAcGFyYW0gaW5kZXgKICAgICAqIEByZXR1cm5zIE5ldyBvYmplY3QKICAgICAqLwogICAgZ2V0UG9pbnQoaW5kZXgpIHsKICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnBvaW50c0NvdW50KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJQb2ludCBpbmRleCBvdXQgb2YgcmFuZ2UiKTsKICAgICAgfQogICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyh0aGlzLmFycmF5YiwgaW5kZXggKiB0aGlzLnBvaW50U2l6ZSwgdGhpcy5wb2ludFNpemUpOwogICAgICByZXR1cm4gdGhpcy5kZWNvZGVyKGR2KTsKICAgIH0KICB9OwogIHZhciBMQVNGaWxlID0gY2xhc3MgewogICAgYXJyYXlidWZmZXI7CiAgICBmb3JtYXRJZCA9IDA7CiAgICBsb2FkZXI7CiAgICBpc0NvbXByZXNzZWQgPSB0cnVlOwogICAgaXNPcGVuID0gZmFsc2U7CiAgICB2ZXJzaW9uID0gMDsKICAgIHZlcnNpb25Bc1N0cmluZyA9ICIiOwogICAgY29uc3RydWN0b3IoYXJyYXlidWZmZXIpIHsKICAgICAgdGhpcy5hcnJheWJ1ZmZlciA9IGFycmF5YnVmZmVyOwogICAgICBpZiAodGhpcy5kZXRlcm1pbmVWZXJzaW9uKCkgPiAxMykgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiT25seSBmaWxlIHZlcnNpb25zIDw9IDEuMyBhcmUgc3VwcG9ydGVkIGF0IHRoaXMgdGltZSIpOwogICAgICB9CiAgICAgIHRoaXMuZGV0ZXJtaW5lRm9ybWF0KCk7CiAgICAgIGlmIChQT0lOVF9GT1JNQVRfUkVBREVSU1t0aGlzLmZvcm1hdElkXSA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJUaGUgcG9pbnQgZm9ybWF0IElEIGlzIG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgICB0aGlzLmxvYWRlciA9IHRoaXMuaXNDb21wcmVzc2VkID8gbmV3IExBWkxvYWRlcih0aGlzLmFycmF5YnVmZmVyKSA6IG5ldyBMQVNMb2FkZXIyKHRoaXMuYXJyYXlidWZmZXIpOwogICAgfQogICAgLyoqCiAgICAgKiBEZXRlcm1pbmVzIGZvcm1hdCBpbiBwYXJhbWV0ZXJzIG9mIExBU0hlYWVyCiAgICAgKi8KICAgIGRldGVybWluZUZvcm1hdCgpIHsKICAgICAgY29uc3QgZm9ybWF0SWQgPSByZWFkQXModGhpcy5hcnJheWJ1ZmZlciwgVWludDhBcnJheSwgMzIgKiAzICsgOCk7CiAgICAgIGNvbnN0IGJpdDcgPSAoZm9ybWF0SWQgJiAxMjgpID4+IDc7CiAgICAgIGNvbnN0IGJpdDYgPSAoZm9ybWF0SWQgJiA2NCkgPj4gNjsKICAgICAgaWYgKGJpdDcgPT09IDEgJiYgYml0NiA9PT0gMSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiT2xkIHN0eWxlIGNvbXByZXNzaW9uIG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgICB0aGlzLmZvcm1hdElkID0gZm9ybWF0SWQgJiA2MzsKICAgICAgdGhpcy5pc0NvbXByZXNzZWQgPSBiaXQ3ID09PSAxIHx8IGJpdDYgPT09IDE7CiAgICB9CiAgICAvKioKICAgICAqIERldGVybWluZXMgdmVyc2lvbgogICAgICogQHJldHVybnMgdmVyc2lvbgogICAgICovCiAgICBkZXRlcm1pbmVWZXJzaW9uKCkgewogICAgICBjb25zdCB2ZXIgPSBuZXcgSW50OEFycmF5KHRoaXMuYXJyYXlidWZmZXIsIDI0LCAyKTsKICAgICAgdGhpcy52ZXJzaW9uID0gdmVyWzBdICogMTAgKyB2ZXJbMV07CiAgICAgIHRoaXMudmVyc2lvbkFzU3RyaW5nID0gYCR7dmVyWzBdfS4ke3ZlclsxXX1gOwogICAgICByZXR1cm4gdGhpcy52ZXJzaW9uOwogICAgfQogICAgLyoqCiAgICAgKiBSZWFkcyBpZiB0aGUgZmlsZSBpcyBvcGVuCiAgICAgKiBAcmV0dXJucyBib29sZWFuCiAgICAgKi8KICAgIG9wZW4oKSB7CiAgICAgIGlmICh0aGlzLmxvYWRlci5vcGVuKCkpIHsKICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgaGVhZGVyCiAgICAgKiBAcmV0dXJucyBIZWFkZXIKICAgICAqLwogICAgZ2V0SGVhZGVyKCkgewogICAgICByZXR1cm4gdGhpcy5sb2FkZXIuZ2V0SGVhZGVyKCk7CiAgICB9CiAgICAvKioKICAgICAqIEBwYXJhbSBjb3VudAogICAgICogQHBhcmFtIHN0YXJ0CiAgICAgKiBAcGFyYW0gc2tpcAogICAgICogQHJldHVybnMgRGF0YQogICAgICovCiAgICByZWFkRGF0YShjb3VudCwgc3RhcnQsIHNraXApIHsKICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnJlYWREYXRhKGNvdW50LCBzdGFydCwgc2tpcCk7CiAgICB9CiAgICAvKioKICAgICAqIENsb3NlcyB0aGUgZmlsZQogICAgICovCiAgICBjbG9zZSgpIHsKICAgICAgaWYgKHRoaXMubG9hZGVyLmNsb3NlKCkpIHsKICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqLwogICAgZ2V0VW5wYWNrZXIoKSB7CiAgICAgIHJldHVybiBMQVNEZWNvZGVyOwogICAgfQogIH07CgogIC8vIHNyYy9saWIvZ2V0LWxhcy1zY2hlbWEudHMKICBmdW5jdGlvbiBnZXRMQVNTY2hlbWEobGFzSGVhZGVyLCBhdHRyaWJ1dGVzKSB7CiAgICBjb25zdCBtZXRhZGF0YU1hcCA9IG1ha2VNZXRhZGF0YUZyb21MYXNIZWFkZXIobGFzSGVhZGVyKTsKICAgIGNvbnN0IHNjaGVtYSA9IGRlZHVjZU1lc2hTY2hlbWEoYXR0cmlidXRlcywgbWV0YWRhdGFNYXApOwogICAgcmV0dXJuIHNjaGVtYTsKICB9CiAgZnVuY3Rpb24gbWFrZU1ldGFkYXRhRnJvbUxhc0hlYWRlcihsYXNIZWFkZXIpIHsKICAgIGNvbnN0IG1ldGFkYXRhID0ge307CiAgICBtZXRhZGF0YS5sYXNfcG9pbnRzT2Zmc2V0ID0gbGFzSGVhZGVyLnBvaW50c09mZnNldC50b1N0cmluZygxMCk7CiAgICBtZXRhZGF0YS5sYXNfcG9pbnRzRm9ybWF0SWQgPSBsYXNIZWFkZXIucG9pbnRzRm9ybWF0SWQudG9TdHJpbmcoMTApOwogICAgbWV0YWRhdGEubGFzX3BvaW50c1N0cnVjdFNpemUgPSBsYXNIZWFkZXIucG9pbnRzU3RydWN0U2l6ZS50b1N0cmluZygxMCk7CiAgICBtZXRhZGF0YS5sYXNfcG9pbnRzQ291bnQgPSBsYXNIZWFkZXIucG9pbnRzQ291bnQudG9TdHJpbmcoMTApOwogICAgbWV0YWRhdGEubGFzX3NjYWxlID0gSlNPTi5zdHJpbmdpZnkobGFzSGVhZGVyLnNjYWxlKTsKICAgIG1ldGFkYXRhLmxhc19vZmZzZXQgPSBKU09OLnN0cmluZ2lmeShsYXNIZWFkZXIub2Zmc2V0KTsKICAgIGlmIChsYXNIZWFkZXIubWF4cyAhPT0gdm9pZCAwKSB7CiAgICAgIG1ldGFkYXRhLmxhc19tYXhzID0gSlNPTi5zdHJpbmdpZnkobGFzSGVhZGVyLm1heHMpOwogICAgfQogICAgaWYgKGxhc0hlYWRlci5taW5zICE9PSB2b2lkIDApIHsKICAgICAgbWV0YWRhdGEubGFzX21pbnMgPSBKU09OLnN0cmluZ2lmeShsYXNIZWFkZXIubWlucyk7CiAgICB9CiAgICBtZXRhZGF0YS5sYXNfdG90YWxUb1JlYWQgPSBsYXNIZWFkZXIudG90YWxUb1JlYWQudG9TdHJpbmcoMTApOwogICAgbWV0YWRhdGEubGFzX3BvaW50c0ZvcnRvdGFsUmVhZG1hdElkID0gbGFzSGVhZGVyLnRvdGFsUmVhZC50b1N0cmluZygxMCk7CiAgICBpZiAobGFzSGVhZGVyLnZlcnNpb25Bc1N0cmluZyAhPT0gdm9pZCAwKSB7CiAgICAgIG1ldGFkYXRhLmxhc192ZXJzaW9uQXNTdHJpbmcgPSBsYXNIZWFkZXIudmVyc2lvbkFzU3RyaW5nOwogICAgfQogICAgaWYgKGxhc0hlYWRlci5pc0NvbXByZXNzZWQgIT09IHZvaWQgMCkgewogICAgICBtZXRhZGF0YS5sYXNfaXNDb21wcmVzc2VkID0gbGFzSGVhZGVyLmlzQ29tcHJlc3NlZC50b1N0cmluZygpOwogICAgfQogICAgcmV0dXJuIG1ldGFkYXRhOwogIH0KCiAgLy8gc3JjL2xpYi9wYXJzZS1sYXMudHMKICBmdW5jdGlvbiBwYXJzZUxBUyhhcnJheUJ1ZmZlciwgb3B0aW9ucykgewogICAgcmV0dXJuIHBhcnNlTEFTTWVzaChhcnJheUJ1ZmZlciwgb3B0aW9ucyk7CiAgfQogIGZ1bmN0aW9uIHBhcnNlTEFTTWVzaChhcnJheUJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7CiAgICBsZXQgcG9pbnRJbmRleCA9IDA7CiAgICBsZXQgcG9zaXRpb25zOwogICAgbGV0IGNvbG9yczsKICAgIGxldCBpbnRlbnNpdGllczsKICAgIGxldCBjbGFzc2lmaWNhdGlvbnM7CiAgICBsZXQgb3JpZ2luYWxIZWFkZXI7CiAgICBjb25zdCBsYXNNZXNoID0gewogICAgICBsb2FkZXI6ICJsYXMiLAogICAgICBsb2FkZXJEYXRhOiB7fSwKICAgICAgLy8gc2hhcGU6ICdtZXNoJywKICAgICAgc2NoZW1hOiB7IGZpZWxkczogW10sIG1ldGFkYXRhOiB7fSB9LAogICAgICBoZWFkZXI6IHsKICAgICAgICB2ZXJ0ZXhDb3VudDogMCwKICAgICAgICBib3VuZGluZ0JveDogWwogICAgICAgICAgWzAsIDAsIDBdLAogICAgICAgICAgWzAsIDAsIDBdCiAgICAgICAgXQogICAgICB9LAogICAgICBhdHRyaWJ1dGVzOiB7fSwKICAgICAgdG9wb2xvZ3k6ICJwb2ludC1saXN0IiwKICAgICAgbW9kZTogMAogICAgICAvLyBHTC5QT0lOVFMKICAgIH07CiAgICBwYXJzZUxBU0NodW5rZWQoYXJyYXlCdWZmZXIsIG9wdGlvbnMubGFzPy5za2lwLCAoZGVjb2RlciA9IHt9LCBsYXNIZWFkZXIpID0+IHsKICAgICAgaWYgKCFvcmlnaW5hbEhlYWRlcikgewogICAgICAgIG9yaWdpbmFsSGVhZGVyID0gbGFzSGVhZGVyOwogICAgICAgIGNvbnN0IHRvdGFsID0gbGFzSGVhZGVyLnRvdGFsVG9SZWFkOwogICAgICAgIGNvbnN0IFBvc2l0aW9uc1R5cGUgPSBvcHRpb25zLmxhcz8uZnA2NCA/IEZsb2F0NjRBcnJheSA6IEZsb2F0MzJBcnJheTsKICAgICAgICBwb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25zVHlwZSh0b3RhbCAqIDMpOwogICAgICAgIGNvbG9ycyA9IGxhc0hlYWRlci5wb2ludHNGb3JtYXRJZCA+PSAyID8gbmV3IFVpbnQ4QXJyYXkodG90YWwgKiA0KSA6IG51bGw7CiAgICAgICAgaW50ZW5zaXRpZXMgPSBuZXcgVWludDE2QXJyYXkodG90YWwpOwogICAgICAgIGNsYXNzaWZpY2F0aW9ucyA9IG5ldyBVaW50OEFycmF5KHRvdGFsKTsKICAgICAgICBsYXNNZXNoLmxvYWRlckRhdGEgPSBsYXNIZWFkZXI7CiAgICAgICAgbGFzTWVzaC5hdHRyaWJ1dGVzID0gewogICAgICAgICAgUE9TSVRJT046IHsgdmFsdWU6IHBvc2l0aW9ucywgc2l6ZTogMyB9LAogICAgICAgICAgLy8gbm9uLWdsdGYgYXR0cmlidXRlcywgdXNlIG5vbi1jYXBpdGFsaXplZCBuYW1lcyBmb3Igbm93CiAgICAgICAgICBpbnRlbnNpdHk6IHsgdmFsdWU6IGludGVuc2l0aWVzLCBzaXplOiAxIH0sCiAgICAgICAgICBjbGFzc2lmaWNhdGlvbjogeyB2YWx1ZTogY2xhc3NpZmljYXRpb25zLCBzaXplOiAxIH0KICAgICAgICB9OwogICAgICAgIGlmIChjb2xvcnMpIHsKICAgICAgICAgIGxhc01lc2guYXR0cmlidXRlcy5DT0xPUl8wID0geyB2YWx1ZTogY29sb3JzLCBzaXplOiA0IH07CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGRlY29kZXIucG9pbnRzQ291bnQ7CiAgICAgIGNvbnN0IHsKICAgICAgICBzY2FsZTogW3NjYWxlWCwgc2NhbGVZLCBzY2FsZVpdLAogICAgICAgIG9mZnNldDogW29mZnNldFgsIG9mZnNldFksIG9mZnNldFpdCiAgICAgIH0gPSBsYXNIZWFkZXI7CiAgICAgIGNvbnN0IHR3b0J5dGVDb2xvciA9IGRldGVjdFR3b0J5dGVDb2xvcnMoZGVjb2RlciwgYmF0Y2hTaXplLCBvcHRpb25zLmxhcz8uY29sb3JEZXB0aCk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hTaXplOyBpKyspIHsKICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBjb2xvciwgaW50ZW5zaXR5LCBjbGFzc2lmaWNhdGlvbiB9ID0gZGVjb2Rlci5nZXRQb2ludChpKTsKICAgICAgICBwb3NpdGlvbnNbcG9pbnRJbmRleCAqIDNdID0gcG9zaXRpb25bMF0gKiBzY2FsZVggKyBvZmZzZXRYOwogICAgICAgIHBvc2l0aW9uc1twb2ludEluZGV4ICogMyArIDFdID0gcG9zaXRpb25bMV0gKiBzY2FsZVkgKyBvZmZzZXRZOwogICAgICAgIHBvc2l0aW9uc1twb2ludEluZGV4ICogMyArIDJdID0gcG9zaXRpb25bMl0gKiBzY2FsZVogKyBvZmZzZXRaOwogICAgICAgIGlmIChjb2xvciAmJiBjb2xvcnMpIHsKICAgICAgICAgIGlmICh0d29CeXRlQ29sb3IpIHsKICAgICAgICAgICAgY29sb3JzW3BvaW50SW5kZXggKiA0XSA9IGNvbG9yWzBdIC8gMjU2OwogICAgICAgICAgICBjb2xvcnNbcG9pbnRJbmRleCAqIDQgKyAxXSA9IGNvbG9yWzFdIC8gMjU2OwogICAgICAgICAgICBjb2xvcnNbcG9pbnRJbmRleCAqIDQgKyAyXSA9IGNvbG9yWzJdIC8gMjU2OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29sb3JzW3BvaW50SW5kZXggKiA0XSA9IGNvbG9yWzBdOwogICAgICAgICAgICBjb2xvcnNbcG9pbnRJbmRleCAqIDQgKyAxXSA9IGNvbG9yWzFdOwogICAgICAgICAgICBjb2xvcnNbcG9pbnRJbmRleCAqIDQgKyAyXSA9IGNvbG9yWzJdOwogICAgICAgICAgfQogICAgICAgICAgY29sb3JzW3BvaW50SW5kZXggKiA0ICsgM10gPSAyNTU7CiAgICAgICAgfQogICAgICAgIGludGVuc2l0aWVzW3BvaW50SW5kZXhdID0gaW50ZW5zaXR5OwogICAgICAgIGNsYXNzaWZpY2F0aW9uc1twb2ludEluZGV4XSA9IGNsYXNzaWZpY2F0aW9uOwogICAgICAgIHBvaW50SW5kZXgrKzsKICAgICAgfQogICAgICBjb25zdCBtZXNoQmF0Y2ggPSB7CiAgICAgICAgLi4ubGFzTWVzaCwKICAgICAgICBoZWFkZXI6IHsKICAgICAgICAgIHZlcnRleENvdW50OiBsYXNIZWFkZXIudG90YWxSZWFkCiAgICAgICAgfSwKICAgICAgICBwcm9ncmVzczogbGFzSGVhZGVyLnRvdGFsUmVhZCAvIGxhc0hlYWRlci50b3RhbFRvUmVhZAogICAgICB9OwogICAgICBvcHRpb25zPy5vblByb2dyZXNzPy4obWVzaEJhdGNoKTsKICAgIH0pOwogICAgbGFzTWVzaC5oZWFkZXIgPSB7CiAgICAgIHZlcnRleENvdW50OiBvcmlnaW5hbEhlYWRlci50b3RhbFRvUmVhZCwKICAgICAgYm91bmRpbmdCb3g6IGdldE1lc2hCb3VuZGluZ0JveChsYXNNZXNoPy5hdHRyaWJ1dGVzIHx8IHt9KQogICAgfTsKICAgIGlmIChsYXNNZXNoKSB7CiAgICAgIGxhc01lc2guc2NoZW1hID0gZ2V0TEFTU2NoZW1hKGxhc01lc2gubG9hZGVyRGF0YSwgbGFzTWVzaC5hdHRyaWJ1dGVzKTsKICAgIH0KICAgIHJldHVybiBsYXNNZXNoOwogIH0KICBmdW5jdGlvbiBwYXJzZUxBU0NodW5rZWQocmF3RGF0YSwgc2tpcCwgb25QYXJzZURhdGEgPSB7fSkgewogICAgY29uc3QgZGF0YUhhbmRsZXIgPSBuZXcgTEFTRmlsZShyYXdEYXRhKTsKICAgIHRyeSB7CiAgICAgIGRhdGFIYW5kbGVyLm9wZW4oKTsKICAgICAgY29uc3QgaGVhZGVyID0gZGF0YUhhbmRsZXIuZ2V0SGVhZGVyKCk7CiAgICAgIGNvbnN0IFVucGFja2VyID0gZGF0YUhhbmRsZXIuZ2V0VW5wYWNrZXIoKTsKICAgICAgY29uc3QgdG90YWxUb1JlYWQgPSBNYXRoLmNlaWwoaGVhZGVyLnBvaW50c0NvdW50IC8gTWF0aC5tYXgoMSwgc2tpcCkpOwogICAgICBoZWFkZXIudG90YWxUb1JlYWQgPSB0b3RhbFRvUmVhZDsKICAgICAgbGV0IHRvdGFsUmVhZCA9IDA7CiAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgY29uc3QgY2h1bmsgPSBkYXRhSGFuZGxlci5yZWFkRGF0YSgxZTMgKiAxMDAsIDAsIHNraXApOwogICAgICAgIHRvdGFsUmVhZCArPSBjaHVuay5jb3VudDsKICAgICAgICBoZWFkZXIudG90YWxSZWFkID0gdG90YWxSZWFkOwogICAgICAgIGhlYWRlci52ZXJzaW9uQXNTdHJpbmcgPSBjaHVuay52ZXJzaW9uQXNTdHJpbmc7CiAgICAgICAgaGVhZGVyLmlzQ29tcHJlc3NlZCA9IGNodW5rLmlzQ29tcHJlc3NlZDsKICAgICAgICBjb25zdCB1bnBhY2tlciA9IG5ldyBVbnBhY2tlcihjaHVuay5idWZmZXIsIGNodW5rLmNvdW50LCBoZWFkZXIpOwogICAgICAgIG9uUGFyc2VEYXRhKHVucGFja2VyLCBoZWFkZXIpOwogICAgICAgIGlmICghY2h1bmsuaGFzTW9yZURhdGEgfHwgdG90YWxSZWFkID49IHRvdGFsVG9SZWFkKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgdGhyb3cgZTsKICAgIH0gZmluYWxseSB7CiAgICAgIGRhdGFIYW5kbGVyLmNsb3NlKCk7CiAgICB9CiAgfQogIGZ1bmN0aW9uIGRldGVjdFR3b0J5dGVDb2xvcnMoZGVjb2RlciA9IHt9LCBiYXRjaFNpemUsIGNvbG9yRGVwdGgpIHsKICAgIGxldCB0d29CeXRlQ29sb3IgPSBmYWxzZTsKICAgIHN3aXRjaCAoY29sb3JEZXB0aCkgewogICAgICBjYXNlIDg6CiAgICAgICAgdHdvQnl0ZUNvbG9yID0gZmFsc2U7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMTY6CiAgICAgICAgdHdvQnl0ZUNvbG9yID0gdHJ1ZTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiYXV0byI6CiAgICAgICAgaWYgKGRlY29kZXIuZ2V0UG9pbnQoMCkuY29sb3IpIHsKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hTaXplOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgeyBjb2xvciB9ID0gZGVjb2Rlci5nZXRQb2ludChpKTsKICAgICAgICAgICAgaWYgKGNvbG9yWzBdID4gMjU1IHx8IGNvbG9yWzFdID4gMjU1IHx8IGNvbG9yWzJdID4gMjU1KSB7CiAgICAgICAgICAgICAgdHdvQnl0ZUNvbG9yID0gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICBjb25zb2xlLndhcm4oImxhczogaWxsZWdhbCB2YWx1ZSBmb3Igb3B0aW9ucy5sYXMuY29sb3JEZXB0aCIpOwogICAgICAgIGJyZWFrOwogICAgfQogICAgcmV0dXJuIHR3b0J5dGVDb2xvcjsKICB9CgogIC8vIHNyYy9pbmRleC50cwogIHZhciBMQVNMb2FkZXIzID0gewogICAgLi4uTEFTTG9hZGVyLAogICAgcGFyc2U6IGFzeW5jIChhcnJheUJ1ZmZlciwgb3B0aW9ucykgPT4gcGFyc2VMQVMoYXJyYXlCdWZmZXIsIG9wdGlvbnMpLAogICAgcGFyc2VTeW5jOiAoYXJyYXlCdWZmZXIsIG9wdGlvbnMpID0+IHBhcnNlTEFTKGFycmF5QnVmZmVyLCBvcHRpb25zKQogIH07CgogIC8vIHNyYy93b3JrZXJzL2xhcy13b3JrZXIudHMKICBjcmVhdGVMb2FkZXJXb3JrZXIoTEFTTG9hZGVyMyk7Cn0pKCk7Cg==", U7 = ({
  showPointCloud: A,
  showScatterplot: g,
  loadedData: I,
  onDataLoad: C,
  filteredSectionPoints: t,
  NumericThreshold: s,
  numericField: r,
  pointOpacity: l,
  pointSize: d,
  layoutMode: h,
  FancyPositions: D,
  colorParams: w,
  lazUrl: p
}) => Z.useMemo(() => {
  if (!I && !p)
    return [];
  const b = I ?? p, S = typeof b == "string" && !!C, K = [];
  A && K.push(
    new FG({
      id: "laz-point-cloud-layer",
      data: b,
      onDataLoad: S ? C : null,
      visible: A,
      colorFormat: "RGBA",
      getNormal: [0, 1, 0],
      extensions: [new Op({ filterSize: 1 })],
      transitions: { getPosition: 800 },
      loaders: [wH],
      loadOptions: {
        las: {
          workerUrl: _7
        }
      },
      updateTriggers: {
        getColor: [
          r?.name,
          s,
          w.hiddenCategoryIds,
          w.customColors,
          w.coloringAnnotation,
          w.selectedCategories
        ],
        getPosition: [h, D]
      },
      getColor: (T, { index: E, data: H }) => {
        const R = H.extData;
        return z1(E, R, w);
      },
      getPosition: (T, { index: E, data: H }) => {
        const R = H.extData;
        if ((h === "2d-treemap" || h === "2d-histogram") && D)
          return [
            D[E * 3],
            D[E * 3 + 1],
            D[E * 3 + 2]
          ];
        {
          const x = R.POSITION.value;
          return [
            x[E * 3],
            x[E * 3 + 1],
            x[E * 3 + 2]
          ];
        }
      },
      opacity: l,
      pointSize: d,
      pickable: !0
    })
  );
  const Y = r !== null ? [r.ContinuousConfig.Min, r.ContinuousConfig.Max] : null;
  return g && !A && I && K.push(
    new i0({
      id: "scatter-plot-layer",
      data: t,
      extensions: [new Op({ filterSize: 1 })],
      getFilterValue: (T) => {
        const E = I.extData;
        return E?.logPs ? E.logPs[T] : s + 1;
      },
      filterRange: [s, Y?.[1] || 100],
      filterTransformColor: !0,
      filterTransformSize: !0,
      filterEnabled: !!r,
      visible: g,
      pickable: !0,
      opacity: l,
      stroked: !1,
      filled: !0,
      radiusScale: d * 0.1,
      // radiusMinPixels: 0,
      // radiusMaxPixels: 20,
      lineWidthMinPixels: 0,
      getPosition: (T) => {
        if (!I?.extData?.POSITION) return [0, 0, 0];
        const E = T * 3;
        return [
          I.extData.POSITION.value[E],
          I.extData.POSITION.value[E + 1],
          0
        ];
      },
      getFillColor: (T) => {
        if (!I?.extData) return [0, 0, 0, 0];
        const E = I.extData;
        return z1(T, E, w);
      },
      updateTriggers: {
        getFillColor: [
          r?.name,
          s,
          w.hiddenCategoryIds,
          w.customColors,
          w.coloringAnnotation,
          w.selectedCategories
        ]
      }
    })
  ), K;
}, [
  A,
  g,
  I,
  C,
  t,
  s,
  r,
  l,
  d,
  h,
  D,
  w,
  p
]), F7 = () => {
  const [A, g] = Z.useState(!1), [I, C] = Z.useState(hp), [t, s] = Z.useState(hp), [r, l] = Z.useState(
    V4
  ), [d, h] = Z.useState(null), [D, w] = Z.useState(!1), [p, b] = Z.useState("3d");
  Z.useEffect(() => {
    if (!A || !D)
      return;
    let K;
    const Y = () => {
      C((T) => ({
        ...T,
        rotationOrbit: (T.rotationOrbit || 0) + 0.2,
        transitionDuration: 0
      })), K = requestAnimationFrame(Y);
    };
    return Y(), () => {
      cancelAnimationFrame(K);
    };
  }, [A, D]);
  const S = Z.useCallback(() => {
    w((K) => !K);
  }, []);
  return {
    viewState: I,
    stviewState: r,
    initialCamera: t,
    activeZoom: d,
    autoRotate: D,
    layoutMode: p,
    updateViewState: C,
    updateStviewState: l,
    setInitialCamera: s,
    setActiveZoom: h,
    setAutoRotate: w,
    setLayoutMode: b,
    toggleAutoRotate: S,
    setIsLoaded: g
  };
}, X7 = (A, g) => {
  const [I, C] = Z.useState(
    "__UNINITIALIZED__"
  );
  Z.useEffect(() => {
    if (!g) return;
    const { DefaultAnnoType: S, AvailableAnnoTypes: K } = g;
    C(
      K.includes(S) ? S : K[0]
    );
  }, [g]);
  const [t, s] = Z.useState({});
  Z.useEffect(() => {
    if (!g) return;
    const S = {};
    g.AvailableAnnoTypes.forEach((K) => {
      S[K] = null;
    }), s(S);
  }, [g]);
  const [r, l] = Z.useState(
    {}
  );
  Z.useEffect(() => {
    if (!g) return;
    const S = {};
    g.AvailableAnnoTypes.forEach((K) => {
      S[K] = /* @__PURE__ */ new Set();
    }), l(S);
  }, [g]);
  const [d, h] = Z.useState({});
  Z.useEffect(() => {
    if (!g) return;
    const S = {};
    for (const K of g.AvailableAnnoTypes) {
      const Y = g.AnnoMaps[K]?.Items ?? [], T = {};
      for (const E of Y)
        E.Color && (T[E.Code] = E.Color);
      S[K] = T;
    }
    h(S);
  }, [g]), Z.useEffect(() => {
    if (!g || !A?.extData?.annotations) return;
    const S = A.extData, K = S.annotations, Y = {};
    for (const T of g.AvailableAnnoTypes) {
      const E = g.AnnoMaps?.[T]?.Items ?? [], H = {};
      if (E.some((x) => x.Color != null))
        for (const x of E)
          x.Color && (H[x.Code] = x.Color);
      else if (K[T] && S.originalColor) {
        const x = K[T], U = S.originalColor;
        for (let J = 0; J < x.length; J++) {
          const L = x[J];
          if (H[L]) continue;
          const eg = J * 4;
          if (H[L] = [U[eg], U[eg + 1], U[eg + 2]], Object.keys(H).length >= E.length) break;
        }
      }
      Y[T] = H;
    }
    h(Y);
  }, [g, A]);
  const [D, w] = Z.useState({});
  Z.useEffect(() => {
    if (!g) return;
    const S = {};
    g.AvailableAnnoTypes.forEach((K) => {
      S[K] = {};
    }), w(S);
  }, [g]);
  const p = Z.useCallback((S) => {
    C(S), s((K) => ({
      ...K,
      [S]: null
    }));
  }, []), b = Z.useMemo(
    () => ({
      selectedCategories: t,
      hiddenCategoryIds: r,
      coloringAnnotation: I,
      customColors: D,
      categoryColors: d
    }),
    [
      t,
      r,
      I,
      D,
      d
    ]
  );
  return {
    coloringAnnotation: I,
    selectedCategories: t,
    hiddenCategoryIds: r,
    categoryColors: d,
    customColors: D,
    setColoringAnnotation: C,
    setSelectedCategories: s,
    setHiddenCategoryIds: l,
    setCategoryColors: h,
    setCustomColors: w,
    setAnnotationForColoring: p,
    colorParams: b
  };
}, Q7 = () => {
  const [A, g] = Z.useState(!1), [I, C] = Z.useState(!1), [t, s] = Z.useState(!0), [r, l] = Z.useState(!1), [d, h] = Z.useState(1), [D, w] = Z.useState(1), [p, b] = Z.useState(0);
  return {
    continuousOpen: A,
    colorPickerOpen: I,
    showPointCloud: t,
    showScatterplot: r,
    pointSize: d,
    pointOpacity: D,
    numericThreshold: p,
    setContinuousOpen: g,
    setColorPickerOpen: C,
    setshowPointCloud: s,
    setShowScatterplot: l,
    setPointSize: h,
    setPointOpacity: w,
    setNumericThreshold: b
  };
}, z7 = (A, g, I, C, t) => {
  const [s, r] = Z.useState(
    []
  ), [l, d] = Z.useState(0), [h, D] = Z.useState([]), [w, p] = Z.useState({}), b = Z.useRef(/* @__PURE__ */ new Set()), S = Z.useRef(/* @__PURE__ */ new Set()), K = Z.useCallback(() => {
    if (!A?.extData?.annotations?.section || l === null)
      return;
    const H = A.extData.annotations.section;
    console.time(`Filter section ${l}`);
    const R = Array.from(
      { length: H.length },
      (x, U) => U
    ).filter((x) => H[x] === l);
    console.timeEnd(`Filter section ${l}`), r(R);
  }, [A, l]);
  Z.useEffect(() => {
    !g && I && K();
  }, [l, g, I, K]);
  const Y = Z.useCallback(
    (H) => {
      H !== l && d(H);
    },
    [l]
  ), T = async (H) => {
    if (!(b.current.has(H) || S.current.has(H))) {
      if (b.current.add(H), console.log(`Rendering preview for section ${H}...`), !A?.extData?.annotations?.section) {
        b.current.delete(H);
        return;
      }
      try {
        const R = A.extData.annotations.section, x = Array.from(
          { length: R.length },
          (Bg, Rg) => Rg
        ).filter((Bg) => R[Bg] === H);
        if (x.length === 0) {
          console.log(`No points found for section ${H}`), b.current.delete(H);
          return;
        }
        console.log(
          `Found ${x.length} points for section ${H}`
        );
        const U = A.extData.POSITION.value;
        let J = 1 / 0, L = -1 / 0, eg = 1 / 0, Mg = -1 / 0;
        for (const Bg of x) {
          const Rg = U[Bg * 3], N = U[Bg * 3 + 1];
          J = Math.min(J, Rg), L = Math.max(L, Rg), eg = Math.min(eg, N), Mg = Math.max(Mg, N);
        }
        console.log(
          `Section ${H} bounds: X[${J}, ${L}], Y[${eg}, ${Mg}]`
        );
        const ig = Math.max(L - J, Mg - eg) * 0.01;
        J -= ig, L += ig, eg -= ig, Mg += ig;
        const Zg = document.createElement("canvas");
        Zg.width = 150, Zg.height = 150, Zg.style.position = "absolute", Zg.style.left = "-9999px", Zg.style.top = "-9999px", document.body.appendChild(Zg);
        const Kg = (J + L) / 2, mg = (eg + Mg) / 2, Ng = Math.max(L - J, Mg - eg), cg = Math.log2(150 / Ng) - 0.5;
        console.log(
          `Section ${H} viewState: center=[${Kg}, ${mg}], zoom=${cg}`
        );
        const z = {
          target: [Kg, mg, 0],
          zoom: cg,
          minZoom: -10,
          maxZoom: 10
        }, Q = new _G({ id: "preview-view" });
        return new Promise((Bg, Rg) => {
          let N = null, F, rg = !1;
          const Cg = () => {
            if (N && clearTimeout(N), F)
              try {
                F.finalize();
              } catch (Yg) {
                console.error(
                  `Error finalizing deck for section ${H}:`,
                  Yg
                );
              }
            Zg.parentNode && Zg.parentNode.removeChild(Zg), b.current.delete(H);
          }, Sg = () => {
            rg || (rg = !0, S.current.add(H), Cg(), Bg());
          }, kg = (Yg) => {
            rg || (rg = !0, Cg(), Rg(Yg));
          };
          N = setTimeout(() => {
            console.error(`Timeout waiting for section ${H} render`), kg(new Error(`Timeout for section ${H}`));
          }, 2e3);
          try {
            F = new e0({
              canvas: Zg,
              width: 150,
              height: 150,
              viewState: {
                "preview-view": z
              },
              views: [Q],
              layers: [
                new i0({
                  id: `preview-scatter-${H}`,
                  data: x,
                  getPosition: (Yg) => {
                    const Wg = Yg * 3;
                    return [U[Wg], U[Wg + 1], 0];
                  },
                  getFillColor: (Yg) => {
                    if (!t)
                      return [180, 180, 180, 255];
                    const Wg = Yg, Xg = A.extData, nI = t?.DefaultAnnoType, sI = Xg.annotations[nI];
                    if (!sI) return [180, 180, 180, 255];
                    const Ug = sI[Wg], fI = Ug != null ? Number(Ug) : null;
                    if (fI !== null && C[nI]?.[fI]) {
                      const VI = C[nI][fI];
                      return [VI[0], VI[1], VI[2], 255];
                    }
                    return [180, 180, 180, 255];
                  },
                  radiusScale: 1,
                  radiusMinPixels: 2,
                  radiusMaxPixels: 4
                })
              ],
              onAfterRender: ({ gl: Yg }) => {
                if (!rg)
                  try {
                    console.log(`Section ${H} onAfterRender called`), setTimeout(() => {
                      try {
                        if (rg) return;
                        console.log(`Section ${H} attempting capture...`);
                        const Wg = Zg.toDataURL("image/png");
                        p((Xg) => ({
                          ...Xg,
                          [H]: Wg
                        })), console.log(
                          `Successfully captured preview for section ${H}`
                        ), Sg();
                      } catch (Wg) {
                        console.error(
                          `Error capturing section ${H}:`,
                          Wg
                        ), kg(
                          Wg instanceof Error ? Wg : new Error(`Capture error for section ${H}`)
                        );
                      }
                    }, 100);
                  } catch (Wg) {
                    console.error(
                      `Error in onAfterRender for section ${H}:`,
                      Wg
                    ), kg(
                      Wg instanceof Error ? Wg : new Error(`Render error for section ${H}`)
                    );
                  }
              },
              onError: (Yg) => {
                console.error(`Deck error for section ${H}:`, Yg), kg(
                  new Error(
                    `Deck error for section ${H}: ${Yg.message}`
                  )
                );
              }
            }), console.log(`Triggering initial render for section ${H}...`), F.redraw();
          } catch (Yg) {
            console.error(`Error creating Deck for section ${H}:`, Yg), kg(
              Yg instanceof Error ? Yg : new Error(`Create error for section ${H}`)
            );
          }
        });
      } catch (R) {
        throw b.current.delete(H), console.error(`Error rendering preview for section ${H}:`, R), R;
      }
    }
  }, E = async () => {
    if (!A?.extData?.annotations?.section || h.length === 0)
      return;
    console.log(
      `Starting to render ${h.length} section previews...`
    );
    const H = [];
    for (let R = 0; R < h.length; R += nP)
      H.push(h.slice(R, R + nP));
    for (let R = 0; R < H.length; R++) {
      const x = H[R];
      console.log(
        `Processing chunk ${R + 1}/${H.length} with sections: ${x.join(", ")}`
      );
      try {
        await Promise.allSettled(
          x.map(async (U) => {
            try {
              await T(U);
            } catch (J) {
              console.error(`Failed to render section ${U}:`, J);
            }
          })
        ), R < H.length - 1 && await new Promise((U) => setTimeout(U, 100));
      } catch (U) {
        console.error(`Error processing chunk ${R}:`, U);
      }
    }
    console.log("Finished rendering all section previews");
  };
  return Z.useEffect(() => {
    !g && I && h.length > 0 && Object.keys(w).length < h.length && (b.current.clear(), S.current.clear(), E());
  }, [g, I, h.length]), Z.useEffect(() => () => {
    b.current.clear(), S.current.clear();
  }, []), {
    filteredSectionPoints: s,
    currentSectionID: l,
    availableSectionIDs: h,
    sectionPreviews: w,
    setCurrentSectionID: d,
    setAvailableSectionIDs: D,
    handleSectionClick: Y,
    filterSectionPoints: K
  };
}, J7 = (A, g, I) => {
  const C = A.reduce((h, [D, w]) => h + w, 0), t = [];
  let s = 0, r = 0, l = g, d = I;
  return A.forEach(([h, D], w) => {
    const p = D / C;
    if (w === A.length - 1)
      t.push({
        category: h,
        x: s,
        y: r,
        width: l,
        height: d
      });
    else {
      const b = p * g * I;
      if (l > d) {
        const S = b / d;
        t.push({
          category: h,
          x: s,
          y: r,
          width: Math.min(S, l),
          height: d
        }), s += S, l -= S;
      } else {
        const S = b / l;
        t.push({
          category: h,
          x: s,
          y: r,
          width: l,
          height: Math.min(S, d)
        }), r += S, d -= S;
      }
    }
  }), t;
}, L7 = (A, g) => {
  if (!A?.extData?.POSITION) return null;
  const I = A.extData.POSITION.value, C = I.length / 3, t = new Float32Array(C * 3), r = A.extData?.annotations?.[g];
  if (!r) return null;
  const l = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
  for (let T = 0; T < C; T++) {
    const E = r[T];
    l.set(E, (l.get(E) || 0) + 1), d.has(E) || d.set(E, []), d.get(E).push(T);
  }
  const h = Array.from(l.entries()).sort(
    (T, E) => E[1] - T[1]
  );
  let D = 1 / 0, w = -1 / 0, p = 1 / 0, b = -1 / 0;
  for (let T = 0; T < C; T++) {
    const E = I[T * 3], H = I[T * 3 + 1];
    D = Math.min(D, E), w = Math.max(w, E), p = Math.min(p, H), b = Math.max(b, H);
  }
  const S = w - D, K = b - p;
  return J7(
    h,
    S,
    K
  ).forEach(({ category: T, x: E, y: H, width: R, height: x }) => {
    const U = d.get(T) || [], J = Math.sqrt(U.length);
    U.forEach((L, eg) => {
      const Mg = eg % J, ig = Math.floor(eg / J);
      t[L * 3] = D + E + Mg / J * R, t[L * 3 + 1] = p + H + ig / J * x, t[L * 3 + 2] = (Math.random() - 0.5) * 0.01;
    });
  }), t;
}, q7 = (A, g, I) => {
  if (!A?.extData?.POSITION || !g) return null;
  const C = A.extData.POSITION.value, t = C.length / 3, s = new Float32Array(t * 3), r = A.extData, l = r?.numeric?.values, d = r?.annotations?.[I];
  if (!l || !d) return null;
  const h = /* @__PURE__ */ new Map();
  for (let L = 0; L < t; L++) {
    const eg = d[L], Mg = l[L];
    h.has(eg) || h.set(eg, []), h.get(eg).push(Mg);
  }
  const D = r.numeric?.ContinuousConfig.Max ? r.numeric.ContinuousConfig.Min : 0, p = (r.numeric?.ContinuousConfig.Max ? r.numeric.ContinuousConfig.Max : 1) - D, b = 30, S = p / b;
  let K = 1 / 0, Y = -1 / 0, T = 1 / 0, E = -1 / 0;
  for (let L = 0; L < t; L++) {
    const eg = C[L * 3], Mg = C[L * 3 + 1];
    K = Math.min(K, eg), Y = Math.max(Y, eg), T = Math.min(T, Mg), E = Math.max(E, Mg);
  }
  const H = Y - K, R = E - T, x = H / b, U = Array.from(h.keys()), J = R / U.length;
  return U.forEach((L, eg) => {
    const Mg = Array.from({ length: b }, () => []), ig = [];
    for (let mg = 0; mg < t; mg++)
      d[mg] === L && ig.push(mg);
    ig.forEach((mg) => {
      const Ng = l[mg];
      if (Ng != null && !isNaN(Ng)) {
        const cg = Math.min(
          Math.max(0, Math.floor((Ng - D) / S)),
          b - 1
        );
        Mg[cg].push(mg);
      }
    });
    const Zg = Math.max(1, ...Mg.map((mg) => mg.length)), Kg = T + eg * J;
    Mg.forEach((mg, Ng) => {
      if (!mg || mg.length === 0) return;
      const cg = mg.length / Zg * J * 0.8, z = K + Ng * x;
      mg.forEach((Q, Bg) => {
        if (Q >= 0 && Q < t) {
          const Rg = Math.ceil(Math.sqrt(mg.length)), N = Math.floor(Bg / Rg), F = Bg % Rg;
          s[Q * 3] = z + F / Rg * x, s[Q * 3 + 1] = Kg + N / Rg * cg, s[Q * 3 + 2] = (Math.random() - 0.5) * 0.01;
        }
      });
    });
  }), s;
}, $7 = (A, g, I, C, t, s, r, l) => {
  const [d, h] = Z.useState(
    null
  ), D = Z.useCallback(() => {
    if (A === "3d" && C)
      if (I) {
        const w = q7(
          t,
          I,
          C
        );
        w && (console.log("Generated histogram positions for trait analysis"), h(w), g("2d-histogram"), l(3), r({
          ...s,
          rotationX: 0,
          zoom: s.zoom + 1,
          transitionDuration: 0
        }));
      } else {
        const w = L7(
          t,
          C
        );
        w && (console.log("Generated treemap positions for annotation analysis"), h(w), g("2d-treemap"), l(2), r({
          ...s,
          rotationX: 0,
          zoom: s.zoom + 1,
          transitionDuration: 0
        }));
      }
    else
      g("3d"), r({
        ...s,
        transitionDuration: 0
      }), l(1), h(null);
  }, [
    A,
    I,
    C,
    t,
    s,
    r,
    g,
    l
  ]);
  return {
    FancyPositions: d,
    setFancyPositions: h,
    toggleLayoutMode: D
  };
};
function J1(A, g) {
  if (typeof A == "function")
    return A(g);
  A != null && (A.current = g);
}
function mc(...A) {
  return (g) => {
    let I = !1;
    const C = A.map((t) => {
      const s = J1(t, g);
      return !I && typeof s == "function" && (I = !0), s;
    });
    if (I)
      return () => {
        for (let t = 0; t < C.length; t++) {
          const s = C[t];
          typeof s == "function" ? s() : J1(A[t], null);
        }
      };
  };
}
function BA(...A) {
  return Z.useCallback(mc(...A), A);
}
// @__NO_SIDE_EFFECTS__
function jf(A) {
  const g = /* @__PURE__ */ IQ(A), I = Z.forwardRef((C, t) => {
    const { children: s, ...r } = C, l = Z.Children.toArray(s), d = l.find(CQ);
    if (d) {
      const h = d.props.children, D = l.map((w) => w === d ? Z.Children.count(h) > 1 ? Z.Children.only(null) : Z.isValidElement(h) ? h.props.children : null : w);
      return /* @__PURE__ */ v.jsx(g, { ...r, ref: t, children: Z.isValidElement(h) ? Z.cloneElement(h, void 0, D) : null });
    }
    return /* @__PURE__ */ v.jsx(g, { ...r, ref: t, children: s });
  });
  return I.displayName = `${A}.Slot`, I;
}
var gQ = /* @__PURE__ */ jf("Slot");
// @__NO_SIDE_EFFECTS__
function IQ(A) {
  const g = Z.forwardRef((I, C) => {
    const { children: t, ...s } = I;
    if (Z.isValidElement(t)) {
      const r = tQ(t), l = eQ(s, t.props);
      return t.type !== Z.Fragment && (l.ref = C ? mc(C, r) : r), Z.cloneElement(t, l);
    }
    return Z.Children.count(t) > 1 ? Z.Children.only(null) : null;
  });
  return g.displayName = `${A}.SlotClone`, g;
}
var AQ = Symbol("radix.slottable");
function CQ(A) {
  return Z.isValidElement(A) && typeof A.type == "function" && "__radixId" in A.type && A.type.__radixId === AQ;
}
function eQ(A, g) {
  const I = { ...g };
  for (const C in g) {
    const t = A[C], s = g[C];
    /^on[A-Z]/.test(C) ? t && s ? I[C] = (...l) => {
      const d = s(...l);
      return t(...l), d;
    } : t && (I[C] = t) : C === "style" ? I[C] = { ...t, ...s } : C === "className" && (I[C] = [t, s].filter(Boolean).join(" "));
  }
  return { ...A, ...I };
}
function tQ(A) {
  let g = Object.getOwnPropertyDescriptor(A.props, "ref")?.get, I = g && "isReactWarning" in g && g.isReactWarning;
  return I ? A.ref : (g = Object.getOwnPropertyDescriptor(A, "ref")?.get, I = g && "isReactWarning" in g && g.isReactWarning, I ? A.props.ref : A.props.ref || A.ref);
}
function BH(A) {
  var g, I, C = "";
  if (typeof A == "string" || typeof A == "number") C += A;
  else if (typeof A == "object") if (Array.isArray(A)) {
    var t = A.length;
    for (g = 0; g < t; g++) A[g] && (I = BH(A[g])) && (C && (C += " "), C += I);
  } else for (I in A) A[I] && (C && (C += " "), C += I);
  return C;
}
function pH() {
  for (var A, g, I = 0, C = "", t = arguments.length; I < t; I++) (A = arguments[I]) && (g = BH(A)) && (C && (C += " "), C += g);
  return C;
}
const L1 = (A) => typeof A == "boolean" ? `${A}` : A === 0 ? "0" : A, q1 = pH, iQ = (A, g) => (I) => {
  var C;
  if (g?.variants == null) return q1(A, I?.class, I?.className);
  const { variants: t, defaultVariants: s } = g, r = Object.keys(t).map((h) => {
    const D = I?.[h], w = s?.[h];
    if (D === null) return null;
    const p = L1(D) || L1(w);
    return t[h][p];
  }), l = I && Object.entries(I).reduce((h, D) => {
    let [w, p] = D;
    return p === void 0 || (h[w] = p), h;
  }, {}), d = g == null || (C = g.compoundVariants) === null || C === void 0 ? void 0 : C.reduce((h, D) => {
    let { class: w, className: p, ...b } = D;
    return Object.entries(b).every((S) => {
      let [K, Y] = S;
      return Array.isArray(Y) ? Y.includes({
        ...s,
        ...l
      }[K]) : {
        ...s,
        ...l
      }[K] === Y;
    }) ? [
      ...h,
      w,
      p
    ] : h;
  }, []);
  return q1(A, r, d, I?.class, I?.className);
}, XG = "-", nQ = (A) => {
  const g = oQ(A), {
    conflictingClassGroups: I,
    conflictingClassGroupModifiers: C
  } = A;
  return {
    getClassGroupId: (r) => {
      const l = r.split(XG);
      return l[0] === "" && l.length !== 1 && l.shift(), mH(l, g) || sQ(r);
    },
    getConflictingClassGroupIds: (r, l) => {
      const d = I[r] || [];
      return l && C[r] ? [...d, ...C[r]] : d;
    }
  };
}, mH = (A, g) => {
  if (A.length === 0)
    return g.classGroupId;
  const I = A[0], C = g.nextPart.get(I), t = C ? mH(A.slice(1), C) : void 0;
  if (t)
    return t;
  if (g.validators.length === 0)
    return;
  const s = A.join(XG);
  return g.validators.find(({
    validator: r
  }) => r(s))?.classGroupId;
}, $1 = /^\[(.+)\]$/, sQ = (A) => {
  if ($1.test(A)) {
    const g = $1.exec(A)[1], I = g?.substring(0, g.indexOf(":"));
    if (I)
      return "arbitrary.." + I;
  }
}, oQ = (A) => {
  const {
    theme: g,
    classGroups: I
  } = A, C = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const t in I)
    HS(I[t], C, t, g);
  return C;
}, HS = (A, g, I, C) => {
  A.forEach((t) => {
    if (typeof t == "string") {
      const s = t === "" ? g : gZ(g, t);
      s.classGroupId = I;
      return;
    }
    if (typeof t == "function") {
      if (aQ(t)) {
        HS(t(C), g, I, C);
        return;
      }
      g.validators.push({
        validator: t,
        classGroupId: I
      });
      return;
    }
    Object.entries(t).forEach(([s, r]) => {
      HS(r, gZ(g, s), I, C);
    });
  });
}, gZ = (A, g) => {
  let I = A;
  return g.split(XG).forEach((C) => {
    I.nextPart.has(C) || I.nextPart.set(C, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), I = I.nextPart.get(C);
  }), I;
}, aQ = (A) => A.isThemeGetter, rQ = (A) => {
  if (A < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let g = 0, I = /* @__PURE__ */ new Map(), C = /* @__PURE__ */ new Map();
  const t = (s, r) => {
    I.set(s, r), g++, g > A && (g = 0, C = I, I = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let r = I.get(s);
      if (r !== void 0)
        return r;
      if ((r = C.get(s)) !== void 0)
        return t(s, r), r;
    },
    set(s, r) {
      I.has(s) ? I.set(s, r) : t(s, r);
    }
  };
}, ES = "!", RS = ":", lQ = RS.length, cQ = (A) => {
  const {
    prefix: g,
    experimentalParseClassName: I
  } = A;
  let C = (t) => {
    const s = [];
    let r = 0, l = 0, d = 0, h;
    for (let S = 0; S < t.length; S++) {
      let K = t[S];
      if (r === 0 && l === 0) {
        if (K === RS) {
          s.push(t.slice(d, S)), d = S + lQ;
          continue;
        }
        if (K === "/") {
          h = S;
          continue;
        }
      }
      K === "[" ? r++ : K === "]" ? r-- : K === "(" ? l++ : K === ")" && l--;
    }
    const D = s.length === 0 ? t : t.substring(d), w = uQ(D), p = w !== D, b = h && h > d ? h - d : void 0;
    return {
      modifiers: s,
      hasImportantModifier: p,
      baseClassName: w,
      maybePostfixModifierPosition: b
    };
  };
  if (g) {
    const t = g + RS, s = C;
    C = (r) => r.startsWith(t) ? s(r.substring(t.length)) : {
      isExternal: !0,
      modifiers: [],
      hasImportantModifier: !1,
      baseClassName: r,
      maybePostfixModifierPosition: void 0
    };
  }
  if (I) {
    const t = C;
    C = (s) => I({
      className: s,
      parseClassName: t
    });
  }
  return C;
}, uQ = (A) => A.endsWith(ES) ? A.substring(0, A.length - 1) : A.startsWith(ES) ? A.substring(1) : A, dQ = (A) => {
  const g = Object.fromEntries(A.orderSensitiveModifiers.map((C) => [C, !0]));
  return (C) => {
    if (C.length <= 1)
      return C;
    const t = [];
    let s = [];
    return C.forEach((r) => {
      r[0] === "[" || g[r] ? (t.push(...s.sort(), r), s = []) : s.push(r);
    }), t.push(...s.sort()), t;
  };
}, fQ = (A) => ({
  cache: rQ(A.cacheSize),
  parseClassName: cQ(A),
  sortModifiers: dQ(A),
  ...nQ(A)
}), hQ = /\s+/, yQ = (A, g) => {
  const {
    parseClassName: I,
    getClassGroupId: C,
    getConflictingClassGroupIds: t,
    sortModifiers: s
  } = g, r = [], l = A.trim().split(hQ);
  let d = "";
  for (let h = l.length - 1; h >= 0; h -= 1) {
    const D = l[h], {
      isExternal: w,
      modifiers: p,
      hasImportantModifier: b,
      baseClassName: S,
      maybePostfixModifierPosition: K
    } = I(D);
    if (w) {
      d = D + (d.length > 0 ? " " + d : d);
      continue;
    }
    let Y = !!K, T = C(Y ? S.substring(0, K) : S);
    if (!T) {
      if (!Y) {
        d = D + (d.length > 0 ? " " + d : d);
        continue;
      }
      if (T = C(S), !T) {
        d = D + (d.length > 0 ? " " + d : d);
        continue;
      }
      Y = !1;
    }
    const E = s(p).join(":"), H = b ? E + ES : E, R = H + T;
    if (r.includes(R))
      continue;
    r.push(R);
    const x = t(T, Y);
    for (let U = 0; U < x.length; ++U) {
      const J = x[U];
      r.push(H + J);
    }
    d = D + (d.length > 0 ? " " + d : d);
  }
  return d;
};
function DQ() {
  let A = 0, g, I, C = "";
  for (; A < arguments.length; )
    (g = arguments[A++]) && (I = bH(g)) && (C && (C += " "), C += I);
  return C;
}
const bH = (A) => {
  if (typeof A == "string")
    return A;
  let g, I = "";
  for (let C = 0; C < A.length; C++)
    A[C] && (g = bH(A[C])) && (I && (I += " "), I += g);
  return I;
};
function MQ(A, ...g) {
  let I, C, t, s = r;
  function r(d) {
    const h = g.reduce((D, w) => w(D), A());
    return I = fQ(h), C = I.cache.get, t = I.cache.set, s = l, l(d);
  }
  function l(d) {
    const h = C(d);
    if (h)
      return h;
    const D = yQ(d, I);
    return t(d, D), D;
  }
  return function() {
    return s(DQ.apply(null, arguments));
  };
}
const KC = (A) => {
  const g = (I) => I[A] || [];
  return g.isThemeGetter = !0, g;
}, SH = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, GH = /^\((?:(\w[\w-]*):)?(.+)\)$/i, wQ = /^\d+\/\d+$/, BQ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, pQ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, mQ = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, bQ = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, SQ = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Cf = (A) => wQ.test(A), EI = (A) => !!A && !Number.isNaN(Number(A)), rr = (A) => !!A && Number.isInteger(Number(A)), Ob = (A) => A.endsWith("%") && EI(A.slice(0, -1)), Ko = (A) => BQ.test(A), GQ = () => !0, KQ = (A) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  pQ.test(A) && !mQ.test(A)
), KH = () => !1, TQ = (A) => bQ.test(A), YQ = (A) => SQ.test(A), PQ = (A) => !II(A) && !AI(A), ZQ = (A) => Rf(A, PH, KH), II = (A) => SH.test(A), ac = (A) => Rf(A, ZH, KQ), Nb = (A) => Rf(A, RQ, EI), IZ = (A) => Rf(A, TH, KH), jQ = (A) => Rf(A, YH, YQ), _B = (A) => Rf(A, jH, TQ), AI = (A) => GH.test(A), _D = (A) => Of(A, ZH), vQ = (A) => Of(A, OQ), AZ = (A) => Of(A, TH), HQ = (A) => Of(A, PH), EQ = (A) => Of(A, YH), UB = (A) => Of(A, jH, !0), Rf = (A, g, I) => {
  const C = SH.exec(A);
  return C ? C[1] ? g(C[1]) : I(C[2]) : !1;
}, Of = (A, g, I = !1) => {
  const C = GH.exec(A);
  return C ? C[1] ? g(C[1]) : I : !1;
}, TH = (A) => A === "position" || A === "percentage", YH = (A) => A === "image" || A === "url", PH = (A) => A === "length" || A === "size" || A === "bg-size", ZH = (A) => A === "length", RQ = (A) => A === "number", OQ = (A) => A === "family-name", jH = (A) => A === "shadow", NQ = () => {
  const A = KC("color"), g = KC("font"), I = KC("text"), C = KC("font-weight"), t = KC("tracking"), s = KC("leading"), r = KC("breakpoint"), l = KC("container"), d = KC("spacing"), h = KC("radius"), D = KC("shadow"), w = KC("inset-shadow"), p = KC("text-shadow"), b = KC("drop-shadow"), S = KC("blur"), K = KC("perspective"), Y = KC("aspect"), T = KC("ease"), E = KC("animate"), H = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], R = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], x = () => [...R(), AI, II], U = () => ["auto", "hidden", "clip", "visible", "scroll"], J = () => ["auto", "contain", "none"], L = () => [AI, II, d], eg = () => [Cf, "full", "auto", ...L()], Mg = () => [rr, "none", "subgrid", AI, II], ig = () => ["auto", {
    span: ["full", rr, AI, II]
  }, rr, AI, II], Zg = () => [rr, "auto", AI, II], Kg = () => ["auto", "min", "max", "fr", AI, II], mg = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Ng = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], cg = () => ["auto", ...L()], z = () => [Cf, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...L()], Q = () => [A, AI, II], Bg = () => [...R(), AZ, IZ, {
    position: [AI, II]
  }], Rg = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], N = () => ["auto", "cover", "contain", HQ, ZQ, {
    size: [AI, II]
  }], F = () => [Ob, _D, ac], rg = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    h,
    AI,
    II
  ], Cg = () => ["", EI, _D, ac], Sg = () => ["solid", "dashed", "dotted", "double"], kg = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], Yg = () => [EI, Ob, AZ, IZ], Wg = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    S,
    AI,
    II
  ], Xg = () => ["none", EI, AI, II], nI = () => ["none", EI, AI, II], sI = () => [EI, AI, II], Ug = () => [Cf, "full", ...L()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Ko],
      breakpoint: [Ko],
      color: [GQ],
      container: [Ko],
      "drop-shadow": [Ko],
      ease: ["in", "out", "in-out"],
      font: [PQ],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Ko],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Ko],
      shadow: [Ko],
      spacing: ["px", EI],
      text: [Ko],
      "text-shadow": [Ko],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", Cf, II, AI, Y]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [EI, II, AI, l]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": H()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": H()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: x()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: U()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": U()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": U()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: J()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": J()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": J()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: eg()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": eg()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": eg()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: eg()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: eg()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: eg()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: eg()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: eg()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: eg()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [rr, "auto", AI, II]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [Cf, "full", "auto", l, ...L()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [EI, Cf, "auto", "initial", "none", II]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", EI, AI, II]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", EI, AI, II]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [rr, "first", "last", "none", AI, II]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": Mg()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ig()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Zg()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Zg()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": Mg()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ig()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Zg()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Zg()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": Kg()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": Kg()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: L()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": L()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": L()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...mg(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...Ng(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...Ng()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...mg()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...Ng(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...Ng(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": mg()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...Ng(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...Ng()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: L()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: L()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: L()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: L()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: L()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: L()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: L()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: L()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: L()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: cg()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: cg()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: cg()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: cg()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: cg()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: cg()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: cg()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: cg()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: cg()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": L()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": L()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: z()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [l, "screen", ...z()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          l,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...z()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          l,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [r]
          },
          ...z()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...z()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...z()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...z()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", I, _D, ac]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [C, AI, Nb]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Ob, II]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [vQ, II, g]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [t, AI, II]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [EI, "none", AI, Nb]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          s,
          ...L()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", AI, II]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", AI, II]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: Q()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: Q()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Sg(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [EI, "from-font", "auto", AI, ac]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: Q()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [EI, "auto", AI, II]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: L()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", AI, II]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", AI, II]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: Bg()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: Rg()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: N()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, rr, AI, II],
          radial: ["", AI, II],
          conic: [rr, AI, II]
        }, EQ, jQ]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: Q()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: F()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: F()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: F()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: Q()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: Q()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: Q()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: rg()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": rg()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": rg()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": rg()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": rg()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": rg()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": rg()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": rg()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": rg()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": rg()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": rg()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": rg()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": rg()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": rg()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": rg()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: Cg()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": Cg()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": Cg()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": Cg()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": Cg()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": Cg()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": Cg()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": Cg()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": Cg()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": Cg()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": Cg()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Sg(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Sg(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: Q()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": Q()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": Q()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": Q()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": Q()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": Q()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": Q()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": Q()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": Q()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: Q()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Sg(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [EI, AI, II]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", EI, _D, ac]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: Q()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          D,
          UB,
          _B
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: Q()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", w, UB, _B]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": Q()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: Cg()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: Q()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [EI, ac]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": Q()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": Cg()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": Q()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", p, UB, _B]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": Q()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [EI, AI, II]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...kg(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": kg()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [EI]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": Yg()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": Yg()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": Q()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": Q()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": Yg()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": Yg()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": Q()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": Q()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": Yg()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": Yg()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": Q()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": Q()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": Yg()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": Yg()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": Q()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": Q()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": Yg()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": Yg()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": Q()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": Q()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": Yg()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": Yg()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": Q()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": Q()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": Yg()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": Yg()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": Q()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": Q()
      }],
      "mask-image-radial": [{
        "mask-radial": [AI, II]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": Yg()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": Yg()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": Q()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": Q()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": R()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [EI]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": Yg()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": Yg()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": Q()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": Q()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: Bg()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: Rg()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: N()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", AI, II]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          AI,
          II
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: Wg()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [EI, AI, II]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [EI, AI, II]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          b,
          UB,
          _B
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": Q()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", EI, AI, II]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [EI, AI, II]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", EI, AI, II]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [EI, AI, II]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", EI, AI, II]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          AI,
          II
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": Wg()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [EI, AI, II]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [EI, AI, II]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", EI, AI, II]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [EI, AI, II]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", EI, AI, II]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [EI, AI, II]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [EI, AI, II]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", EI, AI, II]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": L()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": L()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": L()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", AI, II]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [EI, "initial", AI, II]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", T, AI, II]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [EI, AI, II]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", E, AI, II]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [K, AI, II]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": x()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: Xg()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": Xg()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": Xg()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": Xg()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: nI()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": nI()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": nI()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": nI()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: sI()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": sI()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": sI()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [AI, II, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: x()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Ug()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Ug()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Ug()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Ug()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: Q()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: Q()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", AI, II]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": L()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": L()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": L()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": L()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": L()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": L()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": L()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": L()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": L()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": L()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": L()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": L()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": L()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": L()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": L()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": L()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": L()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": L()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", AI, II]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...Q()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [EI, _D, ac, Nb]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...Q()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, kQ = /* @__PURE__ */ MQ(NQ);
function kI(...A) {
  return kQ(pH(A));
}
const WQ = iQ(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Ke({
  className: A,
  variant: g,
  size: I,
  asChild: C = !1,
  ...t
}) {
  const s = C ? gQ : "button";
  return /* @__PURE__ */ v.jsx(
    s,
    {
      "data-slot": "button",
      className: kI(WQ({ variant: g, size: I, className: A })),
      ...t
    }
  );
}
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VQ = (A) => A.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), xQ = (A) => A.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (g, I, C) => C ? C.toUpperCase() : I.toLowerCase()
), CZ = (A) => {
  const g = xQ(A);
  return g.charAt(0).toUpperCase() + g.slice(1);
}, vH = (...A) => A.filter((g, I, C) => !!g && g.trim() !== "" && C.indexOf(g) === I).join(" ").trim(), _Q = (A) => {
  for (const g in A)
    if (g.startsWith("aria-") || g === "role" || g === "title")
      return !0;
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var UQ = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FQ = Z.forwardRef(
  ({
    color: A = "currentColor",
    size: g = 24,
    strokeWidth: I = 2,
    absoluteStrokeWidth: C,
    className: t = "",
    children: s,
    iconNode: r,
    ...l
  }, d) => Z.createElement(
    "svg",
    {
      ref: d,
      ...UQ,
      width: g,
      height: g,
      stroke: A,
      strokeWidth: C ? Number(I) * 24 / Number(g) : I,
      className: vH("lucide", t),
      ...!s && !_Q(l) && { "aria-hidden": "true" },
      ...l
    },
    [
      ...r.map(([h, D]) => Z.createElement(h, D)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YA = (A, g) => {
  const I = Z.forwardRef(
    ({ className: C, ...t }, s) => Z.createElement(FQ, {
      ref: s,
      iconNode: g,
      className: vH(
        `lucide-${VQ(CZ(A))}`,
        `lucide-${A}`,
        C
      ),
      ...t
    })
  );
  return I.displayName = CZ(A), I;
};
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XQ = [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
], QQ = YA("arrow-left", XQ);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zQ = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
], JQ = YA("arrow-right", zQ);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LQ = [
  [
    "path",
    {
      d: "M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",
      key: "18u6gg"
    }
  ],
  ["circle", { cx: "12", cy: "13", r: "3", key: "1vg3eu" }]
], qQ = YA("camera", LQ);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $Q = [
  ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" }],
  ["circle", { cx: "18.5", cy: "5.5", r: ".5", fill: "currentColor", key: "lysivs" }],
  ["circle", { cx: "11.5", cy: "11.5", r: ".5", fill: "currentColor", key: "byv1b8" }],
  ["circle", { cx: "7.5", cy: "16.5", r: ".5", fill: "currentColor", key: "nkw3mc" }],
  ["circle", { cx: "17.5", cy: "14.5", r: ".5", fill: "currentColor", key: "1gjh6j" }],
  ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }]
], gz = YA("chart-scatter", $Q);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Iz = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Az = YA("chevron-down", Iz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cz = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], ez = YA("chevron-right", Cz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tz = [
  ["path", { d: "m7 6 5 5 5-5", key: "1lc07p" }],
  ["path", { d: "m7 13 5 5 5-5", key: "1d48rs" }]
], iz = YA("chevrons-down", tz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nz = [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
], eZ = YA("circle-check-big", nz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sz = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
], oz = YA("circle-check", sz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const az = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], rz = YA("circle-question-mark", az);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lz = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], cz = YA("circle", lz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uz = [
  [
    "path",
    {
      d: "M21 21H8a2 2 0 0 1-1.42-.587l-3.994-3.999a2 2 0 0 1 0-2.828l10-10a2 2 0 0 1 2.829 0l5.999 6a2 2 0 0 1 0 2.828L12.834 21",
      key: "g5wo59"
    }
  ],
  ["path", { d: "m5.082 11.09 8.828 8.828", key: "1wx5vj" }]
], dz = YA("eraser", uz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fz = [
  [
    "path",
    {
      d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
      key: "ct8e1f"
    }
  ],
  ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242", key: "151rxh" }],
  [
    "path",
    {
      d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
      key: "13bj9a"
    }
  ],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
], hz = YA("eye-off", fz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yz = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M16 16s-1.5-2-4-2-4 2-4 2", key: "epbg0q" }],
  ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9", key: "yxxnd0" }],
  ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9", key: "1p4y9e" }]
], Dz = YA("frown", yz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mz = [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
], wz = YA("layers", Mz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bz = [
  ["path", { d: "M21 6H3", key: "1jwq7v" }],
  ["path", { d: "M7 12H3", key: "13ou7f" }],
  ["path", { d: "M7 18H3", key: "1sijw9" }],
  [
    "path",
    {
      d: "M12 18a5 5 0 0 0 9-3 4.5 4.5 0 0 0-4.5-4.5c-1.33 0-2.54.54-3.41 1.41L11 14",
      key: "qth677"
    }
  ],
  ["path", { d: "M11 10v4h4", key: "172dkj" }]
], pz = YA("list-restart", Bz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mz = [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
], bz = YA("loader", mz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sz = [
  ["path", { d: "M5 3v16h16", key: "1mqmf9" }],
  ["path", { d: "m5 19 6-6", key: "jh6hbb" }],
  ["path", { d: "m2 6 3-3 3 3", key: "tkyvxa" }],
  ["path", { d: "m18 16 3 3-3 3", key: "1d4glt" }]
], Gz = YA("move-3d", Sz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kz = [
  [
    "path",
    { d: "m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z", key: "irua1i" }
  ],
  ["path", { d: "m5 2 5 5", key: "1lls2c" }],
  ["path", { d: "M2 13h15", key: "1hkzvu" }],
  ["path", { d: "M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z", key: "xk76lq" }]
], Tz = YA("paint-bucket", Kz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yz = [
  [
    "path",
    {
      d: "M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z",
      key: "e79jfc"
    }
  ],
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }]
], HH = YA("palette", Yz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pz = [
  ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }],
  ["path", { d: "M16 16h5v5", key: "ccwih5" }]
], EH = YA("refresh-ccw", Pz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zz = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
], jz = YA("refresh-cw", Zz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vz = [
  [
    "path",
    {
      d: "M16.466 7.5C15.643 4.237 13.952 2 12 2 9.239 2 7 6.477 7 12s2.239 10 5 10c.342 0 .677-.069 1-.2",
      key: "10n0gc"
    }
  ],
  ["path", { d: "m15.194 13.707 3.814 1.86-1.86 3.814", key: "16shm9" }],
  [
    "path",
    {
      d: "M19 15.57c-1.804.885-4.274 1.43-7 1.43-5.523 0-10-2.239-10-5s4.477-5 10-5c4.838 0 8.873 1.718 9.8 4",
      key: "1lxi77"
    }
  ]
], Hz = YA("rotate-3d", vz);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ez = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], RH = YA("search", Ez);
/**
 * @license lucide-react v0.541.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Rz = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Oz = YA("x", Rz), Nz = ({
  isLoaded: A,
  showPointCloud: g,
  hasSections: I,
  onContinuousOpen: C,
  onToggleView: t,
  onCapture: s
}) => /* @__PURE__ */ v.jsx("header", { className: "shadow-sm border-b py-2 px-4", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
  /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-1 sm:gap-10 flex-1 min-w-0", children: /* @__PURE__ */ v.jsxs(
    Ke,
    {
      variant: "outline",
      size: "sm",
      onClick: C,
      disabled: !A,
      children: [
        /* @__PURE__ */ v.jsx(RH, { className: "h-4 w-4" }),
        /* @__PURE__ */ v.jsx("span", { className: "hidden sm:inline ml-1", children: "Query Continuous" })
      ]
    }
  ) }),
  /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1 sm:gap-10 flex-shrink-0", children: [
    I && /* @__PURE__ */ v.jsxs(
      Ke,
      {
        variant: "outline",
        size: "sm",
        onClick: t,
        disabled: !A,
        title: g ? "Switch to 2D View" : "Switch to 3D View",
        children: [
          g ? /* @__PURE__ */ v.jsx(wz, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Gz, { className: "h-4 w-4" }),
          /* @__PURE__ */ v.jsx("span", { className: "hidden sm:inline ml-1", children: g ? "2D View" : "3D View" })
        ]
      }
    ),
    /* @__PURE__ */ v.jsxs(
      Ke,
      {
        variant: "outline",
        size: "sm",
        onClick: s,
        disabled: !A,
        title: "Capture Current View",
        children: [
          /* @__PURE__ */ v.jsx(qQ, { className: "h-4 w-4" }),
          /* @__PURE__ */ v.jsx("span", { className: "hidden md:inline ml-1", children: "Capture" })
        ]
      }
    )
  ] })
] }) });
function RI(A, g, { checkForDefaultPrevented: I = !0 } = {}) {
  return function(t) {
    if (A?.(t), I === !1 || !t.defaultPrevented)
      return g?.(t);
  };
}
function kz(A, g) {
  const I = Z.createContext(g), C = (s) => {
    const { children: r, ...l } = s, d = Z.useMemo(() => l, Object.values(l));
    return /* @__PURE__ */ v.jsx(I.Provider, { value: d, children: r });
  };
  C.displayName = A + "Provider";
  function t(s) {
    const r = Z.useContext(I);
    if (r) return r;
    if (g !== void 0) return g;
    throw new Error(`\`${s}\` must be used within \`${A}\``);
  }
  return [C, t];
}
function Tn(A, g = []) {
  let I = [];
  function C(s, r) {
    const l = Z.createContext(r), d = I.length;
    I = [...I, r];
    const h = (w) => {
      const { scope: p, children: b, ...S } = w, K = p?.[A]?.[d] || l, Y = Z.useMemo(() => S, Object.values(S));
      return /* @__PURE__ */ v.jsx(K.Provider, { value: Y, children: b });
    };
    h.displayName = s + "Provider";
    function D(w, p) {
      const b = p?.[A]?.[d] || l, S = Z.useContext(b);
      if (S) return S;
      if (r !== void 0) return r;
      throw new Error(`\`${w}\` must be used within \`${s}\``);
    }
    return [h, D];
  }
  const t = () => {
    const s = I.map((r) => Z.createContext(r));
    return function(l) {
      const d = l?.[A] || s;
      return Z.useMemo(
        () => ({ [`__scope${A}`]: { ...l, [A]: d } }),
        [l, d]
      );
    };
  };
  return t.scopeName = A, [C, Wz(t, ...g)];
}
function Wz(...A) {
  const g = A[0];
  if (A.length === 1) return g;
  const I = () => {
    const C = A.map((t) => ({
      useScope: t(),
      scopeName: t.scopeName
    }));
    return function(s) {
      const r = C.reduce((l, { useScope: d, scopeName: h }) => {
        const w = d(s)[`__scope${h}`];
        return { ...l, ...w };
      }, {});
      return Z.useMemo(() => ({ [`__scope${g.scopeName}`]: r }), [r]);
    };
  };
  return I.scopeName = g.scopeName, I;
}
var jo = globalThis?.document ? Z.useLayoutEffect : () => {
}, Vz = kZ[" useInsertionEffect ".trim().toString()] || jo;
function mr({
  prop: A,
  defaultProp: g,
  onChange: I = () => {
  },
  caller: C
}) {
  const [t, s, r] = xz({
    defaultProp: g,
    onChange: I
  }), l = A !== void 0, d = l ? A : t;
  {
    const D = Z.useRef(A !== void 0);
    Z.useEffect(() => {
      const w = D.current;
      w !== l && console.warn(
        `${C} is changing from ${w ? "controlled" : "uncontrolled"} to ${l ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), D.current = l;
    }, [l, C]);
  }
  const h = Z.useCallback(
    (D) => {
      if (l) {
        const w = _z(D) ? D(A) : D;
        w !== A && r.current?.(w);
      } else
        s(D);
    },
    [l, A, s, r]
  );
  return [d, h];
}
function xz({
  defaultProp: A,
  onChange: g
}) {
  const [I, C] = Z.useState(A), t = Z.useRef(I), s = Z.useRef(g);
  return Vz(() => {
    s.current = g;
  }, [g]), Z.useEffect(() => {
    t.current !== I && (s.current?.(I), t.current = I);
  }, [I, t]), [I, C, s];
}
function _z(A) {
  return typeof A == "function";
}
var QG = eG();
const Uz = /* @__PURE__ */ CG(QG);
var Fz = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], jI = Fz.reduce((A, g) => {
  const I = /* @__PURE__ */ jf(`Primitive.${g}`), C = Z.forwardRef((t, s) => {
    const { asChild: r, ...l } = t, d = r ? I : g;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(d, { ...l, ref: s });
  });
  return C.displayName = `Primitive.${g}`, { ...A, [g]: C };
}, {});
function Xz(A, g) {
  A && QG.flushSync(() => A.dispatchEvent(g));
}
function Qz(A, g) {
  return Z.useReducer((I, C) => g[I][C] ?? I, A);
}
var Ks = (A) => {
  const { present: g, children: I } = A, C = zz(g), t = typeof I == "function" ? I({ present: C.isPresent }) : Z.Children.only(I), s = BA(C.ref, Jz(t));
  return typeof I == "function" || C.isPresent ? Z.cloneElement(t, { ref: s }) : null;
};
Ks.displayName = "Presence";
function zz(A) {
  const [g, I] = Z.useState(), C = Z.useRef(null), t = Z.useRef(A), s = Z.useRef("none"), r = A ? "mounted" : "unmounted", [l, d] = Qz(r, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Z.useEffect(() => {
    const h = FB(C.current);
    s.current = l === "mounted" ? h : "none";
  }, [l]), jo(() => {
    const h = C.current, D = t.current;
    if (D !== A) {
      const p = s.current, b = FB(h);
      A ? d("MOUNT") : b === "none" || h?.display === "none" ? d("UNMOUNT") : d(D && p !== b ? "ANIMATION_OUT" : "UNMOUNT"), t.current = A;
    }
  }, [A, d]), jo(() => {
    if (g) {
      let h;
      const D = g.ownerDocument.defaultView ?? window, w = (b) => {
        const K = FB(C.current).includes(CSS.escape(b.animationName));
        if (b.target === g && K && (d("ANIMATION_END"), !t.current)) {
          const Y = g.style.animationFillMode;
          g.style.animationFillMode = "forwards", h = D.setTimeout(() => {
            g.style.animationFillMode === "forwards" && (g.style.animationFillMode = Y);
          });
        }
      }, p = (b) => {
        b.target === g && (s.current = FB(C.current));
      };
      return g.addEventListener("animationstart", p), g.addEventListener("animationcancel", w), g.addEventListener("animationend", w), () => {
        D.clearTimeout(h), g.removeEventListener("animationstart", p), g.removeEventListener("animationcancel", w), g.removeEventListener("animationend", w);
      };
    } else
      d("ANIMATION_END");
  }, [g, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(l),
    ref: Z.useCallback((h) => {
      C.current = h ? getComputedStyle(h) : null, I(h);
    }, [])
  };
}
function FB(A) {
  return A?.animationName || "none";
}
function Jz(A) {
  let g = Object.getOwnPropertyDescriptor(A.props, "ref")?.get, I = g && "isReactWarning" in g && g.isReactWarning;
  return I ? A.ref : (g = Object.getOwnPropertyDescriptor(A, "ref")?.get, I = g && "isReactWarning" in g && g.isReactWarning, I ? A.props.ref : A.props.ref || A.ref);
}
var Lz = kZ[" useId ".trim().toString()] || (() => {
}), qz = 0;
function vi(A) {
  const [g, I] = Z.useState(Lz());
  return jo(() => {
    I((C) => C ?? String(qz++));
  }, [A]), A || (g ? `radix-${g}` : "");
}
var n0 = "Collapsible", [$z, Tgg] = Tn(n0), [g8, zG] = $z(n0), JG = Z.forwardRef(
  (A, g) => {
    const {
      __scopeCollapsible: I,
      open: C,
      defaultOpen: t,
      disabled: s,
      onOpenChange: r,
      ...l
    } = A, [d, h] = mr({
      prop: C,
      defaultProp: t ?? !1,
      onChange: r,
      caller: n0
    });
    return /* @__PURE__ */ v.jsx(
      g8,
      {
        scope: I,
        disabled: s,
        contentId: vi(),
        open: d,
        onOpenToggle: Z.useCallback(() => h((D) => !D), [h]),
        children: /* @__PURE__ */ v.jsx(
          jI.div,
          {
            "data-state": gK(d),
            "data-disabled": s ? "" : void 0,
            ...l,
            ref: g
          }
        )
      }
    );
  }
);
JG.displayName = n0;
var OH = "CollapsibleTrigger", LG = Z.forwardRef(
  (A, g) => {
    const { __scopeCollapsible: I, ...C } = A, t = zG(OH, I);
    return /* @__PURE__ */ v.jsx(
      jI.button,
      {
        type: "button",
        "aria-controls": t.contentId,
        "aria-expanded": t.open || !1,
        "data-state": gK(t.open),
        "data-disabled": t.disabled ? "" : void 0,
        disabled: t.disabled,
        ...C,
        ref: g,
        onClick: RI(A.onClick, t.onOpenToggle)
      }
    );
  }
);
LG.displayName = OH;
var qG = "CollapsibleContent", $G = Z.forwardRef(
  (A, g) => {
    const { forceMount: I, ...C } = A, t = zG(qG, A.__scopeCollapsible);
    return /* @__PURE__ */ v.jsx(Ks, { present: I || t.open, children: ({ present: s }) => /* @__PURE__ */ v.jsx(I8, { ...C, ref: g, present: s }) });
  }
);
$G.displayName = qG;
var I8 = Z.forwardRef((A, g) => {
  const { __scopeCollapsible: I, present: C, children: t, ...s } = A, r = zG(qG, I), [l, d] = Z.useState(C), h = Z.useRef(null), D = BA(g, h), w = Z.useRef(0), p = w.current, b = Z.useRef(0), S = b.current, K = r.open || l, Y = Z.useRef(K), T = Z.useRef(void 0);
  return Z.useEffect(() => {
    const E = requestAnimationFrame(() => Y.current = !1);
    return () => cancelAnimationFrame(E);
  }, []), jo(() => {
    const E = h.current;
    if (E) {
      T.current = T.current || {
        transitionDuration: E.style.transitionDuration,
        animationName: E.style.animationName
      }, E.style.transitionDuration = "0s", E.style.animationName = "none";
      const H = E.getBoundingClientRect();
      w.current = H.height, b.current = H.width, Y.current || (E.style.transitionDuration = T.current.transitionDuration, E.style.animationName = T.current.animationName), d(C);
    }
  }, [r.open, C]), /* @__PURE__ */ v.jsx(
    jI.div,
    {
      "data-state": gK(r.open),
      "data-disabled": r.disabled ? "" : void 0,
      id: r.contentId,
      hidden: !K,
      ...s,
      ref: D,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": S ? `${S}px` : void 0,
        ...A.style
      },
      children: K && t
    }
  );
});
function gK(A) {
  return A ? "open" : "closed";
}
var A8 = JG;
function C8({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(A8, { "data-slot": "collapsible", ...A });
}
function e8({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(
    LG,
    {
      "data-slot": "collapsible-trigger",
      ...A
    }
  );
}
function t8({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(
    $G,
    {
      "data-slot": "collapsible-content",
      ...A
    }
  );
}
const i8 = ({
  annotationConfig: A,
  loadedAnnotations: g,
  coloringAnnotation: I,
  selectedCategories: C,
  hiddenCategoryIds: t,
  categoryColors: s,
  customColors: r,
  currentNumericName: l,
  isLoaded: d,
  onColorPickerOpen: h,
  onSetAnnotationForColoring: D,
  onSelectedCategoriesChange: w,
  onHiddenCategoryIdsChange: p
}) => {
  const b = (K, Y) => {
    const T = { ...C };
    C[K] === Y ? T[K] = null : T[K] = Y, w(T);
  }, S = (K, Y) => {
    const T = t[K] || /* @__PURE__ */ new Set(), E = new Set(T);
    E.has(Y) ? E.delete(Y) : E.add(Y);
    const H = {
      ...t,
      [K]: E
    };
    p(H);
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "bg-card border border-border  h-full rounded-md overflow-y-auto", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "sticky top-0 bg-card  py-2 px-2 border-b z-10 flex flex-row justify-between items-center border-b-border", children: [
      /* @__PURE__ */ v.jsx("h3", { className: "text-sm font-semibold", children: "Annotations" }),
      /* @__PURE__ */ v.jsx(
        Ke,
        {
          variant: "outline",
          size: "icon",
          className: "text-xs h-6 w-6 p-0",
          onClick: h,
          children: /* @__PURE__ */ v.jsx(HH, { className: "h-1 w-1" })
        }
      )
    ] }),
    /* @__PURE__ */ v.jsx("div", { className: "p-1 flex-1 flex flex-col", children: Array.from(g).map((K) => {
      const Y = A?.AnnoMaps?.[K]?.Items ?? [];
      return /* @__PURE__ */ v.jsxs(
        C8,
        {
          className: "mb-1 border-b border-b-border",
          disabled: !d,
          defaultOpen: I === K,
          children: [
            /* @__PURE__ */ v.jsxs(e8, { className: "flex items-center justify-between w-full p-1 text-left", children: [
              /* @__PURE__ */ v.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ v.jsx(
                "span",
                {
                  className: `text-sm ${I === K ? "font-bold" : "text-muted-foreground font-medium"}`,
                  children: K
                }
              ) }),
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center space-x-1", children: [
                I !== K && /* @__PURE__ */ v.jsx(
                  Ke,
                  {
                    variant: "outline",
                    size: "sm",
                    className: "text-xs h-6 w-6 p-0",
                    onClick: (T) => {
                      T.stopPropagation(), D(K);
                    },
                    children: /* @__PURE__ */ v.jsx(Tz, { className: "h-4 w-4" })
                  }
                ),
                /* @__PURE__ */ v.jsx(iz, { className: "h-4 w-4" })
              ] })
            ] }),
            /* @__PURE__ */ v.jsx(t8, { className: "p-0 border-t", children: /* @__PURE__ */ v.jsx(
              n8,
              {
                type: K,
                categories: Y,
                selectedCategory: C[K],
                hiddenCategories: t[K] || /* @__PURE__ */ new Set(),
                categoryColors: s[K] ?? {},
                customColors: r[K] ?? {},
                currentNumericName: l,
                coloringAnnotation: I,
                onCategorySelect: b,
                onCategoryToggle: S
              }
            ) })
          ]
        },
        K
      );
    }) })
  ] });
}, n8 = ({
  type: A,
  categories: g,
  selectedCategory: I,
  hiddenCategories: C,
  categoryColors: t,
  customColors: s,
  currentNumericName: r,
  coloringAnnotation: l,
  onCategorySelect: d,
  onCategoryToggle: h
}) => /* @__PURE__ */ v.jsx("div", { className: "space-y-1 overflow-y-auto", children: g.map((D) => {
  const w = D.Code, p = D.Name, b = C.has(w), S = I === w, K = r !== null, T = l === A ? s[w] || `rgb(${(t[w] || [180, 180, 180]).join(", ")})` : "#cccccc";
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      className: `flex items-center justify-between p-1.5 pb-3 rounded ${S ? "bg-primary/10 border-primary/30" : ""} ${K ? "opacity-50" : "hover:bg-secondary"} ${b ? "opacity-50" : ""}`,
      children: /* @__PURE__ */ v.jsxs(
        "div",
        {
          className: "flex items-center flex-1 cursor-pointer",
          onClick: () => d(A, w),
          children: [
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "w-4 h-4 rounded-sm flex items-center justify-center mr-1.5",
                style: { backgroundColor: T },
                onClick: (E) => {
                  E.stopPropagation(), h(A, w);
                },
                children: b ? /* @__PURE__ */ v.jsx(hz, { className: "h-2 w-2 text-white" }) : S && /* @__PURE__ */ v.jsx(oz, { className: "h-2 w-2 text-white" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "span",
              {
                className: `text-xs ${S ? "font-medium" : "text-muted-foreground"} truncate`,
                title: p,
                children: p
              }
            )
          ]
        }
      )
    },
    w
  );
}) });
function NH(A, [g, I]) {
  return Math.min(I, Math.max(g, A));
}
var s8 = Z.createContext(void 0);
function IK(A) {
  const g = Z.useContext(s8);
  return A || g || "ltr";
}
function AK(A) {
  const g = Z.useRef({ value: A, previous: A });
  return Z.useMemo(() => (g.current.value !== A && (g.current.previous = g.current.value, g.current.value = A), g.current.previous), [A]);
}
function s0(A) {
  const [g, I] = Z.useState(void 0);
  return jo(() => {
    if (A) {
      I({ width: A.offsetWidth, height: A.offsetHeight });
      const C = new ResizeObserver((t) => {
        if (!Array.isArray(t) || !t.length)
          return;
        const s = t[0];
        let r, l;
        if ("borderBoxSize" in s) {
          const d = s.borderBoxSize, h = Array.isArray(d) ? d[0] : d;
          r = h.inlineSize, l = h.blockSize;
        } else
          r = A.offsetWidth, l = A.offsetHeight;
        I({ width: r, height: l });
      });
      return C.observe(A, { box: "border-box" }), () => C.unobserve(A);
    } else
      I(void 0);
  }, [A]), g;
}
function kH(A) {
  const g = A + "CollectionProvider", [I, C] = Tn(g), [t, s] = I(
    g,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), r = (K) => {
    const { scope: Y, children: T } = K, E = EA.useRef(null), H = EA.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ v.jsx(t, { scope: Y, itemMap: H, collectionRef: E, children: T });
  };
  r.displayName = g;
  const l = A + "CollectionSlot", d = /* @__PURE__ */ jf(l), h = EA.forwardRef(
    (K, Y) => {
      const { scope: T, children: E } = K, H = s(l, T), R = BA(Y, H.collectionRef);
      return /* @__PURE__ */ v.jsx(d, { ref: R, children: E });
    }
  );
  h.displayName = l;
  const D = A + "CollectionItemSlot", w = "data-radix-collection-item", p = /* @__PURE__ */ jf(D), b = EA.forwardRef(
    (K, Y) => {
      const { scope: T, children: E, ...H } = K, R = EA.useRef(null), x = BA(Y, R), U = s(D, T);
      return EA.useEffect(() => (U.itemMap.set(R, { ref: R, ...H }), () => void U.itemMap.delete(R))), /* @__PURE__ */ v.jsx(p, { [w]: "", ref: x, children: E });
    }
  );
  b.displayName = D;
  function S(K) {
    const Y = s(A + "CollectionConsumer", K);
    return EA.useCallback(() => {
      const E = Y.collectionRef.current;
      if (!E) return [];
      const H = Array.from(E.querySelectorAll(`[${w}]`));
      return Array.from(Y.itemMap.values()).sort(
        (U, J) => H.indexOf(U.ref.current) - H.indexOf(J.ref.current)
      );
    }, [Y.collectionRef, Y.itemMap]);
  }
  return [
    { Provider: r, Slot: h, ItemSlot: b },
    S,
    C
  ];
}
var WH = ["PageUp", "PageDown"], VH = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], xH = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Nf = "Slider", [OS, o8, a8] = kH(Nf), [_H, Ygg] = Tn(Nf, [
  a8
]), [r8, o0] = _H(Nf), UH = Z.forwardRef(
  (A, g) => {
    const {
      name: I,
      min: C = 0,
      max: t = 100,
      step: s = 1,
      orientation: r = "horizontal",
      disabled: l = !1,
      minStepsBetweenThumbs: d = 0,
      defaultValue: h = [C],
      value: D,
      onValueChange: w = () => {
      },
      onValueCommit: p = () => {
      },
      inverted: b = !1,
      form: S,
      ...K
    } = A, Y = Z.useRef(/* @__PURE__ */ new Set()), T = Z.useRef(0), H = r === "horizontal" ? l8 : c8, [R = [], x] = mr({
      prop: D,
      defaultProp: h,
      onChange: (ig) => {
        [...Y.current][T.current]?.focus(), w(ig);
      }
    }), U = Z.useRef(R);
    function J(ig) {
      const Zg = y8(R, ig);
      Mg(ig, Zg);
    }
    function L(ig) {
      Mg(ig, T.current);
    }
    function eg() {
      const ig = U.current[T.current];
      R[T.current] !== ig && p(R);
    }
    function Mg(ig, Zg, { commit: Kg } = { commit: !1 }) {
      const mg = B8(s), Ng = p8(Math.round((ig - C) / s) * s + C, mg), cg = NH(Ng, [C, t]);
      x((z = []) => {
        const Q = f8(z, cg, Zg);
        if (w8(Q, d * s)) {
          T.current = Q.indexOf(cg);
          const Bg = String(Q) !== String(z);
          return Bg && Kg && p(Q), Bg ? Q : z;
        } else
          return z;
      });
    }
    return /* @__PURE__ */ v.jsx(
      r8,
      {
        scope: A.__scopeSlider,
        name: I,
        disabled: l,
        min: C,
        max: t,
        valueIndexToChangeRef: T,
        thumbs: Y.current,
        values: R,
        orientation: r,
        form: S,
        children: /* @__PURE__ */ v.jsx(OS.Provider, { scope: A.__scopeSlider, children: /* @__PURE__ */ v.jsx(OS.Slot, { scope: A.__scopeSlider, children: /* @__PURE__ */ v.jsx(
          H,
          {
            "aria-disabled": l,
            "data-disabled": l ? "" : void 0,
            ...K,
            ref: g,
            onPointerDown: RI(K.onPointerDown, () => {
              l || (U.current = R);
            }),
            min: C,
            max: t,
            inverted: b,
            onSlideStart: l ? void 0 : J,
            onSlideMove: l ? void 0 : L,
            onSlideEnd: l ? void 0 : eg,
            onHomeKeyDown: () => !l && Mg(C, 0, { commit: !0 }),
            onEndKeyDown: () => !l && Mg(t, R.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: ig, direction: Zg }) => {
              if (!l) {
                const Ng = WH.includes(ig.key) || ig.shiftKey && VH.includes(ig.key) ? 10 : 1, cg = T.current, z = R[cg], Q = s * Ng * Zg;
                Mg(z + Q, cg, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
UH.displayName = Nf;
var [FH, XH] = _H(Nf, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), l8 = Z.forwardRef(
  (A, g) => {
    const {
      min: I,
      max: C,
      dir: t,
      inverted: s,
      onSlideStart: r,
      onSlideMove: l,
      onSlideEnd: d,
      onStepKeyDown: h,
      ...D
    } = A, [w, p] = Z.useState(null), b = BA(g, (H) => p(H)), S = Z.useRef(void 0), K = IK(t), Y = K === "ltr", T = Y && !s || !Y && s;
    function E(H) {
      const R = S.current || w.getBoundingClientRect(), x = [0, R.width], J = CK(x, T ? [I, C] : [C, I]);
      return S.current = R, J(H - R.left);
    }
    return /* @__PURE__ */ v.jsx(
      FH,
      {
        scope: A.__scopeSlider,
        startEdge: T ? "left" : "right",
        endEdge: T ? "right" : "left",
        direction: T ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ v.jsx(
          QH,
          {
            dir: K,
            "data-orientation": "horizontal",
            ...D,
            ref: b,
            style: {
              ...D.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (H) => {
              const R = E(H.clientX);
              r?.(R);
            },
            onSlideMove: (H) => {
              const R = E(H.clientX);
              l?.(R);
            },
            onSlideEnd: () => {
              S.current = void 0, d?.();
            },
            onStepKeyDown: (H) => {
              const x = xH[T ? "from-left" : "from-right"].includes(H.key);
              h?.({ event: H, direction: x ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), c8 = Z.forwardRef(
  (A, g) => {
    const {
      min: I,
      max: C,
      inverted: t,
      onSlideStart: s,
      onSlideMove: r,
      onSlideEnd: l,
      onStepKeyDown: d,
      ...h
    } = A, D = Z.useRef(null), w = BA(g, D), p = Z.useRef(void 0), b = !t;
    function S(K) {
      const Y = p.current || D.current.getBoundingClientRect(), T = [0, Y.height], H = CK(T, b ? [C, I] : [I, C]);
      return p.current = Y, H(K - Y.top);
    }
    return /* @__PURE__ */ v.jsx(
      FH,
      {
        scope: A.__scopeSlider,
        startEdge: b ? "bottom" : "top",
        endEdge: b ? "top" : "bottom",
        size: "height",
        direction: b ? 1 : -1,
        children: /* @__PURE__ */ v.jsx(
          QH,
          {
            "data-orientation": "vertical",
            ...h,
            ref: w,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (K) => {
              const Y = S(K.clientY);
              s?.(Y);
            },
            onSlideMove: (K) => {
              const Y = S(K.clientY);
              r?.(Y);
            },
            onSlideEnd: () => {
              p.current = void 0, l?.();
            },
            onStepKeyDown: (K) => {
              const T = xH[b ? "from-bottom" : "from-top"].includes(K.key);
              d?.({ event: K, direction: T ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), QH = Z.forwardRef(
  (A, g) => {
    const {
      __scopeSlider: I,
      onSlideStart: C,
      onSlideMove: t,
      onSlideEnd: s,
      onHomeKeyDown: r,
      onEndKeyDown: l,
      onStepKeyDown: d,
      ...h
    } = A, D = o0(Nf, I);
    return /* @__PURE__ */ v.jsx(
      jI.span,
      {
        ...h,
        ref: g,
        onKeyDown: RI(A.onKeyDown, (w) => {
          w.key === "Home" ? (r(w), w.preventDefault()) : w.key === "End" ? (l(w), w.preventDefault()) : WH.concat(VH).includes(w.key) && (d(w), w.preventDefault());
        }),
        onPointerDown: RI(A.onPointerDown, (w) => {
          const p = w.target;
          p.setPointerCapture(w.pointerId), w.preventDefault(), D.thumbs.has(p) ? p.focus() : C(w);
        }),
        onPointerMove: RI(A.onPointerMove, (w) => {
          w.target.hasPointerCapture(w.pointerId) && t(w);
        }),
        onPointerUp: RI(A.onPointerUp, (w) => {
          const p = w.target;
          p.hasPointerCapture(w.pointerId) && (p.releasePointerCapture(w.pointerId), s(w));
        })
      }
    );
  }
), zH = "SliderTrack", JH = Z.forwardRef(
  (A, g) => {
    const { __scopeSlider: I, ...C } = A, t = o0(zH, I);
    return /* @__PURE__ */ v.jsx(
      jI.span,
      {
        "data-disabled": t.disabled ? "" : void 0,
        "data-orientation": t.orientation,
        ...C,
        ref: g
      }
    );
  }
);
JH.displayName = zH;
var NS = "SliderRange", LH = Z.forwardRef(
  (A, g) => {
    const { __scopeSlider: I, ...C } = A, t = o0(NS, I), s = XH(NS, I), r = Z.useRef(null), l = BA(g, r), d = t.values.length, h = t.values.map(
      (p) => gE(p, t.min, t.max)
    ), D = d > 1 ? Math.min(...h) : 0, w = 100 - Math.max(...h);
    return /* @__PURE__ */ v.jsx(
      jI.span,
      {
        "data-orientation": t.orientation,
        "data-disabled": t.disabled ? "" : void 0,
        ...C,
        ref: l,
        style: {
          ...A.style,
          [s.startEdge]: D + "%",
          [s.endEdge]: w + "%"
        }
      }
    );
  }
);
LH.displayName = NS;
var kS = "SliderThumb", qH = Z.forwardRef(
  (A, g) => {
    const I = o8(A.__scopeSlider), [C, t] = Z.useState(null), s = BA(g, (l) => t(l)), r = Z.useMemo(
      () => C ? I().findIndex((l) => l.ref.current === C) : -1,
      [I, C]
    );
    return /* @__PURE__ */ v.jsx(u8, { ...A, ref: s, index: r });
  }
), u8 = Z.forwardRef(
  (A, g) => {
    const { __scopeSlider: I, index: C, name: t, ...s } = A, r = o0(kS, I), l = XH(kS, I), [d, h] = Z.useState(null), D = BA(g, (E) => h(E)), w = d ? r.form || !!d.closest("form") : !0, p = s0(d), b = r.values[C], S = b === void 0 ? 0 : gE(b, r.min, r.max), K = h8(C, r.values.length), Y = p?.[l.size], T = Y ? D8(Y, S, l.direction) : 0;
    return Z.useEffect(() => {
      if (d)
        return r.thumbs.add(d), () => {
          r.thumbs.delete(d);
        };
    }, [d, r.thumbs]), /* @__PURE__ */ v.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [l.startEdge]: `calc(${S}% + ${T}px)`
        },
        children: [
          /* @__PURE__ */ v.jsx(OS.ItemSlot, { scope: A.__scopeSlider, children: /* @__PURE__ */ v.jsx(
            jI.span,
            {
              role: "slider",
              "aria-label": A["aria-label"] || K,
              "aria-valuemin": r.min,
              "aria-valuenow": b,
              "aria-valuemax": r.max,
              "aria-orientation": r.orientation,
              "data-orientation": r.orientation,
              "data-disabled": r.disabled ? "" : void 0,
              tabIndex: r.disabled ? void 0 : 0,
              ...s,
              ref: D,
              style: b === void 0 ? { display: "none" } : A.style,
              onFocus: RI(A.onFocus, () => {
                r.valueIndexToChangeRef.current = C;
              })
            }
          ) }),
          w && /* @__PURE__ */ v.jsx(
            $H,
            {
              name: t ?? (r.name ? r.name + (r.values.length > 1 ? "[]" : "") : void 0),
              form: r.form,
              value: b
            },
            C
          )
        ]
      }
    );
  }
);
qH.displayName = kS;
var d8 = "RadioBubbleInput", $H = Z.forwardRef(
  ({ __scopeSlider: A, value: g, ...I }, C) => {
    const t = Z.useRef(null), s = BA(t, C), r = AK(g);
    return Z.useEffect(() => {
      const l = t.current;
      if (!l) return;
      const d = window.HTMLInputElement.prototype, D = Object.getOwnPropertyDescriptor(d, "value").set;
      if (r !== g && D) {
        const w = new Event("input", { bubbles: !0 });
        D.call(l, g), l.dispatchEvent(w);
      }
    }, [r, g]), /* @__PURE__ */ v.jsx(
      jI.input,
      {
        style: { display: "none" },
        ...I,
        ref: s,
        defaultValue: g
      }
    );
  }
);
$H.displayName = d8;
function f8(A = [], g, I) {
  const C = [...A];
  return C[I] = g, C.sort((t, s) => t - s);
}
function gE(A, g, I) {
  const s = 100 / (I - g) * (A - g);
  return NH(s, [0, 100]);
}
function h8(A, g) {
  return g > 2 ? `Value ${A + 1} of ${g}` : g === 2 ? ["Minimum", "Maximum"][A] : void 0;
}
function y8(A, g) {
  if (A.length === 1) return 0;
  const I = A.map((t) => Math.abs(t - g)), C = Math.min(...I);
  return I.indexOf(C);
}
function D8(A, g, I) {
  const C = A / 2, s = CK([0, 50], [0, C]);
  return (C - s(g) * I) * I;
}
function M8(A) {
  return A.slice(0, -1).map((g, I) => A[I + 1] - g);
}
function w8(A, g) {
  if (g > 0) {
    const I = M8(A);
    return Math.min(...I) >= g;
  }
  return !0;
}
function CK(A, g) {
  return (I) => {
    if (A[0] === A[1] || g[0] === g[1]) return g[0];
    const C = (g[1] - g[0]) / (A[1] - A[0]);
    return g[0] + C * (I - A[0]);
  };
}
function B8(A) {
  return (String(A).split(".")[1] || "").length;
}
function p8(A, g) {
  const I = Math.pow(10, g);
  return Math.round(A * I) / I;
}
var m8 = UH, b8 = JH, S8 = LH, G8 = qH;
function WS({
  className: A,
  defaultValue: g,
  value: I,
  min: C = 0,
  max: t = 100,
  ...s
}) {
  const r = Z.useMemo(
    () => Array.isArray(I) ? I : Array.isArray(g) ? g : [C, t],
    [I, g, C, t]
  );
  return /* @__PURE__ */ v.jsxs(
    m8,
    {
      "data-slot": "slider",
      defaultValue: g,
      value: I,
      min: C,
      max: t,
      className: kI(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        A
      ),
      ...s,
      children: [
        /* @__PURE__ */ v.jsx(
          b8,
          {
            "data-slot": "slider-track",
            className: kI(
              "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
            ),
            children: /* @__PURE__ */ v.jsx(
              S8,
              {
                "data-slot": "slider-range",
                className: kI(
                  "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
                )
              }
            )
          }
        ),
        Array.from({ length: r.length }, (l, d) => /* @__PURE__ */ v.jsx(
          G8,
          {
            "data-slot": "slider-thumb",
            className: "border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
          },
          d
        ))
      ]
    }
  );
}
function bc(A) {
  const g = Z.useRef(A);
  return Z.useEffect(() => {
    g.current = A;
  }), Z.useMemo(() => (...I) => g.current?.(...I), []);
}
var kb = "rovingFocusGroup.onEntryFocus", K8 = { bubbles: !1, cancelable: !0 }, YM = "RovingFocusGroup", [VS, IE, T8] = kH(YM), [Y8, AE] = Tn(
  YM,
  [T8]
), [P8, Z8] = Y8(YM), CE = Z.forwardRef(
  (A, g) => /* @__PURE__ */ v.jsx(VS.Provider, { scope: A.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(VS.Slot, { scope: A.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(j8, { ...A, ref: g }) }) })
);
CE.displayName = YM;
var j8 = Z.forwardRef((A, g) => {
  const {
    __scopeRovingFocusGroup: I,
    orientation: C,
    loop: t = !1,
    dir: s,
    currentTabStopId: r,
    defaultCurrentTabStopId: l,
    onCurrentTabStopIdChange: d,
    onEntryFocus: h,
    preventScrollOnEntryFocus: D = !1,
    ...w
  } = A, p = Z.useRef(null), b = BA(g, p), S = IK(s), [K, Y] = mr({
    prop: r,
    defaultProp: l ?? null,
    onChange: d,
    caller: YM
  }), [T, E] = Z.useState(!1), H = bc(h), R = IE(I), x = Z.useRef(!1), [U, J] = Z.useState(0);
  return Z.useEffect(() => {
    const L = p.current;
    if (L)
      return L.addEventListener(kb, H), () => L.removeEventListener(kb, H);
  }, [H]), /* @__PURE__ */ v.jsx(
    P8,
    {
      scope: I,
      orientation: C,
      dir: S,
      loop: t,
      currentTabStopId: K,
      onItemFocus: Z.useCallback(
        (L) => Y(L),
        [Y]
      ),
      onItemShiftTab: Z.useCallback(() => E(!0), []),
      onFocusableItemAdd: Z.useCallback(
        () => J((L) => L + 1),
        []
      ),
      onFocusableItemRemove: Z.useCallback(
        () => J((L) => L - 1),
        []
      ),
      children: /* @__PURE__ */ v.jsx(
        jI.div,
        {
          tabIndex: T || U === 0 ? -1 : 0,
          "data-orientation": C,
          ...w,
          ref: b,
          style: { outline: "none", ...A.style },
          onMouseDown: RI(A.onMouseDown, () => {
            x.current = !0;
          }),
          onFocus: RI(A.onFocus, (L) => {
            const eg = !x.current;
            if (L.target === L.currentTarget && eg && !T) {
              const Mg = new CustomEvent(kb, K8);
              if (L.currentTarget.dispatchEvent(Mg), !Mg.defaultPrevented) {
                const ig = R().filter((cg) => cg.focusable), Zg = ig.find((cg) => cg.active), Kg = ig.find((cg) => cg.id === K), Ng = [Zg, Kg, ...ig].filter(
                  Boolean
                ).map((cg) => cg.ref.current);
                iE(Ng, D);
              }
            }
            x.current = !1;
          }),
          onBlur: RI(A.onBlur, () => E(!1))
        }
      )
    }
  );
}), eE = "RovingFocusGroupItem", tE = Z.forwardRef(
  (A, g) => {
    const {
      __scopeRovingFocusGroup: I,
      focusable: C = !0,
      active: t = !1,
      tabStopId: s,
      children: r,
      ...l
    } = A, d = vi(), h = s || d, D = Z8(eE, I), w = D.currentTabStopId === h, p = IE(I), { onFocusableItemAdd: b, onFocusableItemRemove: S, currentTabStopId: K } = D;
    return Z.useEffect(() => {
      if (C)
        return b(), () => S();
    }, [C, b, S]), /* @__PURE__ */ v.jsx(
      VS.ItemSlot,
      {
        scope: I,
        id: h,
        focusable: C,
        active: t,
        children: /* @__PURE__ */ v.jsx(
          jI.span,
          {
            tabIndex: w ? 0 : -1,
            "data-orientation": D.orientation,
            ...l,
            ref: g,
            onMouseDown: RI(A.onMouseDown, (Y) => {
              C ? D.onItemFocus(h) : Y.preventDefault();
            }),
            onFocus: RI(A.onFocus, () => D.onItemFocus(h)),
            onKeyDown: RI(A.onKeyDown, (Y) => {
              if (Y.key === "Tab" && Y.shiftKey) {
                D.onItemShiftTab();
                return;
              }
              if (Y.target !== Y.currentTarget) return;
              const T = E8(Y, D.orientation, D.dir);
              if (T !== void 0) {
                if (Y.metaKey || Y.ctrlKey || Y.altKey || Y.shiftKey) return;
                Y.preventDefault();
                let H = p().filter((R) => R.focusable).map((R) => R.ref.current);
                if (T === "last") H.reverse();
                else if (T === "prev" || T === "next") {
                  T === "prev" && H.reverse();
                  const R = H.indexOf(Y.currentTarget);
                  H = D.loop ? R8(H, R + 1) : H.slice(R + 1);
                }
                setTimeout(() => iE(H));
              }
            }),
            children: typeof r == "function" ? r({ isCurrentTabStop: w, hasTabStop: K != null }) : r
          }
        )
      }
    );
  }
);
tE.displayName = eE;
var v8 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function H8(A, g) {
  return g !== "rtl" ? A : A === "ArrowLeft" ? "ArrowRight" : A === "ArrowRight" ? "ArrowLeft" : A;
}
function E8(A, g, I) {
  const C = H8(A.key, I);
  if (!(g === "vertical" && ["ArrowLeft", "ArrowRight"].includes(C)) && !(g === "horizontal" && ["ArrowUp", "ArrowDown"].includes(C)))
    return v8[C];
}
function iE(A, g = !1) {
  const I = document.activeElement;
  for (const C of A)
    if (C === I || (C.focus({ preventScroll: g }), document.activeElement !== I)) return;
}
function R8(A, g) {
  return A.map((I, C) => A[(g + C) % A.length]);
}
var O8 = CE, N8 = tE, eK = "Radio", [k8, nE] = Tn(eK), [W8, V8] = k8(eK), sE = Z.forwardRef(
  (A, g) => {
    const {
      __scopeRadio: I,
      name: C,
      checked: t = !1,
      required: s,
      disabled: r,
      value: l = "on",
      onCheck: d,
      form: h,
      ...D
    } = A, [w, p] = Z.useState(null), b = BA(g, (Y) => p(Y)), S = Z.useRef(!1), K = w ? h || !!w.closest("form") : !0;
    return /* @__PURE__ */ v.jsxs(W8, { scope: I, checked: t, disabled: r, children: [
      /* @__PURE__ */ v.jsx(
        jI.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": t,
          "data-state": lE(t),
          "data-disabled": r ? "" : void 0,
          disabled: r,
          value: l,
          ...D,
          ref: b,
          onClick: RI(A.onClick, (Y) => {
            t || d?.(), K && (S.current = Y.isPropagationStopped(), S.current || Y.stopPropagation());
          })
        }
      ),
      K && /* @__PURE__ */ v.jsx(
        rE,
        {
          control: w,
          bubbles: !S.current,
          name: C,
          value: l,
          checked: t,
          required: s,
          disabled: r,
          form: h,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
sE.displayName = eK;
var oE = "RadioIndicator", aE = Z.forwardRef(
  (A, g) => {
    const { __scopeRadio: I, forceMount: C, ...t } = A, s = V8(oE, I);
    return /* @__PURE__ */ v.jsx(Ks, { present: C || s.checked, children: /* @__PURE__ */ v.jsx(
      jI.span,
      {
        "data-state": lE(s.checked),
        "data-disabled": s.disabled ? "" : void 0,
        ...t,
        ref: g
      }
    ) });
  }
);
aE.displayName = oE;
var x8 = "RadioBubbleInput", rE = Z.forwardRef(
  ({
    __scopeRadio: A,
    control: g,
    checked: I,
    bubbles: C = !0,
    ...t
  }, s) => {
    const r = Z.useRef(null), l = BA(r, s), d = AK(I), h = s0(g);
    return Z.useEffect(() => {
      const D = r.current;
      if (!D) return;
      const w = window.HTMLInputElement.prototype, b = Object.getOwnPropertyDescriptor(
        w,
        "checked"
      ).set;
      if (d !== I && b) {
        const S = new Event("click", { bubbles: C });
        b.call(D, I), D.dispatchEvent(S);
      }
    }, [d, I, C]), /* @__PURE__ */ v.jsx(
      jI.input,
      {
        type: "radio",
        "aria-hidden": !0,
        defaultChecked: I,
        ...t,
        tabIndex: -1,
        ref: l,
        style: {
          ...t.style,
          ...h,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
rE.displayName = x8;
function lE(A) {
  return A ? "checked" : "unchecked";
}
var _8 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], a0 = "RadioGroup", [U8, Pgg] = Tn(a0, [
  AE,
  nE
]), cE = AE(), uE = nE(), [F8, X8] = U8(a0), dE = Z.forwardRef(
  (A, g) => {
    const {
      __scopeRadioGroup: I,
      name: C,
      defaultValue: t,
      value: s,
      required: r = !1,
      disabled: l = !1,
      orientation: d,
      dir: h,
      loop: D = !0,
      onValueChange: w,
      ...p
    } = A, b = cE(I), S = IK(h), [K, Y] = mr({
      prop: s,
      defaultProp: t ?? null,
      onChange: w,
      caller: a0
    });
    return /* @__PURE__ */ v.jsx(
      F8,
      {
        scope: I,
        name: C,
        required: r,
        disabled: l,
        value: K,
        onValueChange: Y,
        children: /* @__PURE__ */ v.jsx(
          O8,
          {
            asChild: !0,
            ...b,
            orientation: d,
            dir: S,
            loop: D,
            children: /* @__PURE__ */ v.jsx(
              jI.div,
              {
                role: "radiogroup",
                "aria-required": r,
                "aria-orientation": d,
                "data-disabled": l ? "" : void 0,
                dir: S,
                ...p,
                ref: g
              }
            )
          }
        )
      }
    );
  }
);
dE.displayName = a0;
var fE = "RadioGroupItem", hE = Z.forwardRef(
  (A, g) => {
    const { __scopeRadioGroup: I, disabled: C, ...t } = A, s = X8(fE, I), r = s.disabled || C, l = cE(I), d = uE(I), h = Z.useRef(null), D = BA(g, h), w = s.value === t.value, p = Z.useRef(!1);
    return Z.useEffect(() => {
      const b = (K) => {
        _8.includes(K.key) && (p.current = !0);
      }, S = () => p.current = !1;
      return document.addEventListener("keydown", b), document.addEventListener("keyup", S), () => {
        document.removeEventListener("keydown", b), document.removeEventListener("keyup", S);
      };
    }, []), /* @__PURE__ */ v.jsx(
      N8,
      {
        asChild: !0,
        ...l,
        focusable: !r,
        active: w,
        children: /* @__PURE__ */ v.jsx(
          sE,
          {
            disabled: r,
            required: s.required,
            checked: w,
            ...d,
            ...t,
            name: s.name,
            ref: D,
            onCheck: () => s.onValueChange(t.value),
            onKeyDown: RI((b) => {
              b.key === "Enter" && b.preventDefault();
            }),
            onFocus: RI(t.onFocus, () => {
              p.current && h.current?.click();
            })
          }
        )
      }
    );
  }
);
hE.displayName = fE;
var Q8 = "RadioGroupIndicator", yE = Z.forwardRef(
  (A, g) => {
    const { __scopeRadioGroup: I, ...C } = A, t = uE(I);
    return /* @__PURE__ */ v.jsx(aE, { ...t, ...C, ref: g });
  }
);
yE.displayName = Q8;
var z8 = dE, J8 = hE, L8 = yE;
function q8({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    z8,
    {
      "data-slot": "radio-group",
      className: kI("grid gap-3", A),
      ...g
    }
  );
}
function Wb({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    J8,
    {
      "data-slot": "radio-group-item",
      className: kI(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        A
      ),
      ...g,
      children: /* @__PURE__ */ v.jsx(
        L8,
        {
          "data-slot": "radio-group-indicator",
          className: "relative flex items-center justify-center",
          children: /* @__PURE__ */ v.jsx(cz, { className: "fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" })
        }
      )
    }
  );
}
var $8 = "Label", DE = Z.forwardRef((A, g) => /* @__PURE__ */ v.jsx(
  jI.label,
  {
    ...A,
    ref: g,
    onMouseDown: (I) => {
      I.target.closest("button, input, select, textarea") || (A.onMouseDown?.(I), !I.defaultPrevented && I.detail > 1 && I.preventDefault());
    }
  }
));
DE.displayName = $8;
var gJ = DE;
function XB({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    gJ,
    {
      "data-slot": "label",
      className: kI(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        A
      ),
      ...g
    }
  );
}
function r0({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card",
      className: kI(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        A
      ),
      ...g
    }
  );
}
function tK({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-header",
      className: kI(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        A
      ),
      ...g
    }
  );
}
function iK({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-title",
      className: kI("leading-none font-semibold", A),
      ...g
    }
  );
}
function ME({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-action",
      className: kI(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        A
      ),
      ...g
    }
  );
}
function l0({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-content",
      className: kI("px-6", A),
      ...g
    }
  );
}
var c0 = "Switch", [IJ, Zgg] = Tn(c0), [AJ, CJ] = IJ(c0), wE = Z.forwardRef(
  (A, g) => {
    const {
      __scopeSwitch: I,
      name: C,
      checked: t,
      defaultChecked: s,
      required: r,
      disabled: l,
      value: d = "on",
      onCheckedChange: h,
      form: D,
      ...w
    } = A, [p, b] = Z.useState(null), S = BA(g, (H) => b(H)), K = Z.useRef(!1), Y = p ? D || !!p.closest("form") : !0, [T, E] = mr({
      prop: t,
      defaultProp: s ?? !1,
      onChange: h,
      caller: c0
    });
    return /* @__PURE__ */ v.jsxs(AJ, { scope: I, checked: T, disabled: l, children: [
      /* @__PURE__ */ v.jsx(
        jI.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": T,
          "aria-required": r,
          "data-state": bE(T),
          "data-disabled": l ? "" : void 0,
          disabled: l,
          value: d,
          ...w,
          ref: S,
          onClick: RI(A.onClick, (H) => {
            E((R) => !R), Y && (K.current = H.isPropagationStopped(), K.current || H.stopPropagation());
          })
        }
      ),
      Y && /* @__PURE__ */ v.jsx(
        mE,
        {
          control: p,
          bubbles: !K.current,
          name: C,
          value: d,
          checked: T,
          required: r,
          disabled: l,
          form: D,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
wE.displayName = c0;
var BE = "SwitchThumb", pE = Z.forwardRef(
  (A, g) => {
    const { __scopeSwitch: I, ...C } = A, t = CJ(BE, I);
    return /* @__PURE__ */ v.jsx(
      jI.span,
      {
        "data-state": bE(t.checked),
        "data-disabled": t.disabled ? "" : void 0,
        ...C,
        ref: g
      }
    );
  }
);
pE.displayName = BE;
var eJ = "SwitchBubbleInput", mE = Z.forwardRef(
  ({
    __scopeSwitch: A,
    control: g,
    checked: I,
    bubbles: C = !0,
    ...t
  }, s) => {
    const r = Z.useRef(null), l = BA(r, s), d = AK(I), h = s0(g);
    return Z.useEffect(() => {
      const D = r.current;
      if (!D) return;
      const w = window.HTMLInputElement.prototype, b = Object.getOwnPropertyDescriptor(
        w,
        "checked"
      ).set;
      if (d !== I && b) {
        const S = new Event("click", { bubbles: C });
        b.call(D, I), D.dispatchEvent(S);
      }
    }, [d, I, C]), /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: I,
        ...t,
        tabIndex: -1,
        ref: l,
        style: {
          ...t.style,
          ...h,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
mE.displayName = eJ;
function bE(A) {
  return A ? "checked" : "unchecked";
}
var tJ = wE, iJ = pE;
function nJ({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    tJ,
    {
      "data-slot": "switch",
      className: kI(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        A
      ),
      ...g,
      children: /* @__PURE__ */ v.jsx(
        iJ,
        {
          "data-slot": "switch-thumb",
          className: kI(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
const sJ = ["top", "right", "bottom", "left"], wr = Math.min, Xt = Math.max, Np = Math.round, QB = Math.floor, bs = (A) => ({
  x: A,
  y: A
}), oJ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, aJ = {
  start: "end",
  end: "start"
};
function xS(A, g, I) {
  return Xt(A, wr(g, I));
}
function vo(A, g) {
  return typeof A == "function" ? A(g) : A;
}
function Ho(A) {
  return A.split("-")[0];
}
function kf(A) {
  return A.split("-")[1];
}
function nK(A) {
  return A === "x" ? "y" : "x";
}
function sK(A) {
  return A === "y" ? "height" : "width";
}
const rJ = /* @__PURE__ */ new Set(["top", "bottom"]);
function ms(A) {
  return rJ.has(Ho(A)) ? "y" : "x";
}
function oK(A) {
  return nK(ms(A));
}
function lJ(A, g, I) {
  I === void 0 && (I = !1);
  const C = kf(A), t = oK(A), s = sK(t);
  let r = t === "x" ? C === (I ? "end" : "start") ? "right" : "left" : C === "start" ? "bottom" : "top";
  return g.reference[s] > g.floating[s] && (r = kp(r)), [r, kp(r)];
}
function cJ(A) {
  const g = kp(A);
  return [_S(A), g, _S(g)];
}
function _S(A) {
  return A.replace(/start|end/g, (g) => aJ[g]);
}
const tZ = ["left", "right"], iZ = ["right", "left"], uJ = ["top", "bottom"], dJ = ["bottom", "top"];
function fJ(A, g, I) {
  switch (A) {
    case "top":
    case "bottom":
      return I ? g ? iZ : tZ : g ? tZ : iZ;
    case "left":
    case "right":
      return g ? uJ : dJ;
    default:
      return [];
  }
}
function hJ(A, g, I, C) {
  const t = kf(A);
  let s = fJ(Ho(A), I === "start", C);
  return t && (s = s.map((r) => r + "-" + t), g && (s = s.concat(s.map(_S)))), s;
}
function kp(A) {
  return A.replace(/left|right|bottom|top/g, (g) => oJ[g]);
}
function yJ(A) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...A
  };
}
function SE(A) {
  return typeof A != "number" ? yJ(A) : {
    top: A,
    right: A,
    bottom: A,
    left: A
  };
}
function Wp(A) {
  const {
    x: g,
    y: I,
    width: C,
    height: t
  } = A;
  return {
    width: C,
    height: t,
    top: I,
    left: g,
    right: g + C,
    bottom: I + t,
    x: g,
    y: I
  };
}
function nZ(A, g, I) {
  let {
    reference: C,
    floating: t
  } = A;
  const s = ms(g), r = oK(g), l = sK(r), d = Ho(g), h = s === "y", D = C.x + C.width / 2 - t.width / 2, w = C.y + C.height / 2 - t.height / 2, p = C[l] / 2 - t[l] / 2;
  let b;
  switch (d) {
    case "top":
      b = {
        x: D,
        y: C.y - t.height
      };
      break;
    case "bottom":
      b = {
        x: D,
        y: C.y + C.height
      };
      break;
    case "right":
      b = {
        x: C.x + C.width,
        y: w
      };
      break;
    case "left":
      b = {
        x: C.x - t.width,
        y: w
      };
      break;
    default:
      b = {
        x: C.x,
        y: C.y
      };
  }
  switch (kf(g)) {
    case "start":
      b[r] -= p * (I && h ? -1 : 1);
      break;
    case "end":
      b[r] += p * (I && h ? -1 : 1);
      break;
  }
  return b;
}
const DJ = async (A, g, I) => {
  const {
    placement: C = "bottom",
    strategy: t = "absolute",
    middleware: s = [],
    platform: r
  } = I, l = s.filter(Boolean), d = await (r.isRTL == null ? void 0 : r.isRTL(g));
  let h = await r.getElementRects({
    reference: A,
    floating: g,
    strategy: t
  }), {
    x: D,
    y: w
  } = nZ(h, C, d), p = C, b = {}, S = 0;
  for (let K = 0; K < l.length; K++) {
    const {
      name: Y,
      fn: T
    } = l[K], {
      x: E,
      y: H,
      data: R,
      reset: x
    } = await T({
      x: D,
      y: w,
      initialPlacement: C,
      placement: p,
      strategy: t,
      middlewareData: b,
      rects: h,
      platform: r,
      elements: {
        reference: A,
        floating: g
      }
    });
    D = E ?? D, w = H ?? w, b = {
      ...b,
      [Y]: {
        ...b[Y],
        ...R
      }
    }, x && S <= 50 && (S++, typeof x == "object" && (x.placement && (p = x.placement), x.rects && (h = x.rects === !0 ? await r.getElementRects({
      reference: A,
      floating: g,
      strategy: t
    }) : x.rects), {
      x: D,
      y: w
    } = nZ(h, p, d)), K = -1);
  }
  return {
    x: D,
    y: w,
    placement: p,
    strategy: t,
    middlewareData: b
  };
};
async function hM(A, g) {
  var I;
  g === void 0 && (g = {});
  const {
    x: C,
    y: t,
    platform: s,
    rects: r,
    elements: l,
    strategy: d
  } = A, {
    boundary: h = "clippingAncestors",
    rootBoundary: D = "viewport",
    elementContext: w = "floating",
    altBoundary: p = !1,
    padding: b = 0
  } = vo(g, A), S = SE(b), Y = l[p ? w === "floating" ? "reference" : "floating" : w], T = Wp(await s.getClippingRect({
    element: (I = await (s.isElement == null ? void 0 : s.isElement(Y))) == null || I ? Y : Y.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: h,
    rootBoundary: D,
    strategy: d
  })), E = w === "floating" ? {
    x: C,
    y: t,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, H = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), R = await (s.isElement == null ? void 0 : s.isElement(H)) ? await (s.getScale == null ? void 0 : s.getScale(H)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = Wp(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: E,
    offsetParent: H,
    strategy: d
  }) : E);
  return {
    top: (T.top - x.top + S.top) / R.y,
    bottom: (x.bottom - T.bottom + S.bottom) / R.y,
    left: (T.left - x.left + S.left) / R.x,
    right: (x.right - T.right + S.right) / R.x
  };
}
const MJ = (A) => ({
  name: "arrow",
  options: A,
  async fn(g) {
    const {
      x: I,
      y: C,
      placement: t,
      rects: s,
      platform: r,
      elements: l,
      middlewareData: d
    } = g, {
      element: h,
      padding: D = 0
    } = vo(A, g) || {};
    if (h == null)
      return {};
    const w = SE(D), p = {
      x: I,
      y: C
    }, b = oK(t), S = sK(b), K = await r.getDimensions(h), Y = b === "y", T = Y ? "top" : "left", E = Y ? "bottom" : "right", H = Y ? "clientHeight" : "clientWidth", R = s.reference[S] + s.reference[b] - p[b] - s.floating[S], x = p[b] - s.reference[b], U = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(h));
    let J = U ? U[H] : 0;
    (!J || !await (r.isElement == null ? void 0 : r.isElement(U))) && (J = l.floating[H] || s.floating[S]);
    const L = R / 2 - x / 2, eg = J / 2 - K[S] / 2 - 1, Mg = wr(w[T], eg), ig = wr(w[E], eg), Zg = Mg, Kg = J - K[S] - ig, mg = J / 2 - K[S] / 2 + L, Ng = xS(Zg, mg, Kg), cg = !d.arrow && kf(t) != null && mg !== Ng && s.reference[S] / 2 - (mg < Zg ? Mg : ig) - K[S] / 2 < 0, z = cg ? mg < Zg ? mg - Zg : mg - Kg : 0;
    return {
      [b]: p[b] + z,
      data: {
        [b]: Ng,
        centerOffset: mg - Ng - z,
        ...cg && {
          alignmentOffset: z
        }
      },
      reset: cg
    };
  }
}), wJ = function(A) {
  return A === void 0 && (A = {}), {
    name: "flip",
    options: A,
    async fn(g) {
      var I, C;
      const {
        placement: t,
        middlewareData: s,
        rects: r,
        initialPlacement: l,
        platform: d,
        elements: h
      } = g, {
        mainAxis: D = !0,
        crossAxis: w = !0,
        fallbackPlacements: p,
        fallbackStrategy: b = "bestFit",
        fallbackAxisSideDirection: S = "none",
        flipAlignment: K = !0,
        ...Y
      } = vo(A, g);
      if ((I = s.arrow) != null && I.alignmentOffset)
        return {};
      const T = Ho(t), E = ms(l), H = Ho(l) === l, R = await (d.isRTL == null ? void 0 : d.isRTL(h.floating)), x = p || (H || !K ? [kp(l)] : cJ(l)), U = S !== "none";
      !p && U && x.push(...hJ(l, K, S, R));
      const J = [l, ...x], L = await hM(g, Y), eg = [];
      let Mg = ((C = s.flip) == null ? void 0 : C.overflows) || [];
      if (D && eg.push(L[T]), w) {
        const mg = lJ(t, r, R);
        eg.push(L[mg[0]], L[mg[1]]);
      }
      if (Mg = [...Mg, {
        placement: t,
        overflows: eg
      }], !eg.every((mg) => mg <= 0)) {
        var ig, Zg;
        const mg = (((ig = s.flip) == null ? void 0 : ig.index) || 0) + 1, Ng = J[mg];
        if (Ng && (!(w === "alignment" ? E !== ms(Ng) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        Mg.every((Q) => ms(Q.placement) === E ? Q.overflows[0] > 0 : !0)))
          return {
            data: {
              index: mg,
              overflows: Mg
            },
            reset: {
              placement: Ng
            }
          };
        let cg = (Zg = Mg.filter((z) => z.overflows[0] <= 0).sort((z, Q) => z.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : Zg.placement;
        if (!cg)
          switch (b) {
            case "bestFit": {
              var Kg;
              const z = (Kg = Mg.filter((Q) => {
                if (U) {
                  const Bg = ms(Q.placement);
                  return Bg === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Bg === "y";
                }
                return !0;
              }).map((Q) => [Q.placement, Q.overflows.filter((Bg) => Bg > 0).reduce((Bg, Rg) => Bg + Rg, 0)]).sort((Q, Bg) => Q[1] - Bg[1])[0]) == null ? void 0 : Kg[0];
              z && (cg = z);
              break;
            }
            case "initialPlacement":
              cg = l;
              break;
          }
        if (t !== cg)
          return {
            reset: {
              placement: cg
            }
          };
      }
      return {};
    }
  };
};
function sZ(A, g) {
  return {
    top: A.top - g.height,
    right: A.right - g.width,
    bottom: A.bottom - g.height,
    left: A.left - g.width
  };
}
function oZ(A) {
  return sJ.some((g) => A[g] >= 0);
}
const BJ = function(A) {
  return A === void 0 && (A = {}), {
    name: "hide",
    options: A,
    async fn(g) {
      const {
        rects: I
      } = g, {
        strategy: C = "referenceHidden",
        ...t
      } = vo(A, g);
      switch (C) {
        case "referenceHidden": {
          const s = await hM(g, {
            ...t,
            elementContext: "reference"
          }), r = sZ(s, I.reference);
          return {
            data: {
              referenceHiddenOffsets: r,
              referenceHidden: oZ(r)
            }
          };
        }
        case "escaped": {
          const s = await hM(g, {
            ...t,
            altBoundary: !0
          }), r = sZ(s, I.floating);
          return {
            data: {
              escapedOffsets: r,
              escaped: oZ(r)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, GE = /* @__PURE__ */ new Set(["left", "top"]);
async function pJ(A, g) {
  const {
    placement: I,
    platform: C,
    elements: t
  } = A, s = await (C.isRTL == null ? void 0 : C.isRTL(t.floating)), r = Ho(I), l = kf(I), d = ms(I) === "y", h = GE.has(r) ? -1 : 1, D = s && d ? -1 : 1, w = vo(g, A);
  let {
    mainAxis: p,
    crossAxis: b,
    alignmentAxis: S
  } = typeof w == "number" ? {
    mainAxis: w,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: w.mainAxis || 0,
    crossAxis: w.crossAxis || 0,
    alignmentAxis: w.alignmentAxis
  };
  return l && typeof S == "number" && (b = l === "end" ? S * -1 : S), d ? {
    x: b * D,
    y: p * h
  } : {
    x: p * h,
    y: b * D
  };
}
const mJ = function(A) {
  return A === void 0 && (A = 0), {
    name: "offset",
    options: A,
    async fn(g) {
      var I, C;
      const {
        x: t,
        y: s,
        placement: r,
        middlewareData: l
      } = g, d = await pJ(g, A);
      return r === ((I = l.offset) == null ? void 0 : I.placement) && (C = l.arrow) != null && C.alignmentOffset ? {} : {
        x: t + d.x,
        y: s + d.y,
        data: {
          ...d,
          placement: r
        }
      };
    }
  };
}, bJ = function(A) {
  return A === void 0 && (A = {}), {
    name: "shift",
    options: A,
    async fn(g) {
      const {
        x: I,
        y: C,
        placement: t
      } = g, {
        mainAxis: s = !0,
        crossAxis: r = !1,
        limiter: l = {
          fn: (Y) => {
            let {
              x: T,
              y: E
            } = Y;
            return {
              x: T,
              y: E
            };
          }
        },
        ...d
      } = vo(A, g), h = {
        x: I,
        y: C
      }, D = await hM(g, d), w = ms(Ho(t)), p = nK(w);
      let b = h[p], S = h[w];
      if (s) {
        const Y = p === "y" ? "top" : "left", T = p === "y" ? "bottom" : "right", E = b + D[Y], H = b - D[T];
        b = xS(E, b, H);
      }
      if (r) {
        const Y = w === "y" ? "top" : "left", T = w === "y" ? "bottom" : "right", E = S + D[Y], H = S - D[T];
        S = xS(E, S, H);
      }
      const K = l.fn({
        ...g,
        [p]: b,
        [w]: S
      });
      return {
        ...K,
        data: {
          x: K.x - I,
          y: K.y - C,
          enabled: {
            [p]: s,
            [w]: r
          }
        }
      };
    }
  };
}, SJ = function(A) {
  return A === void 0 && (A = {}), {
    options: A,
    fn(g) {
      const {
        x: I,
        y: C,
        placement: t,
        rects: s,
        middlewareData: r
      } = g, {
        offset: l = 0,
        mainAxis: d = !0,
        crossAxis: h = !0
      } = vo(A, g), D = {
        x: I,
        y: C
      }, w = ms(t), p = nK(w);
      let b = D[p], S = D[w];
      const K = vo(l, g), Y = typeof K == "number" ? {
        mainAxis: K,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...K
      };
      if (d) {
        const H = p === "y" ? "height" : "width", R = s.reference[p] - s.floating[H] + Y.mainAxis, x = s.reference[p] + s.reference[H] - Y.mainAxis;
        b < R ? b = R : b > x && (b = x);
      }
      if (h) {
        var T, E;
        const H = p === "y" ? "width" : "height", R = GE.has(Ho(t)), x = s.reference[w] - s.floating[H] + (R && ((T = r.offset) == null ? void 0 : T[w]) || 0) + (R ? 0 : Y.crossAxis), U = s.reference[w] + s.reference[H] + (R ? 0 : ((E = r.offset) == null ? void 0 : E[w]) || 0) - (R ? Y.crossAxis : 0);
        S < x ? S = x : S > U && (S = U);
      }
      return {
        [p]: b,
        [w]: S
      };
    }
  };
}, GJ = function(A) {
  return A === void 0 && (A = {}), {
    name: "size",
    options: A,
    async fn(g) {
      var I, C;
      const {
        placement: t,
        rects: s,
        platform: r,
        elements: l
      } = g, {
        apply: d = () => {
        },
        ...h
      } = vo(A, g), D = await hM(g, h), w = Ho(t), p = kf(t), b = ms(t) === "y", {
        width: S,
        height: K
      } = s.floating;
      let Y, T;
      w === "top" || w === "bottom" ? (Y = w, T = p === (await (r.isRTL == null ? void 0 : r.isRTL(l.floating)) ? "start" : "end") ? "left" : "right") : (T = w, Y = p === "end" ? "top" : "bottom");
      const E = K - D.top - D.bottom, H = S - D.left - D.right, R = wr(K - D[Y], E), x = wr(S - D[T], H), U = !g.middlewareData.shift;
      let J = R, L = x;
      if ((I = g.middlewareData.shift) != null && I.enabled.x && (L = H), (C = g.middlewareData.shift) != null && C.enabled.y && (J = E), U && !p) {
        const Mg = Xt(D.left, 0), ig = Xt(D.right, 0), Zg = Xt(D.top, 0), Kg = Xt(D.bottom, 0);
        b ? L = S - 2 * (Mg !== 0 || ig !== 0 ? Mg + ig : Xt(D.left, D.right)) : J = K - 2 * (Zg !== 0 || Kg !== 0 ? Zg + Kg : Xt(D.top, D.bottom));
      }
      await d({
        ...g,
        availableWidth: L,
        availableHeight: J
      });
      const eg = await r.getDimensions(l.floating);
      return S !== eg.width || K !== eg.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function u0() {
  return typeof window < "u";
}
function Wf(A) {
  return KE(A) ? (A.nodeName || "").toLowerCase() : "#document";
}
function zt(A) {
  var g;
  return (A == null || (g = A.ownerDocument) == null ? void 0 : g.defaultView) || window;
}
function Ts(A) {
  var g;
  return (g = (KE(A) ? A.ownerDocument : A.document) || window.document) == null ? void 0 : g.documentElement;
}
function KE(A) {
  return u0() ? A instanceof Node || A instanceof zt(A).Node : !1;
}
function Sn(A) {
  return u0() ? A instanceof Element || A instanceof zt(A).Element : !1;
}
function Gs(A) {
  return u0() ? A instanceof HTMLElement || A instanceof zt(A).HTMLElement : !1;
}
function aZ(A) {
  return !u0() || typeof ShadowRoot > "u" ? !1 : A instanceof ShadowRoot || A instanceof zt(A).ShadowRoot;
}
const KJ = /* @__PURE__ */ new Set(["inline", "contents"]);
function PM(A) {
  const {
    overflow: g,
    overflowX: I,
    overflowY: C,
    display: t
  } = Gn(A);
  return /auto|scroll|overlay|hidden|clip/.test(g + C + I) && !KJ.has(t);
}
const TJ = /* @__PURE__ */ new Set(["table", "td", "th"]);
function YJ(A) {
  return TJ.has(Wf(A));
}
const PJ = [":popover-open", ":modal"];
function d0(A) {
  return PJ.some((g) => {
    try {
      return A.matches(g);
    } catch {
      return !1;
    }
  });
}
const ZJ = ["transform", "translate", "scale", "rotate", "perspective"], jJ = ["transform", "translate", "scale", "rotate", "perspective", "filter"], vJ = ["paint", "layout", "strict", "content"];
function aK(A) {
  const g = rK(), I = Sn(A) ? Gn(A) : A;
  return ZJ.some((C) => I[C] ? I[C] !== "none" : !1) || (I.containerType ? I.containerType !== "normal" : !1) || !g && (I.backdropFilter ? I.backdropFilter !== "none" : !1) || !g && (I.filter ? I.filter !== "none" : !1) || jJ.some((C) => (I.willChange || "").includes(C)) || vJ.some((C) => (I.contain || "").includes(C));
}
function HJ(A) {
  let g = Br(A);
  for (; Gs(g) && !vf(g); ) {
    if (aK(g))
      return g;
    if (d0(g))
      return null;
    g = Br(g);
  }
  return null;
}
function rK() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const EJ = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function vf(A) {
  return EJ.has(Wf(A));
}
function Gn(A) {
  return zt(A).getComputedStyle(A);
}
function f0(A) {
  return Sn(A) ? {
    scrollLeft: A.scrollLeft,
    scrollTop: A.scrollTop
  } : {
    scrollLeft: A.scrollX,
    scrollTop: A.scrollY
  };
}
function Br(A) {
  if (Wf(A) === "html")
    return A;
  const g = (
    // Step into the shadow DOM of the parent of a slotted node.
    A.assignedSlot || // DOM Element detected.
    A.parentNode || // ShadowRoot detected.
    aZ(A) && A.host || // Fallback.
    Ts(A)
  );
  return aZ(g) ? g.host : g;
}
function TE(A) {
  const g = Br(A);
  return vf(g) ? A.ownerDocument ? A.ownerDocument.body : A.body : Gs(g) && PM(g) ? g : TE(g);
}
function yM(A, g, I) {
  var C;
  g === void 0 && (g = []), I === void 0 && (I = !0);
  const t = TE(A), s = t === ((C = A.ownerDocument) == null ? void 0 : C.body), r = zt(t);
  if (s) {
    const l = US(r);
    return g.concat(r, r.visualViewport || [], PM(t) ? t : [], l && I ? yM(l) : []);
  }
  return g.concat(t, yM(t, [], I));
}
function US(A) {
  return A.parent && Object.getPrototypeOf(A.parent) ? A.frameElement : null;
}
function YE(A) {
  const g = Gn(A);
  let I = parseFloat(g.width) || 0, C = parseFloat(g.height) || 0;
  const t = Gs(A), s = t ? A.offsetWidth : I, r = t ? A.offsetHeight : C, l = Np(I) !== s || Np(C) !== r;
  return l && (I = s, C = r), {
    width: I,
    height: C,
    $: l
  };
}
function lK(A) {
  return Sn(A) ? A : A.contextElement;
}
function Bf(A) {
  const g = lK(A);
  if (!Gs(g))
    return bs(1);
  const I = g.getBoundingClientRect(), {
    width: C,
    height: t,
    $: s
  } = YE(g);
  let r = (s ? Np(I.width) : I.width) / C, l = (s ? Np(I.height) : I.height) / t;
  return (!r || !Number.isFinite(r)) && (r = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: r,
    y: l
  };
}
const RJ = /* @__PURE__ */ bs(0);
function PE(A) {
  const g = zt(A);
  return !rK() || !g.visualViewport ? RJ : {
    x: g.visualViewport.offsetLeft,
    y: g.visualViewport.offsetTop
  };
}
function OJ(A, g, I) {
  return g === void 0 && (g = !1), !I || g && I !== zt(A) ? !1 : g;
}
function Sc(A, g, I, C) {
  g === void 0 && (g = !1), I === void 0 && (I = !1);
  const t = A.getBoundingClientRect(), s = lK(A);
  let r = bs(1);
  g && (C ? Sn(C) && (r = Bf(C)) : r = Bf(A));
  const l = OJ(s, I, C) ? PE(s) : bs(0);
  let d = (t.left + l.x) / r.x, h = (t.top + l.y) / r.y, D = t.width / r.x, w = t.height / r.y;
  if (s) {
    const p = zt(s), b = C && Sn(C) ? zt(C) : C;
    let S = p, K = US(S);
    for (; K && C && b !== S; ) {
      const Y = Bf(K), T = K.getBoundingClientRect(), E = Gn(K), H = T.left + (K.clientLeft + parseFloat(E.paddingLeft)) * Y.x, R = T.top + (K.clientTop + parseFloat(E.paddingTop)) * Y.y;
      d *= Y.x, h *= Y.y, D *= Y.x, w *= Y.y, d += H, h += R, S = zt(K), K = US(S);
    }
  }
  return Wp({
    width: D,
    height: w,
    x: d,
    y: h
  });
}
function cK(A, g) {
  const I = f0(A).scrollLeft;
  return g ? g.left + I : Sc(Ts(A)).left + I;
}
function ZE(A, g, I) {
  I === void 0 && (I = !1);
  const C = A.getBoundingClientRect(), t = C.left + g.scrollLeft - (I ? 0 : (
    // RTL <body> scrollbar.
    cK(A, C)
  )), s = C.top + g.scrollTop;
  return {
    x: t,
    y: s
  };
}
function NJ(A) {
  let {
    elements: g,
    rect: I,
    offsetParent: C,
    strategy: t
  } = A;
  const s = t === "fixed", r = Ts(C), l = g ? d0(g.floating) : !1;
  if (C === r || l && s)
    return I;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = bs(1);
  const D = bs(0), w = Gs(C);
  if ((w || !w && !s) && ((Wf(C) !== "body" || PM(r)) && (d = f0(C)), Gs(C))) {
    const b = Sc(C);
    h = Bf(C), D.x = b.x + C.clientLeft, D.y = b.y + C.clientTop;
  }
  const p = r && !w && !s ? ZE(r, d, !0) : bs(0);
  return {
    width: I.width * h.x,
    height: I.height * h.y,
    x: I.x * h.x - d.scrollLeft * h.x + D.x + p.x,
    y: I.y * h.y - d.scrollTop * h.y + D.y + p.y
  };
}
function kJ(A) {
  return Array.from(A.getClientRects());
}
function WJ(A) {
  const g = Ts(A), I = f0(A), C = A.ownerDocument.body, t = Xt(g.scrollWidth, g.clientWidth, C.scrollWidth, C.clientWidth), s = Xt(g.scrollHeight, g.clientHeight, C.scrollHeight, C.clientHeight);
  let r = -I.scrollLeft + cK(A);
  const l = -I.scrollTop;
  return Gn(C).direction === "rtl" && (r += Xt(g.clientWidth, C.clientWidth) - t), {
    width: t,
    height: s,
    x: r,
    y: l
  };
}
function VJ(A, g) {
  const I = zt(A), C = Ts(A), t = I.visualViewport;
  let s = C.clientWidth, r = C.clientHeight, l = 0, d = 0;
  if (t) {
    s = t.width, r = t.height;
    const h = rK();
    (!h || h && g === "fixed") && (l = t.offsetLeft, d = t.offsetTop);
  }
  return {
    width: s,
    height: r,
    x: l,
    y: d
  };
}
const xJ = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function _J(A, g) {
  const I = Sc(A, !0, g === "fixed"), C = I.top + A.clientTop, t = I.left + A.clientLeft, s = Gs(A) ? Bf(A) : bs(1), r = A.clientWidth * s.x, l = A.clientHeight * s.y, d = t * s.x, h = C * s.y;
  return {
    width: r,
    height: l,
    x: d,
    y: h
  };
}
function rZ(A, g, I) {
  let C;
  if (g === "viewport")
    C = VJ(A, I);
  else if (g === "document")
    C = WJ(Ts(A));
  else if (Sn(g))
    C = _J(g, I);
  else {
    const t = PE(A);
    C = {
      x: g.x - t.x,
      y: g.y - t.y,
      width: g.width,
      height: g.height
    };
  }
  return Wp(C);
}
function jE(A, g) {
  const I = Br(A);
  return I === g || !Sn(I) || vf(I) ? !1 : Gn(I).position === "fixed" || jE(I, g);
}
function UJ(A, g) {
  const I = g.get(A);
  if (I)
    return I;
  let C = yM(A, [], !1).filter((l) => Sn(l) && Wf(l) !== "body"), t = null;
  const s = Gn(A).position === "fixed";
  let r = s ? Br(A) : A;
  for (; Sn(r) && !vf(r); ) {
    const l = Gn(r), d = aK(r);
    !d && l.position === "fixed" && (t = null), (s ? !d && !t : !d && l.position === "static" && !!t && xJ.has(t.position) || PM(r) && !d && jE(A, r)) ? C = C.filter((D) => D !== r) : t = l, r = Br(r);
  }
  return g.set(A, C), C;
}
function FJ(A) {
  let {
    element: g,
    boundary: I,
    rootBoundary: C,
    strategy: t
  } = A;
  const r = [...I === "clippingAncestors" ? d0(g) ? [] : UJ(g, this._c) : [].concat(I), C], l = r[0], d = r.reduce((h, D) => {
    const w = rZ(g, D, t);
    return h.top = Xt(w.top, h.top), h.right = wr(w.right, h.right), h.bottom = wr(w.bottom, h.bottom), h.left = Xt(w.left, h.left), h;
  }, rZ(g, l, t));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
function XJ(A) {
  const {
    width: g,
    height: I
  } = YE(A);
  return {
    width: g,
    height: I
  };
}
function QJ(A, g, I) {
  const C = Gs(g), t = Ts(g), s = I === "fixed", r = Sc(A, !0, s, g);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = bs(0);
  function h() {
    d.x = cK(t);
  }
  if (C || !C && !s)
    if ((Wf(g) !== "body" || PM(t)) && (l = f0(g)), C) {
      const b = Sc(g, !0, s, g);
      d.x = b.x + g.clientLeft, d.y = b.y + g.clientTop;
    } else t && h();
  s && !C && t && h();
  const D = t && !C && !s ? ZE(t, l) : bs(0), w = r.left + l.scrollLeft - d.x - D.x, p = r.top + l.scrollTop - d.y - D.y;
  return {
    x: w,
    y: p,
    width: r.width,
    height: r.height
  };
}
function Vb(A) {
  return Gn(A).position === "static";
}
function lZ(A, g) {
  if (!Gs(A) || Gn(A).position === "fixed")
    return null;
  if (g)
    return g(A);
  let I = A.offsetParent;
  return Ts(A) === I && (I = I.ownerDocument.body), I;
}
function vE(A, g) {
  const I = zt(A);
  if (d0(A))
    return I;
  if (!Gs(A)) {
    let t = Br(A);
    for (; t && !vf(t); ) {
      if (Sn(t) && !Vb(t))
        return t;
      t = Br(t);
    }
    return I;
  }
  let C = lZ(A, g);
  for (; C && YJ(C) && Vb(C); )
    C = lZ(C, g);
  return C && vf(C) && Vb(C) && !aK(C) ? I : C || HJ(A) || I;
}
const zJ = async function(A) {
  const g = this.getOffsetParent || vE, I = this.getDimensions, C = await I(A.floating);
  return {
    reference: QJ(A.reference, await g(A.floating), A.strategy),
    floating: {
      x: 0,
      y: 0,
      width: C.width,
      height: C.height
    }
  };
};
function JJ(A) {
  return Gn(A).direction === "rtl";
}
const LJ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: NJ,
  getDocumentElement: Ts,
  getClippingRect: FJ,
  getOffsetParent: vE,
  getElementRects: zJ,
  getClientRects: kJ,
  getDimensions: XJ,
  getScale: Bf,
  isElement: Sn,
  isRTL: JJ
};
function HE(A, g) {
  return A.x === g.x && A.y === g.y && A.width === g.width && A.height === g.height;
}
function qJ(A, g) {
  let I = null, C;
  const t = Ts(A);
  function s() {
    var l;
    clearTimeout(C), (l = I) == null || l.disconnect(), I = null;
  }
  function r(l, d) {
    l === void 0 && (l = !1), d === void 0 && (d = 1), s();
    const h = A.getBoundingClientRect(), {
      left: D,
      top: w,
      width: p,
      height: b
    } = h;
    if (l || g(), !p || !b)
      return;
    const S = QB(w), K = QB(t.clientWidth - (D + p)), Y = QB(t.clientHeight - (w + b)), T = QB(D), H = {
      rootMargin: -S + "px " + -K + "px " + -Y + "px " + -T + "px",
      threshold: Xt(0, wr(1, d)) || 1
    };
    let R = !0;
    function x(U) {
      const J = U[0].intersectionRatio;
      if (J !== d) {
        if (!R)
          return r();
        J ? r(!1, J) : C = setTimeout(() => {
          r(!1, 1e-7);
        }, 1e3);
      }
      J === 1 && !HE(h, A.getBoundingClientRect()) && r(), R = !1;
    }
    try {
      I = new IntersectionObserver(x, {
        ...H,
        // Handle <iframe>s
        root: t.ownerDocument
      });
    } catch {
      I = new IntersectionObserver(x, H);
    }
    I.observe(A);
  }
  return r(!0), s;
}
function $J(A, g, I, C) {
  C === void 0 && (C = {});
  const {
    ancestorScroll: t = !0,
    ancestorResize: s = !0,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = C, h = lK(A), D = t || s ? [...h ? yM(h) : [], ...yM(g)] : [];
  D.forEach((T) => {
    t && T.addEventListener("scroll", I, {
      passive: !0
    }), s && T.addEventListener("resize", I);
  });
  const w = h && l ? qJ(h, I) : null;
  let p = -1, b = null;
  r && (b = new ResizeObserver((T) => {
    let [E] = T;
    E && E.target === h && b && (b.unobserve(g), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var H;
      (H = b) == null || H.observe(g);
    })), I();
  }), h && !d && b.observe(h), b.observe(g));
  let S, K = d ? Sc(A) : null;
  d && Y();
  function Y() {
    const T = Sc(A);
    K && !HE(K, T) && I(), K = T, S = requestAnimationFrame(Y);
  }
  return I(), () => {
    var T;
    D.forEach((E) => {
      t && E.removeEventListener("scroll", I), s && E.removeEventListener("resize", I);
    }), w?.(), (T = b) == null || T.disconnect(), b = null, d && cancelAnimationFrame(S);
  };
}
const g5 = mJ, I5 = bJ, A5 = wJ, C5 = GJ, e5 = BJ, cZ = MJ, t5 = SJ, i5 = (A, g, I) => {
  const C = /* @__PURE__ */ new Map(), t = {
    platform: LJ,
    ...I
  }, s = {
    ...t.platform,
    _c: C
  };
  return DJ(A, g, {
    ...t,
    platform: s
  });
};
var n5 = typeof document < "u", s5 = function() {
}, rp = n5 ? Z.useLayoutEffect : s5;
function Vp(A, g) {
  if (A === g)
    return !0;
  if (typeof A != typeof g)
    return !1;
  if (typeof A == "function" && A.toString() === g.toString())
    return !0;
  let I, C, t;
  if (A && g && typeof A == "object") {
    if (Array.isArray(A)) {
      if (I = A.length, I !== g.length) return !1;
      for (C = I; C-- !== 0; )
        if (!Vp(A[C], g[C]))
          return !1;
      return !0;
    }
    if (t = Object.keys(A), I = t.length, I !== Object.keys(g).length)
      return !1;
    for (C = I; C-- !== 0; )
      if (!{}.hasOwnProperty.call(g, t[C]))
        return !1;
    for (C = I; C-- !== 0; ) {
      const s = t[C];
      if (!(s === "_owner" && A.$$typeof) && !Vp(A[s], g[s]))
        return !1;
    }
    return !0;
  }
  return A !== A && g !== g;
}
function EE(A) {
  return typeof window > "u" ? 1 : (A.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function uZ(A, g) {
  const I = EE(A);
  return Math.round(g * I) / I;
}
function xb(A) {
  const g = Z.useRef(A);
  return rp(() => {
    g.current = A;
  }), g;
}
function o5(A) {
  A === void 0 && (A = {});
  const {
    placement: g = "bottom",
    strategy: I = "absolute",
    middleware: C = [],
    platform: t,
    elements: {
      reference: s,
      floating: r
    } = {},
    transform: l = !0,
    whileElementsMounted: d,
    open: h
  } = A, [D, w] = Z.useState({
    x: 0,
    y: 0,
    strategy: I,
    placement: g,
    middlewareData: {},
    isPositioned: !1
  }), [p, b] = Z.useState(C);
  Vp(p, C) || b(C);
  const [S, K] = Z.useState(null), [Y, T] = Z.useState(null), E = Z.useCallback((Q) => {
    Q !== U.current && (U.current = Q, K(Q));
  }, []), H = Z.useCallback((Q) => {
    Q !== J.current && (J.current = Q, T(Q));
  }, []), R = s || S, x = r || Y, U = Z.useRef(null), J = Z.useRef(null), L = Z.useRef(D), eg = d != null, Mg = xb(d), ig = xb(t), Zg = xb(h), Kg = Z.useCallback(() => {
    if (!U.current || !J.current)
      return;
    const Q = {
      placement: g,
      strategy: I,
      middleware: p
    };
    ig.current && (Q.platform = ig.current), i5(U.current, J.current, Q).then((Bg) => {
      const Rg = {
        ...Bg,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Zg.current !== !1
      };
      mg.current && !Vp(L.current, Rg) && (L.current = Rg, QG.flushSync(() => {
        w(Rg);
      }));
    });
  }, [p, g, I, ig, Zg]);
  rp(() => {
    h === !1 && L.current.isPositioned && (L.current.isPositioned = !1, w((Q) => ({
      ...Q,
      isPositioned: !1
    })));
  }, [h]);
  const mg = Z.useRef(!1);
  rp(() => (mg.current = !0, () => {
    mg.current = !1;
  }), []), rp(() => {
    if (R && (U.current = R), x && (J.current = x), R && x) {
      if (Mg.current)
        return Mg.current(R, x, Kg);
      Kg();
    }
  }, [R, x, Kg, Mg, eg]);
  const Ng = Z.useMemo(() => ({
    reference: U,
    floating: J,
    setReference: E,
    setFloating: H
  }), [E, H]), cg = Z.useMemo(() => ({
    reference: R,
    floating: x
  }), [R, x]), z = Z.useMemo(() => {
    const Q = {
      position: I,
      left: 0,
      top: 0
    };
    if (!cg.floating)
      return Q;
    const Bg = uZ(cg.floating, D.x), Rg = uZ(cg.floating, D.y);
    return l ? {
      ...Q,
      transform: "translate(" + Bg + "px, " + Rg + "px)",
      ...EE(cg.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: I,
      left: Bg,
      top: Rg
    };
  }, [I, l, cg.floating, D.x, D.y]);
  return Z.useMemo(() => ({
    ...D,
    update: Kg,
    refs: Ng,
    elements: cg,
    floatingStyles: z
  }), [D, Kg, Ng, cg, z]);
}
const a5 = (A) => {
  function g(I) {
    return {}.hasOwnProperty.call(I, "current");
  }
  return {
    name: "arrow",
    options: A,
    fn(I) {
      const {
        element: C,
        padding: t
      } = typeof A == "function" ? A(I) : A;
      return C && g(C) ? C.current != null ? cZ({
        element: C.current,
        padding: t
      }).fn(I) : {} : C ? cZ({
        element: C,
        padding: t
      }).fn(I) : {};
    }
  };
}, r5 = (A, g) => ({
  ...g5(A),
  options: [A, g]
}), l5 = (A, g) => ({
  ...I5(A),
  options: [A, g]
}), c5 = (A, g) => ({
  ...t5(A),
  options: [A, g]
}), u5 = (A, g) => ({
  ...A5(A),
  options: [A, g]
}), d5 = (A, g) => ({
  ...C5(A),
  options: [A, g]
}), f5 = (A, g) => ({
  ...e5(A),
  options: [A, g]
}), h5 = (A, g) => ({
  ...a5(A),
  options: [A, g]
});
var y5 = "Arrow", RE = Z.forwardRef((A, g) => {
  const { children: I, width: C = 10, height: t = 5, ...s } = A;
  return /* @__PURE__ */ v.jsx(
    jI.svg,
    {
      ...s,
      ref: g,
      width: C,
      height: t,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: A.asChild ? I : /* @__PURE__ */ v.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
RE.displayName = y5;
var D5 = RE, uK = "Popper", [OE, h0] = Tn(uK), [M5, NE] = OE(uK), kE = (A) => {
  const { __scopePopper: g, children: I } = A, [C, t] = Z.useState(null);
  return /* @__PURE__ */ v.jsx(M5, { scope: g, anchor: C, onAnchorChange: t, children: I });
};
kE.displayName = uK;
var WE = "PopperAnchor", VE = Z.forwardRef(
  (A, g) => {
    const { __scopePopper: I, virtualRef: C, ...t } = A, s = NE(WE, I), r = Z.useRef(null), l = BA(g, r), d = Z.useRef(null);
    return Z.useEffect(() => {
      const h = d.current;
      d.current = C?.current || r.current, h !== d.current && s.onAnchorChange(d.current);
    }), C ? null : /* @__PURE__ */ v.jsx(jI.div, { ...t, ref: l });
  }
);
VE.displayName = WE;
var dK = "PopperContent", [w5, B5] = OE(dK), xE = Z.forwardRef(
  (A, g) => {
    const {
      __scopePopper: I,
      side: C = "bottom",
      sideOffset: t = 0,
      align: s = "center",
      alignOffset: r = 0,
      arrowPadding: l = 0,
      avoidCollisions: d = !0,
      collisionBoundary: h = [],
      collisionPadding: D = 0,
      sticky: w = "partial",
      hideWhenDetached: p = !1,
      updatePositionStrategy: b = "optimized",
      onPlaced: S,
      ...K
    } = A, Y = NE(dK, I), [T, E] = Z.useState(null), H = BA(g, (Yg) => E(Yg)), [R, x] = Z.useState(null), U = s0(R), J = U?.width ?? 0, L = U?.height ?? 0, eg = C + (s !== "center" ? "-" + s : ""), Mg = typeof D == "number" ? D : { top: 0, right: 0, bottom: 0, left: 0, ...D }, ig = Array.isArray(h) ? h : [h], Zg = ig.length > 0, Kg = {
      padding: Mg,
      boundary: ig.filter(m5),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Zg
    }, { refs: mg, floatingStyles: Ng, placement: cg, isPositioned: z, middlewareData: Q } = o5({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: eg,
      whileElementsMounted: (...Yg) => $J(...Yg, {
        animationFrame: b === "always"
      }),
      elements: {
        reference: Y.anchor
      },
      middleware: [
        r5({ mainAxis: t + L, alignmentAxis: r }),
        d && l5({
          mainAxis: !0,
          crossAxis: !1,
          limiter: w === "partial" ? c5() : void 0,
          ...Kg
        }),
        d && u5({ ...Kg }),
        d5({
          ...Kg,
          apply: ({ elements: Yg, rects: Wg, availableWidth: Xg, availableHeight: nI }) => {
            const { width: sI, height: Ug } = Wg.reference, fI = Yg.floating.style;
            fI.setProperty("--radix-popper-available-width", `${Xg}px`), fI.setProperty("--radix-popper-available-height", `${nI}px`), fI.setProperty("--radix-popper-anchor-width", `${sI}px`), fI.setProperty("--radix-popper-anchor-height", `${Ug}px`);
          }
        }),
        R && h5({ element: R, padding: l }),
        b5({ arrowWidth: J, arrowHeight: L }),
        p && f5({ strategy: "referenceHidden", ...Kg })
      ]
    }), [Bg, Rg] = FE(cg), N = bc(S);
    jo(() => {
      z && N?.();
    }, [z, N]);
    const F = Q.arrow?.x, rg = Q.arrow?.y, Cg = Q.arrow?.centerOffset !== 0, [Sg, kg] = Z.useState();
    return jo(() => {
      T && kg(window.getComputedStyle(T).zIndex);
    }, [T]), /* @__PURE__ */ v.jsx(
      "div",
      {
        ref: mg.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...Ng,
          transform: z ? Ng.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Sg,
          "--radix-popper-transform-origin": [
            Q.transformOrigin?.x,
            Q.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...Q.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: A.dir,
        children: /* @__PURE__ */ v.jsx(
          w5,
          {
            scope: I,
            placedSide: Bg,
            onArrowChange: x,
            arrowX: F,
            arrowY: rg,
            shouldHideArrow: Cg,
            children: /* @__PURE__ */ v.jsx(
              jI.div,
              {
                "data-side": Bg,
                "data-align": Rg,
                ...K,
                ref: H,
                style: {
                  ...K.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: z ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
xE.displayName = dK;
var _E = "PopperArrow", p5 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, UE = Z.forwardRef(function(g, I) {
  const { __scopePopper: C, ...t } = g, s = B5(_E, C), r = p5[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ v.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [r]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ v.jsx(
          D5,
          {
            ...t,
            ref: I,
            style: {
              ...t.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
UE.displayName = _E;
function m5(A) {
  return A !== null;
}
var b5 = (A) => ({
  name: "transformOrigin",
  options: A,
  fn(g) {
    const { placement: I, rects: C, middlewareData: t } = g, r = t.arrow?.centerOffset !== 0, l = r ? 0 : A.arrowWidth, d = r ? 0 : A.arrowHeight, [h, D] = FE(I), w = { start: "0%", center: "50%", end: "100%" }[D], p = (t.arrow?.x ?? 0) + l / 2, b = (t.arrow?.y ?? 0) + d / 2;
    let S = "", K = "";
    return h === "bottom" ? (S = r ? w : `${p}px`, K = `${-d}px`) : h === "top" ? (S = r ? w : `${p}px`, K = `${C.floating.height + d}px`) : h === "right" ? (S = `${-d}px`, K = r ? w : `${b}px`) : h === "left" && (S = `${C.floating.width + d}px`, K = r ? w : `${b}px`), { data: { x: S, y: K } };
  }
});
function FE(A) {
  const [g, I = "center"] = A.split("-");
  return [g, I];
}
var XE = kE, fK = VE, QE = xE, zE = UE, S5 = "Portal", y0 = Z.forwardRef((A, g) => {
  const { container: I, ...C } = A, [t, s] = Z.useState(!1);
  jo(() => s(!0), []);
  const r = I || t && globalThis?.document?.body;
  return r ? Uz.createPortal(/* @__PURE__ */ v.jsx(jI.div, { ...C, ref: g }), r) : null;
});
y0.displayName = S5;
function G5(A, g = globalThis?.document) {
  const I = bc(A);
  Z.useEffect(() => {
    const C = (t) => {
      t.key === "Escape" && I(t);
    };
    return g.addEventListener("keydown", C, { capture: !0 }), () => g.removeEventListener("keydown", C, { capture: !0 });
  }, [I, g]);
}
var K5 = "DismissableLayer", FS = "dismissableLayer.update", T5 = "dismissableLayer.pointerDownOutside", Y5 = "dismissableLayer.focusOutside", dZ, JE = Z.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), D0 = Z.forwardRef(
  (A, g) => {
    const {
      disableOutsidePointerEvents: I = !1,
      onEscapeKeyDown: C,
      onPointerDownOutside: t,
      onFocusOutside: s,
      onInteractOutside: r,
      onDismiss: l,
      ...d
    } = A, h = Z.useContext(JE), [D, w] = Z.useState(null), p = D?.ownerDocument ?? globalThis?.document, [, b] = Z.useState({}), S = BA(g, (J) => w(J)), K = Array.from(h.layers), [Y] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1), T = K.indexOf(Y), E = D ? K.indexOf(D) : -1, H = h.layersWithOutsidePointerEventsDisabled.size > 0, R = E >= T, x = j5((J) => {
      const L = J.target, eg = [...h.branches].some((Mg) => Mg.contains(L));
      !R || eg || (t?.(J), r?.(J), J.defaultPrevented || l?.());
    }, p), U = v5((J) => {
      const L = J.target;
      [...h.branches].some((Mg) => Mg.contains(L)) || (s?.(J), r?.(J), J.defaultPrevented || l?.());
    }, p);
    return G5((J) => {
      E === h.layers.size - 1 && (C?.(J), !J.defaultPrevented && l && (J.preventDefault(), l()));
    }, p), Z.useEffect(() => {
      if (D)
        return I && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (dZ = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), h.layersWithOutsidePointerEventsDisabled.add(D)), h.layers.add(D), fZ(), () => {
          I && h.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = dZ);
        };
    }, [D, p, I, h]), Z.useEffect(() => () => {
      D && (h.layers.delete(D), h.layersWithOutsidePointerEventsDisabled.delete(D), fZ());
    }, [D, h]), Z.useEffect(() => {
      const J = () => b({});
      return document.addEventListener(FS, J), () => document.removeEventListener(FS, J);
    }, []), /* @__PURE__ */ v.jsx(
      jI.div,
      {
        ...d,
        ref: S,
        style: {
          pointerEvents: H ? R ? "auto" : "none" : void 0,
          ...A.style
        },
        onFocusCapture: RI(A.onFocusCapture, U.onFocusCapture),
        onBlurCapture: RI(A.onBlurCapture, U.onBlurCapture),
        onPointerDownCapture: RI(
          A.onPointerDownCapture,
          x.onPointerDownCapture
        )
      }
    );
  }
);
D0.displayName = K5;
var P5 = "DismissableLayerBranch", Z5 = Z.forwardRef((A, g) => {
  const I = Z.useContext(JE), C = Z.useRef(null), t = BA(g, C);
  return Z.useEffect(() => {
    const s = C.current;
    if (s)
      return I.branches.add(s), () => {
        I.branches.delete(s);
      };
  }, [I.branches]), /* @__PURE__ */ v.jsx(jI.div, { ...A, ref: t });
});
Z5.displayName = P5;
function j5(A, g = globalThis?.document) {
  const I = bc(A), C = Z.useRef(!1), t = Z.useRef(() => {
  });
  return Z.useEffect(() => {
    const s = (l) => {
      if (l.target && !C.current) {
        let d = function() {
          LE(
            T5,
            I,
            h,
            { discrete: !0 }
          );
        };
        const h = { originalEvent: l };
        l.pointerType === "touch" ? (g.removeEventListener("click", t.current), t.current = d, g.addEventListener("click", t.current, { once: !0 })) : d();
      } else
        g.removeEventListener("click", t.current);
      C.current = !1;
    }, r = window.setTimeout(() => {
      g.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(r), g.removeEventListener("pointerdown", s), g.removeEventListener("click", t.current);
    };
  }, [g, I]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => C.current = !0
  };
}
function v5(A, g = globalThis?.document) {
  const I = bc(A), C = Z.useRef(!1);
  return Z.useEffect(() => {
    const t = (s) => {
      s.target && !C.current && LE(Y5, I, { originalEvent: s }, {
        discrete: !1
      });
    };
    return g.addEventListener("focusin", t), () => g.removeEventListener("focusin", t);
  }, [g, I]), {
    onFocusCapture: () => C.current = !0,
    onBlurCapture: () => C.current = !1
  };
}
function fZ() {
  const A = new CustomEvent(FS);
  document.dispatchEvent(A);
}
function LE(A, g, I, { discrete: C }) {
  const t = I.originalEvent.target, s = new CustomEvent(A, { bubbles: !1, cancelable: !0, detail: I });
  g && t.addEventListener(A, g, { once: !0 }), C ? Xz(t, s) : t.dispatchEvent(s);
}
var _b, M0 = "HoverCard", [qE, jgg] = Tn(M0, [
  h0
]), w0 = h0(), [H5, B0] = qE(M0), $E = (A) => {
  const {
    __scopeHoverCard: g,
    children: I,
    open: C,
    defaultOpen: t,
    onOpenChange: s,
    openDelay: r = 700,
    closeDelay: l = 300
  } = A, d = w0(g), h = Z.useRef(0), D = Z.useRef(0), w = Z.useRef(!1), p = Z.useRef(!1), [b, S] = mr({
    prop: C,
    defaultProp: t ?? !1,
    onChange: s,
    caller: M0
  }), K = Z.useCallback(() => {
    clearTimeout(D.current), h.current = window.setTimeout(() => S(!0), r);
  }, [r, S]), Y = Z.useCallback(() => {
    clearTimeout(h.current), !w.current && !p.current && (D.current = window.setTimeout(() => S(!1), l));
  }, [l, S]), T = Z.useCallback(() => S(!1), [S]);
  return Z.useEffect(() => () => {
    clearTimeout(h.current), clearTimeout(D.current);
  }, []), /* @__PURE__ */ v.jsx(
    H5,
    {
      scope: g,
      open: b,
      onOpenChange: S,
      onOpen: K,
      onClose: Y,
      onDismiss: T,
      hasSelectionRef: w,
      isPointerDownOnContentRef: p,
      children: /* @__PURE__ */ v.jsx(XE, { ...d, children: I })
    }
  );
};
$E.displayName = M0;
var gR = "HoverCardTrigger", IR = Z.forwardRef(
  (A, g) => {
    const { __scopeHoverCard: I, ...C } = A, t = B0(gR, I), s = w0(I);
    return /* @__PURE__ */ v.jsx(fK, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      jI.a,
      {
        "data-state": t.open ? "open" : "closed",
        ...C,
        ref: g,
        onPointerEnter: RI(A.onPointerEnter, _p(t.onOpen)),
        onPointerLeave: RI(A.onPointerLeave, _p(t.onClose)),
        onFocus: RI(A.onFocus, t.onOpen),
        onBlur: RI(A.onBlur, t.onClose),
        onTouchStart: RI(A.onTouchStart, (r) => r.preventDefault())
      }
    ) });
  }
);
IR.displayName = gR;
var hK = "HoverCardPortal", [E5, R5] = qE(hK, {
  forceMount: void 0
}), AR = (A) => {
  const { __scopeHoverCard: g, forceMount: I, children: C, container: t } = A, s = B0(hK, g);
  return /* @__PURE__ */ v.jsx(E5, { scope: g, forceMount: I, children: /* @__PURE__ */ v.jsx(Ks, { present: I || s.open, children: /* @__PURE__ */ v.jsx(y0, { asChild: !0, container: t, children: C }) }) });
};
AR.displayName = hK;
var xp = "HoverCardContent", CR = Z.forwardRef(
  (A, g) => {
    const I = R5(xp, A.__scopeHoverCard), { forceMount: C = I.forceMount, ...t } = A, s = B0(xp, A.__scopeHoverCard);
    return /* @__PURE__ */ v.jsx(Ks, { present: C || s.open, children: /* @__PURE__ */ v.jsx(
      O5,
      {
        "data-state": s.open ? "open" : "closed",
        ...t,
        onPointerEnter: RI(A.onPointerEnter, _p(s.onOpen)),
        onPointerLeave: RI(A.onPointerLeave, _p(s.onClose)),
        ref: g
      }
    ) });
  }
);
CR.displayName = xp;
var O5 = Z.forwardRef((A, g) => {
  const {
    __scopeHoverCard: I,
    onEscapeKeyDown: C,
    onPointerDownOutside: t,
    onFocusOutside: s,
    onInteractOutside: r,
    ...l
  } = A, d = B0(xp, I), h = w0(I), D = Z.useRef(null), w = BA(g, D), [p, b] = Z.useState(!1);
  return Z.useEffect(() => {
    if (p) {
      const S = document.body;
      return _b = S.style.userSelect || S.style.webkitUserSelect, S.style.userSelect = "none", S.style.webkitUserSelect = "none", () => {
        S.style.userSelect = _b, S.style.webkitUserSelect = _b;
      };
    }
  }, [p]), Z.useEffect(() => {
    if (D.current) {
      const S = () => {
        b(!1), d.isPointerDownOnContentRef.current = !1, setTimeout(() => {
          document.getSelection()?.toString() !== "" && (d.hasSelectionRef.current = !0);
        });
      };
      return document.addEventListener("pointerup", S), () => {
        document.removeEventListener("pointerup", S), d.hasSelectionRef.current = !1, d.isPointerDownOnContentRef.current = !1;
      };
    }
  }, [d.isPointerDownOnContentRef, d.hasSelectionRef]), Z.useEffect(() => {
    D.current && W5(D.current).forEach((K) => K.setAttribute("tabindex", "-1"));
  }), /* @__PURE__ */ v.jsx(
    D0,
    {
      asChild: !0,
      disableOutsidePointerEvents: !1,
      onInteractOutside: r,
      onEscapeKeyDown: C,
      onPointerDownOutside: t,
      onFocusOutside: RI(s, (S) => {
        S.preventDefault();
      }),
      onDismiss: d.onDismiss,
      children: /* @__PURE__ */ v.jsx(
        QE,
        {
          ...h,
          ...l,
          onPointerDown: RI(l.onPointerDown, (S) => {
            S.currentTarget.contains(S.target) && b(!0), d.hasSelectionRef.current = !1, d.isPointerDownOnContentRef.current = !0;
          }),
          ref: w,
          style: {
            ...l.style,
            userSelect: p ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: p ? "text" : void 0,
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      )
    }
  );
}), N5 = "HoverCardArrow", k5 = Z.forwardRef(
  (A, g) => {
    const { __scopeHoverCard: I, ...C } = A, t = w0(I);
    return /* @__PURE__ */ v.jsx(zE, { ...t, ...C, ref: g });
  }
);
k5.displayName = N5;
function _p(A) {
  return (g) => g.pointerType === "touch" ? void 0 : A();
}
function W5(A) {
  const g = [], I = document.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (C) => C.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; I.nextNode(); ) g.push(I.currentNode);
  return g;
}
var V5 = $E, x5 = IR, _5 = AR, U5 = CR;
function F5({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(V5, { "data-slot": "hover-card", ...A });
}
function X5({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(x5, { "data-slot": "hover-card-trigger", ...A });
}
function Q5({
  className: A,
  align: g = "center",
  sideOffset: I = 4,
  ...C
}) {
  return /* @__PURE__ */ v.jsx(_5, { "data-slot": "hover-card-portal", children: /* @__PURE__ */ v.jsx(
    U5,
    {
      "data-slot": "hover-card-content",
      align: g,
      sideOffset: I,
      className: kI(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
        A
      ),
      ...C
    }
  ) });
}
const z5 = ({
  activeZoom: A,
  autoRotate: g,
  layoutMode: I,
  viewState: C,
  initialCamera: t,
  pointSize: s,
  pointOpacity: r,
  isLoaded: l,
  currentTrait: d,
  coloringAnnotation: h,
  selectedCategories: D,
  onZoomChange: w,
  onAutoRotateToggle: p,
  onLayoutModeToggle: b,
  onPointSizeChange: S,
  onPointOpacityChange: K,
  onResetPointControls: Y,
  onViewStateUpdate: T,
  annotationConfig: E
}) => {
  const H = (x) => {
    if (A === x) return;
    let U;
    switch (x) {
      case "far":
        U = t.zoom - 2;
        break;
      case "near":
        U = t.zoom + 2;
        break;
      default:
        U = t.zoom;
        break;
    }
    T({
      ...C,
      zoom: U,
      transitionDuration: 600
    }), w(x);
  }, R = () => {
    T({
      ...t,
      transitionDuration: 600
    }), w("standard");
  };
  return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      L5,
      {
        activeZoom: A,
        autoRotate: g,
        layoutMode: I,
        currentTrait: d,
        isLoaded: l,
        onZoomClick: H,
        onAutoRotateToggle: p,
        onLayoutModeToggle: b,
        onResetCamera: R
      }
    ),
    /* @__PURE__ */ v.jsx(
      q5,
      {
        pointSize: s,
        pointOpacity: r,
        isLoaded: l,
        onPointSizeChange: S,
        onPointOpacityChange: K,
        onResetPointControls: Y
      }
    ),
    /* @__PURE__ */ v.jsx(
      J5,
      {
        currentTrait: d,
        coloringAnnotation: h,
        selectedCategories: D,
        viewState: C,
        annotationConfig: E
      }
    )
  ] });
}, J5 = ({
  currentTrait: A,
  coloringAnnotation: g,
  selectedCategories: I,
  viewState: C,
  annotationConfig: t
}) => {
  const [s, r] = Z.useState(!1), l = () => {
    const d = [];
    return Object.entries(I).forEach(
      ([h, D]) => {
        if (D !== null) {
          const w = t?.AnnoMaps?.[h], p = w && Array.isArray(w.Items) ? w.Items.find((b) => b?.Code === D)?.Name : w ? (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            w[D] ?? void 0
          ) : void 0;
          p ? d.push(p) : d.push(D.toString());
        }
      }
    ), d.length === 0 ? "None" : d.length > 3 ? `${d.slice(0, 3).join(";")} +${d.length - 3} more` : d.join(";");
  };
  return /* @__PURE__ */ v.jsxs(r0, { className: "w-full p-2 rounded-md flex justify-center gap-0", children: [
    /* @__PURE__ */ v.jsx(tK, { className: "items-center pb-0 px-1", children: /* @__PURE__ */ v.jsx(iK, { children: "Information" }) }),
    /* @__PURE__ */ v.jsx(l0, { className: "pb-0 px-0 flex-col flex ", children: /* @__PURE__ */ v.jsx(JG, { open: s, onOpenChange: r, children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 my-2 text-sm text-muted-foreground", children: [
      /* @__PURE__ */ v.jsxs("div", { children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Current Trait: " }),
        A || "None"
      ] }),
      /* @__PURE__ */ v.jsxs("div", { children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Current Annotation: " }),
        g
      ] }),
      /* @__PURE__ */ v.jsx(LG, { className: "flex items-center gap-2 text-xs text-primary hover:text-indigo-300 transition-colors", children: s ? /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(Az, { className: "h-3 w-3" }),
        "Show Less"
      ] }) : /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(ez, { className: "h-3 w-3" }),
        "Show More Details"
      ] }) }),
      /* @__PURE__ */ v.jsxs($G, { className: "space-y-2", children: [
        /* @__PURE__ */ v.jsxs("div", { children: [
          /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Selected Categories:" }),
          /* @__PURE__ */ v.jsx("div", { className: "text-xs mt-1 max-h-16 overflow-y-auto", children: l() })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { children: [
          /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Camera Zoom: " }),
          C.zoom?.toFixed(2)
        ] }),
        /* @__PURE__ */ v.jsxs("div", { children: [
          /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Camera Rotation:" }),
          " ",
          `[${C.rotationX?.toFixed(1)}, ${C.rotationOrbit?.toFixed(
            1
          )}]`
        ] }),
        /* @__PURE__ */ v.jsxs("div", { children: [
          /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Camera target: " }),
          `[${C.target?.map((d) => d.toFixed(1)).join(", ")}]`
        ] })
      ] })
    ] }) }) })
  ] });
}, L5 = ({
  activeZoom: A,
  autoRotate: g,
  layoutMode: I,
  currentTrait: C,
  isLoaded: t,
  onZoomClick: s,
  onAutoRotateToggle: r,
  onLayoutModeToggle: l,
  onResetCamera: d
}) => /* @__PURE__ */ v.jsxs(r0, { className: "w-full p-2 rounded-md", children: [
  /* @__PURE__ */ v.jsxs(tK, { className: "items-center pb-0 px-1", children: [
    /* @__PURE__ */ v.jsx(iK, { children: "Camera Controls" }),
    /* @__PURE__ */ v.jsx(ME, { children: /* @__PURE__ */ v.jsx($5, {}) })
  ] }),
  /* @__PURE__ */ v.jsx(l0, { className: "pb-0 px-0", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 lg:justify-between lg:flex-row", children: [
    /* @__PURE__ */ v.jsxs(
      q8,
      {
        defaultValue: "standard",
        value: A || "standard",
        className: "gap-2",
        disabled: !t,
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ v.jsx(
              Wb,
              {
                value: "far",
                id: "r2",
                onClick: () => s("far")
              }
            ),
            /* @__PURE__ */ v.jsx(XB, { htmlFor: "r2", children: "Far" })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ v.jsx(
              Wb,
              {
                value: "standard",
                id: "r1",
                onClick: () => s("standard")
              }
            ),
            /* @__PURE__ */ v.jsx(XB, { htmlFor: "r1", children: "Standard" })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ v.jsx(
              Wb,
              {
                value: "near",
                id: "r3",
                onClick: () => s("near")
              }
            ),
            /* @__PURE__ */ v.jsx(XB, { htmlFor: "r3", children: "Near" })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ v.jsx(
        Ke,
        {
          variant: "outline",
          size: "sm",
          onClick: d,
          disabled: !t,
          children: /* @__PURE__ */ v.jsxs("span", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ v.jsx(EH, { className: "h-4 w-4" }),
            "Reset View"
          ] })
        }
      ),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ v.jsx(
          nJ,
          {
            id: "autoRotate",
            checked: g,
            defaultChecked: !1,
            onCheckedChange: r
          }
        ),
        /* @__PURE__ */ v.jsx(XB, { htmlFor: "autoRotate", children: /* @__PURE__ */ v.jsxs("span", { className: "flex items-center gap-1", children: [
          /* @__PURE__ */ v.jsx(Hz, { className: "h-4 w-4" }),
          "AutoRotate"
        ] }) })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "flex justify-between items-center", children: /* @__PURE__ */ v.jsx(
        Ke,
        {
          variant: I === "2d-treemap" ? "default" : "outline",
          size: "sm",
          onClick: l,
          disabled: !t,
          children: /* @__PURE__ */ v.jsxs("span", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ v.jsx(gz, { className: "h-4 w-4" }),
            I === "3d" ? C ? "3D  Histogram" : "3D  Treemap" : I === "2d-histogram" ? "Histogram  3D" : "Treemap  3D"
          ] })
        }
      ) })
    ] })
  ] }) })
] }), q5 = ({
  pointSize: A,
  pointOpacity: g,
  isLoaded: I,
  onPointSizeChange: C,
  onPointOpacityChange: t,
  onResetPointControls: s
}) => /* @__PURE__ */ v.jsxs(r0, { className: "w-full p-2 rounded-md", children: [
  /* @__PURE__ */ v.jsxs(tK, { className: "items-center pb-0 px-1", children: [
    /* @__PURE__ */ v.jsx(iK, { children: "Piont Controls" }),
    /* @__PURE__ */ v.jsx(ME, { children: /* @__PURE__ */ v.jsx(
      Ke,
      {
        variant: "outline",
        size: "sm",
        onClick: s,
        disabled: !I,
        children: /* @__PURE__ */ v.jsxs("span", { className: "flex items-center gap-1", children: [
          /* @__PURE__ */ v.jsx(EH, { className: "h-3 w-3" }),
          "Reset"
        ] })
      }
    ) })
  ] }),
  /* @__PURE__ */ v.jsxs(l0, { className: "pb-0 px-0 flex-col flex ", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 my-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 lg:justify-between lg:flex-row", children: [
        /* @__PURE__ */ v.jsx("label", { className: "text-sm", children: "Size" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-xs", children: A.toFixed(1) })
      ] }),
      /* @__PURE__ */ v.jsx(
        WS,
        {
          min: 0.1,
          max: 3,
          step: 0.1,
          value: [A],
          onValueChange: (r) => C(r[0]),
          disabled: !I
        }
      )
    ] }),
    /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 my-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex justify-between", children: [
        /* @__PURE__ */ v.jsx("label", { className: "text-sm", children: "Opacity" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-xs", children: g.toFixed(1) })
      ] }),
      /* @__PURE__ */ v.jsx(
        WS,
        {
          min: 0.1,
          max: 1,
          step: 0.05,
          value: [g],
          onValueChange: (r) => t(r[0]),
          disabled: !I
        }
      )
    ] })
  ] })
] }), $5 = () => /* @__PURE__ */ v.jsxs(F5, { children: [
  /* @__PURE__ */ v.jsx(X5, { asChild: !0, children: /* @__PURE__ */ v.jsx(
    Ke,
    {
      variant: "ghost",
      size: "sm",
      className: "h-3 w-3 p-0 ",
      title: "View Controls Help",
      children: /* @__PURE__ */ v.jsx(rz, { className: "" })
    }
  ) }),
  /* @__PURE__ */ v.jsx(Q5, { className: "w-64 p-3", align: "end", children: /* @__PURE__ */ v.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ v.jsxs("div", { className: "text-xs space-y-1", children: [
    /* @__PURE__ */ v.jsxs("div", { children: [
      "",
      " ",
      /* @__PURE__ */ v.jsxs("strong", { children: [
        "Scroll /",
        " ",
        /* @__PURE__ */ v.jsx("kbd", { className: "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 items-center gap-1 rounded border px-1.5 font-mono text-[10px] font-medium opacity-100 select-none", children: "+-" }),
        ":"
      ] }),
      " ",
      "Zoom in/out"
    ] }),
    /* @__PURE__ */ v.jsxs("div", { children: [
      " ",
      /* @__PURE__ */ v.jsx("strong", { children: "Drag:" }),
      " Rotate (3D) / Pan (2D)"
    ] }),
    /* @__PURE__ */ v.jsxs("div", { children: [
      "",
      " ",
      /* @__PURE__ */ v.jsxs("strong", { children: [
        " ",
        /* @__PURE__ */ v.jsx("kbd", { className: "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 items-center gap-1 rounded border px-1.5 font-mono text-[10px] font-medium opacity-100 select-none", children: "Shift" }),
        " ",
        "+ Drag:"
      ] }),
      " ",
      "Pan (3D)"
    ] }),
    /* @__PURE__ */ v.jsxs("div", { children: [
      "",
      " ",
      /* @__PURE__ */ v.jsxs("strong", { children: [
        /* @__PURE__ */ v.jsx("kbd", { className: "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 items-center gap-1 rounded border px-1.5 font-mono text-[10px] font-medium opacity-100 select-none", children: "" }),
        ":"
      ] }),
      " ",
      "Pan (3D & 2D)"
    ] }),
    /* @__PURE__ */ v.jsxs("div", { children: [
      "",
      " ",
      /* @__PURE__ */ v.jsxs("strong", { children: [
        " ",
        /* @__PURE__ */ v.jsx("kbd", { className: "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 items-center gap-1 rounded border px-1.5 font-mono text-[10px] font-medium opacity-100 select-none", children: "Shift" }),
        " ",
        "+",
        " ",
        /* @__PURE__ */ v.jsx("kbd", { className: "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 items-center gap-1 rounded border px-1.5 font-mono text-[10px] font-medium opacity-100 select-none", children: "" }),
        ":"
      ] }),
      " ",
      "Roate (3D)"
    ] })
  ] }) }) })
] }), gL = typeof window < "u" ? Z.useLayoutEffect : Z.useEffect;
function Up(A, g) {
  for (; A; ) {
    if (A === g)
      return !0;
    A = Object.getPrototypeOf(A);
  }
  return !1;
}
const IL = { position: "absolute", zIndex: -1 };
function eR(A, g) {
  if (typeof A == "function")
    return A(g);
  if (Array.isArray(A))
    return A.map((I) => eR(I, g));
  if (p0(A)) {
    if (AL(A))
      return g.style = IL, Z.cloneElement(A, g);
    if (CL(A))
      return Z.cloneElement(A, g);
  }
  return A;
}
function p0(A) {
  return A && typeof A == "object" && "type" in A || !1;
}
function AL(A) {
  return A.props?.mapStyle;
}
function CL(A) {
  const g = A.type;
  return g && g.deckGLViewProps;
}
function XS(A) {
  if (typeof A == "function")
    return Z.createElement(Mr, {}, A);
  if (Array.isArray(A))
    return A.map(XS);
  if (p0(A)) {
    if (A.type === Z.Fragment)
      return XS(A.props.children);
    if (Up(A.type, Mr))
      return A;
  }
  return A;
}
function eL({ children: A, layers: g = [], views: I = null }) {
  const C = [], t = [], s = {};
  return Z.Children.forEach(XS(A), (r) => {
    if (p0(r)) {
      const l = r.type;
      if (Up(l, TM)) {
        const d = tL(l, r.props);
        t.push(d);
      } else
        C.push(r);
      if (Up(l, Mr) && l !== Mr && r.props.id) {
        const d = new l(r.props);
        s[d.id] = d;
      }
    } else r && C.push(r);
  }), Object.keys(s).length > 0 && (Array.isArray(I) ? I.forEach((r) => {
    s[r.id] = r;
  }) : I && (s[I.id] = I), I = Object.values(s)), g = t.length > 0 ? [...t, ...g] : g, { layers: g, children: C, views: I };
}
function tL(A, g) {
  const I = {}, C = A.defaultProps || {};
  for (const t in g)
    C[t] !== g[t] && (I[t] = g[t]);
  return new A(I);
}
const iL = Z.createContext();
function nL({ children: A, deck: g, ContextProvider: I = iL.Provider }) {
  const { viewManager: C } = g || {};
  if (!C || !C.views.length)
    return [];
  const t = {}, s = C.views[0].id;
  for (const r of A) {
    let l = s, d = r;
    p0(r) && Up(r.type, Mr) && (l = r.props.id || s, d = r.props.children);
    const h = C.getViewport(l), D = C.getViewState(l);
    if (h) {
      D.padding = h.padding;
      const { x: w, y: p, width: b, height: S } = h;
      d = eR(d, {
        x: w,
        y: p,
        width: b,
        height: S,
        viewport: h,
        viewState: D
      }), t[l] || (t[l] = {
        viewport: h,
        children: []
      }), t[l].children.push(d);
    }
  }
  return Object.keys(t).map((r) => {
    const { viewport: l, children: d } = t[r], { x: h, y: D, width: w, height: p } = l, b = {
      position: "absolute",
      left: h,
      top: D,
      width: w,
      height: p
    }, S = `view-${r}`, K = Z.createElement("div", { key: S, id: S, style: b }, ...d), Y = {
      deck: g,
      viewport: l,
      // @ts-expect-error accessing protected property
      container: g.canvas.offsetParent,
      // @ts-expect-error accessing protected property
      eventManager: g.eventManager,
      onViewStateChange: (E) => {
        E.viewId = r, g._onViewStateChange(E);
      },
      widgets: []
    }, T = `view-${r}-context`;
    return Z.createElement(I, { key: T, value: Y }, K);
  });
}
const sL = {
  mixBlendMode: null
};
function oL({ width: A, height: g, style: I }) {
  const C = {
    position: "absolute",
    zIndex: 0,
    left: 0,
    top: 0,
    width: A,
    height: g
  }, t = {
    left: 0,
    top: 0
  };
  if (I)
    for (const s in I)
      s in sL ? t[s] = I[s] : C[s] = I[s];
  return { containerStyle: C, canvasStyle: t };
}
function aL(A) {
  return {
    get deck() {
      return A.deck;
    },
    // The following method can only be called after ref is available, by which point deck is defined in useEffect
    pickObject: (g) => A.deck.pickObject(g),
    pickMultipleObjects: (g) => A.deck.pickMultipleObjects(g),
    pickObjects: (g) => A.deck.pickObjects(g)
  };
}
function tR(A) {
  A.redrawReason && (A.deck._drawLayers(A.redrawReason), A.redrawReason = null);
}
function rL(A, g, I) {
  const C = new g({
    ...I,
    // The Deck's animation loop is independent from React's render cycle, causing potential
    // synchronization issues. We provide this custom render function to make sure that React
    // and Deck update on the same schedule.
    // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale
    _customRender: I.deviceProps?.adapters?.[0]?.type === "webgpu" ? void 0 : (t) => {
      A.redrawReason = t;
      const s = C.getViewports();
      A.lastRenderedViewports !== s ? A.forceUpdate() : tR(A);
    }
  });
  return C;
}
function lL(A, g) {
  const [I, C] = Z.useState(0), s = Z.useRef({
    control: null,
    version: I,
    forceUpdate: () => C((x) => x + 1)
  }).current, r = Z.useRef(null), l = Z.useRef(null), d = Z.useMemo(() => eL(A), [A.layers, A.views, A.children]);
  let h = !0;
  const D = (x) => h && A.viewState ? (s.viewStateUpdateRequested = x, null) : (s.viewStateUpdateRequested = null, A.onViewStateChange?.(x)), w = (x) => {
    h ? s.interactionStateUpdateRequested = x : (s.interactionStateUpdateRequested = null, A.onInteractionStateChange?.(x));
  }, p = Z.useMemo(() => {
    const x = {
      widgets: [],
      ...A,
      // Override user styling props. We will set the canvas style in render()
      style: null,
      width: "100%",
      height: "100%",
      parent: r.current,
      canvas: l.current,
      layers: d.layers,
      views: d.views,
      onViewStateChange: D,
      onInteractionStateChange: w
    };
    return delete x._customRender, s.deck && s.deck.setProps(x), x;
  }, [A]);
  Z.useEffect(() => {
    const x = A.Deck || e0;
    return s.deck = rL(s, x, {
      ...p,
      parent: r.current,
      canvas: l.current
    }), () => s.deck?.finalize();
  }, []), gL(() => {
    tR(s);
    const { viewStateUpdateRequested: x, interactionStateUpdateRequested: U } = s;
    x && D(x), U && w(U);
  }), Z.useImperativeHandle(g, () => aL(s), []);
  const b = s.deck && s.deck.isInitialized ? s.deck.getViewports() : void 0, { ContextProvider: S, width: K = "100%", height: Y = "100%", id: T, style: E } = A, { containerStyle: H, canvasStyle: R } = Z.useMemo(() => oL({ width: K, height: Y, style: E }), [K, Y, E]);
  if (!s.viewStateUpdateRequested && s.lastRenderedViewports === b || // case 2
  s.version !== I) {
    s.lastRenderedViewports = b, s.version = I;
    const x = nL({
      children: d.children,
      deck: s.deck,
      ContextProvider: S
    }), U = Z.createElement("canvas", {
      key: "canvas",
      id: T || "deckgl-overlay",
      ref: l,
      style: R
    });
    s.control = Z.createElement("div", { id: `${T || "deckgl"}-wrapper`, ref: r, style: H }, [U, x]);
  }
  return h = !1, s.control;
}
const cL = Z.forwardRef(lL);
function uL(A) {
  return Object.prototype.toString.call(A) === "[object Object]";
}
function hZ(A) {
  return uL(A) || Array.isArray(A);
}
function dL() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function yK(A, g) {
  const I = Object.keys(A), C = Object.keys(g);
  if (I.length !== C.length) return !1;
  const t = JSON.stringify(Object.keys(A.breakpoints || {})), s = JSON.stringify(Object.keys(g.breakpoints || {}));
  return t !== s ? !1 : I.every((r) => {
    const l = A[r], d = g[r];
    return typeof l == "function" ? `${l}` == `${d}` : !hZ(l) || !hZ(d) ? l === d : yK(l, d);
  });
}
function yZ(A) {
  return A.concat().sort((g, I) => g.name > I.name ? 1 : -1).map((g) => g.options);
}
function fL(A, g) {
  if (A.length !== g.length) return !1;
  const I = yZ(A), C = yZ(g);
  return I.every((t, s) => {
    const r = C[s];
    return yK(t, r);
  });
}
function DK(A) {
  return typeof A == "number";
}
function QS(A) {
  return typeof A == "string";
}
function m0(A) {
  return typeof A == "boolean";
}
function DZ(A) {
  return Object.prototype.toString.call(A) === "[object Object]";
}
function WA(A) {
  return Math.abs(A);
}
function MK(A) {
  return Math.sign(A);
}
function aM(A, g) {
  return WA(A - g);
}
function hL(A, g) {
  if (A === 0 || g === 0 || WA(A) <= WA(g)) return 0;
  const I = aM(WA(A), WA(g));
  return WA(I / A);
}
function yL(A) {
  return Math.round(A * 100) / 100;
}
function DM(A) {
  return MM(A).map(Number);
}
function bn(A) {
  return A[ZM(A)];
}
function ZM(A) {
  return Math.max(0, A.length - 1);
}
function wK(A, g) {
  return g === ZM(A);
}
function MZ(A, g = 0) {
  return Array.from(Array(A), (I, C) => g + C);
}
function MM(A) {
  return Object.keys(A);
}
function iR(A, g) {
  return [A, g].reduce((I, C) => (MM(C).forEach((t) => {
    const s = I[t], r = C[t], l = DZ(s) && DZ(r);
    I[t] = l ? iR(s, r) : r;
  }), I), {});
}
function zS(A, g) {
  return typeof g.MouseEvent < "u" && A instanceof g.MouseEvent;
}
function DL(A, g) {
  const I = {
    start: C,
    center: t,
    end: s
  };
  function C() {
    return 0;
  }
  function t(d) {
    return s(d) / 2;
  }
  function s(d) {
    return g - d;
  }
  function r(d, h) {
    return QS(A) ? I[A](d) : A(g, d, h);
  }
  return {
    measure: r
  };
}
function wM() {
  let A = [];
  function g(t, s, r, l = {
    passive: !0
  }) {
    let d;
    if ("addEventListener" in t)
      t.addEventListener(s, r, l), d = () => t.removeEventListener(s, r, l);
    else {
      const h = t;
      h.addListener(r), d = () => h.removeListener(r);
    }
    return A.push(d), C;
  }
  function I() {
    A = A.filter((t) => t());
  }
  const C = {
    add: g,
    clear: I
  };
  return C;
}
function ML(A, g, I, C) {
  const t = wM(), s = 1e3 / 60;
  let r = null, l = 0, d = 0;
  function h() {
    t.add(A, "visibilitychange", () => {
      A.hidden && S();
    });
  }
  function D() {
    b(), t.clear();
  }
  function w(Y) {
    if (!d) return;
    r || (r = Y, I(), I());
    const T = Y - r;
    for (r = Y, l += T; l >= s; )
      I(), l -= s;
    const E = l / s;
    C(E), d && (d = g.requestAnimationFrame(w));
  }
  function p() {
    d || (d = g.requestAnimationFrame(w));
  }
  function b() {
    g.cancelAnimationFrame(d), r = null, l = 0, d = 0;
  }
  function S() {
    r = null, l = 0;
  }
  return {
    init: h,
    destroy: D,
    start: p,
    stop: b,
    update: I,
    render: C
  };
}
function wL(A, g) {
  const I = g === "rtl", C = A === "y", t = C ? "y" : "x", s = C ? "x" : "y", r = !C && I ? -1 : 1, l = D(), d = w();
  function h(S) {
    const {
      height: K,
      width: Y
    } = S;
    return C ? K : Y;
  }
  function D() {
    return C ? "top" : I ? "right" : "left";
  }
  function w() {
    return C ? "bottom" : I ? "left" : "right";
  }
  function p(S) {
    return S * r;
  }
  return {
    scroll: t,
    cross: s,
    startEdge: l,
    endEdge: d,
    measureSize: h,
    direction: p
  };
}
function Gc(A = 0, g = 0) {
  const I = WA(A - g);
  function C(h) {
    return h < A;
  }
  function t(h) {
    return h > g;
  }
  function s(h) {
    return C(h) || t(h);
  }
  function r(h) {
    return s(h) ? C(h) ? A : g : h;
  }
  function l(h) {
    return I ? h - I * Math.ceil((h - g) / I) : h;
  }
  return {
    length: I,
    max: g,
    min: A,
    constrain: r,
    reachedAny: s,
    reachedMax: t,
    reachedMin: C,
    removeOffset: l
  };
}
function nR(A, g, I) {
  const {
    constrain: C
  } = Gc(0, A), t = A + 1;
  let s = r(g);
  function r(p) {
    return I ? WA((t + p) % t) : C(p);
  }
  function l() {
    return s;
  }
  function d(p) {
    return s = r(p), w;
  }
  function h(p) {
    return D().set(l() + p);
  }
  function D() {
    return nR(A, l(), I);
  }
  const w = {
    get: l,
    set: d,
    add: h,
    clone: D
  };
  return w;
}
function BL(A, g, I, C, t, s, r, l, d, h, D, w, p, b, S, K, Y, T, E) {
  const {
    cross: H,
    direction: R
  } = A, x = ["INPUT", "SELECT", "TEXTAREA"], U = {
    passive: !1
  }, J = wM(), L = wM(), eg = Gc(50, 225).constrain(b.measure(20)), Mg = {
    mouse: 300,
    touch: 400
  }, ig = {
    mouse: 500,
    touch: 600
  }, Zg = S ? 43 : 25;
  let Kg = !1, mg = 0, Ng = 0, cg = !1, z = !1, Q = !1, Bg = !1;
  function Rg(Ug) {
    if (!E) return;
    function fI(oA) {
      (m0(E) || E(Ug, oA)) && kg(oA);
    }
    const VI = g;
    J.add(VI, "dragstart", (oA) => oA.preventDefault(), U).add(VI, "touchmove", () => {
    }, U).add(VI, "touchend", () => {
    }).add(VI, "touchstart", fI).add(VI, "mousedown", fI).add(VI, "touchcancel", Wg).add(VI, "contextmenu", Wg).add(VI, "click", Xg, !0);
  }
  function N() {
    J.clear(), L.clear();
  }
  function F() {
    const Ug = Bg ? I : g;
    L.add(Ug, "touchmove", Yg, U).add(Ug, "touchend", Wg).add(Ug, "mousemove", Yg, U).add(Ug, "mouseup", Wg);
  }
  function rg(Ug) {
    const fI = Ug.nodeName || "";
    return x.includes(fI);
  }
  function Cg() {
    return (S ? ig : Mg)[Bg ? "mouse" : "touch"];
  }
  function Sg(Ug, fI) {
    const VI = w.add(MK(Ug) * -1), oA = D.byDistance(Ug, !S).distance;
    return S || WA(Ug) < eg ? oA : Y && fI ? oA * 0.5 : D.byIndex(VI.get(), 0).distance;
  }
  function kg(Ug) {
    const fI = zS(Ug, C);
    Bg = fI, Q = S && fI && !Ug.buttons && Kg, Kg = aM(t.get(), r.get()) >= 2, !(fI && Ug.button !== 0) && (rg(Ug.target) || (cg = !0, s.pointerDown(Ug), h.useFriction(0).useDuration(0), t.set(r), F(), mg = s.readPoint(Ug), Ng = s.readPoint(Ug, H), p.emit("pointerDown")));
  }
  function Yg(Ug) {
    if (!zS(Ug, C) && Ug.touches.length >= 2) return Wg(Ug);
    const VI = s.readPoint(Ug), oA = s.readPoint(Ug, H), _C = aM(VI, mg), UC = aM(oA, Ng);
    if (!z && !Bg && (!Ug.cancelable || (z = _C > UC, !z)))
      return Wg(Ug);
    const vI = s.pointerMove(Ug);
    _C > K && (Q = !0), h.useFriction(0.3).useDuration(0.75), l.start(), t.add(R(vI)), Ug.preventDefault();
  }
  function Wg(Ug) {
    const VI = D.byDistance(0, !1).index !== w.get(), oA = s.pointerUp(Ug) * Cg(), _C = Sg(R(oA), VI), UC = hL(oA, _C), vI = Zg - 10 * UC, CC = T + UC / 50;
    z = !1, cg = !1, L.clear(), h.useDuration(vI).useFriction(CC), d.distance(_C, !S), Bg = !1, p.emit("pointerUp");
  }
  function Xg(Ug) {
    Q && (Ug.stopPropagation(), Ug.preventDefault(), Q = !1);
  }
  function nI() {
    return cg;
  }
  return {
    init: Rg,
    destroy: N,
    pointerDown: nI
  };
}
function pL(A, g) {
  let C, t;
  function s(w) {
    return w.timeStamp;
  }
  function r(w, p) {
    const S = `client${(p || A.scroll) === "x" ? "X" : "Y"}`;
    return (zS(w, g) ? w : w.touches[0])[S];
  }
  function l(w) {
    return C = w, t = w, r(w);
  }
  function d(w) {
    const p = r(w) - r(t), b = s(w) - s(C) > 170;
    return t = w, b && (C = w), p;
  }
  function h(w) {
    if (!C || !t) return 0;
    const p = r(t) - r(C), b = s(w) - s(C), S = s(w) - s(t) > 170, K = p / b;
    return b && !S && WA(K) > 0.1 ? K : 0;
  }
  return {
    pointerDown: l,
    pointerMove: d,
    pointerUp: h,
    readPoint: r
  };
}
function mL() {
  function A(I) {
    const {
      offsetTop: C,
      offsetLeft: t,
      offsetWidth: s,
      offsetHeight: r
    } = I;
    return {
      top: C,
      right: t + s,
      bottom: C + r,
      left: t,
      width: s,
      height: r
    };
  }
  return {
    measure: A
  };
}
function bL(A) {
  function g(C) {
    return A * (C / 100);
  }
  return {
    measure: g
  };
}
function SL(A, g, I, C, t, s, r) {
  const l = [A].concat(C);
  let d, h, D = [], w = !1;
  function p(Y) {
    return t.measureSize(r.measure(Y));
  }
  function b(Y) {
    if (!s) return;
    h = p(A), D = C.map(p);
    function T(E) {
      for (const H of E) {
        if (w) return;
        const R = H.target === A, x = C.indexOf(H.target), U = R ? h : D[x], J = p(R ? A : C[x]);
        if (WA(J - U) >= 0.5) {
          Y.reInit(), g.emit("resize");
          break;
        }
      }
    }
    d = new ResizeObserver((E) => {
      (m0(s) || s(Y, E)) && T(E);
    }), I.requestAnimationFrame(() => {
      l.forEach((E) => d.observe(E));
    });
  }
  function S() {
    w = !0, d && d.disconnect();
  }
  return {
    init: b,
    destroy: S
  };
}
function GL(A, g, I, C, t, s) {
  let r = 0, l = 0, d = t, h = s, D = A.get(), w = 0;
  function p() {
    const U = C.get() - A.get(), J = !d;
    let L = 0;
    return J ? (r = 0, I.set(C), A.set(C), L = U) : (I.set(A), r += U / d, r *= h, D += r, A.add(r), L = D - w), l = MK(L), w = D, x;
  }
  function b() {
    const U = C.get() - g.get();
    return WA(U) < 1e-3;
  }
  function S() {
    return d;
  }
  function K() {
    return l;
  }
  function Y() {
    return r;
  }
  function T() {
    return H(t);
  }
  function E() {
    return R(s);
  }
  function H(U) {
    return d = U, x;
  }
  function R(U) {
    return h = U, x;
  }
  const x = {
    direction: K,
    duration: S,
    velocity: Y,
    seek: p,
    settled: b,
    useBaseFriction: E,
    useBaseDuration: T,
    useFriction: R,
    useDuration: H
  };
  return x;
}
function KL(A, g, I, C, t) {
  const s = t.measure(10), r = t.measure(50), l = Gc(0.1, 0.99);
  let d = !1;
  function h() {
    return !(d || !A.reachedAny(I.get()) || !A.reachedAny(g.get()));
  }
  function D(b) {
    if (!h()) return;
    const S = A.reachedMin(g.get()) ? "min" : "max", K = WA(A[S] - g.get()), Y = I.get() - g.get(), T = l.constrain(K / r);
    I.subtract(Y * T), !b && WA(Y) < s && (I.set(A.constrain(I.get())), C.useDuration(25).useBaseFriction());
  }
  function w(b) {
    d = !b;
  }
  return {
    shouldConstrain: h,
    constrain: D,
    toggleActive: w
  };
}
function TL(A, g, I, C, t) {
  const s = Gc(-g + A, 0), r = w(), l = D(), d = p();
  function h(S, K) {
    return aM(S, K) <= 1;
  }
  function D() {
    const S = r[0], K = bn(r), Y = r.lastIndexOf(S), T = r.indexOf(K) + 1;
    return Gc(Y, T);
  }
  function w() {
    return I.map((S, K) => {
      const {
        min: Y,
        max: T
      } = s, E = s.constrain(S), H = !K, R = wK(I, K);
      return H ? T : R || h(Y, E) ? Y : h(T, E) ? T : E;
    }).map((S) => parseFloat(S.toFixed(3)));
  }
  function p() {
    if (g <= A + t) return [s.max];
    if (C === "keepSnaps") return r;
    const {
      min: S,
      max: K
    } = l;
    return r.slice(S, K);
  }
  return {
    snapsContained: d,
    scrollContainLimit: l
  };
}
function YL(A, g, I) {
  const C = g[0], t = I ? C - A : bn(g);
  return {
    limit: Gc(t, C)
  };
}
function PL(A, g, I, C) {
  const s = g.min + 0.1, r = g.max + 0.1, {
    reachedMin: l,
    reachedMax: d
  } = Gc(s, r);
  function h(p) {
    return p === 1 ? d(I.get()) : p === -1 ? l(I.get()) : !1;
  }
  function D(p) {
    if (!h(p)) return;
    const b = A * (p * -1);
    C.forEach((S) => S.add(b));
  }
  return {
    loop: D
  };
}
function ZL(A) {
  const {
    max: g,
    length: I
  } = A;
  function C(s) {
    const r = s - g;
    return I ? r / -I : 0;
  }
  return {
    get: C
  };
}
function jL(A, g, I, C, t) {
  const {
    startEdge: s,
    endEdge: r
  } = A, {
    groupSlides: l
  } = t, d = w().map(g.measure), h = p(), D = b();
  function w() {
    return l(C).map((K) => bn(K)[r] - K[0][s]).map(WA);
  }
  function p() {
    return C.map((K) => I[s] - K[s]).map((K) => -WA(K));
  }
  function b() {
    return l(h).map((K) => K[0]).map((K, Y) => K + d[Y]);
  }
  return {
    snaps: h,
    snapsAligned: D
  };
}
function vL(A, g, I, C, t, s) {
  const {
    groupSlides: r
  } = t, {
    min: l,
    max: d
  } = C, h = D();
  function D() {
    const p = r(s), b = !A || g === "keepSnaps";
    return I.length === 1 ? [s] : b ? p : p.slice(l, d).map((S, K, Y) => {
      const T = !K, E = wK(Y, K);
      if (T) {
        const H = bn(Y[0]) + 1;
        return MZ(H);
      }
      if (E) {
        const H = ZM(s) - bn(Y)[0] + 1;
        return MZ(H, bn(Y)[0]);
      }
      return S;
    });
  }
  return {
    slideRegistry: h
  };
}
function HL(A, g, I, C, t) {
  const {
    reachedAny: s,
    removeOffset: r,
    constrain: l
  } = C;
  function d(S) {
    return S.concat().sort((K, Y) => WA(K) - WA(Y))[0];
  }
  function h(S) {
    const K = A ? r(S) : l(S), Y = g.map((E, H) => ({
      diff: D(E - K, 0),
      index: H
    })).sort((E, H) => WA(E.diff) - WA(H.diff)), {
      index: T
    } = Y[0];
    return {
      index: T,
      distance: K
    };
  }
  function D(S, K) {
    const Y = [S, S + I, S - I];
    if (!A) return S;
    if (!K) return d(Y);
    const T = Y.filter((E) => MK(E) === K);
    return T.length ? d(T) : bn(Y) - I;
  }
  function w(S, K) {
    const Y = g[S] - t.get(), T = D(Y, K);
    return {
      index: S,
      distance: T
    };
  }
  function p(S, K) {
    const Y = t.get() + S, {
      index: T,
      distance: E
    } = h(Y), H = !A && s(Y);
    if (!K || H) return {
      index: T,
      distance: S
    };
    const R = g[T] - E, x = S + D(R, 0);
    return {
      index: T,
      distance: x
    };
  }
  return {
    byDistance: p,
    byIndex: w,
    shortcut: D
  };
}
function EL(A, g, I, C, t, s, r) {
  function l(w) {
    const p = w.distance, b = w.index !== g.get();
    s.add(p), p && (C.duration() ? A.start() : (A.update(), A.render(1), A.update())), b && (I.set(g.get()), g.set(w.index), r.emit("select"));
  }
  function d(w, p) {
    const b = t.byDistance(w, p);
    l(b);
  }
  function h(w, p) {
    const b = g.clone().set(w), S = t.byIndex(b.get(), p);
    l(S);
  }
  return {
    distance: d,
    index: h
  };
}
function RL(A, g, I, C, t, s, r, l) {
  const d = {
    passive: !0,
    capture: !0
  };
  let h = 0;
  function D(b) {
    if (!l) return;
    function S(K) {
      if ((/* @__PURE__ */ new Date()).getTime() - h > 10) return;
      r.emit("slideFocusStart"), A.scrollLeft = 0;
      const E = I.findIndex((H) => H.includes(K));
      DK(E) && (t.useDuration(0), C.index(E, 0), r.emit("slideFocus"));
    }
    s.add(document, "keydown", w, !1), g.forEach((K, Y) => {
      s.add(K, "focus", (T) => {
        (m0(l) || l(b, T)) && S(Y);
      }, d);
    });
  }
  function w(b) {
    b.code === "Tab" && (h = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: D
  };
}
function IM(A) {
  let g = A;
  function I() {
    return g;
  }
  function C(d) {
    g = r(d);
  }
  function t(d) {
    g += r(d);
  }
  function s(d) {
    g -= r(d);
  }
  function r(d) {
    return DK(d) ? d : d.get();
  }
  return {
    get: I,
    set: C,
    add: t,
    subtract: s
  };
}
function sR(A, g) {
  const I = A.scroll === "x" ? r : l, C = g.style;
  let t = null, s = !1;
  function r(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function l(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function d(p) {
    if (s) return;
    const b = yL(A.direction(p));
    b !== t && (C.transform = I(b), t = b);
  }
  function h(p) {
    s = !p;
  }
  function D() {
    s || (C.transform = "", g.getAttribute("style") || g.removeAttribute("style"));
  }
  return {
    clear: D,
    to: d,
    toggleActive: h
  };
}
function OL(A, g, I, C, t, s, r, l, d) {
  const D = DM(t), w = DM(t).reverse(), p = T().concat(E());
  function b(J, L) {
    return J.reduce((eg, Mg) => eg - t[Mg], L);
  }
  function S(J, L) {
    return J.reduce((eg, Mg) => b(eg, L) > 0 ? eg.concat([Mg]) : eg, []);
  }
  function K(J) {
    return s.map((L, eg) => ({
      start: L - C[eg] + 0.5 + J,
      end: L + g - 0.5 + J
    }));
  }
  function Y(J, L, eg) {
    const Mg = K(L);
    return J.map((ig) => {
      const Zg = eg ? 0 : -I, Kg = eg ? I : 0, mg = eg ? "end" : "start", Ng = Mg[ig][mg];
      return {
        index: ig,
        loopPoint: Ng,
        slideLocation: IM(-1),
        translate: sR(A, d[ig]),
        target: () => l.get() > Ng ? Zg : Kg
      };
    });
  }
  function T() {
    const J = r[0], L = S(w, J);
    return Y(L, I, !1);
  }
  function E() {
    const J = g - r[0] - 1, L = S(D, J);
    return Y(L, -I, !0);
  }
  function H() {
    return p.every(({
      index: J
    }) => {
      const L = D.filter((eg) => eg !== J);
      return b(L, g) <= 0.1;
    });
  }
  function R() {
    p.forEach((J) => {
      const {
        target: L,
        translate: eg,
        slideLocation: Mg
      } = J, ig = L();
      ig !== Mg.get() && (eg.to(ig), Mg.set(ig));
    });
  }
  function x() {
    p.forEach((J) => J.translate.clear());
  }
  return {
    canLoop: H,
    clear: x,
    loop: R,
    loopPoints: p
  };
}
function NL(A, g, I) {
  let C, t = !1;
  function s(d) {
    if (!I) return;
    function h(D) {
      for (const w of D)
        if (w.type === "childList") {
          d.reInit(), g.emit("slidesChanged");
          break;
        }
    }
    C = new MutationObserver((D) => {
      t || (m0(I) || I(d, D)) && h(D);
    }), C.observe(A, {
      childList: !0
    });
  }
  function r() {
    C && C.disconnect(), t = !0;
  }
  return {
    init: s,
    destroy: r
  };
}
function kL(A, g, I, C) {
  const t = {};
  let s = null, r = null, l, d = !1;
  function h() {
    l = new IntersectionObserver((S) => {
      d || (S.forEach((K) => {
        const Y = g.indexOf(K.target);
        t[Y] = K;
      }), s = null, r = null, I.emit("slidesInView"));
    }, {
      root: A.parentElement,
      threshold: C
    }), g.forEach((S) => l.observe(S));
  }
  function D() {
    l && l.disconnect(), d = !0;
  }
  function w(S) {
    return MM(t).reduce((K, Y) => {
      const T = parseInt(Y), {
        isIntersecting: E
      } = t[T];
      return (S && E || !S && !E) && K.push(T), K;
    }, []);
  }
  function p(S = !0) {
    if (S && s) return s;
    if (!S && r) return r;
    const K = w(S);
    return S && (s = K), S || (r = K), K;
  }
  return {
    init: h,
    destroy: D,
    get: p
  };
}
function WL(A, g, I, C, t, s) {
  const {
    measureSize: r,
    startEdge: l,
    endEdge: d
  } = A, h = I[0] && t, D = S(), w = K(), p = I.map(r), b = Y();
  function S() {
    if (!h) return 0;
    const E = I[0];
    return WA(g[l] - E[l]);
  }
  function K() {
    if (!h) return 0;
    const E = s.getComputedStyle(bn(C));
    return parseFloat(E.getPropertyValue(`margin-${d}`));
  }
  function Y() {
    return I.map((E, H, R) => {
      const x = !H, U = wK(R, H);
      return x ? p[H] + D : U ? p[H] + w : R[H + 1][l] - E[l];
    }).map(WA);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: b,
    startGap: D,
    endGap: w
  };
}
function VL(A, g, I, C, t, s, r, l, d) {
  const {
    startEdge: h,
    endEdge: D,
    direction: w
  } = A, p = DK(I);
  function b(T, E) {
    return DM(T).filter((H) => H % E === 0).map((H) => T.slice(H, H + E));
  }
  function S(T) {
    return T.length ? DM(T).reduce((E, H, R) => {
      const x = bn(E) || 0, U = x === 0, J = H === ZM(T), L = t[h] - s[x][h], eg = t[h] - s[H][D], Mg = !C && U ? w(r) : 0, ig = !C && J ? w(l) : 0, Zg = WA(eg - ig - (L + Mg));
      return R && Zg > g + d && E.push(H), J && E.push(T.length), E;
    }, []).map((E, H, R) => {
      const x = Math.max(R[H - 1] || 0);
      return T.slice(x, E);
    }) : [];
  }
  function K(T) {
    return p ? b(T, I) : S(T);
  }
  return {
    groupSlides: K
  };
}
function xL(A, g, I, C, t, s, r) {
  const {
    align: l,
    axis: d,
    direction: h,
    startIndex: D,
    loop: w,
    duration: p,
    dragFree: b,
    dragThreshold: S,
    inViewThreshold: K,
    slidesToScroll: Y,
    skipSnaps: T,
    containScroll: E,
    watchResize: H,
    watchSlides: R,
    watchDrag: x,
    watchFocus: U
  } = s, J = 2, L = mL(), eg = L.measure(g), Mg = I.map(L.measure), ig = wL(d, h), Zg = ig.measureSize(eg), Kg = bL(Zg), mg = DL(l, Zg), Ng = !w && !!E, cg = w || !!E, {
    slideSizes: z,
    slideSizesWithGaps: Q,
    startGap: Bg,
    endGap: Rg
  } = WL(ig, eg, Mg, I, cg, t), N = VL(ig, Zg, Y, w, eg, Mg, Bg, Rg, J), {
    snaps: F,
    snapsAligned: rg
  } = jL(ig, mg, eg, Mg, N), Cg = -bn(F) + bn(Q), {
    snapsContained: Sg,
    scrollContainLimit: kg
  } = TL(Zg, Cg, rg, E, J), Yg = Ng ? Sg : rg, {
    limit: Wg
  } = YL(Cg, Yg, w), Xg = nR(ZM(Yg), D, w), nI = Xg.clone(), sI = DM(I), Ug = ({
    dragHandler: pA,
    scrollBody: Ri,
    scrollBounds: $t,
    options: {
      loop: gi
    }
  }) => {
    gi || $t.constrain(pA.pointerDown()), Ri.seek();
  }, fI = ({
    scrollBody: pA,
    translate: Ri,
    location: $t,
    offsetLocation: gi,
    previousLocation: ut,
    scrollLooper: Te,
    slideLooper: JA,
    dragHandler: ZC,
    animation: Ie,
    eventHandler: k,
    scrollBounds: og,
    options: {
      loop: Vg
    }
  }, _g) => {
    const Jg = pA.settled(), yI = !og.shouldConstrain(), lI = Vg ? Jg : Jg && yI, TI = lI && !ZC.pointerDown();
    TI && Ie.stop();
    const cI = $t.get() * _g + ut.get() * (1 - _g);
    gi.set(cI), Vg && (Te.loop(pA.direction()), JA.loop()), Ri.to(gi.get()), TI && k.emit("settle"), lI || k.emit("scroll");
  }, VI = ML(C, t, () => Ug(PC), (pA) => fI(PC, pA)), oA = 0.68, _C = Yg[Xg.get()], UC = IM(_C), vI = IM(_C), CC = IM(_C), hC = IM(_C), Lt = GL(UC, CC, vI, hC, p, oA), rI = HL(w, Yg, Cg, Wg, hC), lt = EL(VI, Xg, nI, Lt, rI, hC, r), qt = ZL(Wg), ct = wM(), Eo = kL(g, I, r, K), {
    slideRegistry: Qe
  } = vL(Ng, E, Yg, kg, N, sI), eC = RL(A, I, Qe, lt, Lt, ct, r, U), PC = {
    ownerDocument: C,
    ownerWindow: t,
    eventHandler: r,
    containerRect: eg,
    slideRects: Mg,
    animation: VI,
    axis: ig,
    dragHandler: BL(ig, A, C, t, hC, pL(ig, t), UC, VI, lt, Lt, rI, Xg, r, Kg, b, S, T, oA, x),
    eventStore: ct,
    percentOfView: Kg,
    index: Xg,
    indexPrevious: nI,
    limit: Wg,
    location: UC,
    offsetLocation: CC,
    previousLocation: vI,
    options: s,
    resizeHandler: SL(g, r, t, I, ig, H, L),
    scrollBody: Lt,
    scrollBounds: KL(Wg, CC, hC, Lt, Kg),
    scrollLooper: PL(Cg, Wg, CC, [UC, CC, vI, hC]),
    scrollProgress: qt,
    scrollSnapList: Yg.map(qt.get),
    scrollSnaps: Yg,
    scrollTarget: rI,
    scrollTo: lt,
    slideLooper: OL(ig, Zg, Cg, z, Q, F, Yg, CC, I),
    slideFocus: eC,
    slidesHandler: NL(g, r, R),
    slidesInView: Eo,
    slideIndexes: sI,
    slideRegistry: Qe,
    slidesToScroll: N,
    target: hC,
    translate: sR(ig, g)
  };
  return PC;
}
function _L() {
  let A = {}, g;
  function I(h) {
    g = h;
  }
  function C(h) {
    return A[h] || [];
  }
  function t(h) {
    return C(h).forEach((D) => D(g, h)), d;
  }
  function s(h, D) {
    return A[h] = C(h).concat([D]), d;
  }
  function r(h, D) {
    return A[h] = C(h).filter((w) => w !== D), d;
  }
  function l() {
    A = {};
  }
  const d = {
    init: I,
    emit: t,
    off: r,
    on: s,
    clear: l
  };
  return d;
}
const UL = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function FL(A) {
  function g(s, r) {
    return iR(s, r || {});
  }
  function I(s) {
    const r = s.breakpoints || {}, l = MM(r).filter((d) => A.matchMedia(d).matches).map((d) => r[d]).reduce((d, h) => g(d, h), {});
    return g(s, l);
  }
  function C(s) {
    return s.map((r) => MM(r.breakpoints || {})).reduce((r, l) => r.concat(l), []).map(A.matchMedia);
  }
  return {
    mergeOptions: g,
    optionsAtMedia: I,
    optionsMediaQueries: C
  };
}
function XL(A) {
  let g = [];
  function I(s, r) {
    return g = r.filter(({
      options: l
    }) => A.optionsAtMedia(l).active !== !1), g.forEach((l) => l.init(s, A)), r.reduce((l, d) => Object.assign(l, {
      [d.name]: d
    }), {});
  }
  function C() {
    g = g.filter((s) => s.destroy());
  }
  return {
    init: I,
    destroy: C
  };
}
function Fp(A, g, I) {
  const C = A.ownerDocument, t = C.defaultView, s = FL(t), r = XL(s), l = wM(), d = _L(), {
    mergeOptions: h,
    optionsAtMedia: D,
    optionsMediaQueries: w
  } = s, {
    on: p,
    off: b,
    emit: S
  } = d, K = ig;
  let Y = !1, T, E = h(UL, Fp.globalOptions), H = h(E), R = [], x, U, J;
  function L() {
    const {
      container: sI,
      slides: Ug
    } = H;
    U = (QS(sI) ? A.querySelector(sI) : sI) || A.children[0];
    const VI = QS(Ug) ? U.querySelectorAll(Ug) : Ug;
    J = [].slice.call(VI || U.children);
  }
  function eg(sI) {
    const Ug = xL(A, U, J, C, t, sI, d);
    if (sI.loop && !Ug.slideLooper.canLoop()) {
      const fI = Object.assign({}, sI, {
        loop: !1
      });
      return eg(fI);
    }
    return Ug;
  }
  function Mg(sI, Ug) {
    Y || (E = h(E, sI), H = D(E), R = Ug || R, L(), T = eg(H), w([E, ...R.map(({
      options: fI
    }) => fI)]).forEach((fI) => l.add(fI, "change", ig)), H.active && (T.translate.to(T.location.get()), T.animation.init(), T.slidesInView.init(), T.slideFocus.init(nI), T.eventHandler.init(nI), T.resizeHandler.init(nI), T.slidesHandler.init(nI), T.options.loop && T.slideLooper.loop(), U.offsetParent && J.length && T.dragHandler.init(nI), x = r.init(nI, R)));
  }
  function ig(sI, Ug) {
    const fI = N();
    Zg(), Mg(h({
      startIndex: fI
    }, sI), Ug), d.emit("reInit");
  }
  function Zg() {
    T.dragHandler.destroy(), T.eventStore.clear(), T.translate.clear(), T.slideLooper.clear(), T.resizeHandler.destroy(), T.slidesHandler.destroy(), T.slidesInView.destroy(), T.animation.destroy(), r.destroy(), l.clear();
  }
  function Kg() {
    Y || (Y = !0, l.clear(), Zg(), d.emit("destroy"), d.clear());
  }
  function mg(sI, Ug, fI) {
    !H.active || Y || (T.scrollBody.useBaseFriction().useDuration(Ug === !0 ? 0 : H.duration), T.scrollTo.index(sI, fI || 0));
  }
  function Ng(sI) {
    const Ug = T.index.add(1).get();
    mg(Ug, sI, -1);
  }
  function cg(sI) {
    const Ug = T.index.add(-1).get();
    mg(Ug, sI, 1);
  }
  function z() {
    return T.index.add(1).get() !== N();
  }
  function Q() {
    return T.index.add(-1).get() !== N();
  }
  function Bg() {
    return T.scrollSnapList;
  }
  function Rg() {
    return T.scrollProgress.get(T.offsetLocation.get());
  }
  function N() {
    return T.index.get();
  }
  function F() {
    return T.indexPrevious.get();
  }
  function rg() {
    return T.slidesInView.get();
  }
  function Cg() {
    return T.slidesInView.get(!1);
  }
  function Sg() {
    return x;
  }
  function kg() {
    return T;
  }
  function Yg() {
    return A;
  }
  function Wg() {
    return U;
  }
  function Xg() {
    return J;
  }
  const nI = {
    canScrollNext: z,
    canScrollPrev: Q,
    containerNode: Wg,
    internalEngine: kg,
    destroy: Kg,
    off: b,
    on: p,
    emit: S,
    plugins: Sg,
    previousScrollSnap: F,
    reInit: K,
    rootNode: Yg,
    scrollNext: Ng,
    scrollPrev: cg,
    scrollProgress: Rg,
    scrollSnapList: Bg,
    scrollTo: mg,
    selectedScrollSnap: N,
    slideNodes: Xg,
    slidesInView: rg,
    slidesNotInView: Cg
  };
  return Mg(g, I), setTimeout(() => d.emit("init"), 0), nI;
}
Fp.globalOptions = void 0;
function BK(A = {}, g = []) {
  const I = Z.useRef(A), C = Z.useRef(g), [t, s] = Z.useState(), [r, l] = Z.useState(), d = Z.useCallback(() => {
    t && t.reInit(I.current, C.current);
  }, [t]);
  return Z.useEffect(() => {
    yK(I.current, A) || (I.current = A, d());
  }, [A, d]), Z.useEffect(() => {
    fL(C.current, g) || (C.current = g, d());
  }, [g, d]), Z.useEffect(() => {
    if (dL() && r) {
      Fp.globalOptions = BK.globalOptions;
      const h = Fp(r, I.current, C.current);
      return s(h), () => h.destroy();
    } else
      s(void 0);
  }, [r, s]), [l, t];
}
BK.globalOptions = void 0;
const oR = Z.createContext(null);
function b0() {
  const A = Z.useContext(oR);
  if (!A)
    throw new Error("useCarousel must be used within a <Carousel />");
  return A;
}
function QL({
  orientation: A = "horizontal",
  opts: g,
  setApi: I,
  plugins: C,
  className: t,
  children: s,
  ...r
}) {
  const [l, d] = BK(
    {
      ...g,
      axis: A === "horizontal" ? "x" : "y"
    },
    C
  ), [h, D] = Z.useState(!1), [w, p] = Z.useState(!1), b = Z.useCallback((T) => {
    T && (D(T.canScrollPrev()), p(T.canScrollNext()));
  }, []), S = Z.useCallback(() => {
    d?.scrollPrev();
  }, [d]), K = Z.useCallback(() => {
    d?.scrollNext();
  }, [d]), Y = Z.useCallback(
    (T) => {
      T.key === "ArrowLeft" ? (T.preventDefault(), S()) : T.key === "ArrowRight" && (T.preventDefault(), K());
    },
    [S, K]
  );
  return Z.useEffect(() => {
    !d || !I || I(d);
  }, [d, I]), Z.useEffect(() => {
    if (d)
      return b(d), d.on("reInit", b), d.on("select", b), () => {
        d?.off("select", b);
      };
  }, [d, b]), /* @__PURE__ */ v.jsx(
    oR.Provider,
    {
      value: {
        carouselRef: l,
        api: d,
        opts: g,
        orientation: A || (g?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev: S,
        scrollNext: K,
        canScrollPrev: h,
        canScrollNext: w
      },
      children: /* @__PURE__ */ v.jsx(
        "div",
        {
          onKeyDownCapture: Y,
          className: kI("relative", t),
          role: "region",
          "aria-roledescription": "carousel",
          "data-slot": "carousel",
          ...r,
          children: s
        }
      )
    }
  );
}
function zL({ className: A, ...g }) {
  const { carouselRef: I, orientation: C } = b0();
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      ref: I,
      className: "overflow-hidden",
      "data-slot": "carousel-content",
      children: /* @__PURE__ */ v.jsx(
        "div",
        {
          className: kI(
            "flex",
            C === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
            A
          ),
          ...g
        }
      )
    }
  );
}
function JL({ className: A, ...g }) {
  const { orientation: I } = b0();
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      role: "group",
      "aria-roledescription": "slide",
      "data-slot": "carousel-item",
      className: kI(
        "min-w-0 shrink-0 grow-0 basis-full",
        I === "horizontal" ? "pl-4" : "pt-4",
        A
      ),
      ...g
    }
  );
}
function LL({
  className: A,
  variant: g = "outline",
  size: I = "icon",
  ...C
}) {
  const { orientation: t, scrollPrev: s, canScrollPrev: r } = b0();
  return /* @__PURE__ */ v.jsxs(
    Ke,
    {
      "data-slot": "carousel-previous",
      variant: g,
      size: I,
      className: kI(
        "absolute size-8 rounded-full",
        t === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        A
      ),
      disabled: !r,
      onClick: s,
      ...C,
      children: [
        /* @__PURE__ */ v.jsx(QQ, {}),
        /* @__PURE__ */ v.jsx("span", { className: "sr-only", children: "Previous slide" })
      ]
    }
  );
}
function qL({
  className: A,
  variant: g = "outline",
  size: I = "icon",
  ...C
}) {
  const { orientation: t, scrollNext: s, canScrollNext: r } = b0();
  return /* @__PURE__ */ v.jsxs(
    Ke,
    {
      "data-slot": "carousel-next",
      variant: g,
      size: I,
      className: kI(
        "absolute size-8 rounded-full",
        t === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        A
      ),
      disabled: !r,
      onClick: s,
      ...C,
      children: [
        /* @__PURE__ */ v.jsx(JQ, {}),
        /* @__PURE__ */ v.jsx("span", { className: "sr-only", children: "Next slide" })
      ]
    }
  );
}
const $L = ({
  showPointCloud: A,
  showScatterplot: g,
  availableSectionIDs: I,
  currentSectionID: C,
  onSectionClick: t,
  sectionPreviews: s
}) => {
  const [r, l] = Z.useState();
  return Z.useEffect(() => {
    if (!A && g && I.length > 0 && r && C !== null) {
      const d = I.findIndex(
        (h) => h === C
      );
      d !== -1 && setTimeout(() => {
        r.scrollTo(d, !1);
      }, 0);
    }
  }, [
    C,
    r,
    I,
    A,
    g
  ]), A || !g || I.length === 0 ? null : /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsxs(
    QL,
    {
      opts: {
        align: "center",
        loop: !0,
        dragFree: !0
        // duration: 2000,
      },
      setApi: l,
      className: "w-full",
      children: [
        /* @__PURE__ */ v.jsx(zL, { className: "-ml-2", children: I.map((d) => /* @__PURE__ */ v.jsx(
          JL,
          {
            className: "pl-2 basis-1/6 md:basis-1/8 lg:basis-1/10",
            children: /* @__PURE__ */ v.jsx(
              r0,
              {
                className: `cursor-pointer transition-all py-1 ${C === d ? "border-2 border-primary bg-background/40" : "border border-border hover:border-primary/50 bg-background/40 hover:bg-background/60"}`,
                onClick: () => t(d),
                children: /* @__PURE__ */ v.jsxs(l0, { className: "p-0 aspect-square relative flex items-center justify-center h-20", children: [
                  s[d] ? /* @__PURE__ */ v.jsx(
                    "img",
                    {
                      src: s[d],
                      alt: `Section ${d}`,
                      className: "w-full h-full object-cover"
                    }
                  ) : /* @__PURE__ */ v.jsx("div", { className: "w-full h-full flex flex-col items-center justify-center bg-muted/30", children: /* @__PURE__ */ v.jsx(bz, { className: "h-8 w-8 animate-spin text-primary" }) }),
                  /* @__PURE__ */ v.jsx("div", { className: "absolute bottom-0 left-0 right-0  text-center", children: /* @__PURE__ */ v.jsxs("span", { className: "text-sm font-medium", children: [
                    "Section ",
                    d
                  ] }) })
                ] })
              }
            )
          },
          d
        )) }),
        /* @__PURE__ */ v.jsx(LL, { className: "h-8 w-8" }),
        /* @__PURE__ */ v.jsx(qL, { className: "h-8 w-8" })
      ]
    }
  ) });
};
var rt = {}, UD = {}, wZ;
function g6() {
  if (wZ) return UD;
  wZ = 1, Object.defineProperty(UD, "__esModule", { value: !0 }), UD.parseLengthAndUnit = g, UD.cssValue = I;
  var A = {
    cm: !0,
    mm: !0,
    in: !0,
    px: !0,
    pt: !0,
    pc: !0,
    em: !0,
    ex: !0,
    ch: !0,
    rem: !0,
    vw: !0,
    vh: !0,
    vmin: !0,
    vmax: !0,
    "%": !0
  };
  function g(C) {
    if (typeof C == "number")
      return {
        value: C,
        unit: "px"
      };
    var t, s = (C.match(/^[0-9.]*/) || "").toString();
    s.includes(".") ? t = parseFloat(s) : t = parseInt(s, 10);
    var r = (C.match(/[^0-9]*$/) || "").toString();
    return A[r] ? {
      value: t,
      unit: r
    } : (console.warn("React Spinners: ".concat(C, " is not a valid css value. Defaulting to ").concat(t, "px.")), {
      value: t,
      unit: "px"
    });
  }
  function I(C) {
    var t = g(C);
    return "".concat(t.value).concat(t.unit);
  }
  return UD;
}
var FD = {}, BZ;
function I6() {
  if (BZ) return FD;
  BZ = 1, Object.defineProperty(FD, "__esModule", { value: !0 }), FD.createAnimation = void 0;
  var A = function(g, I, C) {
    var t = "react-spinners-".concat(g, "-").concat(C);
    if (typeof window > "u" || !window.document)
      return t;
    var s = document.createElement("style");
    document.head.appendChild(s);
    var r = s.sheet, l = `
    @keyframes `.concat(t, ` {
      `).concat(I, `
    }
  `);
    return r && r.insertRule(l, 0), t;
  };
  return FD.createAnimation = A, FD;
}
var pZ;
function A6() {
  if (pZ) return rt;
  pZ = 1;
  var A = rt && rt.__assign || function() {
    return A = Object.assign || function(w) {
      for (var p, b = 1, S = arguments.length; b < S; b++) {
        p = arguments[b];
        for (var K in p) Object.prototype.hasOwnProperty.call(p, K) && (w[K] = p[K]);
      }
      return w;
    }, A.apply(this, arguments);
  }, g = rt && rt.__createBinding || (Object.create ? (function(w, p, b, S) {
    S === void 0 && (S = b);
    var K = Object.getOwnPropertyDescriptor(p, b);
    (!K || ("get" in K ? !p.__esModule : K.writable || K.configurable)) && (K = { enumerable: !0, get: function() {
      return p[b];
    } }), Object.defineProperty(w, S, K);
  }) : (function(w, p, b, S) {
    S === void 0 && (S = b), w[S] = p[b];
  })), I = rt && rt.__setModuleDefault || (Object.create ? (function(w, p) {
    Object.defineProperty(w, "default", { enumerable: !0, value: p });
  }) : function(w, p) {
    w.default = p;
  }), C = rt && rt.__importStar || /* @__PURE__ */ (function() {
    var w = function(p) {
      return w = Object.getOwnPropertyNames || function(b) {
        var S = [];
        for (var K in b) Object.prototype.hasOwnProperty.call(b, K) && (S[S.length] = K);
        return S;
      }, w(p);
    };
    return function(p) {
      if (p && p.__esModule) return p;
      var b = {};
      if (p != null) for (var S = w(p), K = 0; K < S.length; K++) S[K] !== "default" && g(b, p, S[K]);
      return I(b, p), b;
    };
  })(), t = rt && rt.__rest || function(w, p) {
    var b = {};
    for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && p.indexOf(S) < 0 && (b[S] = w[S]);
    if (w != null && typeof Object.getOwnPropertySymbols == "function")
      for (var K = 0, S = Object.getOwnPropertySymbols(w); K < S.length; K++)
        p.indexOf(S[K]) < 0 && Object.prototype.propertyIsEnumerable.call(w, S[K]) && (b[S[K]] = w[S[K]]);
    return b;
  };
  Object.defineProperty(rt, "__esModule", { value: !0 });
  var s = C(Yc()), r = /* @__PURE__ */ g6(), l = /* @__PURE__ */ I6(), d = (0, l.createAnimation)("RingLoader", "0% {transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg)} 100% {transform: rotateX(180deg) rotateY(360deg) rotateZ(360deg)}", "right"), h = (0, l.createAnimation)("RingLoader", "0% {transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg)} 100% {transform: rotateX(360deg) rotateY(180deg) rotateZ(360deg)}", "left");
  function D(w) {
    var p = w.loading, b = p === void 0 ? !0 : p, S = w.color, K = S === void 0 ? "#000000" : S, Y = w.speedMultiplier, T = Y === void 0 ? 1 : Y, E = w.cssOverride, H = E === void 0 ? {} : E, R = w.size, x = R === void 0 ? 60 : R, U = t(w, ["loading", "color", "speedMultiplier", "cssOverride", "size"]), J = (0, r.parseLengthAndUnit)(x), L = J.value, eg = J.unit, Mg = A({ display: "inherit", width: (0, r.cssValue)(x), height: (0, r.cssValue)(x), position: "relative" }, H), ig = function(Zg) {
      return {
        position: "absolute",
        top: "0",
        left: "0",
        width: "".concat(L).concat(eg),
        height: "".concat(L).concat(eg),
        border: "".concat(L / 10).concat(eg, " solid ").concat(K),
        opacity: "0.4",
        borderRadius: "100%",
        animationFillMode: "forwards",
        perspective: "800px",
        animation: "".concat(Zg === 1 ? d : h, " ").concat(2 / T, "s 0s infinite linear")
      };
    };
    return b ? s.createElement(
      "span",
      A({ style: Mg }, U),
      s.createElement("span", { style: ig(1) }),
      s.createElement("span", { style: ig(2) })
    ) : null;
  }
  return rt.default = D, rt;
}
var C6 = /* @__PURE__ */ A6();
const e6 = /* @__PURE__ */ CG(C6), t6 = ({
  isLoaded: A,
  showPointCloud: g,
  showScatterplot: I,
  layoutMode: C,
  viewState: t,
  stviewState: s,
  initialCamera: r,
  layers: l,
  loadedData: d,
  loadedAnnotations: h,
  availableSectionIDs: D,
  currentSectionID: w,
  sectionPreviews: p,
  NumericThreshold: b,
  minMaxValue: S,
  device: K,
  onViewStateUpdate: Y,
  onStViewStateUpdate: T,
  onActiveZoomChange: E,
  onSectionClick: H,
  onNumericThresholdChange: R,
  onAfterRender: x,
  annotationConfig: U
}) => {
  const J = Z.useRef(null), L = Z.useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ({ viewState: ig }) => {
      if (g) {
        Y(ig);
        const Zg = ig.zoom, Kg = t.zoom;
        if (Zg !== Kg) {
          const mg = r.zoom - 1, Ng = r.zoom + 1;
          Zg <= mg ? E("far") : Zg >= Ng ? E("near") : E("standard");
        }
      } else
        T(ig);
    },
    [
      g,
      Y,
      T,
      E,
      t.zoom,
      r.zoom
    ]
  ), eg = Z.useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ({ coordinate: ig, index: Zg, layer: Kg }) => {
      if (!ig || !Kg || !d) return null;
      const mg = d.extData;
      let Ng = `
          <div>
            <b>Position:</b> ${ig.map((cg) => cg.toFixed(1)).join(", ")}<br/>
        `;
      if (U?.AnnoMaps && mg.annotations)
        for (const cg of h) {
          const z = mg.annotations[cg];
          if (!z || Zg >= z.length) continue;
          const Q = z[Zg];
          if (Q == null) continue;
          const Bg = U.AnnoMaps?.[cg]?.Items;
          let Rg = `Unknown (${Q})`;
          if (Bg) {
            const F = Bg.find((rg) => rg.Code === Number(Q));
            F?.Name != null && (Rg = String(F.Name));
          }
          const N = cg.charAt(0).toUpperCase() + cg.slice(1);
          Ng += `<b>${N}:</b> ${Rg}<br/>`;
        }
      if (mg.numeric && mg.numeric.values && Zg < mg.numeric.values.length) {
        const cg = mg.numeric.values[Zg];
        typeof cg == "number" && Number.isFinite(cg) && (Ng += `<b>${mg.numeric.name}:</b> ${cg.toFixed(
          4
        )}<br/>`);
      }
      return Ng += "</div>", {
        html: Ng,
        className: "bg-card text-muted-foreground rounded-lg shadow-lg",
        style: {
          backgroundColor: "",
          color: ""
        }
      };
    },
    [d, U?.AnnoMaps, h]
  ), Mg = Z.useCallback(() => {
    S && R(S[0]);
  }, [S, R]);
  return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    !A && /* @__PURE__ */ v.jsx(i6, {}),
    /* @__PURE__ */ v.jsx(
      cL,
      {
        ref: J,
        device: K,
        views: g ? new lH({
          orbitAxis: "Y",
          fovy: 50,
          controller: {
            inertia: !0,
            scrollZoom: !0,
            dragMode: C === "3d" ? "rotate" : "pan"
          }
        }) : new _G({
          controller: {
            inertia: !0,
            scrollZoom: !0
          }
        }),
        viewState: g ? t : s,
        onAfterRender: x,
        onViewStateChange: L,
        layers: l,
        getTooltip: eg
      }
    ),
    !g && I && /* @__PURE__ */ v.jsx("div", { className: "absolute top-2 left-12 right-12 backdrop-blur-sm p-1 rounded-lg shadow-lg bg-transparent", children: /* @__PURE__ */ v.jsx(
      $L,
      {
        showScatterplot: I,
        availableSectionIDs: D,
        showPointCloud: g,
        currentSectionID: w,
        onSectionClick: H,
        sectionPreviews: p
      }
    ) }),
    S && Number.isFinite(S[0]) && Number.isFinite(S[1]) && /* @__PURE__ */ v.jsx(
      "div",
      {
        className: "absolute bottom-4 left-1/2 transform -translate-x-1/2  bg-transparent rounded-lg shadow-lg p-1.5 z-20 pl-3 pr-3",
        style: { minWidth: "80%", backdropFilter: "blur(8px)" },
        children: /* @__PURE__ */ v.jsx(
          n6,
          {
            NumericThreshold: b,
            minMaxLogp: S,
            isLoaded: A,
            onThresholdChange: R,
            onReset: Mg
          }
        )
      }
    )
  ] });
}, i6 = () => /* @__PURE__ */ v.jsx("div", { className: "absolute inset-0 flex items-center justify-center z-10", children: /* @__PURE__ */ v.jsx(
  e6,
  {
    color: "#B967C7",
    cssOverride: {},
    loading: !0,
    size: 200,
    speedMultiplier: 0.5
  }
) }), n6 = ({
  NumericThreshold: A,
  minMaxLogp: g,
  isLoaded: I,
  onThresholdChange: C,
  onReset: t
}) => /* @__PURE__ */ v.jsxs("div", { className: "flex items-center space-x-3", children: [
  /* @__PURE__ */ v.jsxs("div", { className: "text-sm font-medium whitespace-nowrap", children: [
    "LogP: ",
    /* @__PURE__ */ v.jsx("span", { className: "font-bold", children: A.toFixed(2) })
  ] }),
  /* @__PURE__ */ v.jsx("span", { className: "text-xs font-medium", children: g[0].toFixed(2) }),
  /* @__PURE__ */ v.jsxs("div", { className: "flex-1 h-8 relative", children: [
    /* @__PURE__ */ v.jsx(
      "div",
      {
        className: "w-full h-6 rounded-md shadow-inner absolute top-1",
        style: {
          background: "linear-gradient(to right, rgb(0, 50, 255), rgb(128, 50, 128), rgb(255, 50, 0))"
        }
      }
    ),
    /* @__PURE__ */ v.jsx(
      WS,
      {
        min: g[0],
        max: g[1],
        step: (g[1] - g[0]) / 100,
        value: [A],
        onValueChange: (s) => C(s[0]),
        disabled: !I,
        className: `
            cursor-pointer absolute inset-0
            [&>[data-slot=slider-track]]:bg-transparent
            [&>[data-slot=slider-track]>[data-slot=slider-range]]:bg-transparent
            `
      }
    )
  ] }),
  /* @__PURE__ */ v.jsx("span", { className: "text-xs font-medium", children: g[1].toFixed(2) }),
  /* @__PURE__ */ v.jsx(
    Ke,
    {
      variant: "ghost",
      size: "sm",
      className: "h-6 w-6 p-0",
      onClick: t,
      disabled: !I,
      title: "Reset threshold",
      children: /* @__PURE__ */ v.jsx(jz, { className: "h-3 w-3" })
    }
  )
] });
var mZ = 1, s6 = 0.9, o6 = 0.8, a6 = 0.17, Ub = 0.1, Fb = 0.999, r6 = 0.9999, l6 = 0.99, c6 = /[\\\/_+.#"@\[\(\{&]/, u6 = /[\\\/_+.#"@\[\(\{&]/g, d6 = /[\s-]/, aR = /[\s-]/g;
function JS(A, g, I, C, t, s, r) {
  if (s === g.length) return t === A.length ? mZ : l6;
  var l = `${t},${s}`;
  if (r[l] !== void 0) return r[l];
  for (var d = C.charAt(s), h = I.indexOf(d, t), D = 0, w, p, b, S; h >= 0; ) w = JS(A, g, I, C, h + 1, s + 1, r), w > D && (h === t ? w *= mZ : c6.test(A.charAt(h - 1)) ? (w *= o6, b = A.slice(t, h - 1).match(u6), b && t > 0 && (w *= Math.pow(Fb, b.length))) : d6.test(A.charAt(h - 1)) ? (w *= s6, S = A.slice(t, h - 1).match(aR), S && t > 0 && (w *= Math.pow(Fb, S.length))) : (w *= a6, t > 0 && (w *= Math.pow(Fb, h - t))), A.charAt(h) !== g.charAt(s) && (w *= r6)), (w < Ub && I.charAt(h - 1) === C.charAt(s + 1) || C.charAt(s + 1) === C.charAt(s) && I.charAt(h - 1) !== C.charAt(s)) && (p = JS(A, g, I, C, h + 1, s + 2, r), p * Ub > w && (w = p * Ub)), w > D && (D = w), h = I.indexOf(d, h + 1);
  return r[l] = D, D;
}
function bZ(A) {
  return A.toLowerCase().replace(aR, " ");
}
function f6(A, g, I) {
  return A = I && I.length > 0 ? `${A + " " + I.join(" ")}` : A, JS(A, g, bZ(A), bZ(g), 0, 0, {});
}
var Xb = "focusScope.autoFocusOnMount", Qb = "focusScope.autoFocusOnUnmount", SZ = { bubbles: !1, cancelable: !0 }, h6 = "FocusScope", pK = Z.forwardRef((A, g) => {
  const {
    loop: I = !1,
    trapped: C = !1,
    onMountAutoFocus: t,
    onUnmountAutoFocus: s,
    ...r
  } = A, [l, d] = Z.useState(null), h = bc(t), D = bc(s), w = Z.useRef(null), p = BA(g, (K) => d(K)), b = Z.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  Z.useEffect(() => {
    if (C) {
      let K = function(H) {
        if (b.paused || !l) return;
        const R = H.target;
        l.contains(R) ? w.current = R : lr(w.current, { select: !0 });
      }, Y = function(H) {
        if (b.paused || !l) return;
        const R = H.relatedTarget;
        R !== null && (l.contains(R) || lr(w.current, { select: !0 }));
      }, T = function(H) {
        if (document.activeElement === document.body)
          for (const x of H)
            x.removedNodes.length > 0 && lr(l);
      };
      document.addEventListener("focusin", K), document.addEventListener("focusout", Y);
      const E = new MutationObserver(T);
      return l && E.observe(l, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", K), document.removeEventListener("focusout", Y), E.disconnect();
      };
    }
  }, [C, l, b.paused]), Z.useEffect(() => {
    if (l) {
      KZ.add(b);
      const K = document.activeElement;
      if (!l.contains(K)) {
        const T = new CustomEvent(Xb, SZ);
        l.addEventListener(Xb, h), l.dispatchEvent(T), T.defaultPrevented || (y6(p6(rR(l)), { select: !0 }), document.activeElement === K && lr(l));
      }
      return () => {
        l.removeEventListener(Xb, h), setTimeout(() => {
          const T = new CustomEvent(Qb, SZ);
          l.addEventListener(Qb, D), l.dispatchEvent(T), T.defaultPrevented || lr(K ?? document.body, { select: !0 }), l.removeEventListener(Qb, D), KZ.remove(b);
        }, 0);
      };
    }
  }, [l, h, D, b]);
  const S = Z.useCallback(
    (K) => {
      if (!I && !C || b.paused) return;
      const Y = K.key === "Tab" && !K.altKey && !K.ctrlKey && !K.metaKey, T = document.activeElement;
      if (Y && T) {
        const E = K.currentTarget, [H, R] = D6(E);
        H && R ? !K.shiftKey && T === R ? (K.preventDefault(), I && lr(H, { select: !0 })) : K.shiftKey && T === H && (K.preventDefault(), I && lr(R, { select: !0 })) : T === E && K.preventDefault();
      }
    },
    [I, C, b.paused]
  );
  return /* @__PURE__ */ v.jsx(jI.div, { tabIndex: -1, ...r, ref: p, onKeyDown: S });
});
pK.displayName = h6;
function y6(A, { select: g = !1 } = {}) {
  const I = document.activeElement;
  for (const C of A)
    if (lr(C, { select: g }), document.activeElement !== I) return;
}
function D6(A) {
  const g = rR(A), I = GZ(g, A), C = GZ(g.reverse(), A);
  return [I, C];
}
function rR(A) {
  const g = [], I = document.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (C) => {
      const t = C.tagName === "INPUT" && C.type === "hidden";
      return C.disabled || C.hidden || t ? NodeFilter.FILTER_SKIP : C.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; I.nextNode(); ) g.push(I.currentNode);
  return g;
}
function GZ(A, g) {
  for (const I of A)
    if (!M6(I, { upTo: g })) return I;
}
function M6(A, { upTo: g }) {
  if (getComputedStyle(A).visibility === "hidden") return !0;
  for (; A; ) {
    if (g !== void 0 && A === g) return !1;
    if (getComputedStyle(A).display === "none") return !0;
    A = A.parentElement;
  }
  return !1;
}
function w6(A) {
  return A instanceof HTMLInputElement && "select" in A;
}
function lr(A, { select: g = !1 } = {}) {
  if (A && A.focus) {
    const I = document.activeElement;
    A.focus({ preventScroll: !0 }), A !== I && w6(A) && g && A.select();
  }
}
var KZ = B6();
function B6() {
  let A = [];
  return {
    add(g) {
      const I = A[0];
      g !== I && I?.pause(), A = TZ(A, g), A.unshift(g);
    },
    remove(g) {
      A = TZ(A, g), A[0]?.resume();
    }
  };
}
function TZ(A, g) {
  const I = [...A], C = I.indexOf(g);
  return C !== -1 && I.splice(C, 1), I;
}
function p6(A) {
  return A.filter((g) => g.tagName !== "A");
}
var zb = 0;
function lR() {
  Z.useEffect(() => {
    const A = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", A[0] ?? YZ()), document.body.insertAdjacentElement("beforeend", A[1] ?? YZ()), zb++, () => {
      zb === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((g) => g.remove()), zb--;
    };
  }, []);
}
function YZ() {
  const A = document.createElement("span");
  return A.setAttribute("data-radix-focus-guard", ""), A.tabIndex = 0, A.style.outline = "none", A.style.opacity = "0", A.style.position = "fixed", A.style.pointerEvents = "none", A;
}
var Bs = function() {
  return Bs = Object.assign || function(g) {
    for (var I, C = 1, t = arguments.length; C < t; C++) {
      I = arguments[C];
      for (var s in I) Object.prototype.hasOwnProperty.call(I, s) && (g[s] = I[s]);
    }
    return g;
  }, Bs.apply(this, arguments);
};
function cR(A, g) {
  var I = {};
  for (var C in A) Object.prototype.hasOwnProperty.call(A, C) && g.indexOf(C) < 0 && (I[C] = A[C]);
  if (A != null && typeof Object.getOwnPropertySymbols == "function")
    for (var t = 0, C = Object.getOwnPropertySymbols(A); t < C.length; t++)
      g.indexOf(C[t]) < 0 && Object.prototype.propertyIsEnumerable.call(A, C[t]) && (I[C[t]] = A[C[t]]);
  return I;
}
function m6(A, g, I) {
  if (I || arguments.length === 2) for (var C = 0, t = g.length, s; C < t; C++)
    (s || !(C in g)) && (s || (s = Array.prototype.slice.call(g, 0, C)), s[C] = g[C]);
  return A.concat(s || Array.prototype.slice.call(g));
}
var lp = "right-scroll-bar-position", cp = "width-before-scroll-bar", b6 = "with-scroll-bars-hidden", S6 = "--removed-body-scroll-bar-size";
function Jb(A, g) {
  return typeof A == "function" ? A(g) : A && (A.current = g), A;
}
function G6(A, g) {
  var I = Z.useState(function() {
    return {
      // value
      value: A,
      // last callback
      callback: g,
      // "memoized" public interface
      facade: {
        get current() {
          return I.value;
        },
        set current(C) {
          var t = I.value;
          t !== C && (I.value = C, I.callback(C, t));
        }
      }
    };
  })[0];
  return I.callback = g, I.facade;
}
var K6 = typeof window < "u" ? Z.useLayoutEffect : Z.useEffect, PZ = /* @__PURE__ */ new WeakMap();
function T6(A, g) {
  var I = G6(null, function(C) {
    return A.forEach(function(t) {
      return Jb(t, C);
    });
  });
  return K6(function() {
    var C = PZ.get(I);
    if (C) {
      var t = new Set(C), s = new Set(A), r = I.current;
      t.forEach(function(l) {
        s.has(l) || Jb(l, null);
      }), s.forEach(function(l) {
        t.has(l) || Jb(l, r);
      });
    }
    PZ.set(I, A);
  }, [A]), I;
}
function Y6(A) {
  return A;
}
function P6(A, g) {
  g === void 0 && (g = Y6);
  var I = [], C = !1, t = {
    read: function() {
      if (C)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return I.length ? I[I.length - 1] : A;
    },
    useMedium: function(s) {
      var r = g(s, C);
      return I.push(r), function() {
        I = I.filter(function(l) {
          return l !== r;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (C = !0; I.length; ) {
        var r = I;
        I = [], r.forEach(s);
      }
      I = {
        push: function(l) {
          return s(l);
        },
        filter: function() {
          return I;
        }
      };
    },
    assignMedium: function(s) {
      C = !0;
      var r = [];
      if (I.length) {
        var l = I;
        I = [], l.forEach(s), r = I;
      }
      var d = function() {
        var D = r;
        r = [], D.forEach(s);
      }, h = function() {
        return Promise.resolve().then(d);
      };
      h(), I = {
        push: function(D) {
          r.push(D), h();
        },
        filter: function(D) {
          return r = r.filter(D), I;
        }
      };
    }
  };
  return t;
}
function Z6(A) {
  A === void 0 && (A = {});
  var g = P6(null);
  return g.options = Bs({ async: !0, ssr: !1 }, A), g;
}
var uR = function(A) {
  var g = A.sideCar, I = cR(A, ["sideCar"]);
  if (!g)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var C = g.read();
  if (!C)
    throw new Error("Sidecar medium not found");
  return Z.createElement(C, Bs({}, I));
};
uR.isSideCarExport = !0;
function j6(A, g) {
  return A.useMedium(g), uR;
}
var dR = Z6(), Lb = function() {
}, S0 = Z.forwardRef(function(A, g) {
  var I = Z.useRef(null), C = Z.useState({
    onScrollCapture: Lb,
    onWheelCapture: Lb,
    onTouchMoveCapture: Lb
  }), t = C[0], s = C[1], r = A.forwardProps, l = A.children, d = A.className, h = A.removeScrollBar, D = A.enabled, w = A.shards, p = A.sideCar, b = A.noRelative, S = A.noIsolation, K = A.inert, Y = A.allowPinchZoom, T = A.as, E = T === void 0 ? "div" : T, H = A.gapMode, R = cR(A, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = p, U = T6([I, g]), J = Bs(Bs({}, R), t);
  return Z.createElement(
    Z.Fragment,
    null,
    D && Z.createElement(x, { sideCar: dR, removeScrollBar: h, shards: w, noRelative: b, noIsolation: S, inert: K, setCallbacks: s, allowPinchZoom: !!Y, lockRef: I, gapMode: H }),
    r ? Z.cloneElement(Z.Children.only(l), Bs(Bs({}, J), { ref: U })) : Z.createElement(E, Bs({}, J, { className: d, ref: U }), l)
  );
});
S0.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
S0.classNames = {
  fullWidth: cp,
  zeroRight: lp
};
var v6 = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function H6() {
  if (!document)
    return null;
  var A = document.createElement("style");
  A.type = "text/css";
  var g = v6();
  return g && A.setAttribute("nonce", g), A;
}
function E6(A, g) {
  A.styleSheet ? A.styleSheet.cssText = g : A.appendChild(document.createTextNode(g));
}
function R6(A) {
  var g = document.head || document.getElementsByTagName("head")[0];
  g.appendChild(A);
}
var O6 = function() {
  var A = 0, g = null;
  return {
    add: function(I) {
      A == 0 && (g = H6()) && (E6(g, I), R6(g)), A++;
    },
    remove: function() {
      A--, !A && g && (g.parentNode && g.parentNode.removeChild(g), g = null);
    }
  };
}, N6 = function() {
  var A = O6();
  return function(g, I) {
    Z.useEffect(function() {
      return A.add(g), function() {
        A.remove();
      };
    }, [g && I]);
  };
}, fR = function() {
  var A = N6(), g = function(I) {
    var C = I.styles, t = I.dynamic;
    return A(C, t), null;
  };
  return g;
}, k6 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, qb = function(A) {
  return parseInt(A || "", 10) || 0;
}, W6 = function(A) {
  var g = window.getComputedStyle(document.body), I = g[A === "padding" ? "paddingLeft" : "marginLeft"], C = g[A === "padding" ? "paddingTop" : "marginTop"], t = g[A === "padding" ? "paddingRight" : "marginRight"];
  return [qb(I), qb(C), qb(t)];
}, V6 = function(A) {
  if (A === void 0 && (A = "margin"), typeof window > "u")
    return k6;
  var g = W6(A), I = document.documentElement.clientWidth, C = window.innerWidth;
  return {
    left: g[0],
    top: g[1],
    right: g[2],
    gap: Math.max(0, C - I + g[2] - g[0])
  };
}, x6 = fR(), pf = "data-scroll-locked", _6 = function(A, g, I, C) {
  var t = A.left, s = A.top, r = A.right, l = A.gap;
  return I === void 0 && (I = "margin"), `
  .`.concat(b6, ` {
   overflow: hidden `).concat(C, `;
   padding-right: `).concat(l, "px ").concat(C, `;
  }
  body[`).concat(pf, `] {
    overflow: hidden `).concat(C, `;
    overscroll-behavior: contain;
    `).concat([
    g && "position: relative ".concat(C, ";"),
    I === "margin" && `
    padding-left: `.concat(t, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(r, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(l, "px ").concat(C, `;
    `),
    I === "padding" && "padding-right: ".concat(l, "px ").concat(C, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(lp, ` {
    right: `).concat(l, "px ").concat(C, `;
  }
  
  .`).concat(cp, ` {
    margin-right: `).concat(l, "px ").concat(C, `;
  }
  
  .`).concat(lp, " .").concat(lp, ` {
    right: 0 `).concat(C, `;
  }
  
  .`).concat(cp, " .").concat(cp, ` {
    margin-right: 0 `).concat(C, `;
  }
  
  body[`).concat(pf, `] {
    `).concat(S6, ": ").concat(l, `px;
  }
`);
}, ZZ = function() {
  var A = parseInt(document.body.getAttribute(pf) || "0", 10);
  return isFinite(A) ? A : 0;
}, U6 = function() {
  Z.useEffect(function() {
    return document.body.setAttribute(pf, (ZZ() + 1).toString()), function() {
      var A = ZZ() - 1;
      A <= 0 ? document.body.removeAttribute(pf) : document.body.setAttribute(pf, A.toString());
    };
  }, []);
}, F6 = function(A) {
  var g = A.noRelative, I = A.noImportant, C = A.gapMode, t = C === void 0 ? "margin" : C;
  U6();
  var s = Z.useMemo(function() {
    return V6(t);
  }, [t]);
  return Z.createElement(x6, { styles: _6(s, !g, t, I ? "" : "!important") });
}, LS = !1;
if (typeof window < "u")
  try {
    var zB = Object.defineProperty({}, "passive", {
      get: function() {
        return LS = !0, !0;
      }
    });
    window.addEventListener("test", zB, zB), window.removeEventListener("test", zB, zB);
  } catch {
    LS = !1;
  }
var ef = LS ? { passive: !1 } : !1, X6 = function(A) {
  return A.tagName === "TEXTAREA";
}, hR = function(A, g) {
  if (!(A instanceof Element))
    return !1;
  var I = window.getComputedStyle(A);
  return (
    // not-not-scrollable
    I[g] !== "hidden" && // contains scroll inside self
    !(I.overflowY === I.overflowX && !X6(A) && I[g] === "visible")
  );
}, Q6 = function(A) {
  return hR(A, "overflowY");
}, z6 = function(A) {
  return hR(A, "overflowX");
}, jZ = function(A, g) {
  var I = g.ownerDocument, C = g;
  do {
    typeof ShadowRoot < "u" && C instanceof ShadowRoot && (C = C.host);
    var t = yR(A, C);
    if (t) {
      var s = DR(A, C), r = s[1], l = s[2];
      if (r > l)
        return !0;
    }
    C = C.parentNode;
  } while (C && C !== I.body);
  return !1;
}, J6 = function(A) {
  var g = A.scrollTop, I = A.scrollHeight, C = A.clientHeight;
  return [
    g,
    I,
    C
  ];
}, L6 = function(A) {
  var g = A.scrollLeft, I = A.scrollWidth, C = A.clientWidth;
  return [
    g,
    I,
    C
  ];
}, yR = function(A, g) {
  return A === "v" ? Q6(g) : z6(g);
}, DR = function(A, g) {
  return A === "v" ? J6(g) : L6(g);
}, q6 = function(A, g) {
  return A === "h" && g === "rtl" ? -1 : 1;
}, $6 = function(A, g, I, C, t) {
  var s = q6(A, window.getComputedStyle(g).direction), r = s * C, l = I.target, d = g.contains(l), h = !1, D = r > 0, w = 0, p = 0;
  do {
    if (!l)
      break;
    var b = DR(A, l), S = b[0], K = b[1], Y = b[2], T = K - Y - s * S;
    (S || T) && yR(A, l) && (w += T, p += S);
    var E = l.parentNode;
    l = E && E.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? E.host : E;
  } while (
    // portaled content
    !d && l !== document.body || // self content
    d && (g.contains(l) || g === l)
  );
  return (D && Math.abs(w) < 1 || !D && Math.abs(p) < 1) && (h = !0), h;
}, JB = function(A) {
  return "changedTouches" in A ? [A.changedTouches[0].clientX, A.changedTouches[0].clientY] : [0, 0];
}, vZ = function(A) {
  return [A.deltaX, A.deltaY];
}, HZ = function(A) {
  return A && "current" in A ? A.current : A;
}, gq = function(A, g) {
  return A[0] === g[0] && A[1] === g[1];
}, Iq = function(A) {
  return `
  .block-interactivity-`.concat(A, ` {pointer-events: none;}
  .allow-interactivity-`).concat(A, ` {pointer-events: all;}
`);
}, Aq = 0, tf = [];
function Cq(A) {
  var g = Z.useRef([]), I = Z.useRef([0, 0]), C = Z.useRef(), t = Z.useState(Aq++)[0], s = Z.useState(fR)[0], r = Z.useRef(A);
  Z.useEffect(function() {
    r.current = A;
  }, [A]), Z.useEffect(function() {
    if (A.inert) {
      document.body.classList.add("block-interactivity-".concat(t));
      var K = m6([A.lockRef.current], (A.shards || []).map(HZ), !0).filter(Boolean);
      return K.forEach(function(Y) {
        return Y.classList.add("allow-interactivity-".concat(t));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(t)), K.forEach(function(Y) {
          return Y.classList.remove("allow-interactivity-".concat(t));
        });
      };
    }
  }, [A.inert, A.lockRef.current, A.shards]);
  var l = Z.useCallback(function(K, Y) {
    if ("touches" in K && K.touches.length === 2 || K.type === "wheel" && K.ctrlKey)
      return !r.current.allowPinchZoom;
    var T = JB(K), E = I.current, H = "deltaX" in K ? K.deltaX : E[0] - T[0], R = "deltaY" in K ? K.deltaY : E[1] - T[1], x, U = K.target, J = Math.abs(H) > Math.abs(R) ? "h" : "v";
    if ("touches" in K && J === "h" && U.type === "range")
      return !1;
    var L = jZ(J, U);
    if (!L)
      return !0;
    if (L ? x = J : (x = J === "v" ? "h" : "v", L = jZ(J, U)), !L)
      return !1;
    if (!C.current && "changedTouches" in K && (H || R) && (C.current = x), !x)
      return !0;
    var eg = C.current || x;
    return $6(eg, Y, K, eg === "h" ? H : R);
  }, []), d = Z.useCallback(function(K) {
    var Y = K;
    if (!(!tf.length || tf[tf.length - 1] !== s)) {
      var T = "deltaY" in Y ? vZ(Y) : JB(Y), E = g.current.filter(function(x) {
        return x.name === Y.type && (x.target === Y.target || Y.target === x.shadowParent) && gq(x.delta, T);
      })[0];
      if (E && E.should) {
        Y.cancelable && Y.preventDefault();
        return;
      }
      if (!E) {
        var H = (r.current.shards || []).map(HZ).filter(Boolean).filter(function(x) {
          return x.contains(Y.target);
        }), R = H.length > 0 ? l(Y, H[0]) : !r.current.noIsolation;
        R && Y.cancelable && Y.preventDefault();
      }
    }
  }, []), h = Z.useCallback(function(K, Y, T, E) {
    var H = { name: K, delta: Y, target: T, should: E, shadowParent: eq(T) };
    g.current.push(H), setTimeout(function() {
      g.current = g.current.filter(function(R) {
        return R !== H;
      });
    }, 1);
  }, []), D = Z.useCallback(function(K) {
    I.current = JB(K), C.current = void 0;
  }, []), w = Z.useCallback(function(K) {
    h(K.type, vZ(K), K.target, l(K, A.lockRef.current));
  }, []), p = Z.useCallback(function(K) {
    h(K.type, JB(K), K.target, l(K, A.lockRef.current));
  }, []);
  Z.useEffect(function() {
    return tf.push(s), A.setCallbacks({
      onScrollCapture: w,
      onWheelCapture: w,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", d, ef), document.addEventListener("touchmove", d, ef), document.addEventListener("touchstart", D, ef), function() {
      tf = tf.filter(function(K) {
        return K !== s;
      }), document.removeEventListener("wheel", d, ef), document.removeEventListener("touchmove", d, ef), document.removeEventListener("touchstart", D, ef);
    };
  }, []);
  var b = A.removeScrollBar, S = A.inert;
  return Z.createElement(
    Z.Fragment,
    null,
    S ? Z.createElement(s, { styles: Iq(t) }) : null,
    b ? Z.createElement(F6, { noRelative: A.noRelative, gapMode: A.gapMode }) : null
  );
}
function eq(A) {
  for (var g = null; A !== null; )
    A instanceof ShadowRoot && (g = A.host, A = A.host), A = A.parentNode;
  return g;
}
const tq = j6(dR, Cq);
var mK = Z.forwardRef(function(A, g) {
  return Z.createElement(S0, Bs({}, A, { ref: g, sideCar: tq }));
});
mK.classNames = S0.classNames;
var iq = function(A) {
  if (typeof document > "u")
    return null;
  var g = Array.isArray(A) ? A[0] : A;
  return g.ownerDocument.body;
}, nf = /* @__PURE__ */ new WeakMap(), LB = /* @__PURE__ */ new WeakMap(), qB = {}, $b = 0, MR = function(A) {
  return A && (A.host || MR(A.parentNode));
}, nq = function(A, g) {
  return g.map(function(I) {
    if (A.contains(I))
      return I;
    var C = MR(I);
    return C && A.contains(C) ? C : (console.error("aria-hidden", I, "in not contained inside", A, ". Doing nothing"), null);
  }).filter(function(I) {
    return !!I;
  });
}, sq = function(A, g, I, C) {
  var t = nq(g, Array.isArray(A) ? A : [A]);
  qB[I] || (qB[I] = /* @__PURE__ */ new WeakMap());
  var s = qB[I], r = [], l = /* @__PURE__ */ new Set(), d = new Set(t), h = function(w) {
    !w || l.has(w) || (l.add(w), h(w.parentNode));
  };
  t.forEach(h);
  var D = function(w) {
    !w || d.has(w) || Array.prototype.forEach.call(w.children, function(p) {
      if (l.has(p))
        D(p);
      else
        try {
          var b = p.getAttribute(C), S = b !== null && b !== "false", K = (nf.get(p) || 0) + 1, Y = (s.get(p) || 0) + 1;
          nf.set(p, K), s.set(p, Y), r.push(p), K === 1 && S && LB.set(p, !0), Y === 1 && p.setAttribute(I, "true"), S || p.setAttribute(C, "true");
        } catch (T) {
          console.error("aria-hidden: cannot operate on ", p, T);
        }
    });
  };
  return D(g), l.clear(), $b++, function() {
    r.forEach(function(w) {
      var p = nf.get(w) - 1, b = s.get(w) - 1;
      nf.set(w, p), s.set(w, b), p || (LB.has(w) || w.removeAttribute(C), LB.delete(w)), b || w.removeAttribute(I);
    }), $b--, $b || (nf = /* @__PURE__ */ new WeakMap(), nf = /* @__PURE__ */ new WeakMap(), LB = /* @__PURE__ */ new WeakMap(), qB = {});
  };
}, wR = function(A, g, I) {
  I === void 0 && (I = "data-aria-hidden");
  var C = Array.from(Array.isArray(A) ? A : [A]), t = iq(A);
  return t ? (C.push.apply(C, Array.from(t.querySelectorAll("[aria-live], script"))), sq(C, t, I, "aria-hidden")) : function() {
    return null;
  };
}, G0 = "Dialog", [BR, vgg] = Tn(G0), [oq, Yn] = BR(G0), pR = (A) => {
  const {
    __scopeDialog: g,
    children: I,
    open: C,
    defaultOpen: t,
    onOpenChange: s,
    modal: r = !0
  } = A, l = Z.useRef(null), d = Z.useRef(null), [h, D] = mr({
    prop: C,
    defaultProp: t ?? !1,
    onChange: s,
    caller: G0
  });
  return /* @__PURE__ */ v.jsx(
    oq,
    {
      scope: g,
      triggerRef: l,
      contentRef: d,
      contentId: vi(),
      titleId: vi(),
      descriptionId: vi(),
      open: h,
      onOpenChange: D,
      onOpenToggle: Z.useCallback(() => D((w) => !w), [D]),
      modal: r,
      children: I
    }
  );
};
pR.displayName = G0;
var mR = "DialogTrigger", aq = Z.forwardRef(
  (A, g) => {
    const { __scopeDialog: I, ...C } = A, t = Yn(mR, I), s = BA(g, t.triggerRef);
    return /* @__PURE__ */ v.jsx(
      jI.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": t.open,
        "aria-controls": t.contentId,
        "data-state": GK(t.open),
        ...C,
        ref: s,
        onClick: RI(A.onClick, t.onOpenToggle)
      }
    );
  }
);
aq.displayName = mR;
var bK = "DialogPortal", [rq, bR] = BR(bK, {
  forceMount: void 0
}), SR = (A) => {
  const { __scopeDialog: g, forceMount: I, children: C, container: t } = A, s = Yn(bK, g);
  return /* @__PURE__ */ v.jsx(rq, { scope: g, forceMount: I, children: Z.Children.map(C, (r) => /* @__PURE__ */ v.jsx(Ks, { present: I || s.open, children: /* @__PURE__ */ v.jsx(y0, { asChild: !0, container: t, children: r }) })) });
};
SR.displayName = bK;
var Xp = "DialogOverlay", GR = Z.forwardRef(
  (A, g) => {
    const I = bR(Xp, A.__scopeDialog), { forceMount: C = I.forceMount, ...t } = A, s = Yn(Xp, A.__scopeDialog);
    return s.modal ? /* @__PURE__ */ v.jsx(Ks, { present: C || s.open, children: /* @__PURE__ */ v.jsx(cq, { ...t, ref: g }) }) : null;
  }
);
GR.displayName = Xp;
var lq = /* @__PURE__ */ jf("DialogOverlay.RemoveScroll"), cq = Z.forwardRef(
  (A, g) => {
    const { __scopeDialog: I, ...C } = A, t = Yn(Xp, I);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ v.jsx(mK, { as: lq, allowPinchZoom: !0, shards: [t.contentRef], children: /* @__PURE__ */ v.jsx(
        jI.div,
        {
          "data-state": GK(t.open),
          ...C,
          ref: g,
          style: { pointerEvents: "auto", ...C.style }
        }
      ) })
    );
  }
), Kc = "DialogContent", KR = Z.forwardRef(
  (A, g) => {
    const I = bR(Kc, A.__scopeDialog), { forceMount: C = I.forceMount, ...t } = A, s = Yn(Kc, A.__scopeDialog);
    return /* @__PURE__ */ v.jsx(Ks, { present: C || s.open, children: s.modal ? /* @__PURE__ */ v.jsx(uq, { ...t, ref: g }) : /* @__PURE__ */ v.jsx(dq, { ...t, ref: g }) });
  }
);
KR.displayName = Kc;
var uq = Z.forwardRef(
  (A, g) => {
    const I = Yn(Kc, A.__scopeDialog), C = Z.useRef(null), t = BA(g, I.contentRef, C);
    return Z.useEffect(() => {
      const s = C.current;
      if (s) return wR(s);
    }, []), /* @__PURE__ */ v.jsx(
      TR,
      {
        ...A,
        ref: t,
        trapFocus: I.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: RI(A.onCloseAutoFocus, (s) => {
          s.preventDefault(), I.triggerRef.current?.focus();
        }),
        onPointerDownOutside: RI(A.onPointerDownOutside, (s) => {
          const r = s.detail.originalEvent, l = r.button === 0 && r.ctrlKey === !0;
          (r.button === 2 || l) && s.preventDefault();
        }),
        onFocusOutside: RI(
          A.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), dq = Z.forwardRef(
  (A, g) => {
    const I = Yn(Kc, A.__scopeDialog), C = Z.useRef(!1), t = Z.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      TR,
      {
        ...A,
        ref: g,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          A.onCloseAutoFocus?.(s), s.defaultPrevented || (C.current || I.triggerRef.current?.focus(), s.preventDefault()), C.current = !1, t.current = !1;
        },
        onInteractOutside: (s) => {
          A.onInteractOutside?.(s), s.defaultPrevented || (C.current = !0, s.detail.originalEvent.type === "pointerdown" && (t.current = !0));
          const r = s.target;
          I.triggerRef.current?.contains(r) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && t.current && s.preventDefault();
        }
      }
    );
  }
), TR = Z.forwardRef(
  (A, g) => {
    const { __scopeDialog: I, trapFocus: C, onOpenAutoFocus: t, onCloseAutoFocus: s, ...r } = A, l = Yn(Kc, I), d = Z.useRef(null), h = BA(g, d);
    return lR(), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        pK,
        {
          asChild: !0,
          loop: !0,
          trapped: C,
          onMountAutoFocus: t,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ v.jsx(
            D0,
            {
              role: "dialog",
              id: l.contentId,
              "aria-describedby": l.descriptionId,
              "aria-labelledby": l.titleId,
              "data-state": GK(l.open),
              ...r,
              ref: h,
              onDismiss: () => l.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(fq, { titleId: l.titleId }),
        /* @__PURE__ */ v.jsx(yq, { contentRef: d, descriptionId: l.descriptionId })
      ] })
    ] });
  }
), SK = "DialogTitle", YR = Z.forwardRef(
  (A, g) => {
    const { __scopeDialog: I, ...C } = A, t = Yn(SK, I);
    return /* @__PURE__ */ v.jsx(jI.h2, { id: t.titleId, ...C, ref: g });
  }
);
YR.displayName = SK;
var PR = "DialogDescription", ZR = Z.forwardRef(
  (A, g) => {
    const { __scopeDialog: I, ...C } = A, t = Yn(PR, I);
    return /* @__PURE__ */ v.jsx(jI.p, { id: t.descriptionId, ...C, ref: g });
  }
);
ZR.displayName = PR;
var jR = "DialogClose", vR = Z.forwardRef(
  (A, g) => {
    const { __scopeDialog: I, ...C } = A, t = Yn(jR, I);
    return /* @__PURE__ */ v.jsx(
      jI.button,
      {
        type: "button",
        ...C,
        ref: g,
        onClick: RI(A.onClick, () => t.onOpenChange(!1))
      }
    );
  }
);
vR.displayName = jR;
function GK(A) {
  return A ? "open" : "closed";
}
var HR = "DialogTitleWarning", [Hgg, ER] = kz(HR, {
  contentName: Kc,
  titleName: SK,
  docsSlug: "dialog"
}), fq = ({ titleId: A }) => {
  const g = ER(HR), I = `\`${g.contentName}\` requires a \`${g.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${g.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${g.docsSlug}`;
  return Z.useEffect(() => {
    A && (document.getElementById(A) || console.error(I));
  }, [I, A]), null;
}, hq = "DialogDescriptionWarning", yq = ({ contentRef: A, descriptionId: g }) => {
  const C = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${ER(hq).contentName}}.`;
  return Z.useEffect(() => {
    const t = A.current?.getAttribute("aria-describedby");
    g && t && (document.getElementById(g) || console.warn(C));
  }, [C, A, g]), null;
}, RR = pR, OR = SR, NR = GR, kR = KR, Dq = YR, Mq = ZR, wq = vR, XD = '[cmdk-group=""]', gS = '[cmdk-group-items=""]', Bq = '[cmdk-group-heading=""]', WR = '[cmdk-item=""]', EZ = `${WR}:not([aria-disabled="true"])`, qS = "cmdk-item-select", of = "data-value", pq = (A, g, I) => f6(A, g, I), VR = Z.createContext(void 0), jM = () => Z.useContext(VR), xR = Z.createContext(void 0), KK = () => Z.useContext(xR), _R = Z.createContext(void 0), UR = Z.forwardRef((A, g) => {
  let I = af(() => {
    var F, rg;
    return { search: "", value: (rg = (F = A.value) != null ? F : A.defaultValue) != null ? rg : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), C = af(() => /* @__PURE__ */ new Set()), t = af(() => /* @__PURE__ */ new Map()), s = af(() => /* @__PURE__ */ new Map()), r = af(() => /* @__PURE__ */ new Set()), l = FR(A), { label: d, children: h, value: D, onValueChange: w, filter: p, shouldFilter: b, loop: S, disablePointerSelection: K = !1, vimBindings: Y = !0, ...T } = A, E = vi(), H = vi(), R = vi(), x = Z.useRef(null), U = vq();
  Tc(() => {
    if (D !== void 0) {
      let F = D.trim();
      I.current.value = F, J.emit();
    }
  }, [D]), Tc(() => {
    U(6, Kg);
  }, []);
  let J = Z.useMemo(() => ({ subscribe: (F) => (r.current.add(F), () => r.current.delete(F)), snapshot: () => I.current, setState: (F, rg, Cg) => {
    var Sg, kg, Yg, Wg;
    if (!Object.is(I.current[F], rg)) {
      if (I.current[F] = rg, F === "search") Zg(), Mg(), U(1, ig);
      else if (F === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let Xg = document.getElementById(R);
          Xg ? Xg.focus() : (Sg = document.getElementById(E)) == null || Sg.focus();
        }
        if (U(7, () => {
          var Xg;
          I.current.selectedItemId = (Xg = mg()) == null ? void 0 : Xg.id, J.emit();
        }), Cg || U(5, Kg), ((kg = l.current) == null ? void 0 : kg.value) !== void 0) {
          let Xg = rg ?? "";
          (Wg = (Yg = l.current).onValueChange) == null || Wg.call(Yg, Xg);
          return;
        }
      }
      J.emit();
    }
  }, emit: () => {
    r.current.forEach((F) => F());
  } }), []), L = Z.useMemo(() => ({ value: (F, rg, Cg) => {
    var Sg;
    rg !== ((Sg = s.current.get(F)) == null ? void 0 : Sg.value) && (s.current.set(F, { value: rg, keywords: Cg }), I.current.filtered.items.set(F, eg(rg, Cg)), U(2, () => {
      Mg(), J.emit();
    }));
  }, item: (F, rg) => (C.current.add(F), rg && (t.current.has(rg) ? t.current.get(rg).add(F) : t.current.set(rg, /* @__PURE__ */ new Set([F]))), U(3, () => {
    Zg(), Mg(), I.current.value || ig(), J.emit();
  }), () => {
    s.current.delete(F), C.current.delete(F), I.current.filtered.items.delete(F);
    let Cg = mg();
    U(4, () => {
      Zg(), Cg?.getAttribute("id") === F && ig(), J.emit();
    });
  }), group: (F) => (t.current.has(F) || t.current.set(F, /* @__PURE__ */ new Set()), () => {
    s.current.delete(F), t.current.delete(F);
  }), filter: () => l.current.shouldFilter, label: d || A["aria-label"], getDisablePointerSelection: () => l.current.disablePointerSelection, listId: E, inputId: R, labelId: H, listInnerRef: x }), []);
  function eg(F, rg) {
    var Cg, Sg;
    let kg = (Sg = (Cg = l.current) == null ? void 0 : Cg.filter) != null ? Sg : pq;
    return F ? kg(F, I.current.search, rg) : 0;
  }
  function Mg() {
    if (!I.current.search || l.current.shouldFilter === !1) return;
    let F = I.current.filtered.items, rg = [];
    I.current.filtered.groups.forEach((Sg) => {
      let kg = t.current.get(Sg), Yg = 0;
      kg.forEach((Wg) => {
        let Xg = F.get(Wg);
        Yg = Math.max(Xg, Yg);
      }), rg.push([Sg, Yg]);
    });
    let Cg = x.current;
    Ng().sort((Sg, kg) => {
      var Yg, Wg;
      let Xg = Sg.getAttribute("id"), nI = kg.getAttribute("id");
      return ((Yg = F.get(nI)) != null ? Yg : 0) - ((Wg = F.get(Xg)) != null ? Wg : 0);
    }).forEach((Sg) => {
      let kg = Sg.closest(gS);
      kg ? kg.appendChild(Sg.parentElement === kg ? Sg : Sg.closest(`${gS} > *`)) : Cg.appendChild(Sg.parentElement === Cg ? Sg : Sg.closest(`${gS} > *`));
    }), rg.sort((Sg, kg) => kg[1] - Sg[1]).forEach((Sg) => {
      var kg;
      let Yg = (kg = x.current) == null ? void 0 : kg.querySelector(`${XD}[${of}="${encodeURIComponent(Sg[0])}"]`);
      Yg?.parentElement.appendChild(Yg);
    });
  }
  function ig() {
    let F = Ng().find((Cg) => Cg.getAttribute("aria-disabled") !== "true"), rg = F?.getAttribute(of);
    J.setState("value", rg || void 0);
  }
  function Zg() {
    var F, rg, Cg, Sg;
    if (!I.current.search || l.current.shouldFilter === !1) {
      I.current.filtered.count = C.current.size;
      return;
    }
    I.current.filtered.groups = /* @__PURE__ */ new Set();
    let kg = 0;
    for (let Yg of C.current) {
      let Wg = (rg = (F = s.current.get(Yg)) == null ? void 0 : F.value) != null ? rg : "", Xg = (Sg = (Cg = s.current.get(Yg)) == null ? void 0 : Cg.keywords) != null ? Sg : [], nI = eg(Wg, Xg);
      I.current.filtered.items.set(Yg, nI), nI > 0 && kg++;
    }
    for (let [Yg, Wg] of t.current) for (let Xg of Wg) if (I.current.filtered.items.get(Xg) > 0) {
      I.current.filtered.groups.add(Yg);
      break;
    }
    I.current.filtered.count = kg;
  }
  function Kg() {
    var F, rg, Cg;
    let Sg = mg();
    Sg && (((F = Sg.parentElement) == null ? void 0 : F.firstChild) === Sg && ((Cg = (rg = Sg.closest(XD)) == null ? void 0 : rg.querySelector(Bq)) == null || Cg.scrollIntoView({ block: "nearest" })), Sg.scrollIntoView({ block: "nearest" }));
  }
  function mg() {
    var F;
    return (F = x.current) == null ? void 0 : F.querySelector(`${WR}[aria-selected="true"]`);
  }
  function Ng() {
    var F;
    return Array.from(((F = x.current) == null ? void 0 : F.querySelectorAll(EZ)) || []);
  }
  function cg(F) {
    let rg = Ng()[F];
    rg && J.setState("value", rg.getAttribute(of));
  }
  function z(F) {
    var rg;
    let Cg = mg(), Sg = Ng(), kg = Sg.findIndex((Wg) => Wg === Cg), Yg = Sg[kg + F];
    (rg = l.current) != null && rg.loop && (Yg = kg + F < 0 ? Sg[Sg.length - 1] : kg + F === Sg.length ? Sg[0] : Sg[kg + F]), Yg && J.setState("value", Yg.getAttribute(of));
  }
  function Q(F) {
    let rg = mg(), Cg = rg?.closest(XD), Sg;
    for (; Cg && !Sg; ) Cg = F > 0 ? Zq(Cg, XD) : jq(Cg, XD), Sg = Cg?.querySelector(EZ);
    Sg ? J.setState("value", Sg.getAttribute(of)) : z(F);
  }
  let Bg = () => cg(Ng().length - 1), Rg = (F) => {
    F.preventDefault(), F.metaKey ? Bg() : F.altKey ? Q(1) : z(1);
  }, N = (F) => {
    F.preventDefault(), F.metaKey ? cg(0) : F.altKey ? Q(-1) : z(-1);
  };
  return Z.createElement(jI.div, { ref: g, tabIndex: -1, ...T, "cmdk-root": "", onKeyDown: (F) => {
    var rg;
    (rg = T.onKeyDown) == null || rg.call(T, F);
    let Cg = F.nativeEvent.isComposing || F.keyCode === 229;
    if (!(F.defaultPrevented || Cg)) switch (F.key) {
      case "n":
      case "j": {
        Y && F.ctrlKey && Rg(F);
        break;
      }
      case "ArrowDown": {
        Rg(F);
        break;
      }
      case "p":
      case "k": {
        Y && F.ctrlKey && N(F);
        break;
      }
      case "ArrowUp": {
        N(F);
        break;
      }
      case "Home": {
        F.preventDefault(), cg(0);
        break;
      }
      case "End": {
        F.preventDefault(), Bg();
        break;
      }
      case "Enter": {
        F.preventDefault();
        let Sg = mg();
        if (Sg) {
          let kg = new Event(qS);
          Sg.dispatchEvent(kg);
        }
      }
    }
  } }, Z.createElement("label", { "cmdk-label": "", htmlFor: L.inputId, id: L.labelId, style: Eq }, d), K0(A, (F) => Z.createElement(xR.Provider, { value: J }, Z.createElement(VR.Provider, { value: L }, F))));
}), mq = Z.forwardRef((A, g) => {
  var I, C;
  let t = vi(), s = Z.useRef(null), r = Z.useContext(_R), l = jM(), d = FR(A), h = (C = (I = d.current) == null ? void 0 : I.forceMount) != null ? C : r?.forceMount;
  Tc(() => {
    if (!h) return l.item(t, r?.id);
  }, [h]);
  let D = XR(t, s, [A.value, A.children, s], A.keywords), w = KK(), p = pr((U) => U.value && U.value === D.current), b = pr((U) => h || l.filter() === !1 ? !0 : U.search ? U.filtered.items.get(t) > 0 : !0);
  Z.useEffect(() => {
    let U = s.current;
    if (!(!U || A.disabled)) return U.addEventListener(qS, S), () => U.removeEventListener(qS, S);
  }, [b, A.onSelect, A.disabled]);
  function S() {
    var U, J;
    K(), (J = (U = d.current).onSelect) == null || J.call(U, D.current);
  }
  function K() {
    w.setState("value", D.current, !0);
  }
  if (!b) return null;
  let { disabled: Y, value: T, onSelect: E, forceMount: H, keywords: R, ...x } = A;
  return Z.createElement(jI.div, { ref: mc(s, g), ...x, id: t, "cmdk-item": "", role: "option", "aria-disabled": !!Y, "aria-selected": !!p, "data-disabled": !!Y, "data-selected": !!p, onPointerMove: Y || l.getDisablePointerSelection() ? void 0 : K, onClick: Y ? void 0 : S }, A.children);
}), bq = Z.forwardRef((A, g) => {
  let { heading: I, children: C, forceMount: t, ...s } = A, r = vi(), l = Z.useRef(null), d = Z.useRef(null), h = vi(), D = jM(), w = pr((b) => t || D.filter() === !1 ? !0 : b.search ? b.filtered.groups.has(r) : !0);
  Tc(() => D.group(r), []), XR(r, l, [A.value, A.heading, d]);
  let p = Z.useMemo(() => ({ id: r, forceMount: t }), [t]);
  return Z.createElement(jI.div, { ref: mc(l, g), ...s, "cmdk-group": "", role: "presentation", hidden: w ? void 0 : !0 }, I && Z.createElement("div", { ref: d, "cmdk-group-heading": "", "aria-hidden": !0, id: h }, I), K0(A, (b) => Z.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": I ? h : void 0 }, Z.createElement(_R.Provider, { value: p }, b))));
}), Sq = Z.forwardRef((A, g) => {
  let { alwaysRender: I, ...C } = A, t = Z.useRef(null), s = pr((r) => !r.search);
  return !I && !s ? null : Z.createElement(jI.div, { ref: mc(t, g), ...C, "cmdk-separator": "", role: "separator" });
}), Gq = Z.forwardRef((A, g) => {
  let { onValueChange: I, ...C } = A, t = A.value != null, s = KK(), r = pr((h) => h.search), l = pr((h) => h.selectedItemId), d = jM();
  return Z.useEffect(() => {
    A.value != null && s.setState("search", A.value);
  }, [A.value]), Z.createElement(jI.input, { ref: g, ...C, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: !1, "aria-autocomplete": "list", role: "combobox", "aria-expanded": !0, "aria-controls": d.listId, "aria-labelledby": d.labelId, "aria-activedescendant": l, id: d.inputId, type: "text", value: t ? A.value : r, onChange: (h) => {
    t || s.setState("search", h.target.value), I?.(h.target.value);
  } });
}), Kq = Z.forwardRef((A, g) => {
  let { children: I, label: C = "Suggestions", ...t } = A, s = Z.useRef(null), r = Z.useRef(null), l = pr((h) => h.selectedItemId), d = jM();
  return Z.useEffect(() => {
    if (r.current && s.current) {
      let h = r.current, D = s.current, w, p = new ResizeObserver(() => {
        w = requestAnimationFrame(() => {
          let b = h.offsetHeight;
          D.style.setProperty("--cmdk-list-height", b.toFixed(1) + "px");
        });
      });
      return p.observe(h), () => {
        cancelAnimationFrame(w), p.unobserve(h);
      };
    }
  }, []), Z.createElement(jI.div, { ref: mc(s, g), ...t, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": l, "aria-label": C, id: d.listId }, K0(A, (h) => Z.createElement("div", { ref: mc(r, d.listInnerRef), "cmdk-list-sizer": "" }, h)));
}), Tq = Z.forwardRef((A, g) => {
  let { open: I, onOpenChange: C, overlayClassName: t, contentClassName: s, container: r, ...l } = A;
  return Z.createElement(RR, { open: I, onOpenChange: C }, Z.createElement(OR, { container: r }, Z.createElement(NR, { "cmdk-overlay": "", className: t }), Z.createElement(kR, { "aria-label": A.label, "cmdk-dialog": "", className: s }, Z.createElement(UR, { ref: g, ...l }))));
}), Yq = Z.forwardRef((A, g) => pr((I) => I.filtered.count === 0) ? Z.createElement(jI.div, { ref: g, ...A, "cmdk-empty": "", role: "presentation" }) : null), Pq = Z.forwardRef((A, g) => {
  let { progress: I, children: C, label: t = "Loading...", ...s } = A;
  return Z.createElement(jI.div, { ref: g, ...s, "cmdk-loading": "", role: "progressbar", "aria-valuenow": I, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": t }, K0(A, (r) => Z.createElement("div", { "aria-hidden": !0 }, r)));
}), Hc = Object.assign(UR, { List: Kq, Item: mq, Input: Gq, Group: bq, Separator: Sq, Dialog: Tq, Empty: Yq, Loading: Pq });
function Zq(A, g) {
  let I = A.nextElementSibling;
  for (; I; ) {
    if (I.matches(g)) return I;
    I = I.nextElementSibling;
  }
}
function jq(A, g) {
  let I = A.previousElementSibling;
  for (; I; ) {
    if (I.matches(g)) return I;
    I = I.previousElementSibling;
  }
}
function FR(A) {
  let g = Z.useRef(A);
  return Tc(() => {
    g.current = A;
  }), g;
}
var Tc = typeof window > "u" ? Z.useEffect : Z.useLayoutEffect;
function af(A) {
  let g = Z.useRef();
  return g.current === void 0 && (g.current = A()), g;
}
function pr(A) {
  let g = KK(), I = () => A(g.snapshot());
  return Z.useSyncExternalStore(g.subscribe, I, I);
}
function XR(A, g, I, C = []) {
  let t = Z.useRef(), s = jM();
  return Tc(() => {
    var r;
    let l = (() => {
      var h;
      for (let D of I) {
        if (typeof D == "string") return D.trim();
        if (typeof D == "object" && "current" in D) return D.current ? (h = D.current.textContent) == null ? void 0 : h.trim() : t.current;
      }
    })(), d = C.map((h) => h.trim());
    s.value(A, l, d), (r = g.current) == null || r.setAttribute(of, l), t.current = l;
  }), t;
}
var vq = () => {
  let [A, g] = Z.useState(), I = af(() => /* @__PURE__ */ new Map());
  return Tc(() => {
    I.current.forEach((C) => C()), I.current = /* @__PURE__ */ new Map();
  }, [A]), (C, t) => {
    I.current.set(C, t), g({});
  };
};
function Hq(A) {
  let g = A.type;
  return typeof g == "function" ? g(A.props) : "render" in g ? g.render(A.props) : A;
}
function K0({ asChild: A, children: g }, I) {
  return A && Z.isValidElement(g) ? Z.cloneElement(Hq(g), { ref: g.ref }, I(g.props.children)) : I(g);
}
var Eq = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };
function QR({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(RR, { "data-slot": "dialog", modal: !1, ...A });
}
function Rq() {
  if (!(typeof window > "u"))
    return window.__SPATIALVISTA_DIALOG_PORTAL__;
}
function Oq({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(
    OR,
    {
      "data-slot": "dialog-portal",
      container: Rq(),
      ...A
    }
  );
}
function Nq({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    NR,
    {
      "data-slot": "dialog-overlay",
      className: kI(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 absolute inset-0 z-50 bg-black/50 pointer-events-auto",
        A
      ),
      ...g
    }
  );
}
function zR({
  className: A,
  children: g,
  showCloseButton: I = !0,
  ...C
}) {
  return /* @__PURE__ */ v.jsxs(Oq, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ v.jsx(Nq, {}),
    /* @__PURE__ */ v.jsxs(
      kR,
      {
        "data-slot": "dialog-content",
        className: kI(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 absolute top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg pointer-events-auto",
          A
        ),
        ...C,
        children: [
          g,
          I && /* @__PURE__ */ v.jsxs(
            wq,
            {
              "data-slot": "dialog-close",
              className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
              children: [
                /* @__PURE__ */ v.jsx(Oz, {}),
                /* @__PURE__ */ v.jsx("span", { className: "sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function JR({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: kI("flex flex-col gap-2 text-center sm:text-left", A),
      ...g
    }
  );
}
function kq({ className: A, ...g }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: kI(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        A
      ),
      ...g
    }
  );
}
function LR({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Dq,
    {
      "data-slot": "dialog-title",
      className: kI("text-lg leading-none font-semibold", A),
      ...g
    }
  );
}
function qR({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Mq,
    {
      "data-slot": "dialog-description",
      className: kI("text-muted-foreground text-sm", A),
      ...g
    }
  );
}
function Wq({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Hc,
    {
      "data-slot": "command",
      className: kI(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        A
      ),
      ...g
    }
  );
}
function Vq({
  title: A = "Command Palette",
  description: g = "Search for a command to run...",
  children: I,
  className: C,
  showCloseButton: t = !0,
  ...s
}) {
  return /* @__PURE__ */ v.jsxs(QR, { ...s, children: [
    /* @__PURE__ */ v.jsxs(JR, { className: "sr-only", children: [
      /* @__PURE__ */ v.jsx(LR, { children: A }),
      /* @__PURE__ */ v.jsx(qR, { children: g })
    ] }),
    /* @__PURE__ */ v.jsx(
      zR,
      {
        className: kI("overflow-hidden p-0", C),
        showCloseButton: t,
        children: /* @__PURE__ */ v.jsx(Wq, { className: "[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5", children: I })
      }
    )
  ] });
}
function xq({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsxs(
    "div",
    {
      "data-slot": "command-input-wrapper",
      className: "flex h-9 items-center gap-2 border-b px-3",
      children: [
        /* @__PURE__ */ v.jsx(RH, { className: "size-4 shrink-0 opacity-50" }),
        /* @__PURE__ */ v.jsx(
          Hc.Input,
          {
            "data-slot": "command-input",
            className: kI(
              "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
              A
            ),
            ...g
          }
        )
      ]
    }
  );
}
function _q({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Hc.List,
    {
      "data-slot": "command-list",
      className: kI(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        A
      ),
      ...g
    }
  );
}
function Uq({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(
    Hc.Empty,
    {
      "data-slot": "command-empty",
      className: "py-6 text-center text-sm",
      ...A
    }
  );
}
function IS({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Hc.Group,
    {
      "data-slot": "command-group",
      className: kI(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        A
      ),
      ...g
    }
  );
}
function Fq({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Hc.Separator,
    {
      "data-slot": "command-separator",
      className: kI("bg-border -mx-1 h-px", A),
      ...g
    }
  );
}
function AS({
  className: A,
  ...g
}) {
  return /* @__PURE__ */ v.jsx(
    Hc.Item,
    {
      "data-slot": "command-item",
      className: kI(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        A
      ),
      ...g
    }
  );
}
const Xq = ({
  open: A,
  activeContinuous: g,
  continuousFields: I,
  onOpenChange: C,
  onSelectContinuous: t
}) => {
  const s = Object.values(I).filter(
    (l) => l.ContinuousConfig.Source === "gene"
  ), r = Object.values(I).filter(
    (l) => l.ContinuousConfig.Source === "obs"
  );
  return /* @__PURE__ */ v.jsxs(Vq, { open: A, onOpenChange: C, children: [
    /* @__PURE__ */ v.jsx(xq, { placeholder: "Search numeric fields..." }),
    /* @__PURE__ */ v.jsxs(_q, { children: [
      /* @__PURE__ */ v.jsx(Uq, { children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center flex-col text-center py-4", children: [
        /* @__PURE__ */ v.jsx(Dz, { className: "h-4 w-4" }),
        /* @__PURE__ */ v.jsx("span", { children: "No numeric fields found" })
      ] }) }),
      g && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(IS, { heading: "Current Selection", children: /* @__PURE__ */ v.jsxs(
          AS,
          {
            onSelect: () => {
              t(null), C(!1);
            },
            children: [
              /* @__PURE__ */ v.jsx(pz, { className: "mr-2 h-4 w-4" }),
              /* @__PURE__ */ v.jsxs("span", { children: [
                "Clear ",
                g
              ] })
            ]
          }
        ) }),
        /* @__PURE__ */ v.jsx(Fq, {})
      ] }),
      /* @__PURE__ */ v.jsx(IS, { heading: "Continuous Fields", children: r.map((l) => {
        const d = g === l.name;
        return /* @__PURE__ */ v.jsxs(
          AS,
          {
            value: l.name,
            keywords: [l.name, l.ContinuousConfig.Source],
            onSelect: () => {
              t(d ? null : l.name), C(!1);
            },
            className: d ? "bg-primary/10 font-medium" : "",
            children: [
              d && /* @__PURE__ */ v.jsx("span", { className: "mr-2 text-green-400", children: /* @__PURE__ */ v.jsx(eZ, { className: "h-4 w-4" }) }),
              /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col flex-1", children: [
                /* @__PURE__ */ v.jsx("span", { children: l.name }),
                /* @__PURE__ */ v.jsxs("span", { className: "text-xs text-muted-foreground", children: [
                  l.ContinuousConfig.Source,
                  "  [",
                  l.ContinuousConfig.Min.toFixed(2),
                  ",",
                  " ",
                  l.ContinuousConfig.Max.toFixed(2),
                  "]"
                ] })
              ] })
            ]
          },
          l.name
        );
      }) }),
      /* @__PURE__ */ v.jsx(IS, { heading: "Gene Expression", children: s.map((l) => {
        const d = g === l.name;
        return /* @__PURE__ */ v.jsxs(
          AS,
          {
            value: l.name,
            keywords: [l.name, l.ContinuousConfig.Source],
            onSelect: () => {
              t(d ? null : l.name), C(!1);
            },
            className: d ? "bg-primary/10 font-medium" : "",
            children: [
              d && /* @__PURE__ */ v.jsx("span", { className: "mr-2 text-green-400", children: /* @__PURE__ */ v.jsx(eZ, { className: "h-4 w-4" }) }),
              /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col flex-1", children: [
                /* @__PURE__ */ v.jsx("span", { children: l.name }),
                /* @__PURE__ */ v.jsxs("span", { className: "text-xs text-muted-foreground", children: [
                  l.ContinuousConfig.Source,
                  "  [",
                  l.ContinuousConfig.Min.toFixed(2),
                  ",",
                  " ",
                  l.ContinuousConfig.Max.toFixed(2),
                  "]"
                ] })
              ] })
            ]
          },
          l.name
        );
      }) })
    ] })
  ] });
};
function T0() {
  return (T0 = Object.assign || function(A) {
    for (var g = 1; g < arguments.length; g++) {
      var I = arguments[g];
      for (var C in I) Object.prototype.hasOwnProperty.call(I, C) && (A[C] = I[C]);
    }
    return A;
  }).apply(this, arguments);
}
function $R(A, g) {
  if (A == null) return {};
  var I, C, t = {}, s = Object.keys(A);
  for (C = 0; C < s.length; C++) g.indexOf(I = s[C]) >= 0 || (t[I] = A[I]);
  return t;
}
function $S(A) {
  var g = Z.useRef(A), I = Z.useRef(function(C) {
    g.current && g.current(C);
  });
  return g.current = A, I.current;
}
var BM = function(A, g, I) {
  return g === void 0 && (g = 0), I === void 0 && (I = 1), A > I ? I : A < g ? g : A;
}, rM = function(A) {
  return "touches" in A;
}, gG = function(A) {
  return A && A.ownerDocument.defaultView || self;
}, RZ = function(A, g, I) {
  var C = A.getBoundingClientRect(), t = rM(g) ? (function(s, r) {
    for (var l = 0; l < s.length; l++) if (s[l].identifier === r) return s[l];
    return s[0];
  })(g.touches, I) : g;
  return { left: BM((t.pageX - (C.left + gG(A).pageXOffset)) / C.width), top: BM((t.pageY - (C.top + gG(A).pageYOffset)) / C.height) };
}, OZ = function(A) {
  !rM(A) && A.preventDefault();
}, gO = EA.memo(function(A) {
  var g = A.onMove, I = A.onKey, C = $R(A, ["onMove", "onKey"]), t = Z.useRef(null), s = $S(g), r = $S(I), l = Z.useRef(null), d = Z.useRef(!1), h = Z.useMemo(function() {
    var b = function(Y) {
      OZ(Y), (rM(Y) ? Y.touches.length > 0 : Y.buttons > 0) && t.current ? s(RZ(t.current, Y, l.current)) : K(!1);
    }, S = function() {
      return K(!1);
    };
    function K(Y) {
      var T = d.current, E = gG(t.current), H = Y ? E.addEventListener : E.removeEventListener;
      H(T ? "touchmove" : "mousemove", b), H(T ? "touchend" : "mouseup", S);
    }
    return [function(Y) {
      var T = Y.nativeEvent, E = t.current;
      if (E && (OZ(T), !(function(R, x) {
        return x && !rM(R);
      })(T, d.current) && E)) {
        if (rM(T)) {
          d.current = !0;
          var H = T.changedTouches || [];
          H.length && (l.current = H[0].identifier);
        }
        E.focus(), s(RZ(E, T, l.current)), K(!0);
      }
    }, function(Y) {
      var T = Y.which || Y.keyCode;
      T < 37 || T > 40 || (Y.preventDefault(), r({ left: T === 39 ? 0.05 : T === 37 ? -0.05 : 0, top: T === 40 ? 0.05 : T === 38 ? -0.05 : 0 }));
    }, K];
  }, [r, s]), D = h[0], w = h[1], p = h[2];
  return Z.useEffect(function() {
    return p;
  }, [p]), EA.createElement("div", T0({}, C, { onTouchStart: D, onMouseDown: D, className: "react-colorful__interactive", ref: t, onKeyDown: w, tabIndex: 0, role: "slider" }));
}), TK = function(A) {
  return A.filter(Boolean).join(" ");
}, IO = function(A) {
  var g = A.color, I = A.left, C = A.top, t = C === void 0 ? 0.5 : C, s = TK(["react-colorful__pointer", A.className]);
  return EA.createElement("div", { className: s, style: { top: 100 * t + "%", left: 100 * I + "%" } }, EA.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: g } }));
}, ge = function(A, g, I) {
  return g === void 0 && (g = 0), I === void 0 && (I = Math.pow(10, g)), Math.round(I * A) / I;
}, Qq = function(A) {
  return $q(IG(A));
}, IG = function(A) {
  return A[0] === "#" && (A = A.substring(1)), A.length < 6 ? { r: parseInt(A[0] + A[0], 16), g: parseInt(A[1] + A[1], 16), b: parseInt(A[2] + A[2], 16), a: A.length === 4 ? ge(parseInt(A[3] + A[3], 16) / 255, 2) : 1 } : { r: parseInt(A.substring(0, 2), 16), g: parseInt(A.substring(2, 4), 16), b: parseInt(A.substring(4, 6), 16), a: A.length === 8 ? ge(parseInt(A.substring(6, 8), 16) / 255, 2) : 1 };
}, zq = function(A) {
  return qq(Lq(A));
}, Jq = function(A) {
  var g = A.s, I = A.v, C = A.a, t = (200 - g) * I / 100;
  return { h: ge(A.h), s: ge(t > 0 && t < 200 ? g * I / 100 / (t <= 100 ? t : 200 - t) * 100 : 0), l: ge(t / 2), a: ge(C, 2) };
}, AG = function(A) {
  var g = Jq(A);
  return "hsl(" + g.h + ", " + g.s + "%, " + g.l + "%)";
}, Lq = function(A) {
  var g = A.h, I = A.s, C = A.v, t = A.a;
  g = g / 360 * 6, I /= 100, C /= 100;
  var s = Math.floor(g), r = C * (1 - I), l = C * (1 - (g - s) * I), d = C * (1 - (1 - g + s) * I), h = s % 6;
  return { r: ge(255 * [C, l, r, r, d, C][h]), g: ge(255 * [d, C, C, l, r, r][h]), b: ge(255 * [r, r, d, C, C, l][h]), a: ge(t, 2) };
}, $B = function(A) {
  var g = A.toString(16);
  return g.length < 2 ? "0" + g : g;
}, qq = function(A) {
  var g = A.r, I = A.g, C = A.b, t = A.a, s = t < 1 ? $B(ge(255 * t)) : "";
  return "#" + $B(g) + $B(I) + $B(C) + s;
}, $q = function(A) {
  var g = A.r, I = A.g, C = A.b, t = A.a, s = Math.max(g, I, C), r = s - Math.min(g, I, C), l = r ? s === g ? (I - C) / r : s === I ? 2 + (C - g) / r : 4 + (g - I) / r : 0;
  return { h: ge(60 * (l < 0 ? l + 6 : l)), s: ge(s ? r / s * 100 : 0), v: ge(s / 255 * 100), a: t };
}, g$ = EA.memo(function(A) {
  var g = A.hue, I = A.onChange, C = TK(["react-colorful__hue", A.className]);
  return EA.createElement("div", { className: C }, EA.createElement(gO, { onMove: function(t) {
    I({ h: 360 * t.left });
  }, onKey: function(t) {
    I({ h: BM(g + 360 * t.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": ge(g), "aria-valuemax": "360", "aria-valuemin": "0" }, EA.createElement(IO, { className: "react-colorful__hue-pointer", left: g / 360, color: AG({ h: g, s: 100, v: 100, a: 1 }) })));
}), I$ = EA.memo(function(A) {
  var g = A.hsva, I = A.onChange, C = { backgroundColor: AG({ h: g.h, s: 100, v: 100, a: 1 }) };
  return EA.createElement("div", { className: "react-colorful__saturation", style: C }, EA.createElement(gO, { onMove: function(t) {
    I({ s: 100 * t.left, v: 100 - 100 * t.top });
  }, onKey: function(t) {
    I({ s: BM(g.s + 100 * t.left, 0, 100), v: BM(g.v - 100 * t.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + ge(g.s) + "%, Brightness " + ge(g.v) + "%" }, EA.createElement(IO, { className: "react-colorful__saturation-pointer", top: 1 - g.v / 100, left: g.s / 100, color: AG(g) })));
}), AO = function(A, g) {
  if (A === g) return !0;
  for (var I in A) if (A[I] !== g[I]) return !1;
  return !0;
}, A$ = function(A, g) {
  return A.toLowerCase() === g.toLowerCase() || AO(IG(A), IG(g));
};
function C$(A, g, I) {
  var C = $S(I), t = Z.useState(function() {
    return A.toHsva(g);
  }), s = t[0], r = t[1], l = Z.useRef({ color: g, hsva: s });
  Z.useEffect(function() {
    if (!A.equal(g, l.current.color)) {
      var h = A.toHsva(g);
      l.current = { hsva: h, color: g }, r(h);
    }
  }, [g, A]), Z.useEffect(function() {
    var h;
    AO(s, l.current.hsva) || A.equal(h = A.fromHsva(s), l.current.color) || (l.current = { hsva: s, color: h }, C(h));
  }, [s, A, C]);
  var d = Z.useCallback(function(h) {
    r(function(D) {
      return Object.assign({}, D, h);
    });
  }, []);
  return [s, d];
}
var e$ = typeof window < "u" ? Z.useLayoutEffect : Z.useEffect, t$ = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0;
}, NZ = /* @__PURE__ */ new Map(), i$ = function(A) {
  e$(function() {
    var g = A.current ? A.current.ownerDocument : document;
    if (g !== void 0 && !NZ.has(g)) {
      var I = g.createElement("style");
      I.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, NZ.set(g, I);
      var C = t$();
      C && I.setAttribute("nonce", C), g.head.appendChild(I);
    }
  }, []);
}, n$ = function(A) {
  var g = A.className, I = A.colorModel, C = A.color, t = C === void 0 ? I.defaultColor : C, s = A.onChange, r = $R(A, ["className", "colorModel", "color", "onChange"]), l = Z.useRef(null);
  i$(l);
  var d = C$(I, t, s), h = d[0], D = d[1], w = TK(["react-colorful", g]);
  return EA.createElement("div", T0({}, r, { ref: l, className: w }), EA.createElement(I$, { hsva: h, onChange: D }), EA.createElement(g$, { hue: h.h, onChange: D, className: "react-colorful__last-control" }));
}, s$ = { defaultColor: "000", toHsva: Qq, fromHsva: function(A) {
  return zq({ h: A.h, s: A.s, v: A.v, a: 1 });
}, equal: A$ }, o$ = function(A) {
  return EA.createElement(n$, T0({}, A, { colorModel: s$ }));
};
function a$(A) {
  const g = Z.useRef(null);
  return Z.useEffect(() => {
    A && (typeof A == "function" ? A(g.current) : A.current = g.current);
  }), g;
}
var Y0 = "Popover", [CO, Egg] = Tn(Y0, [
  h0
]), vM = h0(), [r$, br] = CO(Y0), eO = (A) => {
  const {
    __scopePopover: g,
    children: I,
    open: C,
    defaultOpen: t,
    onOpenChange: s,
    modal: r = !1
  } = A, l = vM(g), d = Z.useRef(null), [h, D] = Z.useState(!1), [w, p] = mr({
    prop: C,
    defaultProp: t ?? !1,
    onChange: s,
    caller: Y0
  });
  return /* @__PURE__ */ v.jsx(XE, { ...l, children: /* @__PURE__ */ v.jsx(
    r$,
    {
      scope: g,
      contentId: vi(),
      triggerRef: d,
      open: w,
      onOpenChange: p,
      onOpenToggle: Z.useCallback(() => p((b) => !b), [p]),
      hasCustomAnchor: h,
      onCustomAnchorAdd: Z.useCallback(() => D(!0), []),
      onCustomAnchorRemove: Z.useCallback(() => D(!1), []),
      modal: r,
      children: I
    }
  ) });
};
eO.displayName = Y0;
var tO = "PopoverAnchor", l$ = Z.forwardRef(
  (A, g) => {
    const { __scopePopover: I, ...C } = A, t = br(tO, I), s = vM(I), { onCustomAnchorAdd: r, onCustomAnchorRemove: l } = t;
    return Z.useEffect(() => (r(), () => l()), [r, l]), /* @__PURE__ */ v.jsx(fK, { ...s, ...C, ref: g });
  }
);
l$.displayName = tO;
var iO = "PopoverTrigger", nO = Z.forwardRef(
  (A, g) => {
    const { __scopePopover: I, ...C } = A, t = br(iO, I), s = vM(I), r = BA(g, t.triggerRef), l = /* @__PURE__ */ v.jsx(
      jI.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": t.open,
        "aria-controls": t.contentId,
        "data-state": lO(t.open),
        ...C,
        ref: r,
        onClick: RI(A.onClick, t.onOpenToggle)
      }
    );
    return t.hasCustomAnchor ? l : /* @__PURE__ */ v.jsx(fK, { asChild: !0, ...s, children: l });
  }
);
nO.displayName = iO;
var YK = "PopoverPortal", [c$, u$] = CO(YK, {
  forceMount: void 0
}), sO = (A) => {
  const { __scopePopover: g, forceMount: I, children: C, container: t } = A, s = br(YK, g);
  return /* @__PURE__ */ v.jsx(c$, { scope: g, forceMount: I, children: /* @__PURE__ */ v.jsx(Ks, { present: I || s.open, children: /* @__PURE__ */ v.jsx(y0, { asChild: !0, container: t, children: C }) }) });
};
sO.displayName = YK;
var Hf = "PopoverContent", oO = Z.forwardRef(
  (A, g) => {
    const I = u$(Hf, A.__scopePopover), { forceMount: C = I.forceMount, ...t } = A, s = br(Hf, A.__scopePopover);
    return /* @__PURE__ */ v.jsx(Ks, { present: C || s.open, children: s.modal ? /* @__PURE__ */ v.jsx(f$, { ...t, ref: g }) : /* @__PURE__ */ v.jsx(h$, { ...t, ref: g }) });
  }
);
oO.displayName = Hf;
var d$ = /* @__PURE__ */ jf("PopoverContent.RemoveScroll"), f$ = Z.forwardRef(
  (A, g) => {
    const I = br(Hf, A.__scopePopover), C = Z.useRef(null), t = BA(g, C), s = Z.useRef(!1);
    return Z.useEffect(() => {
      const r = C.current;
      if (r) return wR(r);
    }, []), /* @__PURE__ */ v.jsx(mK, { as: d$, allowPinchZoom: !0, children: /* @__PURE__ */ v.jsx(
      aO,
      {
        ...A,
        ref: t,
        trapFocus: I.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: RI(A.onCloseAutoFocus, (r) => {
          r.preventDefault(), s.current || I.triggerRef.current?.focus();
        }),
        onPointerDownOutside: RI(
          A.onPointerDownOutside,
          (r) => {
            const l = r.detail.originalEvent, d = l.button === 0 && l.ctrlKey === !0, h = l.button === 2 || d;
            s.current = h;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: RI(
          A.onFocusOutside,
          (r) => r.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), h$ = Z.forwardRef(
  (A, g) => {
    const I = br(Hf, A.__scopePopover), C = Z.useRef(!1), t = Z.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      aO,
      {
        ...A,
        ref: g,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          A.onCloseAutoFocus?.(s), s.defaultPrevented || (C.current || I.triggerRef.current?.focus(), s.preventDefault()), C.current = !1, t.current = !1;
        },
        onInteractOutside: (s) => {
          A.onInteractOutside?.(s), s.defaultPrevented || (C.current = !0, s.detail.originalEvent.type === "pointerdown" && (t.current = !0));
          const r = s.target;
          I.triggerRef.current?.contains(r) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && t.current && s.preventDefault();
        }
      }
    );
  }
), aO = Z.forwardRef(
  (A, g) => {
    const {
      __scopePopover: I,
      trapFocus: C,
      onOpenAutoFocus: t,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: r,
      onEscapeKeyDown: l,
      onPointerDownOutside: d,
      onFocusOutside: h,
      onInteractOutside: D,
      ...w
    } = A, p = br(Hf, I), b = vM(I);
    return lR(), /* @__PURE__ */ v.jsx(
      pK,
      {
        asChild: !0,
        loop: !0,
        trapped: C,
        onMountAutoFocus: t,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ v.jsx(
          D0,
          {
            asChild: !0,
            disableOutsidePointerEvents: r,
            onInteractOutside: D,
            onEscapeKeyDown: l,
            onPointerDownOutside: d,
            onFocusOutside: h,
            onDismiss: () => p.onOpenChange(!1),
            children: /* @__PURE__ */ v.jsx(
              QE,
              {
                "data-state": lO(p.open),
                role: "dialog",
                id: p.contentId,
                ...b,
                ...w,
                ref: g,
                style: {
                  ...w.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), rO = "PopoverClose", y$ = Z.forwardRef(
  (A, g) => {
    const { __scopePopover: I, ...C } = A, t = br(rO, I);
    return /* @__PURE__ */ v.jsx(
      jI.button,
      {
        type: "button",
        ...C,
        ref: g,
        onClick: RI(A.onClick, () => t.onOpenChange(!1))
      }
    );
  }
);
y$.displayName = rO;
var D$ = "PopoverArrow", M$ = Z.forwardRef(
  (A, g) => {
    const { __scopePopover: I, ...C } = A, t = vM(I);
    return /* @__PURE__ */ v.jsx(zE, { ...t, ...C, ref: g });
  }
);
M$.displayName = D$;
function lO(A) {
  return A ? "open" : "closed";
}
var w$ = eO, B$ = nO, p$ = sO, m$ = oO;
function b$({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(w$, { "data-slot": "popover", ...A });
}
function S$({
  ...A
}) {
  return /* @__PURE__ */ v.jsx(B$, { "data-slot": "popover-trigger", ...A });
}
function G$({
  className: A,
  align: g = "center",
  sideOffset: I = 4,
  ...C
}) {
  return /* @__PURE__ */ v.jsx(p$, { children: /* @__PURE__ */ v.jsx(
    m$,
    {
      "data-slot": "popover-content",
      align: g,
      sideOffset: I,
      className: kI(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
        A
      ),
      ...C
    }
  ) });
}
function K$({ className: A, type: g, ...I }) {
  return /* @__PURE__ */ v.jsx(
    "input",
    {
      type: g,
      "data-slot": "input",
      className: kI(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        A
      ),
      ...I
    }
  );
}
const cO = Z.forwardRef(
  ({
    disabled: A,
    value: g,
    onChange: I,
    onBlur: C,
    name: t,
    className: s,
    size: r,
    showColorPreview: l = !0,
    // 
    ...d
  }, h) => {
    const D = a$(h), [w, p] = Z.useState(!1), b = Z.useMemo(() => g || "#FFFFFF", [g]);
    return /* @__PURE__ */ v.jsxs(b$, { onOpenChange: p, open: w, children: [
      /* @__PURE__ */ v.jsx(S$, { asChild: !0, disabled: A, onBlur: C, children: l ? /* @__PURE__ */ v.jsx(
        Ke,
        {
          ...d,
          className: kI("block", s),
          name: t,
          onClick: () => {
            p(!0);
          },
          size: r,
          style: {
            backgroundColor: b
          },
          variant: "outline",
          children: /* @__PURE__ */ v.jsx("div", {})
        }
      ) : /* @__PURE__ */ v.jsx(
        Ke,
        {
          ...d,
          className: kI("p-1", s),
          name: t,
          onClick: () => {
            p(!0);
          },
          size: r || "icon",
          variant: "ghost",
          children: /* @__PURE__ */ v.jsx(HH, { className: "h-4 w-4" })
        }
      ) }),
      /* @__PURE__ */ v.jsx(G$, { className: "w-auto p-3", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ v.jsx(o$, { color: b, onChange: I }),
        /* @__PURE__ */ v.jsx(
          K$,
          {
            maxLength: 7,
            onChange: (S) => {
              I(S?.currentTarget?.value);
            },
            ref: D,
            value: b
          }
        )
      ] }) })
    ] });
  }
);
cO.displayName = "ColorPicker";
const T$ = ({
  open: A,
  coloringAnnotation: g,
  annotationConfig: I,
  categoryColors: C,
  customColors: t,
  onOpenChange: s,
  onCustomColorsChange: r
}) => {
  if (!A || !g || !I) return null;
  const l = I.AnnoMaps?.[g]?.Items ?? [];
  return /* @__PURE__ */ v.jsx(QR, { open: A, onOpenChange: s, children: /* @__PURE__ */ v.jsxs(zR, { className: "sm:max-w-md", children: [
    /* @__PURE__ */ v.jsxs(JR, { children: [
      /* @__PURE__ */ v.jsx(LR, { children: "Custom Colors" }),
      /* @__PURE__ */ v.jsxs(qR, { children: [
        "Customize colors for categories in",
        " ",
        /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: g }),
        "."
      ] })
    ] }),
    /* @__PURE__ */ v.jsx("div", { className: "py-4 max-h-[60vh] overflow-y-auto", children: l.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground text-center py-6", children: "No categories available." }) : /* @__PURE__ */ v.jsx("div", { className: "grid grid-cols-3 gap-3", children: l.map((d) => {
      const h = d.Code, D = d.Name, p = `rgb(${(C[g]?.[h] ?? [180, 180, 180]).join(", ")})`, b = t[g]?.[h] ?? p;
      return /* @__PURE__ */ v.jsxs(
        "div",
        {
          className: "flex flex-col items-center p-2 border rounded-lg hover:bg-accent",
          children: [
            /* @__PURE__ */ v.jsx(
              "span",
              {
                className: "text-xs font-medium mb-2 h-[2.5rem] text-center line-clamp-2",
                title: D,
                children: D
              }
            ),
            /* @__PURE__ */ v.jsx(
              cO,
              {
                value: b,
                onChange: (S) => {
                  r({
                    ...t,
                    [g]: {
                      ...t[g] ?? {},
                      [h]: S
                    }
                  });
                }
              }
            )
          ]
        },
        h
      );
    }) }) }),
    /* @__PURE__ */ v.jsxs(kq, { children: [
      /* @__PURE__ */ v.jsx(
        Ke,
        {
          variant: "outline",
          onClick: () => {
            r({
              ...t,
              [g]: {}
            });
          },
          children: /* @__PURE__ */ v.jsxs("span", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ v.jsx(dz, { className: "h-4 w-4" }),
            "Reset Colors"
          ] })
        }
      ),
      /* @__PURE__ */ v.jsx(Ke, { onClick: () => s(!1), children: "Done" })
    ] })
  ] }) });
}, AM = Z.createContext(null);
function Y$() {
  const A = Z.useContext(AM);
  if (!A)
    throw new Error(
      "Widget model is not available. Are you running inside anywidget?"
    );
  return A;
}
function gp({
  onLoad: A,
  device: g
}) {
  const I = Z.useRef(null), C = Q7(), t = F7(), s = Y$(), [r, l] = Z.useState(null), [d, h] = Z.useState(null), [D, w] = Z.useState({}), [p, b] = Z.useState({}), [S, K] = Z.useState(null);
  Z.useEffect(() => {
    if (!s) return;
    const z = s.get("continuous_config"), Q = s.get("continuous_bins");
    if (!z || !Q) return;
    const Bg = {};
    for (const [Rg, N] of Object.entries(z)) {
      const F = Q[Rg];
      if (!F) continue;
      const rg = W7(F, N.DType), Cg = N.DType === "float16" ? V7(rg) : rg;
      Bg[Rg] = {
        name: Rg,
        values: Cg,
        ContinuousConfig: N
      };
    }
    b(Bg);
  }, [s]), Z.useEffect(() => {
    if (!s) return;
    const z = s.get("annotation_config"), Q = s.get("annotation_bins");
    if (!z || !Q) return;
    const Bg = {};
    for (const Rg of z.AvailableAnnoTypes) {
      const N = Q[Rg];
      if (!N) continue;
      const F = z.AnnoDtypes?.[Rg];
      if (!F) {
        console.warn(
          `[SpatialVista] Missing AnnoDtypes for annotation "${Rg}", skip.`
        );
        continue;
      }
      switch (F) {
        case "uint8":
          Bg[Rg] = new Uint8Array(
            N.buffer,
            N.byteOffset,
            N.byteLength
          );
          break;
        case "uint16":
          Bg[Rg] = new Uint16Array(
            N.buffer,
            N.byteOffset,
            N.byteLength / 2
          );
          break;
        case "uint32":
          Bg[Rg] = new Uint32Array(
            N.buffer,
            N.byteOffset,
            N.byteLength / 4
          );
          break;
        default:
          console.error(
            `[SpatialVista] Unsupported annotation dtype "${F}" for "${Rg}"`
          );
      }
    }
    h(z), w(Bg);
  }, [s]), Z.useEffect(() => {
    let z = null;
    const Q = () => {
      const Bg = s.get("laz_bytes");
      if (!Bg) return;
      console.log(
        "Vis: received laz_bytes from model, byte length:",
        Bg?.length
      );
      const Rg = new Blob([Bg], { type: "application/octet-stream" });
      z && (console.log("Vis: revoking previous object URL:", z), URL.revokeObjectURL(z)), z = URL.createObjectURL(Rg), console.log("Vis: created object URL for blob:", z), l(z);
    };
    return s.on("change:laz_bytes", Q), Q(), () => {
      s.off("change:laz_bytes", Q), z && (console.log("Vis: cleanup revoking object URL:", z), URL.revokeObjectURL(z));
    };
  }, [s]);
  const {
    isLoaded: Y,
    loadedData: T,
    loadedAnnotations: E,
    numericField: H,
    loadNumericField: R,
    onDataLoad: x
  } = x4({
    onLoad: A,
    updateViewState: t.updateViewState,
    setInitialCamera: t.setInitialCamera,
    setActiveZoom: t.setActiveZoom,
    annotationConfig: d,
    annotationBins: D
  }), U = Z.useCallback(
    (z) => {
      if (K(z), !T) return;
      if (!z) {
        R(null, T);
        return;
      }
      const Q = p[z];
      if (!Q) {
        R(null, T);
        return;
      }
      R(Q, T), C.setNumericThreshold(Q.ContinuousConfig.Min);
    },
    [T, p, R, C]
  );
  Z.useEffect(() => {
    t.setIsLoaded?.(Y);
  }, [Y, t]);
  const J = X7(T, d), L = z7(
    T,
    C.showPointCloud,
    C.showScatterplot,
    J.categoryColors,
    d
  ), eg = $7(
    t.layoutMode,
    t.setLayoutMode,
    S,
    J.coloringAnnotation,
    T,
    t.initialCamera,
    t.updateViewState,
    C.setPointSize
  ), Mg = Z.useCallback(
    ({ gl: z }) => {
      I.current = z;
    },
    []
  ), ig = Z.useCallback(() => {
    if (!I.current) return;
    const z = document.createElement("a"), Q = (/* @__PURE__ */ new Date()).toISOString().replace(/:/g, "-").substring(0, 19);
    z.download = `gsmap3d-vis-${Q}.png`;
    const Bg = I.current.canvas;
    z.href = Bg.toDataURL("image/png"), document.body.appendChild(z), z.click(), document.body.removeChild(z);
  }, []), Zg = d?.AvailableAnnoTypes.includes("section") ?? !1, Kg = Z.useCallback(async () => {
    if (C.showPointCloud) {
      C.setshowPointCloud(!1);
      const z = T?.extData.annotations.section;
      if (L.availableSectionIDs.length === 0) {
        const Q = Array.from(new Set(z)).sort(
          (Bg, Rg) => Bg - Rg
        );
        L.setAvailableSectionIDs(Q), Q.length > 0 && (!L.currentSectionID || !Q.includes(L.currentSectionID)) && L.setCurrentSectionID(Q[0]);
      }
      if (C.setShowScatterplot(!0), T && T.header && T.header.boundingBox) {
        const [Q, Bg] = T.header.boundingBox;
        t.updateStviewState({
          target: [(Q[0] + Bg[0]) / 2, (Q[1] + Bg[1]) / 2, 0],
          zoom: Math.log2(window.innerWidth / (Bg[0] - Q[0])) - 1,
          minZoom: -10,
          maxZoom: 10
        });
      }
    } else
      C.setshowPointCloud(!0), C.setShowScatterplot(!1), console.log("now loaded anns:", E);
  }, [T, E, C, L, t]), mg = {
    ...J.colorParams,
    NumericThreshold: C.numericThreshold
  }, Ng = U7({
    showPointCloud: C.showPointCloud,
    showScatterplot: C.showScatterplot,
    loadedData: T,
    onDataLoad: x,
    filteredSectionPoints: L.filteredSectionPoints,
    NumericThreshold: C.numericThreshold,
    numericField: H,
    pointOpacity: C.pointOpacity,
    pointSize: C.pointSize,
    layoutMode: t.layoutMode,
    FancyPositions: eg.FancyPositions,
    colorParams: mg,
    lazUrl: r
  }), cg = H !== null ? [H.ContinuousConfig.Min, H.ContinuousConfig.Max] : null;
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col h-full w-full", children: [
    /* @__PURE__ */ v.jsx(
      Nz,
      {
        isLoaded: Y,
        showPointCloud: C.showPointCloud,
        hasSections: Zg,
        onContinuousOpen: () => C.setContinuousOpen(!0),
        onToggleView: Kg,
        onCapture: ig
      }
    ),
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-1 overflow-hidden", children: [
      /* @__PURE__ */ v.jsx("div", { className: "hidden md:w-[10%] p-2 overflow-y-auto h-full md:flex flex-col md:min-w-[120px]", children: /* @__PURE__ */ v.jsx(
        i8,
        {
          annotationConfig: d,
          loadedAnnotations: E,
          coloringAnnotation: J.coloringAnnotation,
          selectedCategories: J.selectedCategories,
          hiddenCategoryIds: J.hiddenCategoryIds,
          categoryColors: J.categoryColors,
          customColors: J.customColors,
          currentNumericName: S,
          isLoaded: Y,
          onColorPickerOpen: () => C.setColorPickerOpen(!0),
          onSetAnnotationForColoring: J.setAnnotationForColoring,
          onSelectedCategoriesChange: J.setSelectedCategories,
          onHiddenCategoryIdsChange: J.setHiddenCategoryIds
        }
      ) }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1 min-w-0 h-90% relative lg:w-[70%]", children: /* @__PURE__ */ v.jsx(
        t6,
        {
          isLoaded: Y,
          showPointCloud: C.showPointCloud,
          showScatterplot: C.showScatterplot,
          layoutMode: t.layoutMode,
          viewState: t.viewState,
          stviewState: t.stviewState,
          initialCamera: t.initialCamera,
          layers: Ng,
          loadedData: T,
          loadedAnnotations: E,
          availableSectionIDs: L.availableSectionIDs,
          currentSectionID: L.currentSectionID,
          sectionPreviews: L.sectionPreviews,
          NumericThreshold: C.numericThreshold,
          minMaxValue: cg,
          device: g,
          onViewStateUpdate: t.updateViewState,
          onStViewStateUpdate: t.updateStviewState,
          onActiveZoomChange: t.setActiveZoom,
          onSectionClick: L.handleSectionClick,
          onNumericThresholdChange: C.setNumericThreshold,
          onAfterRender: Mg,
          annotationConfig: d
        }
      ) }),
      /* @__PURE__ */ v.jsx("div", { className: "hidden md:w-[20%] p-2 space-y-3 md:flex flex-col h-full overflow-y-auto", children: /* @__PURE__ */ v.jsx(
        z5,
        {
          activeZoom: t.activeZoom,
          autoRotate: t.autoRotate,
          layoutMode: t.layoutMode,
          viewState: t.viewState,
          initialCamera: t.initialCamera,
          pointSize: C.pointSize,
          pointOpacity: C.pointOpacity,
          isLoaded: Y,
          currentTrait: S,
          coloringAnnotation: J.coloringAnnotation,
          selectedCategories: J.selectedCategories,
          onZoomChange: t.setActiveZoom,
          onAutoRotateToggle: t.toggleAutoRotate,
          onLayoutModeToggle: eg.toggleLayoutMode,
          onResetCamera: () => {
            t.updateViewState({
              ...t.initialCamera,
              transitionDuration: 600
            }), t.setActiveZoom("standard");
          },
          onPointSizeChange: C.setPointSize,
          onPointOpacityChange: C.setPointOpacity,
          onResetPointControls: () => {
            C.setPointSize(1), C.setPointOpacity(1), C.setNumericThreshold(cg ? cg[0] : 0);
          },
          onViewStateUpdate: t.updateViewState,
          annotationConfig: d
        }
      ) })
    ] }),
    /* @__PURE__ */ v.jsx(
      Xq,
      {
        open: C.continuousOpen,
        activeContinuous: S,
        continuousFields: p,
        onOpenChange: C.setContinuousOpen,
        onSelectContinuous: U
      }
    ),
    /* @__PURE__ */ v.jsx(
      T$,
      {
        open: C.colorPickerOpen,
        coloringAnnotation: J.coloringAnnotation,
        annotationConfig: d,
        categoryColors: J.categoryColors,
        customColors: J.customColors,
        onOpenChange: C.setColorPickerOpen,
        onCustomColorsChange: J.setCustomColors
      }
    )
  ] });
}
const P$ = {
  theme: "system",
  setTheme: () => null
}, Z$ = Z.createContext(P$);
function Ip({
  children: A,
  defaultTheme: g = "system",
  storageKey: I = "vite-ui-theme",
  ...C
}) {
  const [t, s] = Z.useState(
    () => localStorage.getItem(I) || g
  );
  Z.useEffect(() => {
    const l = window.document.documentElement;
    if (l.classList.remove("light", "dark"), t === "system") {
      const d = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      l.classList.add(d);
      return;
    }
    l.classList.add(t);
  }, [t]);
  const r = {
    theme: t,
    setTheme: (l) => {
      localStorage.setItem(I, l), s(l);
    }
  };
  return /* @__PURE__ */ v.jsx(Z$.Provider, { ...C, value: r, children: A });
}
function j$(A, g) {
  if (A.__spatialvista_mounted__) {
    try {
      const s = A.__spatialvista_root__;
      s && s.render(
        /* @__PURE__ */ v.jsx(AM.Provider, { value: g, children: /* @__PURE__ */ v.jsx(Ip, { defaultTheme: "light", storageKey: "spatialvista-theme", children: /* @__PURE__ */ v.jsx(gp, {}) }) })
      );
    } catch (s) {
      console.warn("mountWidget: re-render failed for existing mount:", s);
    }
    return;
  }
  A.__spatialvista_mounted__ = !0, A.style.width = "100%", A.style.height = "400px";
  const I = A.shadowRoot || A.attachShadow({ mode: "open" });
  I.__spatialvista_styles_injected__ || (document.querySelectorAll("style").forEach((s) => {
    I.appendChild(s.cloneNode(!0));
  }), I.__spatialvista_styles_injected__ = !0);
  let C = I.getElementById(
    "spatialvista-root-container"
  );
  C || (C = document.createElement("div"), C.id = "spatialvista-root-container", C.style.width = "100%", C.style.height = "100%", C.style.display = "flex", C.style.flexDirection = "column", C.style.position = "relative", C.classList.add("light"), I.appendChild(C));
  let t = I.getElementById(
    "spatialvista-portal-root"
  );
  if (t || (t = document.createElement("div"), t.id = "spatialvista-portal-root", t.style.position = "absolute", t.style.inset = "0", t.style.zIndex = "50", t.style.pointerEvents = "none", I.appendChild(t)), window.__SPATIALVISTA_DIALOG_PORTAL__ = t, A.__spatialvista_root__)
    try {
      A.__spatialvista_root__.render(
        /* @__PURE__ */ v.jsx(AM.Provider, { value: g, children: /* @__PURE__ */ v.jsx(Ip, { defaultTheme: "light", storageKey: "spatialvista-theme", children: /* @__PURE__ */ v.jsx(gp, {}) }) })
      );
    } catch (s) {
      console.warn(
        "mountWidget: failed to reuse existing root, recreating it:",
        s
      );
      const r = _Y.createRoot(C);
      A.__spatialvista_root__ = r, r.render(
        /* @__PURE__ */ v.jsx(AM.Provider, { value: g, children: /* @__PURE__ */ v.jsx(Ip, { defaultTheme: "light", storageKey: "spatialvista-theme", children: /* @__PURE__ */ v.jsx(gp, {}) }) })
      );
    }
  else {
    const s = _Y.createRoot(C);
    A.__spatialvista_root__ = s, s.render(
      /* @__PURE__ */ v.jsx(AM.Provider, { value: g, children: /* @__PURE__ */ v.jsx(Ip, { defaultTheme: "light", storageKey: "spatialvista-theme", children: /* @__PURE__ */ v.jsx(gp, {}) }) })
    );
  }
}
const Rgg = {
  render({ el: A, model: g }) {
    window.__SPATIALVISTA_MODEL__ = g, j$(A, g);
  }
};
export {
  Rgg as default
};
